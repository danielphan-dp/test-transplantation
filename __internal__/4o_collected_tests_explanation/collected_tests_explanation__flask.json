{
  "tests": [
    {
      "name": "test_dump_load_unchanged",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('data', ({' t': (1, 2, 3)}, {' t__': b'a'}, {' di': ' di'}, {'x': (1, 2, 3), 'y': 4}, (1, 2, 3), [(1, 2, 3)], b'\\xff', Markup('<html>'), uuid4(), datetime.now(tz=timezone.utc).replace(microsecond=0)))"
      ],
      "arguments": [
        "data"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.loads(s.dumps(data)) == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "s.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `loads` method is designed to deserialize a JSON string into a Python object, with the ability to customize the deserialization process using an `object_hook`.\n\n**How It Works**:\nThe `loads` method is a part of a class that likely extends a JSON deserialization class. It takes a JSON string `s` and optional keyword arguments `kwargs`. The method sets a default `object_hook` in `kwargs` to `self.object_hook` if it is not already provided. This `object_hook` is a function that can be used to transform the deserialized JSON objects. Finally, it calls the `loads` method of its superclass with the JSON string and the updated `kwargs`, performing the actual deserialization. This allows for custom processing of JSON objects during deserialization, enhancing flexibility."
        }
      ]
    },
    {
      "name": "test_duplicate_tag",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 32,
      "end_line_number": 40,
      "source_code": "def test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(s.tags[' d'], TagDict)",
        "assert isinstance(s.order[0], TagDict)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_tag",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 43,
      "end_line_number": 63,
      "source_code": "def test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.loads(s.dumps(Foo('bar'))).data == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "s.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `loads` method is designed to deserialize a JSON string into a Python object, with the ability to customize the deserialization process using an `object_hook`.\n\n**How It Works**:\nThe `loads` method is a part of a class that likely extends a JSON deserialization class. It takes a JSON string `s` and optional keyword arguments `kwargs`. The method sets a default `object_hook` in `kwargs` to `self.object_hook` if it is not already provided. This `object_hook` allows for custom processing of JSON objects during deserialization. Finally, it calls the superclass's `loads` method with the JSON string and the updated `kwargs`, returning the deserialized Python object. This setup allows for flexible and customizable JSON deserialization, particularly useful when dealing with complex or non-standard JSON structures."
        }
      ]
    },
    {
      "name": "test_tag_interface",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 66,
      "end_line_number": 70,
      "source_code": "def test_tag_interface():\n    t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_tag_order",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 73,
      "end_line_number": 86,
      "source_code": "def test_tag_order():\n    class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(s.order[-2], Tag1)",
        "assert isinstance(s.order[-1], Tag2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_environ_defaults_from_config",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 15,
      "end_line_number": 27,
      "source_code": "def test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://example.com:1234/foo/'",
        "assert rv.data == b'http://example.com:1234/foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_environ_defaults",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 30,
      "end_line_number": 39,
      "source_code": "def test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "app_ctx",
        "req_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://localhost/'",
        "assert rv.data == b'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_environ_base_default",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 42,
      "end_line_number": 54,
      "source_code": "def test_environ_base_default(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"127.0.0.1\"\n        assert flask.g.user_agent == (\n            f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.remote_addr == '127.0.0.1'",
        "assert flask.g.user_agent == f\"Werkzeug/{importlib.metadata.version('werkzeug')}\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_environ_base_modified",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 57,
      "end_line_number": 70,
      "source_code": "def test_environ_base_modified(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"192.168.0.22\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"192.168.0.22\"\n        assert flask.g.user_agent == \"Foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.remote_addr == '192.168.0.22'",
        "assert flask.g.user_agent == 'Foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_client_open_environ",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 73,
      "end_line_number": 87,
      "source_code": "def test_client_open_environ(app, client, request):\n    @app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "request"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'127.0.0.1'",
        "assert rv.data == b'127.0.0.2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_specify_url_scheme",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 90,
      "end_line_number": 99,
      "source_code": "def test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'https://localhost/'",
        "assert rv.data == b'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_path_is_url",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 102,
      "end_line_number": 107,
      "source_code": "def test_path_is_url(app):\n    eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert eb.url_scheme == 'https'",
        "assert eb.host == 'example.com'",
        "assert eb.script_root == ''",
        "assert eb.path == '/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_environbuilder_json_dumps",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'",
      "docstring": "EnvironBuilder.json_dumps() takes settings from the app.",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert eb.input_stream.read().decode('utf8') == '\"\u20ac\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "eb.input_stream.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
          "code_explanation": "**Main Purpose of the Method**:\nThe `eb.input_stream.read` method is designed to handle HTTP GET requests to the `/read` endpoint of a Flask web application. It retrieves a session variable named 'foo' and returns its value as a string. If the 'foo' variable is not set in the session, it defaults to returning '0'.\n\n**How It Works**:\nThe method is defined as a route handler for the `/read` endpoint using Flask's `@app.route('/read')` decorator. When a GET request is made to this endpoint, the `read` function is executed. Inside the function, `flask.session.get('foo', 0)` is used to access the session data. The `get` method attempts to retrieve the value associated with the key 'foo' from the session. If 'foo' is not present, it returns the default value of `0`. The result is then converted to a string and returned as the response to the client. This method relies on Flask's session management to store and retrieve session data across requests."
        }
      ]
    },
    {
      "name": "test_blueprint_with_subdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 117,
      "end_line_number": 138,
      "source_code": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://xxx.example.com:1234/foo/'",
        "assert rv.data == b'http://xxx.example.com:1234/foo/'",
        "assert ctx.request.blueprint == bp.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management to persist data across requests for a particular user."
        }
      ]
    },
    {
      "name": "test_redirect_keep_session",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 141,
      "end_line_number": 166,
      "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "app_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<missing>'",
        "assert rv.data == b'index'",
        "assert flask.session.get('data') == 'foo'",
        "assert rv.data == b'foo'",
        "assert flask.session.get('data') == 'foo'",
        "assert rv.data == b'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests, such as form submissions or API calls.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL with optional data, headers, and other parameters. In the provided code snippets, `client.post` is used to test various endpoints of a web application. For example, it is used to update a post, validate form submissions, and delete a post. The method returns a response object, which can be used to assert the expected behavior of the application, such as checking the status code, response data, or redirection headers."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_session_transactions",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 169,
      "end_line_number": 183,
      "source_code": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'[42]'",
        "assert len(sess) == 0",
        "assert len(sess) == 1",
        "assert len(sess) == 1",
        "assert sess['foo'] == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_transactions_no_null_sessions",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 186,
      "end_line_number": 193,
      "source_code": "def test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Session backend did not open a session' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_session_transactions_keep_context",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 196,
      "end_line_number": 201,
      "source_code": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "req_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert req is not None",
        "assert req is flask.request._get_current_object()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_session_transaction_needs_cookies",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 204,
      "end_line_number": 209,
      "source_code": "def test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n\n    with pytest.raises(TypeError, match=\"Cookies are disabled.\"):\n        with c.session_transaction():\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_test_client_context_binding",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 212,
      "end_line_number": 238,
      "source_code": "def test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.value == 42",
        "assert resp.data == b'Hello World!'",
        "assert resp.status_code == 200",
        "assert not hasattr(flask.g, 'value')",
        "assert b'Internal Server Error' in resp.data",
        "assert resp.status_code == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_reuse_client",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 241,
      "end_line_number": 248,
      "source_code": "def test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').status_code == 404",
        "assert client.get('/').status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side or in a client-side cookie, depending on the session interface configuration."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_full_url_request",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 251,
      "end_line_number": 260,
      "source_code": "def test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert 'gin' in flask.request.form",
        "assert 'vodka' in flask.request.args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with frameworks like Flask or Django. It sends a POST request to a specified URL endpoint within the application, optionally including data as form-encoded or JSON payloads. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking response status codes, headers, or content. This helps ensure that the application behaves correctly when handling POST requests."
        }
      ]
    },
    {
      "name": "test_json_request_and_response",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 263,
      "end_line_number": 279,
      "source_code": "def test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.request.is_json",
        "assert flask.request.get_json() == json_data",
        "assert rv.status_code == 200",
        "assert rv.is_json",
        "assert rv.get_json() == json_data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint within the application, optionally including data as form-encoded or JSON payloads. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post or deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking the status code or verifying changes in the database. The method is crucial for ensuring that the application correctly processes POST requests and handles data validation, authentication, and other logic associated with these requests."
        }
      ]
    },
    {
      "name": "test_client_json_no_app_context",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 282,
      "end_line_number": 299,
      "source_code": "def test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.get_data(as_text=True) == 'Hello, Flask!'",
        "assert ns.count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with frameworks like Flask for testing purposes. When invoked, it sends a POST request to a specified URL endpoint within the application, optionally including data in the request body. The method returns a response object, which can be used to assert expected outcomes, such as checking the status code or verifying changes in the application's state. In the provided code snippets, `client.post` is used to test various functionalities like updating a post, validating input data, and deleting a post, ensuring that the application behaves correctly under different scenarios."
        }
      ]
    },
    {
      "name": "test_subdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 302,
      "end_line_number": 318,
      "source_code": "def test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == response.status_code",
        "assert b'xxx' == response.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_nosubdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 321,
      "end_line_number": 335,
      "source_code": "def test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == response.status_code",
        "assert b'xxx' == response.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_cli_runner_class",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 338,
      "end_line_number": 347,
      "source_code": "def test_cli_runner_class(app):\n    runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(runner, FlaskCliRunner)",
        "assert isinstance(runner, SubRunner)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_invoke",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 350,
      "end_line_number": 361,
      "source_code": "def test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Hello' in result.output",
        "assert 'Hello' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run in a terminal, capturing their output and exit codes for assertions in test cases."
        },
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_cli_custom_obj",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 364,
      "end_line_number": 379,
      "source_code": "def test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert NS.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_client_pop_all_preserved",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 382,
      "end_line_number": 396,
      "source_code": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert _cv_request.get(None) is req_ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers where similar patterns of appending to a list are used to confirm that certain actions have been executed."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "_cv_request.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `_cv_request.get` method is used to retrieve the current request context in a Flask application. It is part of the internal mechanism that manages the request lifecycle, ensuring that the correct context is available when handling requests.\n\n**How It Works**:\nThe method is invoked to access the current request context, which is essential for operations that depend on the request's state, such as session management. In the provided code snippet, the `get` function within the Flask route `/get` uses `flask.session.get('value', 'None')` to retrieve a session variable named 'value'. If the session variable does not exist, it defaults to returning 'None'. This method is part of the broader context management system in Flask, which includes opening and closing sessions, handling request-specific data, and ensuring that the correct context is used throughout the request's lifecycle. The context is managed using a stack-like structure, where contexts are pushed and popped as requests are processed."
        }
      ]
    },
    {
      "name": "test_explicit_instance_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 8,
      "end_line_number": 13,
      "source_code": "def test_explicit_instance_paths(modules_tmp_path):\n    with pytest.raises(ValueError, match=\".*must be absolute\"):\n        flask.Flask(__name__, instance_path=\"instance\")\n\n    app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))\n    assert app.instance_path == os.fspath(modules_tmp_path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_uninstalled_module_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_uninstalled_module_paths(modules_tmp_path, purge_module):\n    (modules_tmp_path / \"config_module_app.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported fresh in subsequent tests, preventing any state or side effects from previous tests from affecting new ones.\n\n**How It Works**:\nThe `purge_module` method is implemented as a pytest fixture. It defines an inner function `inner(name)` that takes the name of a module as an argument. When `inner(name)` is called, it schedules a finalizer using `request.addfinalizer`. This finalizer is a lambda function that removes the specified module from `sys.modules` using `sys.modules.pop(name, None)`. The use of `None` as the default value in `pop` ensures that no error is raised if the module is not present. This fixture can be used in tests to ensure that any changes made to a module during a test do not persist beyond the test's scope."
        }
      ]
    },
    {
      "name": "test_uninstalled_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 30,
      "end_line_number": 43,
      "source_code": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported fresh in subsequent tests, preventing any state or side effects from previous tests from affecting new ones.\n\n**How It Works**:\nThe `purge_module` method is implemented as a pytest fixture. It defines an inner function `inner(name)` that takes the name of a module as an argument. When `inner(name)` is called, it schedules a finalizer using `request.addfinalizer`. This finalizer is a lambda function that removes the specified module from `sys.modules` using `sys.modules.pop(name, None)`. The `None` ensures that no error is raised if the module is not present. By using this fixture, tests can ensure that any changes or state within a module do not persist beyond the test's scope, allowing for clean and isolated test environments."
        }
      ]
    },
    {
      "name": "test_uninstalled_namespace_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 46,
      "end_line_number": 62,
      "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "monkeypatch",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(project2 / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_namespace",
          "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project",
          "code_explanation": "**Main Purpose of the Method**:\nThe `create_namespace` method is designed to set up a temporary project directory structure for a given package name. It creates a namespace package with a basic Flask application, which can be used for testing or development purposes.\n\n**How It Works**:\n1. **Path Setup**: The method constructs a path for a temporary project directory using the `tmp_path` and the provided `package` name. This path is named `project-{package}`.\n\n2. **Modify Python Path**: It uses `monkeypatch.syspath_prepend` to add the project directory to the Python search path (`sys.path`). This ensures that the Python interpreter can locate and import the package.\n\n3. **Namespace Creation**: Within the project directory, it creates a nested directory structure `namespace/{package}`. This structure represents a namespace package.\n\n4. **Initialize Package**: Inside the newly created package directory, it creates an `__init__.py` file. This file contains a simple Flask application setup, initializing a Flask app with `app = flask.Flask(__name__)`.\n\n5. **Return Project Path**: Finally, the method returns the path to the project directory, allowing further operations or tests to be performed on this setup."
        },
        {
          "name": "create_namespace",
          "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project",
          "code_explanation": "**Main Purpose of the Method**:\nThe `create_namespace` method is designed to set up a temporary project directory structure for a given package name. It creates a namespace package with a basic Flask application, which can be used for testing or development purposes.\n\n**How It Works**:\n1. **Path Setup**: The method constructs a path for a temporary project directory using the `tmp_path` and the provided `package` name. This path is stored in the `project` variable.\n\n2. **Modify Python Path**: It uses `monkeypatch.syspath_prepend` to add the project directory to the Python search path, ensuring that the newly created package can be imported.\n\n3. **Namespace Creation**: A directory structure is created under the `project` path, specifically `namespace/package`, using `ns.mkdir(parents=True)`. This ensures that all necessary parent directories are created.\n\n4. **Initialize Package**: An `__init__.py` file is created within the `namespace/package` directory. This file contains a simple Flask application setup, which imports Flask and initializes an app instance.\n\n5. **Return Project Path**: Finally, the method returns the path to the project directory, allowing further operations or tests to be conducted on the created namespace package."
        },
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported fresh in subsequent tests, preventing any state or side effects from previous tests from affecting new ones.\n\n**How It Works**:\nThe `purge_module` method is implemented as a pytest fixture. It defines an inner function `inner(name)` that takes the name of a module as an argument. When `inner(name)` is called, it schedules a finalizer using `request.addfinalizer`. This finalizer is a lambda function that removes the specified module from `sys.modules` using `sys.modules.pop(name, None)`. The `None` ensures that no error is raised if the module is not present. By using this fixture, tests can ensure that any changes or state within a module do not persist beyond the test's scope, allowing for isolated and repeatable test conditions."
        },
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to temporarily remove a specified module from Python's `sys.modules` cache during testing. This is useful for ensuring that a module is re-imported and re-evaluated, which can be necessary when testing changes to the module's code or its dependencies.\n\n**How It Works**:\nThe `purge_module` method is implemented as a pytest fixture. It defines an inner function `inner(name)` that takes the name of a module as an argument. When `inner(name)` is called, it schedules a finalizer function using `request.addfinalizer`. This finalizer function will execute after the test completes, removing the specified module from `sys.modules` using `sys.modules.pop(name, None)`. This ensures that the module is purged from the cache, allowing it to be re-imported fresh in subsequent tests."
        }
      ]
    },
    {
      "name": "test_installed_module_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 65,
      "end_line_number": 77,
      "source_code": "def test_installed_module_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader\n):\n    (site_packages / \"site_app.py\").write_text(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_app-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "site_packages",
        "limit_loader"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_app-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported fresh in subsequent tests, preventing any state or side effects from previous tests from affecting new ones.\n\n**How It Works**:\nThe `purge_module` method is a pytest fixture that provides a function, `inner`, which takes the name of a module as an argument. When `inner` is called with a module name, it registers a finalizer with pytest using `request.addfinalizer`. This finalizer is a lambda function that removes the specified module from `sys.modules` by using `sys.modules.pop(name, None)`. The `pop` method is used to safely remove the module, returning `None` if the module is not present, thus avoiding any KeyError. This mechanism ensures that the module is purged from the cache at the end of the test, allowing for a clean state in subsequent tests."
        }
      ]
    },
    {
      "name": "test_installed_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 80,
      "end_line_number": 96,
      "source_code": "def test_installed_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "limit_loader",
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "monkeypatch"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'installed_package-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported fresh in subsequent tests, preventing any state or side effects from previous tests from affecting new ones.\n\n**How It Works**:\nThe `purge_module` method is a pytest fixture that provides a function, `inner`, which takes the name of a module as an argument. When `inner` is called with a module name, it registers a finalizer with pytest using `request.addfinalizer`. This finalizer is a lambda function that removes the specified module from `sys.modules` using `sys.modules.pop(name, None)`. The use of `None` as the default value in `pop` ensures that no error is raised if the module is not present in `sys.modules`. This mechanism allows for the cleanup of the module cache after each test that uses this fixture, ensuring a clean state for module imports in subsequent tests."
        }
      ]
    },
    {
      "name": "test_prefix_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 99,
      "end_line_number": 111,
      "source_code": "def test_prefix_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "limit_loader",
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "site_packages"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert site_package.app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_package-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
          "code_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is designed to remove a specified module from Python's `sys.modules` cache after a test is completed. This ensures that the module can be re-imported afresh in subsequent tests, preventing any state or side effects from previous imports from affecting new tests.\n\n**How It Works**:\nThe `purge_module` method is implemented as a pytest fixture. It defines an inner function `inner(name)` that takes the name of a module as an argument. When `inner(name)` is called, it schedules a finalizer function using `request.addfinalizer`. This finalizer function is a lambda that removes the specified module from `sys.modules` using `sys.modules.pop(name, None)`. The `None` ensures that no error is raised if the module is not present. By using this fixture, tests can ensure that any changes or state within a module do not persist beyond the test's scope, allowing for clean and isolated test environments."
        }
      ]
    },
    {
      "name": "test_teardown_on_pop",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == []",
        "assert buffer == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_teardown_with_previous_exception",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 30,
      "end_line_number": 44,
      "source_code": "def test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == [None]",
        "assert buffer == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_teardown_with_handled_exception",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 47,
      "end_line_number": 60,
      "source_code": "def test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == [None]",
        "assert buffer == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proper_test_request_context",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 63,
      "end_line_number": 104,
      "source_code": "def test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost.localdomain:5000/'",
        "assert flask.url_for('sub', _external=True) == 'http://foo.localhost.localdomain:5000/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_context_binding",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 107,
      "end_line_number": 120,
      "source_code": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.request",
        "assert index() == 'Hello World!'",
        "assert meh() == 'http://localhost/meh'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `index` method is a Flask route handler that returns the URL of the current request when the root URL (`/`) of the application is accessed.\n\n**How It Works**:  \nThe `index` method is defined as a route in a Flask application using the `@app.route('/')` decorator, which maps the root URL to this function. When a client makes a request to the root URL, the `index` method is invoked. It uses `flask.request.url` to retrieve the full URL of the current request and returns it as the response. This method is useful for debugging or logging purposes, as it provides the exact URL that was accessed."
        },
        {
          "name": "meh",
          "body": "@app.route('/meh')\ndef meh():\n    return flask.request.url",
          "code_explanation": "**Main Purpose of the Method**:\nThe `meh` method is designed to handle HTTP requests to the `/meh` route of a Flask web application and return the full URL of the request.\n\n**How It Works**:\nThe `meh` method is decorated with `@app.route('/meh')`, which registers it as a route handler for the `/meh` URL path in the Flask application. When a request is made to this path, the `meh` function is invoked. Inside the function, `flask.request.url` is used to retrieve the complete URL of the incoming request, which is then returned as the response. This allows the client to see the exact URL that was accessed, including the scheme, host, and path."
        }
      ]
    },
    {
      "name": "test_context_test",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 123,
      "end_line_number": 132,
      "source_code": "def test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.request",
        "assert not flask.has_request_context()",
        "assert flask.request",
        "assert flask.has_request_context()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manual_context_binding",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 135,
      "end_line_number": 145,
      "source_code": "def test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert index() == 'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `index` method is a Flask route handler that returns the URL of the current request when the root URL (`/`) of the application is accessed.\n\n**How It Works**:  \nThe `index` method is defined as a route in a Flask application using the `@app.route('/')` decorator, which maps the root URL to this function. When a client makes a request to the root URL, the `index` method is invoked. It uses `flask.request.url` to retrieve the full URL of the current request and returns it as the response. This method is useful for debugging or logging purposes, as it provides the exact URL that was accessed."
        },
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url",
          "code_explanation": "**Main Purpose of the Method**:\nThe `index` method is a Flask route handler that returns the URL of the current request when the root URL (`/`) of the application is accessed.\n\n**How It Works**:\nThe `index` method is defined as a route in a Flask application using the `@app.route('/')` decorator, which maps the root URL (`/`) to this function. When a client makes a request to the root URL, the `index` method is invoked. It uses `flask.request.url` to retrieve the full URL of the current request and returns it as the response. This method is useful for debugging or logging purposes, as it provides the exact URL that was requested."
        }
      ]
    },
    {
      "name": "test_greenlet_context_copying",
      "module": "test_reqctx",
      "class_name": "TestGreenletContextCopying",
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 150,
      "end_line_number": 177,
      "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert not flask.request",
        "assert not flask.current_app",
        "assert not flask.request",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_greenlet_context_copying_api",
      "module": "test_reqctx",
      "class_name": "TestGreenletContextCopying",
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 179,
      "end_line_number": 202,
      "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        }
      ]
    },
    {
      "name": "test_session_error_pops_context",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 205,
      "end_line_number": 226,
      "source_code": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert not flask.request",
        "assert not flask.current_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_session_dynamic_cookie_name",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 229,
      "end_line_number": 277,
      "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
        "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
        "assert test_client.get('/get').data == b'42'",
        "assert test_client.get('/get_dynamic_cookie').data == b'616'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate a POST request to a specified URL within a testing environment, typically for testing web applications built with frameworks like Flask.\n\n**How It Works**:\nThe `test_client.post` method sends a POST request to a given endpoint, optionally including data in the request body. In the context of the provided code snippets, it is used to test various functionalities such as updating a post, validating input during creation or update, and deleting a post. The method allows developers to verify that the server responds correctly to POST requests, including checking status codes, response data, and any changes made to the database. The method is part of a test client, which mimics the behavior of a web client, enabling automated testing of web application routes and logic."
        },
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications built with frameworks like Flask. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `test_client.post` method is part of a test client, which is a tool provided by web frameworks to mimic client-server interactions. When `post` is called, it sends a POST request to a specified URL with optional data. In the context of the provided code snippets, it is used to test various endpoints of a web application. For example, it is used to update a post by sending data to the `/1/update` endpoint and to validate input by checking the response for error messages when required fields are missing. The method returns a response object, which can be used to assert the expected behavior of the application, such as checking status codes, response data, or headers."
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of their Flask routes without needing to run the server.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is created using `app.test_client()`. This method sends a GET request to the specified route and returns a response object. In the context of the provided code, the method is used to test various routes and their responses, such as checking the status code, response data, and session behavior. For example, in the `test_hello` function, `client.get(\"/hello\")` is used to verify that the `/hello` route returns the expected \"Hello, World!\" response. The method is essential for unit testing Flask applications, allowing developers to ensure their routes behave as expected under different conditions."
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of their Flask routes without needing to run the server.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is created using `app.test_client()`. This method sends a GET request to the specified route and returns a response object. In the context of the provided code, the method is used to test various routes and their responses. For example, in the `test_hello` function, `client.get(\"/hello\")` sends a GET request to the `/hello` route, and the response is checked to ensure it returns the expected data (`b\"Hello, World!\"`). The testing client can be used within a context manager to maintain session state and other request-related data across multiple requests."
        }
      ]
    },
    {
      "name": "test_bad_environ_raises_bad_request",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 280,
      "end_line_number": 293,
      "source_code": "def test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n    assert response.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_environ_for_valid_idna_completes",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 296,
      "end_line_number": 314,
      "source_code": "def test_environ_for_valid_idna_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0160\u00df\u044f.com\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_normal_environ_completes",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 317,
      "end_line_number": 325,
      "source_code": "def test_normal_environ_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_greenlet_context_copying",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 150,
      "end_line_number": 177,
      "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert not flask.request",
        "assert not flask.current_app",
        "assert not flask.request",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_greenlet_context_copying_api",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 179,
      "end_line_number": 202,
      "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_rendered",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 4,
      "end_line_number": 22,
      "source_code": "def test_template_rendered(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert template.name == 'simple_template.html'",
        "assert context['whiskey'] == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_before_render_template",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 25,
      "end_line_number": 47,
      "source_code": "def test_before_render_template():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context[\"whiskey\"] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert template.name == 'simple_template.html'",
        "assert context['whiskey'] == 43",
        "assert rv.data == b'<h1>43</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_signals",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 50,
      "end_line_number": 92,
      "source_code": "def test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.data == b'stuff'",
        "assert rv.data == b'stuff'",
        "assert calls == ['before-signal', 'before-handler', 'handler', 'after-handler', 'after-signal']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_exception_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 95,
      "end_line_number": 112,
      "source_code": "def test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client().get('/').status_code == 500",
        "assert len(recorded) == 1",
        "assert isinstance(recorded[0], ZeroDivisionError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_appcontext_signals",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 115,
      "end_line_number": 136,
      "source_code": "def test_appcontext_signals(app, client):\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.data == b\"Hello\"\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello'",
        "assert recorded == ['push', 'pop']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_flash_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 139,
      "end_line_number": 160,
      "source_code": "def test_flash_signal(app):\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert message == 'This is a flash message'",
        "assert category == 'notice'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_appcontext_tearing_down_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 163,
      "end_line_number": 181,
      "source_code": "def test_appcontext_tearing_down_signal(app, client):\n    app.testing = False\n    recorded = []\n\n    def record_teardown(sender, exc):\n        recorded.append(exc)\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert len(recorded) == 1",
        "assert isinstance(recorded[0], ZeroDivisionError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management to persist data across requests for a particular user."
        }
      ]
    },
    {
      "name": "test_send_file",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 34,
      "end_line_number": 43,
      "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.direct_passthrough",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == f.read()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers in a web application."
        },
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
          "code_explanation": "**Main Purpose of the Method**:\nThe `f.read` method is designed to retrieve a value from the session storage in a Flask web application. Specifically, it attempts to get the value associated with the key `'foo'` from the session, returning `0` if the key does not exist.\n\n**How It Works**:\nThe method is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to fetch the value associated with the key `'foo'`. If the key is not present in the session, it defaults to returning `0`. The result is then converted to a string and returned as the response to the client. This allows the application to maintain stateful information about the user across different requests."
        }
      ]
    },
    {
      "name": "test_static_file",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 45,
      "end_line_number": 90,
      "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 10",
        "assert rv.cache_control.max_age == 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of generator cleanup in the provided code snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or signaled, as seen in the context of generator cleanup in the provided code snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers where actions are logged or verified post-request."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:\nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the occurrence of the `close` method being called. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or flagged for further processing or testing purposes."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing or resource management within the application."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log that the `close` method has been called. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or signaled, as seen in the context of handling teardown requests in a web application."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, specifically appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or flagged for further processing or testing purposes."
        }
      ]
    },
    {
      "name": "test_send_from_directory",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 92,
      "end_line_number": 99,
      "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.strip() == b'Hello Subdomain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case involves appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of generator cleanup in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_url_for_with_anchor",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 103,
      "end_line_number": 108,
      "source_code": "def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _anchor='x y') == '/#x%20y'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_scheme",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 110,
      "end_line_number": 118,
      "source_code": "def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_scheme_not_external",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 120,
      "end_line_number": 129,
      "source_code": "def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_alternating_schemes",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost/'",
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'",
        "assert flask.url_for('index', _external=True) == 'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_with_method",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 143,
      "end_line_number": 162,
      "source_code": "def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('myview', _method='GET') == '/myview/'",
        "assert flask.url_for('myview', id=42, _method='GET') == '/myview/42'",
        "assert flask.url_for('myview', _method='POST') == '/myview/create'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_self",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 164,
      "end_line_number": 169,
      "source_code": "def test_url_for_with_self(self, app, req_ctx):\n        @app.route(\"/<self>\")\n        def index(self):\n            return \"42\"\n\n        assert flask.url_for(\"index\", self=\"2\") == \"/2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', self='2') == '/2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_redirect_no_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 172,
      "end_line_number": 175,
      "source_code": "def test_redirect_no_app():\n    response = flask.redirect(\"https://localhost\", 307)\n    assert response.location == \"https://localhost\"\n    assert response.status_code == 307",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.location == 'https://localhost'",
        "assert response.status_code == 307"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_redirect_with_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 178,
      "end_line_number": 185,
      "source_code": "def test_redirect_with_app(app):\n    def redirect(location, code=302):\n        raise ValueError\n\n    app.redirect = redirect\n\n    with app.app_context(), pytest.raises(ValueError):\n        flask.redirect(\"other\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_abort_no_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 188,
      "end_line_number": 193,
      "source_code": "def test_abort_no_app():\n    with pytest.raises(werkzeug.exceptions.Unauthorized):\n        flask.abort(401)\n\n    with pytest.raises(LookupError):\n        flask.abort(900)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_aborter_class",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 196,
      "end_line_number": 204,
      "source_code": "def test_app_aborter_class():\n    class MyAborter(werkzeug.exceptions.Aborter):\n        pass\n\n    class MyFlask(flask.Flask):\n        aborter_class = MyAborter\n\n    app = MyFlask(__name__)\n    assert isinstance(app.aborter, MyAborter)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.aborter, MyAborter)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_abort_with_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 207,
      "end_line_number": 214,
      "source_code": "def test_abort_with_app(app):\n    class My900Error(werkzeug.exceptions.HTTPException):\n        code = 900\n\n    app.aborter.mapping[900] = My900Error\n\n    with app.app_context(), pytest.raises(My900Error):\n        flask.abort(900)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_name_with_import_error",
      "module": "test_helpers",
      "class_name": "TestNoImports",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 228,
      "end_line_number": 233,
      "source_code": "def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "modules_tmp_path"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_streaming_with_context",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 237,
      "end_line_number": 248,
      "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to check for the presence of the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings that can be used in a streaming context, particularly within a Flask application. It generates a personalized greeting message by yielding parts of the message one at a time.\n\n**How It Works**:\nThe `generate` method is a generator function that uses the `yield` keyword to produce a sequence of strings. It first yields the string `'Hello '`, then retrieves and yields the value of the `'name'` parameter from the Flask request's query arguments (`flask.request.args['name']`), and finally yields the string `'!'`. This method is likely used in a context where the response is streamed to the client, allowing parts of the response to be sent as they are generated, rather than waiting for the entire response to be constructed. This can be particularly useful for improving performance and responsiveness in web applications."
        }
      ]
    },
    {
      "name": "test_streaming_with_context_as_decorator",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 250,
      "end_line_number": 262,
      "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings that can be used in a streaming context, particularly within a Flask application. It constructs a simple greeting message by yielding parts of the message one by one.\n\n**How It Works**:\nThe `generate` method is a generator function that yields three parts of a greeting message sequentially. First, it yields the string `'Hello '`. Then, it accesses the `flask.request.args` dictionary to retrieve the value associated with the key `'name'`, which is expected to be passed as a query parameter in the request URL. Finally, it yields the exclamation mark `'!'`. This method is likely used in a context where the response is streamed to the client, allowing parts of the response to be sent as they are generated."
        }
      ]
    },
    {
      "name": "test_streaming_with_context_and_custom_close",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 264,
      "end_line_number": 293,
      "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert called == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings using a generator. It is intended to be used in a context where the `flask.request.args` dictionary contains a key `'name'`, allowing it to dynamically include a name in the generated output.\n\n**How It Works**:\nThe `generate` method is a generator function, which means it uses the `yield` keyword to produce values one at a time. When called, it will:\n1. Yield the string `'Hello '`.\n2. Yield the value associated with the key `'name'` from the `flask.request.args` dictionary, which contains query parameters from the current HTTP request.\n3. Yield the string `'!'`.\n\nThis method is likely used in a Flask application to create a personalized greeting message by streaming parts of the response. The use of `yield` allows the function to be paused and resumed, making it suitable for streaming responses in a web application context."
        }
      ]
    },
    {
      "name": "test_stream_keeps_session",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 295,
      "end_line_number": 307,
      "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'flask'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "gen",
          "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `gen` method is designed to yield a value from the Flask session, specifically the value associated with the key `'test'`. It is intended to be used in a context where the request context needs to be preserved during streaming responses.\n\n**How It Works**:\nThe `gen` method is decorated with `@flask.stream_with_context`, which ensures that the request context is maintained while the generator is yielding values. This is important because, in Flask, the request context is typically removed once the response starts being sent to the client. By using `stream_with_context`, the method can access request-bound information, such as session data, even during streaming. The method itself simply yields the value stored in `flask.session['test']`, allowing it to be part of a streamed response."
        }
      ]
    },
    {
      "name": "test_get_debug_flag",
      "module": "test_helpers",
      "class_name": "TestHelpers",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 321,
      "end_line_number": 323,
      "source_code": "def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'expect'), [('', False), ('0', False), ('False', False), ('No', False), ('True', True)])"
      ],
      "arguments": [
        "self",
        "monkeypatch",
        "debug",
        "expect"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_debug_flag() == expect"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_response",
      "module": "test_helpers",
      "class_name": "TestHelpers",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 325,
      "end_line_number": 335,
      "source_code": "def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_open_resource",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 339,
      "end_line_number": 343,
      "source_code": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('r', 'rb', 'rt'))"
      ],
      "arguments": [
        "mode"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<h1>Hello World!</h1>' in str(f.read())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
          "code_explanation": "**Main Purpose of the Method**:\nThe `f.read` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'foo'`. If the key does not exist in the session, it defaults to returning `0`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('foo', 0)`. This function attempts to fetch the value associated with the key `'foo'` from the session. If the key is not present, it returns the default value `0`. The result is then converted to a string and returned as the response to the client. This allows the application to maintain state across requests by storing and retrieving data in the session."
        }
      ]
    },
    {
      "name": "test_open_resource_exceptions",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 347,
      "end_line_number": 351,
      "source_code": "def test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('w', 'x', 'a', 'r+'))"
      ],
      "arguments": [
        "mode"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_open_resource_with_encoding",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 355,
      "end_line_number": 360,
      "source_code": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('encoding', ('utf-8', 'utf-16-le'))"
      ],
      "arguments": [
        "tmp_path",
        "encoding"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert f.read() == 'test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
          "code_explanation": "**Main Purpose of the Method**:\nThe `f.read` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'foo'`. If the key does not exist in the session, it defaults to returning `0`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('foo', 0)`. This function attempts to fetch the value associated with the key `'foo'` from the session. If the key is not found, it returns the default value `0`. The result is then converted to a string and returned as the response to the client. This allows the application to maintain state across requests by storing and retrieving data in the session."
        }
      ]
    },
    {
      "name": "test_send_file",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 34,
      "end_line_number": 43,
      "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.direct_passthrough",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == f.read()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers where similar patterns of appending to a list are used to track the execution of certain actions."
        },
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
          "code_explanation": "**Main Purpose of the Method**:\nThe `f.read` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'foo'`. If the key does not exist in the session, it defaults to returning `0`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('foo', 0)`. This function attempts to fetch the value associated with the key `'foo'` from the session. If the key is not present, it returns the default value `0`. The result is then converted to a string and returned as the response to the client. This allows the application to maintain state across requests by storing and retrieving data in the session."
        }
      ]
    },
    {
      "name": "test_static_file",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 45,
      "end_line_number": 90,
      "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 10",
        "assert rv.cache_control.max_age == 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, indicated by appending the number 42 to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the integer 42 to a list called `called`. This action is likely used as a marker or flag to indicate that the `close` operation has been executed. The method does not take any parameters and does not return any value. It is typically used in scenarios where a resource or context needs to be closed, and the action of appending to the list serves as a way to track or log this event."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case involves appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers where similar patterns of appending to a list are used to confirm that certain actions have been executed."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, specifically appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the integer `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or flagged for further processing or testing purposes."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, specifically appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method, possibly for testing or debugging purposes. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource needs to be recorded or verified, as seen in the context of teardown request handlers in the provided test snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the fact that the `close` method has been called. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource needs to be recorded or acknowledged, as seen in the context of handling teardown requests in a web application."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the fact that the `close` method was called. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or acknowledged, as seen in the context of handling teardown requests in a web application."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers in a web application."
        }
      ]
    },
    {
      "name": "test_send_from_directory",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 92,
      "end_line_number": 99,
      "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.strip() == b'Hello Subdomain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, specifically appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method, possibly for testing or debugging purposes. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource needs to be recorded or verified."
        }
      ]
    },
    {
      "name": "test_url_for_with_anchor",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 103,
      "end_line_number": 108,
      "source_code": "def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _anchor='x y') == '/#x%20y'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_scheme",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 110,
      "end_line_number": 118,
      "source_code": "def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_scheme_not_external",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 120,
      "end_line_number": 129,
      "source_code": "def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_alternating_schemes",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost/'",
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'",
        "assert flask.url_for('index', _external=True) == 'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_with_method",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 143,
      "end_line_number": 162,
      "source_code": "def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('myview', _method='GET') == '/myview/'",
        "assert flask.url_for('myview', id=42, _method='GET') == '/myview/42'",
        "assert flask.url_for('myview', _method='POST') == '/myview/create'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_self",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 164,
      "end_line_number": 169,
      "source_code": "def test_url_for_with_self(self, app, req_ctx):\n        @app.route(\"/<self>\")\n        def index(self):\n            return \"42\"\n\n        assert flask.url_for(\"index\", self=\"2\") == \"/2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', self='2') == '/2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_name_with_import_error",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 228,
      "end_line_number": 233,
      "source_code": "def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "modules_tmp_path"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_streaming_with_context",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 237,
      "end_line_number": 248,
      "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side and linked to the client via a session cookie."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings that can be used in a streaming response, particularly in a Flask web application context. It generates a personalized greeting message by yielding parts of the message sequentially.\n\n**How It Works**:\nThe `generate` method is a generator function that yields three parts of a greeting message. First, it yields the string `'Hello '`. Then, it accesses the `flask.request.args` dictionary to retrieve the value associated with the key `'name'`, which is expected to be passed as a query parameter in the URL. Finally, it yields the exclamation mark `'!'`. This sequence of yields allows the method to produce a complete greeting message like \"Hello [name]!\" when the values are concatenated. The use of `yield` makes it suitable for streaming responses, where parts of the response are sent to the client as they are generated."
        }
      ]
    },
    {
      "name": "test_streaming_with_context_as_decorator",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 250,
      "end_line_number": 262,
      "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings that can be used in a streaming response, particularly in a Flask web application context. It dynamically constructs a greeting message by incorporating a name provided through a request's query parameters.\n\n**How It Works**:\nThe `generate` method is a generator function, which means it uses the `yield` keyword to produce values one at a time, allowing for efficient memory usage when dealing with potentially large data streams. In this specific implementation, it yields three parts of a greeting message: the string `'Hello '`, the value of the `'name'` query parameter from the current Flask request, and the string `'!'`. This setup allows the method to be used in a streaming context, where each part of the message is sent to the client as it is generated, rather than waiting for the entire message to be constructed. This is particularly useful in web applications for sending data to the client incrementally."
        }
      ]
    },
    {
      "name": "test_streaming_with_context_and_custom_close",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 264,
      "end_line_number": 293,
      "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert called == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to produce a sequence of strings that can be used in a streaming response, particularly in a Flask web application context. It constructs a simple greeting message by yielding parts of the message one by one.\n\n**How It Works**:\nThe `generate` method is a generator function that yields three parts of a greeting message sequentially. First, it yields the string `'Hello '`. Then, it accesses the `flask.request.args` dictionary to retrieve the value associated with the key `'name'`, which is expected to be passed as a query parameter in the URL. Finally, it yields the exclamation mark `'!'`. This method is likely used in a context where the response is streamed to the client, allowing parts of the response to be sent as they are generated, rather than waiting for the entire response to be constructed."
        }
      ]
    },
    {
      "name": "test_stream_keeps_session",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 295,
      "end_line_number": 307,
      "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'flask'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "gen",
          "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `gen` method is designed to yield a value from the Flask session, specifically the value associated with the key `'test'`. It is intended to be used in a context where the response is streamed, allowing the session data to be accessed during the streaming process.\n\n**How It Works**:\nThe `gen` method is decorated with `@flask.stream_with_context`, which ensures that the request context is preserved while the response is being streamed. This is important because normally, the request context would be removed once the response starts, making it impossible to access session data. By using `stream_with_context`, the method can yield the session data (`flask.session['test']`) as part of a streamed response, maintaining access to the session throughout the streaming process. This is particularly useful in scenarios where you need to generate parts of the response dynamically based on session data."
        }
      ]
    },
    {
      "name": "test_get_debug_flag",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 321,
      "end_line_number": 323,
      "source_code": "def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'expect'), [('', False), ('0', False), ('False', False), ('No', False), ('True', True)])"
      ],
      "arguments": [
        "self",
        "monkeypatch",
        "debug",
        "expect"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_debug_flag() == expect"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_response",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 325,
      "end_line_number": 335,
      "source_code": "def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_route",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 82,
      "end_line_number": 87,
      "source_code": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ['/', '/home', '/bp/', '/view', '/methodview'])"
      ],
      "arguments": [
        "path",
        "async_app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'GET' in response.get_data()",
        "assert b'POST' in response.get_data()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of their Flask routes without needing to run the server.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is created using `app.test_client()`. This method sends a GET request to the specified route and returns a response object. In the context of the provided code, the method is used to test various routes and their responses. For example, in the `test_hello` function, `client.get(\"/hello\")` sends a GET request to the `/hello` route, and the response is checked to ensure it returns the expected data (`b\"Hello, World!\"`). Similarly, in other tests, it is used to verify the status codes and data returned by different routes, ensuring the application behaves as expected under various conditions."
        },
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications built with frameworks like Flask. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `test_client.post` method is part of a test client, which is a tool provided by web frameworks to mimic client-server interactions. When `post` is called, it sends a POST request to a specified URL with optional data, headers, and other parameters. In the context of the provided code snippets, it is used to test various endpoints of a web application, such as updating a post or validating input during creation. The method returns a response object, which can be used to assert expected outcomes, such as checking the status code or response data to ensure the application behaves as intended under different scenarios."
        }
      ]
    },
    {
      "name": "test_async_error_handler",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 91,
      "end_line_number": 94,
      "source_code": "def test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ['/error', '/bp/error'])"
      ],
      "arguments": [
        "path",
        "async_app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 412"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of their Flask routes without needing to run the server.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is created using `app.test_client()`. This client mimics a web browser, allowing you to send requests to your Flask application. When you call `client.get('/get')`, it sends a GET request to the `/get` route of the application. In the context of the provided method body, this route retrieves a value from the session using `flask.session.get('value', 'None')` and returns it. If the session does not contain the key 'value', it defaults to returning the string 'None'. This method is useful for verifying that your application routes return the expected responses under various conditions."
        }
      ]
    },
    {
      "name": "test_async_before_after_request",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 97,
      "end_line_number": 145,
      "source_code": "def test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert app_before_called",
        "assert app_after_called",
        "assert bp_before_called",
        "assert bp_after_called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of the application when a GET request is made to a particular endpoint.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is used to interact with the application in a test environment. When `test_client.get` is called with a specific route, it sends a GET request to that route. The application processes the request as it would in a real scenario, executing the corresponding view function. The method returns a response object that contains the data returned by the view function, the status code, and other response details. This allows developers to assert and verify the expected behavior and output of the application for the given route. In the provided code snippet, the `get` function retrieves a value from the session and returns it, which can be tested using `test_client.get` to ensure the session handling and response are correct."
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `test_client.get` method is used to simulate a GET request to a specified route in a Flask application during testing. It allows developers to test the behavior and response of their Flask routes without needing to run the server.\n\n**How It Works**:\nThe `test_client.get` method is part of Flask's testing client, which is created using `app.test_client()`. This method sends a GET request to the specified route and returns a response object. In the context of the provided code, the method is used to test various routes and their responses. For example, in the `test_hello` function, `client.get(\"/hello\")` sends a GET request to the `/hello` route, and the response is checked to ensure it returns the expected data (`b\"Hello, World!\"`). Similarly, in other test functions, `test_client.get` is used to verify the status codes and data returned by different routes, ensuring the application behaves as expected under various conditions."
        }
      ]
    },
    {
      "name": "test_suppressed_exception_logging",
      "module": "test_subclassing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_subclassing.py",
      "line_number": 6,
      "end_line_number": 21,
      "source_code": "def test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io.StringIO",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert b'Internal Server Error' in rv.data",
        "assert not out.getvalue()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_options_work",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 30,
      "end_line_number": 37,
      "source_code": "def test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
        "assert rv.data == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_options_on_multiple_rules",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 40,
      "end_line_number": 50,
      "source_code": "def test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_method_route",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 54,
      "end_line_number": 62,
      "source_code": "def test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', ['get', 'post', 'put', 'delete', 'patch'])"
      ],
      "arguments": [
        "app",
        "client",
        "method"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client_method('/').data == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_method_route_no_methods",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 65,
      "end_line_number": 67,
      "source_code": "def test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests to the specified URL path. In this case, it is used to create a route for the `/get` endpoint, which retrieves a value from the session and returns it as a response.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which registers the function `get()` as a handler for GET requests to the `/get` URL. Inside the `get()` function, it attempts to retrieve a value associated with the key `'value'` from the Flask session using `flask.session.get('value', 'None')`. If the key does not exist in the session, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to persist data across requests."
        }
      ]
    },
    {
      "name": "test_provide_automatic_options_attr",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 70,
      "end_line_number": 89,
      "source_code": "def test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['OPTIONS']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_provide_automatic_options_kwarg",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 92,
      "end_line_number": 126,
      "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD']",
        "assert rv.status_code == 405",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
        "assert rv.status_code == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests, such as form submissions or API calls.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint within the application being tested. The method can accept additional parameters, such as `data`, which represents the form data or payload to be sent with the request. In the context of the provided code snippets, `client.post` is used to test various functionalities like updating a post, validating form inputs, and deleting a post. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code, response data, or headers."
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It provides a way to respond to HEAD requests by returning a response with specific headers, without including a message body.\n\n**How It Works**:\nThe `client.head` method is implemented within a Flask view class, typically a subclass of `flask.views.MethodView`. When a HEAD request is made to a route associated with this view, the `head` method is invoked. It returns a `flask.Response` object with an empty body and a custom header `X-Method` set to \"HEAD\". This method ensures that the response adheres to the HTTP specification for HEAD requests, which should not contain a message body but can include headers. The method is tested in the `test_explicit_head` function, which verifies that the response data is empty and the custom header is correctly set."
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.delete` method is designed to simulate an HTTP DELETE request in a testing environment, typically used to test the deletion of resources in a web application.\n\n**How It Works**:\nThe method `delete` is a simple function that returns the string `'DELETE'`. In the context of a testing framework, this method would be part of a client object that mimics HTTP requests. When invoked, it simulates sending a DELETE request to a server. The method itself does not perform any actual deletion but is used to verify that the application correctly handles DELETE requests, as seen in the `test_delete` function where it checks if a post is successfully deleted from the database."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment. It is typically used in unit tests to test the behavior of web applications when they receive POST requests.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often provided by web frameworks like Flask, to facilitate testing of web applications. When called, it sends a POST request to a specified URL with optional data. In the context of the provided code snippets, `client.post` is used to test various endpoints of a web application. For example, it is used to test the update functionality by sending updated data to the `/1/update` endpoint and to test validation by sending incomplete data to endpoints like `/create` and `/1/update`. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code or the presence of specific messages in the response data."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_request_dispatching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 129,
      "end_line_number": 149,
      "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint within the application, optionally including data as form-encoded parameters. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking the status code, response data, or headers. This helps ensure that the application behaves correctly when handling POST requests."
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It provides a way to respond to HEAD requests by returning a response with specific headers, without including a message body.\n\n**How It Works**:\nThe `client.head` method is implemented within a Flask view class, typically a subclass of `flask.views.MethodView`. When a HEAD request is made to a route associated with this view, the `head` method is invoked. It returns a `flask.Response` object with an empty body and a custom header `X-Method` set to \"HEAD\". This method is useful for explicitly defining behavior for HEAD requests, ensuring that the response headers are correctly set while the body remains empty, as per the HTTP specification for HEAD requests."
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.delete` method is designed to simulate an HTTP DELETE request in a testing environment, typically used in web applications to test the deletion of resources.\n\n**How It Works**:\nThe method `delete` is a simple function that returns the string `'DELETE'`. In the context of a testing framework, this method would be part of a client object that mimics HTTP requests. When invoked, it simulates sending a DELETE request to a server endpoint. The method itself does not perform any deletion logic; instead, it is likely used in conjunction with a testing framework to verify that the server correctly handles DELETE requests, as seen in the `test_delete` function where a POST request to a delete endpoint is tested to ensure the resource is removed from the database."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method is useful for accessing session data in a web application context, allowing for persistent user-specific data across requests."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests, such as form submissions or API calls.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL with optional data, headers, and other parameters. In the provided code snippets, `client.post` is used to test various endpoints of a web application. For example, it is used to update a post, validate form submissions, and delete a post. The method returns a response object, which can be used to assert the expected behavior of the application, such as checking the status code, response data, or redirection headers."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_disallow_string_for_allowed_methods",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 152,
      "end_line_number": 154,
      "source_code": "def test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_mapping",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 157,
      "end_line_number": 190,
      "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
        "assert rv.status_code == 200",
        "assert random_uuid4 in rv.data.decode('utf-8')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint with optional data payloads. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post or deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking response status codes, headers, or content. This helps ensure that the application behaves correctly when handling POST requests, such as creating or updating resources."
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It allows the server to respond to a HEAD request by returning only the headers without the response body, which is useful for checking what a GET request would return without actually fetching the data.\n\n**How It Works**:\nThe `client.head` method is implemented within a Flask view class, typically a subclass of `flask.views.MethodView`. When a HEAD request is made to a route, the `head` method is invoked. In the provided implementation, it returns a `flask.Response` object with an empty body and a custom header `X-Method` set to \"HEAD\". This response indicates that the request was processed as a HEAD request, and the client receives only the headers, confirming the server's ability to handle the request without sending the full content."
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.delete` method is designed to simulate an HTTP DELETE request in a testing environment, typically used in web applications to test the deletion of resources.\n\n**How It Works**:\nThe method `delete` is a simple function that returns the string `'DELETE'`. In the context of a testing framework, this method would be part of a client object that mimics HTTP requests. When invoked, it simulates sending a DELETE request to a server endpoint. The method itself does not perform any deletion logic; instead, it is likely used in conjunction with a testing framework to verify that the server correctly handles DELETE requests, as seen in the `test_delete` function where a POST request to a delete endpoint is tested for proper redirection and resource removal from the database."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint within the application, optionally including data in the request body. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking the status code, response data, or headers. This helps ensure that the application behaves correctly when handling POST requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_werkzeug_routing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 193,
      "end_line_number": 211,
      "source_code": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'index'",
        "assert client.get('/foo/bar').data == b'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.url_map.add` method is designed to increment a counter each time it is called. This method is likely part of a larger system that tracks the number of times certain actions or configurations are added to the application's URL map.\n\n**How It Works**:\nThe method `add(self, app)` is a simple function that increases the `count` attribute of the object by 1 every time it is invoked. This suggests that the method is used to keep track of how many times something (presumably related to URL mapping or configuration) has been added to the application. The method does not interact with the `app` parameter directly, indicating that its primary role is to update the internal state (`count`) of the object it belongs to."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server side and linked to the client via a session cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_endpoint_decorator",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 214,
      "end_line_number": 231,
      "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'index'",
        "assert client.get('/foo/bar').data == b'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.url_map.add` method is designed to increment a counter each time it is called. This method is likely part of a larger system that tracks or manages the number of times certain actions or configurations are added to the application's URL map.\n\n**How It Works**:\nThe method `add(self, app)` is a simple function that increases the `count` attribute of the object by 1 every time it is invoked. This suggests that the method is used to keep track of how many times something (possibly a URL rule or a configuration) has been added to the application's URL map. The method does not interact with the `app` parameter directly within its body, indicating that the parameter might be used elsewhere in the class or is part of a required method signature. The simplicity of the method implies that it serves as a counter mechanism within a larger framework or application logic."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 234,
      "end_line_number": 254,
      "source_code": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.post('/set', data={'value': '42'}).data == b'value set'",
        "assert client.get('/get').data == b'42'",
        "assert not flask.session.accessed",
        "assert not flask.session.modified",
        "assert flask.session.accessed",
        "assert flask.session.modified",
        "assert not flask.session.accessed",
        "assert not flask.session.modified",
        "assert flask.session.accessed",
        "assert not flask.session.modified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It is part of a test client that mimics the behavior of a web browser, allowing developers to test the server-side logic of their web applications.\n\n**How It Works**:\nThe `client.post` method sends a POST request to a specified URL endpoint with optional data payload. In the context of the provided code snippets, it is used to test various functionalities of a web application, such as updating a post, validating form inputs, and deleting a post. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code, response data, or headers. This method is crucial for ensuring that the server-side logic correctly handles POST requests and performs the intended operations, such as creating, updating, or deleting resources in the application."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 257,
      "end_line_number": 266,
      "source_code": "def test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'path=/foo' in rv.headers['set-cookie'].lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_using_application_root",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 269,
      "end_line_number": 288,
      "source_code": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'path=/bar' in rv.headers['set-cookie'].lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "self.app",
          "body": "@pytest.fixture()\ndef app(self, app):\n\n    @app.route('/custom')\n    def do_custom():\n        raise self.Custom()\n\n    @app.route('/error')\n    def do_error():\n        raise KeyError()\n\n    @app.route('/abort')\n    def do_abort():\n        flask.abort(500)\n\n    @app.route('/raise')\n    def do_raise():\n        raise InternalServerError()\n    app.config['PROPAGATE_EXCEPTIONS'] = False\n    return app",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app` method is a pytest fixture designed to set up a Flask application with specific routes that trigger different types of exceptions. This setup is used for testing how the application handles various error scenarios.\n\n**How It Works**:\nThe method decorates a function with `@pytest.fixture()`, indicating that it is a fixture for use in pytest tests. Inside the function, several routes are defined on the Flask `app` object:\n\n- `/custom`: Raises a custom exception (`self.Custom()`).\n- `/error`: Raises a `KeyError`.\n- `/abort`: Calls `flask.abort(500)`, which raises an HTTP 500 error.\n- `/raise`: Raises an `InternalServerError`.\n\nThe configuration `app.config['PROPAGATE_EXCEPTIONS'] = False` is set to ensure that exceptions are not propagated to the WSGI server, allowing the error handlers to process them. The method returns the configured `app` object, which can then be used in tests to verify the application's error handling behavior."
        }
      ]
    },
    {
      "name": "test_session_using_session_settings",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 291,
      "end_line_number": 331,
      "source_code": "def test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PARTITIONED=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
        "assert 'path=/' in cookie",
        "assert 'secure' in cookie",
        "assert 'httponly' not in cookie",
        "assert 'samesite' in cookie",
        "assert 'partitioned' in cookie",
        "assert 'session=;' in cookie",
        "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
        "assert 'path=/' in cookie",
        "assert 'secure' in cookie",
        "assert 'samesite' in cookie",
        "assert 'partitioned' in cookie"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_using_samesite_attribute",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 334,
      "end_line_number": 358,
      "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'samesite' not in cookie",
        "assert 'samesite=strict' in cookie",
        "assert 'samesite=lax' in cookie"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to retrieve the value associated with the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        }
      ]
    },
    {
      "name": "test_missing_session",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 361,
      "end_line_number": 371,
      "source_code": "def test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.value.args and 'session is unavailable' in e.value.args[0]",
        "assert flask.session.get('missing_key') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "expect_exception",
          "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_exception` method is designed to test whether a specific function call raises a `RuntimeError` with a particular error message. It is used to ensure that certain operations, which are expected to fail under specific conditions, do indeed raise the appropriate exception.\n\n**How It Works**:\nThe method takes a function `f` and its arguments (`*args` and `**kwargs`) as input. It uses `pytest.raises` to execute the function and check if it raises a `RuntimeError`. If the exception is raised, the method asserts that the exception's message contains the phrase \"session is unavailable\". This is useful in testing scenarios where the session is expected to be unavailable, such as when a secret key is not set in a Flask application. The method helps verify that the application behaves correctly by raising the expected error in these situations."
        },
        {
          "name": "expect_exception",
          "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_exception` method is designed to test whether a specific function call raises a `RuntimeError` with a particular error message. It is used to ensure that certain operations, which are expected to fail under specific conditions, do indeed raise the appropriate exception.\n\n**How It Works**:\nThe method takes a function `f` and its arguments (`*args` and `**kwargs`) as input. It uses `pytest.raises` to execute the function and check if it raises a `RuntimeError`. If the exception is raised, the method asserts that the exception's message contains the phrase \"session is unavailable\". This is useful in testing scenarios where the session is expected to be unavailable, such as when a secret key is not set in a Flask application. The method helps verify that the application behaves correctly by raising the expected error in these situations."
        }
      ]
    },
    {
      "name": "test_session_secret_key_fallbacks",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 374,
      "end_line_number": 392,
      "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get().json == {'a': 1}",
        "assert client.get().json == {}",
        "assert client.get().json == {'a': 1}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.post` method is used to define a route in a Flask application that handles HTTP POST requests. It is typically used to create new resources or submit data to the server.\n\n**How It Works**:\nThe `app.post` method is a decorator that registers a function to handle POST requests at a specified URL endpoint. When a POST request is made to this endpoint, the associated function is executed. In the provided code snippets, the `post` method returns a simple string 'Create', indicating a placeholder or minimal implementation. In a more complete application, this method would likely involve processing form data, interacting with a database, and returning a response to the client. The method is part of a broader Flask application structure, where routes are defined using decorators like `@bp.post`, and functions handle the logic for creating, updating, or deleting resources."
        },
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests to the specified URL endpoint. In this case, it is used to create a route for the `/get` endpoint.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which registers the function `get()` as a handler for GET requests to the `/get` URL. When a request is made to this endpoint, the function retrieves a value from the Flask session using `flask.session.get('value', 'None')`. If the key `'value'` is not present in the session, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This setup allows the application to manage session data and provide it to the client upon request."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with frameworks like Flask for testing purposes. When invoked, it sends a POST request to a specified URL endpoint with optional data payloads. In the provided code snippets, `client.post` is used to test various endpoints such as `/1/update`, `/create`, and `/1/delete`. The method can include data in the form of a dictionary, which is sent as form data in the request. The response from the server can then be asserted against expected outcomes, such as checking for status codes, response data, or redirection headers. This method is crucial for ensuring that the application correctly processes POST requests and handles data validation, updates, and deletions as expected."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_expiration",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 395,
      "end_line_number": 424,
      "source_code": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'set-cookie' in rv.headers",
        "assert expires.year == expected.year",
        "assert expires.month == expected.month",
        "assert expires.day == expected.day",
        "assert rv.data == b'True'",
        "assert 'set-cookie' in rv.headers",
        "assert match is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_stored_last",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 427,
      "end_line_number": 438,
      "source_code": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'None'",
        "assert client.get('/').data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_special_types",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 441,
      "end_line_number": 469,
      "source_code": "def test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert s['t'] == (1, 2, 3)",
        "assert type(s['b']) is bytes",
        "assert s['b'] == b'\\xff'",
        "assert type(s['m']) is Markup",
        "assert s['m'] == Markup('<html>')",
        "assert s['u'] == the_uuid",
        "assert s['d'] == now",
        "assert s['t_tag'] == {' t': 'not-a-tuple'}",
        "assert s['di_t_tag'] == {' t__': 'not-a-tuple'}",
        "assert s['di_tag'] == {' di': 'not-a-dict'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_cookie_setting",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 472,
      "end_line_number": 510,
      "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/bump').data == b'1'",
        "assert c.get('/bump').data == b'2'",
        "assert c.get('/bump').data == b'3'",
        "assert (set_cookie is not None) == expect_header",
        "assert rv.data == b'3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to test the behavior of session cookies in a Flask application, specifically checking whether a `set-cookie` header is present in the response based on different session configurations.\n\n**How It Works**:\nThe method uses Flask's test client to simulate HTTP requests to two endpoints: `/bump` and `/read`. The `/bump` endpoint increments a session variable, while the `/read` endpoint returns the current value of that session variable. The method performs the following steps:\n1. It sends three consecutive GET requests to the `/bump` endpoint, asserting that the session variable increments correctly (from `1` to `3`).\n2. It sends a GET request to the `/read` endpoint to retrieve the current session value, asserting it equals `3`.\n3. It checks the response headers for a `set-cookie` header and asserts its presence or absence based on the `expect_header` parameter.\n4. The method is called multiple times with different configurations of `is_permanent` and `SESSION_REFRESH_EACH_REQUEST` to test various scenarios of session persistence and cookie setting behavior."
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to test the behavior of session management in a Flask application, specifically focusing on how session cookies are set based on different configurations of session permanence and session refresh settings.\n\n**How It Works**:\nThe method uses Flask's test client to simulate HTTP requests to two endpoints: `/bump` and `/read`. The `/bump` endpoint increments a session variable `foo` and sets the session's permanence based on the `is_permanent` flag. The `/read` endpoint returns the current value of `foo`. The `run_test` method performs the following steps:\n1. It sends three consecutive GET requests to `/bump`, expecting the session variable `foo` to increment from 1 to 3.\n2. It sends a GET request to `/read` to verify that the session variable `foo` is indeed 3.\n3. It checks the response headers for a `set-cookie` header, which indicates whether a session cookie was set. This is compared against the `expect_header` parameter to ensure the behavior matches the expected outcome based on the session configuration.\n4. The method is called multiple times with different configurations of `is_permanent` and `SESSION_REFRESH_EACH_REQUEST` to test various scenarios of session cookie behavior."
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to test the behavior of session management in a Flask application, specifically focusing on how session cookies are set and managed based on different configurations.\n\n**How It Works**:\nThe method uses Flask's test client to simulate HTTP requests to two endpoints: `/bump` and `/read`. The `/bump` endpoint increments a session variable, while the `/read` endpoint returns the current value of that session variable. The method performs the following steps:\n1. It sends three consecutive GET requests to the `/bump` endpoint, asserting that the session variable increments correctly, returning `b'1'`, `b'2'`, and `b'3'` respectively.\n2. It then sends a GET request to the `/read` endpoint to verify that the session variable's value is `b'3'`.\n3. The method checks the response headers for a `set-cookie` header, which indicates whether a session cookie was set. It asserts that the presence of this header matches the `expect_header` parameter, which is determined by the session's configuration settings (`SESSION_REFRESH_EACH_REQUEST` and `permanent` status).\n4. The method is used in various configurations to test different scenarios of session persistence and cookie setting behavior."
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to test the behavior of session management in a Flask application, specifically focusing on how session cookies are set based on different configurations of session permanence and session refresh settings.\n\n**How It Works**:\nThe method uses Flask's test client to simulate HTTP requests to two endpoints: `/bump` and `/read`. The `/bump` endpoint increments a session variable `foo` and sets the session's permanence based on the `is_permanent` flag. The `/read` endpoint returns the current value of `foo`. The `run_test` method performs the following steps:\n1. It sends three consecutive GET requests to `/bump`, expecting the session variable `foo` to increment from 1 to 3.\n2. It sends a GET request to `/read` to verify that the session variable `foo` is indeed 3.\n3. It checks the response headers for a `set-cookie` header, which indicates whether a session cookie was set. This is compared against the `expect_header` parameter to ensure the behavior matches the expected outcome based on the session configuration.\n4. The method is called multiple times with different configurations of `is_permanent` and `SESSION_REFRESH_EACH_REQUEST` to test various scenarios of session cookie behavior."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests for a user."
        },
        {
          "name": "rv.headers.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `rv.headers.get` method is used to retrieve the value of a specific header from the response headers in a Flask application. It is particularly useful for accessing headers like \"set-cookie\" to verify or manipulate session-related data.\n\n**How It Works**:\nIn the context of a Flask application, when a response is generated, it contains headers that can be accessed using the `headers` attribute of the response object. The `get` method on `rv.headers` allows you to specify the name of the header you want to retrieve. If the header is present, its value is returned; otherwise, it returns `None` or a default value if specified. This method is commonly used in testing scenarios to assert the presence and correctness of headers, such as checking if a \"set-cookie\" header is set when managing session cookies."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests for a user."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        }
      ]
    },
    {
      "name": "test_session_vary_cookie",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 513,
      "end_line_number": 571,
      "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(rv.headers.get_all('Vary')) == 1",
        "assert rv.headers['Vary'] == header_value",
        "assert 'Vary' not in rv.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It checks whether the response headers meet the expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then inspects the response headers. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. If no `header_value` is provided, it asserts that the `Vary` header is absent from the response. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios where caching behavior is influenced by the `Vary` header."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It checks whether the response headers meet the expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method sends a GET request to the specified `path` using a test client. It then inspects the response headers to determine if the `Vary` header is present. If a `header_value` is provided, the method asserts that the `Vary` header exists and matches the given `header_value`. If no `header_value` is provided, it asserts that the `Vary` header is absent from the response headers. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios involving caching and content negotiation."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It checks whether the response headers meet the expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then inspects the response headers. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. It also checks that there is exactly one `Vary` header. If no `header_value` is provided, the method asserts that the `Vary` header is absent from the response headers. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios involving caching or content negotiation."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It ensures that the response headers meet expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then checks the response headers for the `Vary` header. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. If no `header_value` is provided, it asserts that the `Vary` header is absent from the response. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios where caching behavior is influenced by the `Vary` header."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It ensures that the response headers meet expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then checks the response headers for the `Vary` header. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. If no `header_value` is provided, it asserts that the `Vary` header is absent from the response. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios where caching behavior is influenced by the `Vary` header."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It checks whether the response headers meet the expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then inspects the response headers. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. If no `header_value` is provided, it asserts that the `Vary` header is absent from the response. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios where caching behavior is influenced by the `Vary` header."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It ensures that the response headers meet expected conditions, particularly focusing on the `Vary` header.\n\n**How It Works**:\nThe method takes two parameters: `path`, which is the URL path to be requested, and `header_value`, which defaults to `'Cookie'`. It uses a test client to send a GET request to the specified path. If `header_value` is provided, the method asserts that the `Vary` header is present in the response and matches the `header_value`. If `header_value` is not provided (i.e., is `None` or `False`), it asserts that the `Vary` header is absent from the response headers. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in web applications using Flask."
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and value of the `Vary` header in the HTTP response from a specified path. It checks whether the response headers meet the expected conditions based on the provided `header_value`.\n\n**How It Works**:\nThe method uses a test client to send a GET request to the specified `path`. It then inspects the response headers. If a `header_value` is provided, the method asserts that the `Vary` header is present and matches the `header_value`. It also checks that there is exactly one `Vary` header. If no `header_value` is provided, the method asserts that the `Vary` header is absent from the response headers. This method is useful for testing how different configurations or routes affect the HTTP response headers, particularly in scenarios involving caching and content negotiation."
        },
        {
          "name": "response.vary.add",
          "body": "def add(self, app):\n    self.count += 1",
          "code_explanation": "**Main Purpose of the Method**:\nThe `response.vary.add` method is designed to modify a `vary` attribute, likely part of a response object, by incrementing a counter. This suggests it is used to track or manage some aspect of the response's variability, possibly related to HTTP caching mechanisms.\n\n**How It Works**:\nThe method `add` takes a parameter `app` but does not use it within the method body. Instead, it simply increments an internal counter `self.count` by 1 each time it is called. This implies that the method's primary function is to keep track of how many times it has been invoked, which could be used to manage or log the variability of responses in a web application context."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_session_refresh_vary",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 574,
      "end_line_number": 588,
      "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.headers['Vary'] == 'Cookie'",
        "assert rv.headers['Vary'] == 'Cookie'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests to the specified URL endpoint. In this case, it is used to create a route for the `/get` endpoint, which retrieves a value from the session and returns it as a response.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which registers the function `get()` as a handler for GET requests to the `/get` URL. Inside the `get()` function, it attempts to retrieve a value associated with the key `'value'` from the Flask session using `flask.session.get('value', 'None')`. If the key does not exist in the session, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This setup allows the application to manage session data and provide it to users upon request to the `/get` endpoint."
        },
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests to the specified URL path. In this case, it is used to create a route for the `/get` endpoint, which retrieves a value from the session and returns it as a response.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which registers the function `get()` as a handler for GET requests to the `/get` URL. Inside the `get()` function, it attempts to retrieve a value from the Flask session using `flask.session.get('value', 'None')`. If the key `'value'` is not present in the session, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This setup allows the application to manage session data and provide it to users through a simple GET request."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_flashes",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 591,
      "end_line_number": 597,
      "source_code": "def test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.session.modified",
        "assert flask.session.modified",
        "assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_extended_flashing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 600,
      "end_line_number": 678,
      "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
        "assert len(messages) == 3",
        "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
        "assert list(messages) == [('message', 'Hello World')]",
        "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
        "assert len(messages) == 2",
        "assert messages[0] == 'Hello World'",
        "assert messages[1] == Markup('<em>Testing</em>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to persist data across requests for a particular user."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_request_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 681,
      "end_line_number": 703,
      "source_code": "def test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'after' not in evts",
        "assert 'after' in evts",
        "assert rv == b'request|after'",
        "assert 'before' in evts",
        "assert 'after' not in evts"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_request_preprocessing_early_return",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 706,
      "end_line_number": 730,
      "source_code": "def test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == b'hello'",
        "assert evts == [1, 2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_after_request_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 733,
      "end_line_number": 745,
      "source_code": "def test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.headers['X-Foo'] == 'a header'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_teardown_request_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 748,
      "end_line_number": 763,
      "source_code": "def test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert b'Response' in rv.data",
        "assert len(called) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_teardown_request_handler_debug_mode",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 766,
      "end_line_number": 781,
      "source_code": "def test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert b'Response' in rv.data",
        "assert len(called) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_teardown_request_handler_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 784,
      "end_line_number": 819,
      "source_code": "def test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        raise ZeroDivisionError\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert b'Internal Server Error' in rv.data",
        "assert len(called) == 2",
        "assert type(exc) is ZeroDivisionError",
        "assert type(exc) is ZeroDivisionError"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to retrieve the value associated with the key `'value'`. It uses the `get` method of the session object, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_before_after_request_order",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 822,
      "end_line_number": 857,
      "source_code": "def test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'",
        "assert called == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 860,
      "end_line_number": 895,
      "source_code": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404",
        "assert rv.data == b'not found'",
        "assert rv.status_code == 500",
        "assert b'internal server error' == rv.data",
        "assert rv.status_code == 403",
        "assert b'forbidden' == rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_error_handling_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 898,
      "end_line_number": 916,
      "source_code": "def test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.mimetype == 'text/x-special'",
        "assert resp.data == b'internal server error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side and linked to the client via a session cookie."
        }
      ]
    },
    {
      "name": "test_baseexception_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 919,
      "end_line_number": 927,
      "source_code": "def test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_before_request_and_routing_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 930,
      "end_line_number": 941,
      "source_code": "def test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404",
        "assert rv.data == b'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side and linked to the client via a session cookie."
        }
      ]
    },
    {
      "name": "test_user_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 944,
      "end_line_number": 957,
      "source_code": "def test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'42'",
        "assert isinstance(e, MyException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_http_error_subclass_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 960,
      "end_line_number": 989,
      "source_code": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1').data == b'banana'",
        "assert client.get('/2').data == b'apple'",
        "assert client.get('/3').data == b'apple'",
        "assert isinstance(e, ForbiddenSubclass)",
        "assert not isinstance(e, ForbiddenSubclass)",
        "assert isinstance(e, Forbidden)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_errorhandler_precedence",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 992,
      "end_line_number": 1022,
      "source_code": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Exception'",
        "assert rv.data == b'E2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This functionality is useful for maintaining state across requests in a web application."
        }
      ]
    },
    {
      "name": "test_trap_bad_request_key_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1029,
      "end_line_number": 1057,
      "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
      ],
      "arguments": [
        "app",
        "client",
        "debug",
        "trap",
        "expect_key",
        "expect_abort"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert b'missing_key' not in rv.data",
        "assert exc_info.errisinstance(BadRequest)",
        "assert 'missing_key' in exc_info.value.get_description()",
        "assert rv.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_trapping_of_all_http_exceptions",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1060,
      "end_line_number": 1068,
      "source_code": "def test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to persist data across requests for a user."
        }
      ]
    },
    {
      "name": "test_error_handler_after_processor_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1071,
      "end_line_number": 1097,
      "source_code": "def test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert rv.data == b'Hello Server Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_enctype_debug_helper",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1100,
      "end_line_number": 1112,
      "source_code": "def test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'no file contents were transmitted' in str(e.value)",
        "assert \"This was submitted: 'index.txt'\" in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It is part of a test client that mimics the behavior of a web browser, allowing developers to test how their application handles POST requests.\n\n**How It Works**:\nThe `client.post` method sends a POST request to a specified URL endpoint within the application being tested. It can include data payloads, such as form data, which are passed as a dictionary to the `data` parameter. The method returns a response object that contains the server's response to the request, including status codes and any data returned by the server. This allows developers to assert and verify the behavior of their application when handling POST requests, such as checking if data is correctly updated in a database or if appropriate validation messages are returned."
        }
      ]
    },
    {
      "name": "test_response_types",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1115,
      "end_line_number": 1206,
      "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
        "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
        "assert rv.data == b'Meh'",
        "assert rv.headers['X-Foo'] == 'Testing'",
        "assert rv.status_code == 400",
        "assert rv.mimetype == 'text/plain'",
        "assert rv.data == b'Hello'",
        "assert rv.headers['X-Foo'] == 'Test'",
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/plain'",
        "assert rv.data == b'Hi, status!'",
        "assert rv.status_code == 400",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == b'Hello world'",
        "assert rv.content_type == 'text/plain'",
        "assert rv.headers.getlist('X-Foo') == ['Bar']",
        "assert rv.headers['X-Bar'] == 'Foo'",
        "assert rv.status_code == 404",
        "assert rv.data == b'Hello world'",
        "assert rv.status_code == 500",
        "assert b'Not Found' in rv.data",
        "assert rv.status_code == 404",
        "assert rv.json == {'foo': 'bar'}",
        "assert rv.status_code == 201",
        "assert rv.json == ['foo', 'bar']",
        "assert rv.status_code == 201"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_response_type_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1209,
      "end_line_number": 1255,
      "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'returned None' in str(e.value)",
        "assert 'from_none' in str(e.value)",
        "assert 'tuple must have the form' in str(e.value)",
        "assert 'it was a bool' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        }
      ]
    },
    {
      "name": "test_make_response",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1258,
      "end_line_number": 1277,
      "source_code": "def test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(c for c in \"Hello\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Hello\"\n    assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.data == b''",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Awesome'",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 404",
        "assert rv.data == b'W00t'",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_response_with_response_instance",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1280,
      "end_line_number": 1298,
      "source_code": "def test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert rv.data == b'{\"msg\":\"W00t\"}\\n'",
        "assert rv.mimetype == 'application/json'",
        "assert rv.status_code == 400",
        "assert rv.data == b''",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 400",
        "assert rv.headers['Content-Type'] == 'text/html'",
        "assert rv.headers['X-Foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_jsonify_no_prettyprint",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1302,
      "end_line_number": 1307,
      "source_code": "def test_jsonify_no_prettyprint(app, compact):\n    app.json.compact = compact\n    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n    data = rv.data.strip()\n    assert (b\" \" not in data) is compact\n    assert (b\"\\n\" not in data) is compact",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('compact', [True, False])"
      ],
      "arguments": [
        "app",
        "compact"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert (b' ' not in data) is compact",
        "assert (b'\\n' not in data) is compact"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_jsonify_mimetype",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1310,
      "end_line_number": 1314,
      "source_code": "def test_jsonify_mimetype(app, req_ctx):\n    app.json.mimetype = \"application/vnd.api+json\"\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application/vnd.api+json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/vnd.api+json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_dump_dataclass",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1317,
      "end_line_number": 1323,
      "source_code": "def test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert value == {'name': 'Flask'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.json.loads` method is designed to deserialize a JSON-formatted string into a Python object. It is part of a custom JSON provider that allows for additional customization during the deserialization process.\n\n**How It Works**:\nThe `loads` method takes a JSON string `s` and optional keyword arguments `kwargs`. It sets a default `object_hook` in `kwargs` to a custom method `self.object_hook`, which can modify the deserialization behavior. This `object_hook` is used to transform JSON objects during the deserialization process. The method then calls the `loads` method of its superclass, passing the JSON string and the modified `kwargs`. This allows for custom handling of JSON objects, such as converting specific JSON structures into custom Python objects, as demonstrated in the test case where a JSON object with a key `_foo` is converted into an instance of a custom class `X`."
        }
      ]
    },
    {
      "name": "test_jsonify_args_and_kwargs_check",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1326,
      "end_line_number": 1329,
      "source_code": "def test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"args or kwargs\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'args or kwargs' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_generation",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1332,
      "end_line_number": 1341,
      "source_code": "def test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('hello', name='test x') == '/hello/test%20x'",
        "assert flask.url_for('hello', name='test x', _external=True) == 'http://localhost/hello/test%20x'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_error_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1344,
      "end_line_number": 1367,
      "source_code": "def test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('spam') == '/test_handler/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_error_handler_reraise",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1370,
      "end_line_number": 1378,
      "source_code": "def test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_passes_special_values_to_build_error_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1381,
      "end_line_number": 1393,
      "source_code": "def test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert values == {'_external': False, '_anchor': None, '_method': None, '_scheme': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_files",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1396,
      "end_line_number": 1402,
      "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
        "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific cleanup action by appending the integer `42` to a list named `called`. This method is likely used as part of a larger process to track or signal that a particular resource or operation has been closed or completed.\n\n**How It Works**:  \nThe `close` method is a simple function that, when called, appends the number `42` to the `called` list. This action serves as a marker or flag indicating that the method has been executed. The method does not take any parameters and does not return any value. It is typically used in a context where the presence of `42` in the `called` list signifies that the `close` operation has been successfully performed, possibly as part of a teardown or cleanup process in a larger application or testing framework."
        }
      ]
    },
    {
      "name": "test_static_url_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1405,
      "end_line_number": 1413,
      "source_code": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or signaled, as seen in the context of a generator or a teardown request handler where cleanup actions are necessary."
        }
      ]
    },
    {
      "name": "test_static_url_path_with_ending_slash",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1416,
      "end_line_number": 1424,
      "source_code": "def test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of a generator where `gen.close()` is called if the generator has a `close` method."
        }
      ]
    },
    {
      "name": "test_static_url_empty_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1427,
      "end_line_number": 1431,
      "source_code": "def test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of a generator where `gen.close()` is called if the generator has a `close` method."
        }
      ]
    },
    {
      "name": "test_static_url_empty_path_default",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1434,
      "end_line_number": 1438,
      "source_code": "def test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing or resource management within the application."
        }
      ]
    },
    {
      "name": "test_static_folder_with_pathlib_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1441,
      "end_line_number": 1447,
      "source_code": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case involves appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource or context needs to be recorded or flagged, as seen in the context of teardown request handlers in the provided test snippets."
        }
      ]
    },
    {
      "name": "test_static_folder_with_ending_slash",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1450,
      "end_line_number": 1458,
      "source_code": "def test_static_folder_with_ending_slash():\n    app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'catch/all'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_route_with_host_matching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1461,
      "end_line_number": 1479,
      "source_code": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv == 'http://example.com/static/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If this key is not present in the session, the method defaults to returning the string `'None'`. The retrieved value is then returned as the response to the HTTP request. This functionality is useful for maintaining state or user-specific data between requests in a web application."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers where actions are logged or verified post-request."
        }
      ]
    },
    {
      "name": "test_request_locals",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1482,
      "end_line_number": 1484,
      "source_code": "def test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(flask.g) == '<LocalProxy unbound>'",
        "assert not flask.g"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_server_name_matching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1495,
      "end_line_number": 1526,
      "source_code": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('subdomain_matching', 'host_matching', 'expect_base', 'expect_abc', 'expect_xyz'), [(False, False, 'default', 'default', 'default'), (True, False, 'default', 'abc', '<invalid>'), (False, True, 'default', 'abc', 'default')])"
      ],
      "arguments": [
        "subdomain_matching",
        "host_matching",
        "expect_base",
        "expect_abc",
        "expect_xyz"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.text == expect_base",
        "assert r.text == expect_abc",
        "assert r.text == expect_xyz"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side or in a client-side cookie, depending on the session interface configuration."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This call attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_server_name_subdomain",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1529,
      "end_line_number": 1571,
      "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'subdomain'",
        "assert rv.data == b'default'",
        "assert rv.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side or in a client-side cookie, depending on the session interface configuration."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_exception_propagation",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1575,
      "end_line_number": 1588,
      "source_code": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('key', ['TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None])"
      ],
      "arguments": [
        "app",
        "client",
        "key"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').status_code == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_werkzeug_passthrough_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1595,
      "end_line_number": 1606,
      "source_code": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', [True, False])",
        "pytest.mark.parametrize('use_debugger', [True, False])",
        "pytest.mark.parametrize('use_reloader', [True, False])",
        "pytest.mark.parametrize('propagate_exceptions', [None, True, False])"
      ],
      "arguments": [
        "monkeypatch",
        "debug",
        "use_debugger",
        "use_reloader",
        "propagate_exceptions",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "kwargs.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `kwargs.get` method is used to retrieve a value from a dictionary-like object using a specified key, with the option to provide a default value if the key is not found.\n\n**How It Works**:\nIn the context of the provided code, the `flask.session.get('value', 'None')` method is used within a Flask route to attempt to retrieve the value associated with the key `'value'` from the session object. If the key does not exist in the session, it returns the default value `'None'`. This is a common pattern in Flask applications to safely access session data without raising a `KeyError` if the key is missing. The `get` method is a built-in method for dictionary-like objects in Python, providing a safe way to access values with a fallback option."
        }
      ]
    },
    {
      "name": "test_url_processors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1609,
      "end_line_number": 1635,
      "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/foo'",
        "assert client.get('/foo').data == b'/en/about'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
          "code_explanation": "**Main Purpose of the Method**:\nThe `values.setdefault` method in the context of the provided code is used to retrieve a value from a session dictionary in a Flask application. If the specified key does not exist, it sets the key to a default value and returns that default value.\n\n**How It Works**:\nIn the provided code snippet, the `setdefault` method is a route handler in a Flask application. When a request is made to the `/setdefault` endpoint, the method attempts to retrieve the value associated with the key `'test'` from the session. If the key `'test'` does not exist in the session, it sets this key to the value `'default'` and returns `'default'`. This is achieved using the `setdefault` method of the session object, which is a dictionary-like object provided by Flask to manage session data. This method is useful for ensuring that a session key has a default value without overwriting existing values."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_inject_blueprint_url_defaults",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1638,
      "end_line_number": 1659,
      "source_code": "def test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert values == expected",
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_nonascii_pathinfo",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1662,
      "end_line_number": 1668,
      "source_code": "def test_nonascii_pathinfo(app, client):\n    @app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_no_setup_after_first_request",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1671,
      "end_line_number": 1683,
      "source_code": "def test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'Awesome'",
        "assert \"setup method 'add_url_rule'\" in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_routing_redirect_debugging",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1686,
      "end_line_number": 1703,
      "source_code": "def test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'success'",
        "assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to use a real web server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with frameworks like Flask for testing purposes. When invoked, it sends a POST request to a specified URL endpoint within the application. The method can accept additional parameters, such as `data`, which represents the form data to be sent with the request. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post or deleting a post, by sending POST requests with specific data and then asserting the expected outcomes, like changes in the database or specific response messages."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment. It is typically used in unit tests to interact with web applications, allowing developers to test how the application handles POST requests.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often provided by web frameworks like Flask, to facilitate testing of web applications. When invoked, it sends a POST request to a specified URL endpoint with optional data payload. In the context of the provided code snippets, `client.post` is used to test various functionalities such as updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code, response data, or headers. This allows developers to verify that the application behaves correctly when handling POST requests."
        }
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1706,
      "end_line_number": 1728,
      "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'foo'",
        "assert client.get('/bar/').data == b'bar'",
        "assert client.get('/bar/123').data == b'123'",
        "assert flask.url_for('foo') == '/foo/'",
        "assert flask.url_for('bar') == '/bar/'",
        "assert flask.url_for('123') == '/bar/123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_get_method_on_g",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1731,
      "end_line_number": 1736,
      "source_code": "def test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.get('x') is None",
        "assert flask.g.get('x', 11) == 11",
        "assert flask.g.get('x') == 42",
        "assert flask.g.x == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_g_iteration_protocol",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1739,
      "end_line_number": 1744,
      "source_code": "def test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' in flask.g",
        "assert 'foos' not in flask.g",
        "assert sorted(flask.g) == ['bar', 'foo']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subdomain_basic_support",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1747,
      "end_line_number": 1764,
      "source_code": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'normal index'",
        "assert rv.data == b'test index'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to check for the presence of the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value (or the default) is then returned as the response to the client. This method relies on Flask's session management to persist data across requests."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_subdomain_matching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1767,
      "end_line_number": 1777,
      "source_code": "def test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'index for mitsuhiko'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_subdomain_matching_with_ports",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1780,
      "end_line_number": 1790,
      "source_code": "def test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'index for mitsuhiko'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_subdomain_matching_other_name",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1794,
      "end_line_number": 1814,
      "source_code": "def test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('matching', (False, True))"
      ],
      "arguments": [
        "matching"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404 if matching else 204",
        "assert rv.status_code == 404 if matching else 204"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_multi_route_rules",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1817,
      "end_line_number": 1826,
      "source_code": "def test_multi_route_rules(app, client):\n    @app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'a'",
        "assert rv.data == b'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multi_route_class_views",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1829,
      "end_line_number": 1842,
      "source_code": "def test_multi_route_class_views(app, client):\n    class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'a'",
        "assert rv.data == b'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_defaults",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1845,
      "end_line_number": 1854,
      "source_code": "def test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv['result'] == 'running...'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_server_port",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1857,
      "end_line_number": 1867,
      "source_code": "def test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = f\"running on {hostname}:{port} ...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == f\"running on {hostname}:{port} ...\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv['result'] == f'running on {hostname}:{port} ...'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_from_config",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1882,
      "end_line_number": 1891,
      "source_code": "def test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('host,port,server_name,expect_host,expect_port', ((None, None, 'pocoo.org:8080', 'pocoo.org', 8080), ('localhost', None, 'pocoo.org:8080', 'localhost', 8080), (None, 80, 'pocoo.org:8080', 'pocoo.org', 80), ('localhost', 80, 'pocoo.org:8080', 'localhost', 80), ('localhost', 0, 'localhost:8080', 'localhost', 0), (None, None, 'localhost:8080', 'localhost', 8080), (None, None, 'localhost:0', 'localhost', 0)))"
      ],
      "arguments": [
        "monkeypatch",
        "host",
        "port",
        "server_name",
        "expect_host",
        "expect_port",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert hostname == expect_host",
        "assert port == expect_port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_max_cookie_size",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1894,
      "end_line_number": 1921,
      "source_code": "def test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "recwarn"
      ],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.max_cookie_size == default",
        "assert len(recwarn) == 1",
        "assert 'cookie is too large' in str(w.message)",
        "assert len(recwarn) == 0",
        "assert flask.Response().max_cookie_size == 100"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_app_freed_on_zero_refcount",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1925,
      "end_line_number": 1937,
      "source_code": "def test_app_freed_on_zero_refcount():\n    # A Flask instance should not create a reference cycle that prevents CPython\n    # from freeing it when all external references to it are released (see #3761).\n    gc.disable()\n    try:\n        app = flask.Flask(__name__)\n        assert app.view_functions[\"static\"]\n        weak = weakref.ref(app)\n        assert weak() is not None\n        del app\n        assert weak() is None\n    finally:\n        gc.enable()",
      "docstring": null,
      "decorators": [
        "require_cpython_gc"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.view_functions['static']",
        "assert weak() is not None",
        "assert weak() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_with_categories",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 625,
      "end_line_number": 633,
      "source_code": "def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_with_categories/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 3",
        "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filter",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 636,
      "end_line_number": 641,
      "source_code": "def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filter/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == [('message', 'Hello World')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filters",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 644,
      "end_line_number": 652,
      "source_code": "def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filters/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filters2",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 655,
      "end_line_number": 660,
      "source_code": "def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filters_without_returning_categories/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 2",
        "assert messages[0] == 'Hello World'",
        "assert messages[1] == Markup('<em>Testing</em>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_index",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1757,
      "end_line_number": 1758,
      "source_code": "def test_index():\n        return \"test index\"",
      "docstring": null,
      "decorators": [
        "app.route('/', subdomain='test')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "typing",
        "uuid",
        "warnings",
        "weakref",
        "contextlib.nullcontext",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_blueprint_specific_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 8,
      "end_line_number": 43,
      "source_code": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/frontend-no').data == b'frontend says no'",
        "assert client.get('/backend-no').data == b'backend says no'",
        "assert client.get('/what-is-a-sideend').data == b'application itself says no'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_blueprint_specific_user_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 46,
      "end_line_number": 77,
      "source_code": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/decorator').data == b'boom'",
        "assert client.get('/function').data == b'bam'",
        "assert isinstance(e, MyDecoratorException)",
        "assert isinstance(e, MyFunctionException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_blueprint_app_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 80,
      "end_line_number": 101,
      "source_code": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/forbidden').data == b'you shall not pass'",
        "assert client.get('/nope').data == b'you shall not pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_blueprint_prefix_slash",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 120,
      "end_line_number": 128,
      "source_code": "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('prefix', 'rule', 'url'), (('', '/', '/'), ('/', '', '/'), ('/', '/', '/'), ('/foo', '', '/foo'), ('/foo/', '', '/foo/'), ('', '/bar', '/bar'), ('/foo/', '/bar', '/foo/bar'), ('/foo/', 'bar', '/foo/bar'), ('/foo', '/bar', '/foo/bar'), ('/foo/', '//bar', '/foo/bar'), ('/foo//', '/bar', '/foo/bar')))"
      ],
      "arguments": [
        "app",
        "client",
        "prefix",
        "rule",
        "url"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get(url).status_code == 204"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_blueprint_url_defaults",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 131,
      "end_line_number": 148,
      "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1/foo').data == b'23/42'",
        "assert client.get('/2/foo').data == b'19/42'",
        "assert client.get('/1/bar').data == b'23'",
        "assert client.get('/2/bar').data == b'19'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server side and linked to the client via a session cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_blueprint_url_processors",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 151,
      "end_line_number": 173,
      "source_code": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/de/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
          "code_explanation": "**Main Purpose of the Method**:\nThe `values.setdefault` method in the context of the provided code is used to retrieve a value from the Flask session associated with a specific key. If the key does not exist in the session, it sets the key with a default value and returns that default value.\n\n**How It Works**:\nIn the provided code snippet, the `setdefault` method is defined as a route handler in a Flask application. When a request is made to the `/setdefault` route, the method attempts to retrieve the value associated with the key `'test'` from the session. If the key `'test'` is not present in the session, it sets this key with the value `'default'` and returns `'default'`. This is achieved using the `setdefault` method of the session object, which is a dictionary-like object provided by Flask to store session data. This method is useful for ensuring that a session key has a default value without overwriting existing values."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_templates_and_static",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 176,
      "end_line_number": 220,
      "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello from the Frontend'",
        "assert rv.data == b'Hello from the Admin'",
        "assert rv.data == b'Hello from the Admin'",
        "assert rv.data.strip() == b'Admin File'",
        "assert rv.data.strip() == b'/* nested file */'",
        "assert cc.max_age == expected_max_age",
        "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
        "assert e.value.name == 'missing.html'",
        "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, specifically appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method, possibly for testing or debugging purposes. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource needs to be recorded or verified."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing teardown request handlers in a web application."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case involves appending the integer `42` to a list named `called`.\n\n**How It Works**:  \nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the closure of resources or contexts. The method does not take any parameters and does not return any value. It is likely used in a context where the closure of a resource needs to be recorded or verified, as seen in the context of testing or resource management scenarios."
        }
      ]
    },
    {
      "name": "test_default_static_max_age",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 223,
      "end_line_number": 244,
      "source_code": "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert cc.max_age == 100"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `rv.close` method is designed to perform a specific action when closing a resource or context, which in this case is to append the integer `42` to a list named `called`.\n\n**How It Works**:\nThe method `close` is a simple function that, when invoked, appends the number `42` to a list called `called`. This list is presumably used to track or log the invocation of the `close` method, possibly for testing or debugging purposes. The method does not take any parameters and does not return any value. It is likely used in a context where the closing of a resource needs to be recorded or verified."
        }
      ]
    },
    {
      "name": "test_templates_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 247,
      "end_line_number": 251,
      "source_code": "def test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert templates == ['admin/index.html', 'frontend/index.html']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dotted_name_not_allowed",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 254,
      "end_line_number": 256,
      "source_code": "def test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_name_not_allowed",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 259,
      "end_line_number": 261,
      "source_code": "def test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dotted_names_from_app",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 264,
      "end_line_number": 278,
      "source_code": "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'/test/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to persist data across requests for a particular user."
        }
      ]
    },
    {
      "name": "test_empty_url_defaults",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 281,
      "end_line_number": 292,
      "source_code": "def test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'1'",
        "assert client.get('/page/2').data == b'2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 295,
      "end_line_number": 324,
      "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'index'",
        "assert client.get('/py/foo').data == b'bp.foo'",
        "assert client.get('/py/bar').data == b'bp.bar'",
        "assert client.get('/py/bar/123').data == b'bp.123'",
        "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint_with_dots",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 327,
      "end_line_number": 342,
      "source_code": "def test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_endpoint_decorator",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 345,
      "end_line_number": 359,
      "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo').data == b'bar'",
        "assert client.get('/bp_prefix/bar').status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.url_map.add` method is intended to increment a counter each time it is called. This method is likely part of a larger system where the counter is used to track the number of times a particular operation, such as adding a URL rule, is performed.\n\n**How It Works**:\nThe method `add(self, app)` is a simple function that increases the `count` attribute of the object by 1 each time it is invoked. This suggests that the method is used to keep track of how many times a certain action, possibly related to URL mapping or rule addition, has been executed within the application. The method does not interact with the `app` parameter directly, indicating that its primary role is to update the internal state (`count`) of the object it belongs to."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_filter",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 362,
      "end_line_number": 372,
      "source_code": "def test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_filter",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 375,
      "end_line_number": 385,
      "source_code": "def test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_filter_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 388,
      "end_line_number": 398,
      "source_code": "def test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_filter_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 401,
      "end_line_number": 411,
      "source_code": "def test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_filter_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 414,
      "end_line_number": 428,
      "source_code": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_filter_after_route_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 431,
      "end_line_number": 444,
      "source_code": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_filter_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 447,
      "end_line_number": 461,
      "source_code": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 464,
      "end_line_number": 478,
      "source_code": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 481,
      "end_line_number": 495,
      "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_test",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 498,
      "end_line_number": 508,
      "source_code": "def test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is_boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['is_boolean'] == is_boolean",
        "assert app.jinja_env.tests['is_boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_test",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 511,
      "end_line_number": 521,
      "source_code": "def test_add_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is_boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['is_boolean'] == is_boolean",
        "assert app.jinja_env.tests['is_boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_test_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 524,
      "end_line_number": 534,
      "source_code": "def test_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_test_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 537,
      "end_line_number": 547,
      "source_code": "def test_add_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_test_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 550,
      "end_line_number": 564,
      "source_code": "def test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_test_after_route_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 567,
      "end_line_number": 580,
      "source_code": "def test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_test_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 583,
      "end_line_number": 597,
      "source_code": "def test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_test_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 600,
      "end_line_number": 614,
      "source_code": "def test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 617,
      "end_line_number": 631,
      "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_context_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 634,
      "end_line_number": 672,
      "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'43' in app_page_bytes",
        "assert b'42' not in app_page_bytes",
        "assert b'42' in answer_page_bytes",
        "assert b'43' in answer_page_bytes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "template_string",
          "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `template_string` method is designed to render a template directly from a string using Flask's `render_template_string` function. It dynamically generates HTML content based on the presence of specific context variables.\n\n**How It Works**:  \nThe method uses Flask's `render_template_string` to process a Jinja2 template string. The template contains conditional statements that check for the existence of two context variables: `notanswer` and `answer`. If `notanswer` is present, it outputs a message indicating that the value is not the answer. If `answer` is present, it outputs a message confirming the value as the answer. This method is typically used in conjunction with context processors that provide these variables, allowing for dynamic content rendering based on the application's state or logic."
        },
        {
          "name": "template_string",
          "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')",
          "code_explanation": "**Main Purpose of the Method**:\nThe `template_string` method is designed to render a template directly from a string using Flask's `render_template_string` function. It dynamically generates HTML content based on the presence of specific context variables.\n\n**How It Works**:\nThe method uses Flask's `render_template_string` to process a Jinja2 template string. The template contains conditional statements that check for the existence of two variables: `notanswer` and `answer`. If `notanswer` is present in the context, it outputs a message indicating that the value of `notanswer` is not the answer. Similarly, if `answer` is present, it outputs a message stating that the value of `answer` is the answer. This method is typically used in conjunction with context processors that supply these variables, allowing for dynamic content rendering based on the application's state or logic."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This functionality is useful for maintaining state or user-specific data across different requests in a web application."
        }
      ]
    },
    {
      "name": "test_template_global",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 675,
      "end_line_number": 693,
      "source_code": "def test_template_global(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'get_answer' not in app.jinja_env.globals.keys()",
        "assert 'get_answer' in app.jinja_env.globals.keys()",
        "assert app.jinja_env.globals['get_answer'] is get_answer",
        "assert app.jinja_env.globals['get_answer']() == 42",
        "assert rv == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 696,
      "end_line_number": 724,
      "source_code": "def test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert evts == []",
        "assert rv.data == b'request|after'",
        "assert evts == ['before', 'after', 'teardown']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_app_request_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 727,
      "end_line_number": 763,
      "source_code": "def test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert evts == []",
        "assert resp == b'request|after'",
        "assert evts == ['before', 'after', 'teardown']",
        "assert resp == b'request|after'",
        "assert evts == ['before', 'after', 'teardown'] * 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server side and linked to the client via a session cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This functionality is useful for maintaining state across requests in a web application."
        }
      ]
    },
    {
      "name": "test_app_url_processors",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 766,
      "end_line_number": 790,
      "source_code": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/de/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
          "code_explanation": "**Main Purpose of the Method**:\nThe `values.setdefault` method in the context of the provided code is used to retrieve a value from the Flask session associated with a specific key. If the key does not exist in the session, it sets the key with a default value and returns that default value.\n\n**How It Works**:\nIn the provided code snippet, the `setdefault` method is a Flask route handler that uses `flask.session.setdefault('test', 'default')`. This method checks if the key `'test'` exists in the session. If it does, the method returns the current value associated with `'test'`. If the key does not exist, it sets `'test'` to `'default'` in the session and returns `'default'`. This is useful for ensuring that a session key has a value without overwriting an existing one, providing a default when necessary."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_nested_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 793,
      "end_line_number": 839,
      "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/parent/').data == b'Parent yes'",
        "assert client.get('/parent/child/').data == b'Child yes'",
        "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
        "assert client.get('/parent/no').data == b'Parent no'",
        "assert client.get('/parent/child/no').data == b'Parent no'",
        "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_nested_callback_order",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 842,
      "end_line_number": 919,
      "source_code": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/a').data == b'app_1, app_2, parent_1, parent_2, child_1, child_2'",
        "assert client.get('/b').data == b'child'",
        "assert flask.g.seen.pop() == 'app_1'",
        "assert flask.g.seen.pop() == 'app_2'",
        "assert flask.g.seen.pop() == 'parent_1'",
        "assert flask.g.seen.pop() == 'parent_2'",
        "assert flask.g.seen.pop() == 'child_1'",
        "assert flask.g.seen.pop() == 'child_2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_nesting_url_prefixes",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 931,
      "end_line_number": 950,
      "source_code": "def test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('parent_init, child_init, parent_registration, child_registration', [('/parent', '/child', None, None), ('/parent', None, None, '/child'), (None, None, '/parent', '/child'), ('/other', '/something', '/parent', '/child')])"
      ],
      "arguments": [
        "parent_init",
        "child_init",
        "parent_registration",
        "child_registration",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_nesting_subdomains",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 953,
      "end_line_number": 969,
      "source_code": "def test_nesting_subdomains(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_child_and_parent_subdomain",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 972,
      "end_line_number": 991,
      "source_code": "def test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_unique_blueprint_names",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 994,
      "end_line_number": 1008,
      "source_code": "def test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_self_registration",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 1011,
      "end_line_number": 1014,
      "source_code": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_blueprint_renaming",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 1017,
      "end_line_number": 1046,
      "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/a/').data == b'bp.index'",
        "assert client.get('/b/').data == b'alt.index'",
        "assert client.get('/a/a/').data == b'bp.sub.index2'",
        "assert client.get('/b/a/').data == b'alt.sub.index2'",
        "assert client.get('/a/error').data == b'Error'",
        "assert client.get('/b/error').data == b'Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `bp.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to persist data across requests, allowing for stateful interactions in a web application."
        },
        {
          "name": "bp.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `bp.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "bp2.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `bp2.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to check for the presence of the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured with custom session interfaces as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_max_content_length",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_request.py",
      "line_number": 9,
      "end_line_number": 22,
      "source_code": "def test_max_content_length(app: Flask, client: FlaskClient) -> None:\n    app.config[\"MAX_CONTENT_LENGTH\"] = 50\n\n    @app.post(\"/\")\n    def index():\n        request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/\", data={\"myfile\": \"foo\" * 50})\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "flask.Flask",
        "flask.Request",
        "flask.request",
        "flask.testing.FlaskClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.post` method is used to define a route in a Flask application that handles HTTP POST requests. It is typically used to create new resources or perform actions that modify server-side data.\n\n**How It Works**:\nThe `app.post` method is a decorator that registers a function to handle POST requests to a specified URL endpoint. When a POST request is made to this endpoint, the associated function is executed. In the provided code snippets, the `post` method in the `app` class simply returns the string 'Create', indicating a placeholder or minimal implementation. In a more complete application, this method would likely involve processing form data, interacting with a database, and returning a response to the client. The relevant code snippets demonstrate how POST requests are used to create, update, and delete resources in a web application, with form data being validated and database operations being performed accordingly."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to use a real web server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with frameworks like Flask for testing purposes. When invoked, it sends a POST request to a specified URL endpoint within the application. The method can accept additional parameters, such as `data`, which represents the form data to be sent with the request. In the context of the provided code snippets, `client.post` is used to test various functionalities like updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code, response data, or headers."
        }
      ]
    },
    {
      "name": "test_limit_config",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_request.py",
      "line_number": 25,
      "end_line_number": 54,
      "source_code": "def test_limit_config(app: Flask):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 100\n    app.config[\"MAX_FORM_MEMORY_SIZE\"] = 50\n    app.config[\"MAX_FORM_PARTS\"] = 3\n    r = Request({})\n\n    # no app context, use Werkzeug defaults\n    assert r.max_content_length is None\n    assert r.max_form_memory_size == 500_000\n    assert r.max_form_parts == 1_000\n\n    # in app context, use config\n    with app.app_context():\n        assert r.max_content_length == 100\n        assert r.max_form_memory_size == 50\n        assert r.max_form_parts == 3\n\n    # regardless of app context, use override\n    r.max_content_length = 90\n    r.max_form_memory_size = 30\n    r.max_form_parts = 4\n\n    assert r.max_content_length == 90\n    assert r.max_form_memory_size == 30\n    assert r.max_form_parts == 4\n\n    with app.app_context():\n        assert r.max_content_length == 90\n        assert r.max_form_memory_size == 30\n        assert r.max_form_parts == 4",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "__future__.annotations",
        "flask.Flask",
        "flask.Request",
        "flask.request",
        "flask.testing.FlaskClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.max_content_length is None",
        "assert r.max_form_memory_size == 500000",
        "assert r.max_form_parts == 1000",
        "assert r.max_content_length == 90",
        "assert r.max_form_memory_size == 30",
        "assert r.max_form_parts == 4",
        "assert r.max_content_length == 100",
        "assert r.max_form_memory_size == 50",
        "assert r.max_form_parts == 3",
        "assert r.max_content_length == 90",
        "assert r.max_form_memory_size == 30",
        "assert r.max_form_parts == 4"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trusted_hosts_config",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_request.py",
      "line_number": 57,
      "end_line_number": 70,
      "source_code": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "__future__.annotations",
        "flask.Flask",
        "flask.Request",
        "flask.request",
        "flask.testing.FlaskClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.status_code == 200",
        "assert r.status_code == 200",
        "assert r.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests. Specifically, it is a decorator that maps a URL endpoint to a Python function, allowing the application to respond to requests at that endpoint.\n\n**How It Works**:\nIn the provided code snippet, the `app.get` method is used to define a route for the root URL (`\"/\"`). When a GET request is made to this URL, the `index` function is executed, returning the string \"Hello, World!\". Similarly, the `@app.route('/get')` decorator maps the `/get` URL to the `get` function. This function retrieves a value from the session using `flask.session.get('value', 'None')`, which attempts to get the session variable 'value' and defaults to 'None' if it doesn't exist. The retrieved value is then returned as the response to the GET request. This mechanism allows the Flask application to handle specific URL requests and return appropriate responses based on the session data."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_config_from_pyfile",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 19,
      "end_line_number": 22,
      "source_code": "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables. If any of these assertions fail, it indicates a misconfiguration in the app setup."
        }
      ]
    },
    {
      "name": "test_config_from_object",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 25,
      "end_line_number": 28,
      "source_code": "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables."
        }
      ]
    },
    {
      "name": "test_config_from_file_json",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 31,
      "end_line_number": 35,
      "source_code": "def test_config_from_file_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values. It checks for the presence and correctness of certain configuration keys and values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter. It performs a series of assertions to ensure that:\n1. The `secret_key` attribute of the app is set to `'config'`.\n2. The configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`.\n3. The configuration does not include a key `'TestConfig'`.\n\nThese assertions help confirm that the application has been configured as expected, particularly after loading configurations from different sources, such as classes or environment variables. If any of these conditions are not met, the assertions will raise an error, indicating a misconfiguration."
        }
      ]
    },
    {
      "name": "test_config_from_file_toml",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 38,
      "end_line_number": 45,
      "source_code": "def test_config_from_file_toml():\n    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(\n        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n    )\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`, and that `'TestConfig'` is not present in the configuration. These checks ensure that the application has been configured correctly according to the expected setup, typically after loading configuration from a class or environment variable."
        }
      ]
    },
    {
      "name": "test_from_prefixed_env",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 48,
      "end_line_number": 66,
      "source_code": "def test_from_prefixed_env(monkeypatch):\n    monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n    monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n    monkeypatch.setenv(\"FLASK_INT\", \"1\")\n    monkeypatch.setenv(\"FLASK_FLOAT\", \"1.2\")\n    monkeypatch.setenv(\"FLASK_LIST\", \"[1, 2]\")\n    monkeypatch.setenv(\"FLASK_DICT\", '{\"k\": \"v\"}')\n    monkeypatch.setenv(\"NOT_FLASK_OTHER\", \"other\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env()\n\n    assert app.config[\"STRING\"] == \"value\"\n    assert app.config[\"BOOL\"] is True\n    assert app.config[\"INT\"] == 1\n    assert app.config[\"FLOAT\"] == 1.2\n    assert app.config[\"LIST\"] == [1, 2]\n    assert app.config[\"DICT\"] == {\"k\": \"v\"}\n    assert \"OTHER\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['STRING'] == 'value'",
        "assert app.config['BOOL'] is True",
        "assert app.config['INT'] == 1",
        "assert app.config['FLOAT'] == 1.2",
        "assert app.config['LIST'] == [1, 2]",
        "assert app.config['DICT'] == {'k': 'v'}",
        "assert 'OTHER' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_from_prefixed_env_custom_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 69,
      "end_line_number": 76,
      "source_code": "def test_from_prefixed_env_custom_prefix(monkeypatch):\n    monkeypatch.setenv(\"FLASK_A\", \"a\")\n    monkeypatch.setenv(\"NOT_FLASK_A\", \"b\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env(\"NOT_FLASK\")\n\n    assert app.config[\"A\"] == \"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['A'] == 'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_from_prefixed_env_nested",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 79,
      "end_line_number": 107,
      "source_code": "def test_from_prefixed_env_nested(monkeypatch):\n    monkeypatch.setenv(\"FLASK_EXIST__ok\", \"other\")\n    monkeypatch.setenv(\"FLASK_EXIST__inner__ik\", \"2\")\n    monkeypatch.setenv(\"FLASK_EXIST__new__more\", '{\"k\": false}')\n    monkeypatch.setenv(\"FLASK_NEW__K\", \"v\")\n\n    app = flask.Flask(__name__)\n    app.config[\"EXIST\"] = {\"ok\": \"value\", \"flag\": True, \"inner\": {\"ik\": 1}}\n    app.config.from_prefixed_env()\n\n    if os.name != \"nt\":\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 2},\n            \"new\": {\"more\": {\"k\": False}},\n        }\n    else:\n        # Windows env var keys are always uppercase.\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"value\",\n            \"OK\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 1},\n            \"INNER\": {\"IK\": 2},\n            \"NEW\": {\"MORE\": {\"k\": False}},\n        }\n\n    assert app.config[\"NEW\"] == {\"K\": \"v\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['NEW'] == {'K': 'v'}",
        "assert app.config['EXIST'] == {'ok': 'other', 'flag': True, 'inner': {'ik': 2}, 'new': {'more': {'k': False}}}",
        "assert app.config['EXIST'] == {'ok': 'value', 'OK': 'other', 'flag': True, 'inner': {'ik': 1}, 'INNER': {'IK': 2}, 'NEW': {'MORE': {'k': False}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_from_mapping",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 110,
      "end_line_number": 129,
      "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables."
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables. If any of these assertions fail, it indicates a misconfiguration in the app setup."
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables. If any of these assertions fail, it indicates a misconfiguration in the app setup."
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test class or environment variable. If any of these assertions fail, it indicates a misconfiguration in the app setup."
        }
      ]
    },
    {
      "name": "test_config_from_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, and that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`. Additionally, it checks that `'TestConfig'` is not present in the app's configuration. These assertions ensure that the app's configuration matches the expected setup, which is typically defined in a test case using configuration objects or environment variables."
        }
      ]
    },
    {
      "name": "test_config_from_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 144,
      "end_line_number": 158,
      "source_code": "def test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert \"'FOO_SETTINGS' is not set\" in str(e.value)",
        "assert not app.config.from_envvar('FOO_SETTINGS', silent=True)",
        "assert app.config.from_envvar('FOO_SETTINGS')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to check the application's configuration. It asserts that the `secret_key` attribute of the app is set to `'config'`, that the configuration dictionary (`app.config`) contains a key `'TEST_KEY'` with the value `'foo'`, and that `'TestConfig'` is not present in the configuration. These checks ensure that the application has been configured correctly according to the expected settings, which are likely set up in the test cases using different configuration methods like `from_object` or `from_envvar`."
        }
      ]
    },
    {
      "name": "test_config_from_envvar_missing",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 161,
      "end_line_number": 171,
      "source_code": "def test_config_from_envvar_missing(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.cfg'\")",
        "assert not app.config.from_envvar('FOO_SETTINGS', silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_missing",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 174,
      "end_line_number": 183,
      "source_code": "def test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.cfg'\")",
        "assert not app.config.from_pyfile('missing.cfg', silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_missing_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 186,
      "end_line_number": 195,
      "source_code": "def test_config_missing_file():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.json'\")",
        "assert not app.config.from_file('missing.json', load=json.load, silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_config_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 198,
      "end_line_number": 208,
      "source_code": "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.config, Config)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
          "code_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to verify that a Flask application's configuration has been correctly set up with specific expected values.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as its parameter and performs a series of assertions to ensure the configuration is as expected. It checks that the `app.secret_key` is set to `'config'`, the `app.config` dictionary contains a key `'TEST_KEY'` with the value `'foo'`, and that `'TestConfig'` is not present in the `app.config`. These assertions help confirm that the application has been configured correctly, typically after loading configuration settings from a class or environment variable. If any of these conditions are not met, the assertions will raise an error, indicating a misconfiguration."
        }
      ]
    },
    {
      "name": "test_session_lifetime",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 211,
      "end_line_number": 214,
      "source_code": "def test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config[\"PERMANENT_SESSION_LIFETIME\"] = 42\n    assert app.permanent_session_lifetime.seconds == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.permanent_session_lifetime.seconds == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_namespace",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 217,
      "end_line_number": 240,
      "source_code": "def test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert 2 == len(foo_options)",
        "assert 'foo option 1' == foo_options['option_1']",
        "assert 'foo option 2' == foo_options['option_2']",
        "assert 2 == len(bar_options)",
        "assert 'bar stuff 1' == bar_options['STUFF_1']",
        "assert 'bar stuff 2' == bar_options['STUFF_2']",
        "assert 2 == len(foo_options)",
        "assert 'foo option 1' == foo_options['foo_option_1']",
        "assert 'foo option 2' == foo_options['foo_option_2']",
        "assert 2 == len(bar_options)",
        "assert 'bar stuff 1' == bar_options['BAR_STUFF_1']",
        "assert 'bar stuff 2' == bar_options['BAR_STUFF_2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_from_pyfile_weird_encoding",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 244,
      "end_line_number": 250,
      "source_code": "def test_from_pyfile_weird_encoding(tmp_path, encoding):\n    f = tmp_path / \"my_config.py\"\n    f.write_text(f'# -*- coding: {encoding} -*-\\nTEST_VALUE = \"f\u00f6\u00f6\"\\n', encoding)\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(os.fspath(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\u00f6\u00f6\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('encoding', ['utf-8', 'iso-8859-15', 'latin-1'])"
      ],
      "arguments": [
        "tmp_path",
        "encoding"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert value == 'f\u00f6\u00f6'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_view",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 17,
      "end_line_number": 25,
      "source_code": "def test_basic_view(app):\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to verify the behavior of a Flask application by testing the HTTP methods supported by a specific route. It ensures that the application correctly handles GET, POST, PUT, and OPTIONS requests.\n\n**How It Works**:\nThe method uses Flask's test client to simulate requests to the root URL (`/`) of the application. It performs the following checks:\n1. Sends a GET request and asserts that the response data is `b'GET'`.\n2. Sends a POST request and asserts that the response data is `b'POST'`.\n3. Sends a PUT request and asserts that the response status code is `405`, indicating that the method is not allowed.\n4. Sends an OPTIONS request and parses the `Allow` header to check which HTTP methods are supported. It asserts that the allowed methods are `GET`, `HEAD`, `OPTIONS`, and `POST`, ensuring the application is configured to handle these methods correctly."
        }
      ]
    },
    {
      "name": "test_method_based_view",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 28,
      "end_line_number": 38,
      "source_code": "def test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to verify the behavior of a Flask application by testing the HTTP methods supported by a specific route. It ensures that the application correctly handles GET, POST, PUT, and OPTIONS requests.\n\n**How It Works**:\nThe method uses Flask's test client to simulate HTTP requests to the root URL (`/`) of the application. It performs the following checks:\n1. Sends a GET request and asserts that the response data is `b'GET'`.\n2. Sends a POST request and asserts that the response data is `b'POST'`.\n3. Sends a PUT request and asserts that the response status code is `405`, indicating that the method is not allowed.\n4. Sends an OPTIONS request and parses the `Allow` header to check which HTTP methods are supported. It asserts that the allowed methods are `GET`, `HEAD`, `OPTIONS`, and `POST`, ensuring the application correctly advertises its capabilities."
        }
      ]
    },
    {
      "name": "test_view_patching",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 41,
      "end_line_number": 59,
      "source_code": "def test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            raise ZeroDivisionError\n\n        def post(self):\n            raise ZeroDivisionError\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to verify the behavior of a Flask application by testing the HTTP methods supported by a specific route. It ensures that the application correctly handles GET, POST, PUT, and OPTIONS requests.\n\n**How It Works**:\nThe method uses Flask's test client to simulate requests to the root URL (`/`) of the application. It performs the following checks:\n1. Sends a GET request and asserts that the response data is `b'GET'`.\n2. Sends a POST request and asserts that the response data is `b'POST'`.\n3. Sends a PUT request and asserts that the response status code is `405`, indicating that the method is not allowed.\n4. Sends an OPTIONS request and parses the `Allow` header to check which HTTP methods are supported. It asserts that the allowed methods are `GET`, `HEAD`, `OPTIONS`, and `POST`, ensuring the application correctly advertises its capabilities."
        }
      ]
    },
    {
      "name": "test_view_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 62,
      "end_line_number": 77,
      "source_code": "def test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_view_decorators",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 80,
      "end_line_number": 98,
      "source_code": "def test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.headers['X-Parachute'] == 'awesome'",
        "assert rv.data == b'Awesome'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_view_provide_automatic_options_attr",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 101,
      "end_line_number": 138,
      "source_code": "def test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['OPTIONS']",
        "assert 'OPTIONS' in rv.allow"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_implicit_head",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 141,
      "end_line_number": 152,
      "source_code": "def test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Blub'",
        "assert rv.headers['X-Method'] == 'GET'",
        "assert rv.data == b''",
        "assert rv.headers['X-Method'] == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application, allowing the server to respond with headers without sending the body of the response.\n\n**How It Works**:\nThe `client.head` method is implemented within a Flask view class, typically a subclass of `flask.views.MethodView`. When a HEAD request is made to a route, the `head` method is invoked. It returns a `flask.Response` object with an empty body and custom headers, such as `{'X-Method': 'HEAD'}`. This method is useful for testing or when you need to provide metadata about a resource without transferring the resource itself. In the context of the provided code snippets, the `client.head` method is tested to ensure it correctly returns an empty body and the appropriate headers, distinguishing it from a GET request which would include the response body."
        }
      ]
    },
    {
      "name": "test_explicit_head",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 155,
      "end_line_number": 168,
      "source_code": "def test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'GET'",
        "assert rv.data == b''",
        "assert rv.headers['X-Method'] == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It provides a way to respond to HEAD requests by returning a response with specific headers, without including a message body.\n\n**How It Works**:\nThe `client.head` method is implemented within a Flask view class, typically a subclass of `flask.views.MethodView`. When a HEAD request is made to a route associated with this view, the `head` method is invoked. It returns a `flask.Response` object with an empty body and a custom header `X-Method` set to \"HEAD\". This method ensures that the response adheres to the HTTP specification for HEAD requests, which should not contain a message body but can include headers. The method is tested in the `test_explicit_head` function, where it confirms that the response data is empty and the header is correctly set."
        }
      ]
    },
    {
      "name": "test_endpoint_override",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 171,
      "end_line_number": 186,
      "source_code": "def test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
          "code_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to verify the behavior of a Flask application's endpoint by testing its response to different HTTP methods (GET, POST, PUT, OPTIONS).\n\n**How It Works**:\nThe method uses Flask's `test_client` to simulate requests to the root URL (`/`) of the application. It performs the following checks:\n1. Sends a GET request and asserts that the response data is `b'GET'`.\n2. Sends a POST request and asserts that the response data is `b'POST'`.\n3. Sends a PUT request and asserts that the response status code is `405`, indicating that the method is not allowed.\n4. Sends an OPTIONS request and parses the `Allow` header to check which HTTP methods are supported by the endpoint. It asserts that the allowed methods are `GET`, `HEAD`, `OPTIONS`, and `POST`, ensuring the endpoint's compliance with expected behavior."
        }
      ]
    },
    {
      "name": "test_methods_var_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 189,
      "end_line_number": 204,
      "source_code": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.open('/', method='PROPFIND').data == b'PROPFIND'",
        "assert ChildView.methods == {'PROPFIND', 'GET'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_multiple_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 207,
      "end_line_number": 223,
      "source_code": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.delete('/').data == b'DELETE'",
        "assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.delete` method is designed to simulate an HTTP DELETE request in a testing environment, typically used to test the deletion of resources in a web application.\n\n**How It Works**:\nThe method `delete` is a simple function that returns the string `'DELETE'`. In the context of a testing framework, this method would be part of a client object that mimics HTTP requests. When invoked, it simulates sending a DELETE request to a server endpoint. The method itself does not perform any actual deletion but is used to verify that the application correctly handles DELETE requests, as seen in the `test_delete` function where it checks if a post is successfully deleted from the database."
        }
      ]
    },
    {
      "name": "test_remove_method_from_parent",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 226,
      "end_line_number": 242,
      "source_code": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.post('/').status_code == 405",
        "assert sorted(View.methods) == ['GET']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests without needing to run a live server.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint with optional data payloads. In the provided code snippets, `client.post` is used to test various endpoints by sending data to them and asserting the expected outcomes. For example, it is used to update a post's title, validate form submissions, and delete a post. The method returns a response object, which can be used to check the status code, headers, and content of the response, allowing developers to verify that their application behaves as expected when handling POST requests."
        }
      ]
    },
    {
      "name": "test_init_once",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 245,
      "end_line_number": 260,
      "source_code": "def test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'1'",
        "assert client.get('/').data == b'1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_error_handler_no_match",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 10,
      "end_line_number": 58,
      "source_code": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CustomException() is an instance, not a class.' in str(exc_info.value)",
        "assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)",
        "assert 'Use a subclass of HTTPException' in str(exc_info.value)",
        "assert client.get('/custom').data == b'custom'",
        "assert client.get('/keyerror').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct'",
        "assert isinstance(e, CustomException)",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to retrieve the value associated with the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_error_handler_subclass",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 61,
      "end_line_number": 97,
      "source_code": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/parent').data == b'parent'",
        "assert c.get('/child-unregistered').data == b'parent'",
        "assert c.get('/child-registered').data == b'child-registered'",
        "assert isinstance(e, ParentException)",
        "assert isinstance(e, ChildExceptionRegistered)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the HTTP request. This method leverages Flask's session management to maintain state across different requests from the same client."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the HTTP request. This method leverages Flask's session management to maintain state across different requests from the same client."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        }
      ]
    },
    {
      "name": "test_error_handler_http_subclass",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 100,
      "end_line_number": 133,
      "source_code": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/forbidden').data == b'forbidden'",
        "assert c.get('/forbidden-unregistered').data == b'forbidden'",
        "assert c.get('/forbidden-registered').data == b'forbidden-registered'",
        "assert isinstance(e, Forbidden)",
        "assert isinstance(e, ForbiddenSubclassRegistered)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If this key is not present in the session, the method returns a default value of `'None'`. The retrieved value is then returned as the response to the HTTP request. This functionality is useful for maintaining stateful data across different requests from the same client."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests, allowing data to be stored and retrieved on a per-session basis."
        }
      ]
    },
    {
      "name": "test_error_handler_blueprint",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 136,
      "end_line_number": 160,
      "source_code": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/error').data == b'app-error'",
        "assert c.get('/bp/error').data == b'bp-error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests, allowing data to be stored and retrieved on a per-session basis."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests for a user."
        }
      ]
    },
    {
      "name": "test_default_error_handler",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 163,
      "end_line_number": 214,
      "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/bp/undefined').data == b'bp-default'",
        "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
        "assert c.get('/undefined').data == b'default'",
        "assert c.get('/forbidden').data == b'forbidden'",
        "assert c.get('/slash', follow_redirects=True).data == b'slash'",
        "assert isinstance(e, HTTPException)",
        "assert isinstance(e, NotFound)",
        "assert isinstance(e, Forbidden)",
        "assert isinstance(e, HTTPException)",
        "assert isinstance(e, NotFound)",
        "assert isinstance(e, Forbidden)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests, allowing data to be stored and retrieved on a per-session basis."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If this key is not present in the session, the method returns a default value of `'None'`. The retrieved value is then returned as the response to the HTTP request made to the `/get` endpoint."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests, allowing data to be stored and retrieved on a per-session basis."
        }
      ]
    },
    {
      "name": "test_handle_class_or_code",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 253,
      "end_line_number": 267,
      "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
      "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
      "decorators": [
        "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
      ],
      "arguments": [
        "self",
        "app",
        "client",
        "to_handle"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'wrapped Custom'",
        "assert client.get('/error').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/raise').data == b'direct InternalServerError'",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to generate a string message that describes the nature of an exception. It distinguishes between exceptions that are directly raised and those that are wrapped within another exception.\n\n**How It Works**:\nThe method takes an exception `e` as its parameter. It first checks if the exception has an attribute `original_exception`, which indicates that the exception is a wrapper around another exception. If this attribute is present, the method returns a string indicating that the exception is \"wrapped\" along with the type of the original exception. If the `original_exception` attribute is not present, it returns a string indicating that the exception is \"direct\" along with the type of the exception itself. This helps in understanding whether an error is a direct result of an operation or if it is a propagated error from another underlying issue."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client side in a secure cookie."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_handle_generic_http",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 269,
      "end_line_number": 281,
      "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
      "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/error').data == b'500'",
        "assert client.get('/abort').data == b'500'",
        "assert client.get('/not-found').data == b'404'",
        "assert isinstance(e, HTTPException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the server-side and linked to the client via a session cookie."
        }
      ]
    },
    {
      "name": "test_handle_generic",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 283,
      "end_line_number": 295,
      "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
      "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'direct Custom'",
        "assert client.get('/error').data == b'direct KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/not-found').data == b'direct NotFound'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to generate a descriptive string indicating whether an exception is a direct occurrence or a wrapped (nested) exception. This helps in understanding the nature of the error when handling exceptions.\n\n**How It Works**:\nThe method takes an exception `e` as its parameter. It first checks if the exception has an attribute `original_exception`, which is a common pattern for wrapped exceptions where the original exception is stored within another exception. If `original_exception` is present, the method returns a string indicating that the exception is \"wrapped\" along with the type of the original exception. If `original_exception` is not present, it returns a string indicating that the exception is \"direct\" along with the type of the current exception. This distinction helps in error handling by providing more context about the exception's origin."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to persist data across requests for a user."
        }
      ]
    },
    {
      "name": "test_handle_class_or_code",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 253,
      "end_line_number": 267,
      "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
      "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
      "decorators": [
        "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
      ],
      "arguments": [
        "self",
        "app",
        "client",
        "to_handle"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'wrapped Custom'",
        "assert client.get('/error').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/raise').data == b'direct InternalServerError'",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to generate a descriptive string that indicates whether an exception is a direct occurrence or a wrapped (nested) exception. This helps in understanding the nature of the error when handling exceptions.\n\n**How It Works**:\nThe method takes an exception `e` as its parameter. It first checks if the exception has an attribute `original_exception`, which is a common pattern for wrapped exceptions where the original exception is stored as an attribute of a new exception. If `original_exception` is present, the method returns a string indicating that the exception is \"wrapped\" along with the type of the original exception. If `original_exception` is not present, it returns a string indicating that the exception is \"direct\" along with the type of the current exception. This distinction helps in error handling by providing more context about the exception's origin."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This functionality is useful for maintaining state across requests in a web application."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_handle_generic_http",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 269,
      "end_line_number": 281,
      "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
      "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/error').data == b'500'",
        "assert client.get('/abort').data == b'500'",
        "assert client.get('/not-found').data == b'404'",
        "assert isinstance(e, HTTPException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask to retrieve the value associated with the key `'value'`. It uses the `get` method of the session dictionary, which allows specifying a default return value (`'None'` in this case) if the key is not found. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_handle_generic",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 283,
      "end_line_number": 295,
      "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
      "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'direct Custom'",
        "assert client.get('/error').data == b'direct KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/not-found').data == b'direct NotFound'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to generate a string message that describes the nature of an exception. It distinguishes between exceptions that are directly raised and those that are wrapped within another exception.\n\n**How It Works**:\nThe method takes an exception `e` as its parameter. It first checks if the exception `e` has an attribute `original_exception`, which indicates that `e` is a wrapper around another exception. If `original_exception` is present, the method returns a string indicating that the exception is \"wrapped\" along with the type of the original exception. If `original_exception` is not present, it returns a string indicating that the exception is \"direct\" along with the type of the exception `e`. This helps in understanding whether an error is a direct result of an operation or if it is a propagated error from another underlying issue."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management to persist data across requests for a user."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_custom_converters",
      "module": "test_converters",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_converters.py",
      "line_number": 8,
      "end_line_number": 26,
      "source_code": "def test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "werkzeug.routing.BaseConverter",
        "flask.request",
        "flask.session",
        "flask.url_for"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1,2,3').data == b'1|2|3'",
        "assert url_for('index', args=[4, 5, 6]) == '/4,5,6'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be configured to use different backends like cookies or server-side storage."
        }
      ]
    },
    {
      "name": "test_context_available",
      "module": "test_converters",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_converters.py",
      "line_number": 29,
      "end_line_number": 42,
      "source_code": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "werkzeug.routing.BaseConverter",
        "flask.request",
        "flask.session",
        "flask.url_for"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/admin').data == b'admin'",
        "assert request is not None",
        "assert session is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests. Specifically, it is a decorator that maps the specified URL path to a Python function, allowing the application to respond to requests made to that path.\n\n**How It Works**:\nIn the provided code snippet, the `app.get` method is used to create a route for the URL path `/get`. When a GET request is made to this path, the `get` function is executed. Inside this function, the `flask.session.get('value', 'None')` method is called to retrieve a value from the session storage, with a default value of `'None'` if the key `'value'` does not exist. The retrieved value is then returned as the response to the client. This setup allows the application to manage session data and provide dynamic responses based on the session's state."
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_aborting",
      "module": "test_regression",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_regression.py",
      "line_number": 4,
      "end_line_number": 30,
      "source_code": "def test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert location_parts[2] == 'test'",
        "assert rv.data == b'42'",
        "assert location_parts[0] == 'http://localhost'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across requests."
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to maintain state across different requests from the same client."
        }
      ]
    },
    {
      "name": "test_basic_url_generation",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 8,
      "end_line_number": 18,
      "source_code": "def test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_generation_requires_server_name",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 21,
      "end_line_number": 24,
      "source_code": "def test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_generation_without_context_fails",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_context_means_app_context",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 32,
      "end_line_number": 35,
      "source_code": "def test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.current_app",
        "assert flask.current_app._get_current_object() is app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_context_provides_current_app",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 38,
      "end_line_number": 41,
      "source_code": "def test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.current_app",
        "assert flask.current_app._get_current_object() is app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_tearing_down",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 44,
      "end_line_number": 54,
      "source_code": "def test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_tearing_down_with_previous_exception",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 57,
      "end_line_number": 72,
      "source_code": "def test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_except_block",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 75,
      "end_line_number": 88,
      "source_code": "def test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_app_handler",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 91,
      "end_line_number": 110,
      "source_code": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_app_tearing_down_with_unhandled_exception",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 113,
      "end_line_number": 131,
      "source_code": "def test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(cleanup_stuff) == 1",
        "assert isinstance(cleanup_stuff[0], ValueError)",
        "assert str(cleanup_stuff[0]) == 'dummy'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_app_ctx_globals_methods",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 134,
      "end_line_number": 154,
      "source_code": "def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.get('foo') is None",
        "assert flask.g.get('foo', 'bar') == 'bar'",
        "assert 'foo' not in flask.g",
        "assert 'foo' in flask.g",
        "assert flask.g.bar == 'the cake is a lie'",
        "assert flask.g.pop('bar') == 'the cake is a lie'",
        "assert flask.g.pop('bar', 'more cake') == 'more cake'",
        "assert list(flask.g) == ['foo']",
        "assert repr(flask.g) == \"<flask.g of 'flask_test'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_app_ctx_globals_class",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 157,
      "end_line_number": 164,
      "source_code": "def test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.render_template_string('{{ g.spam }}') == 'eggs'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_context_refcounts",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 167,
      "end_line_number": 190,
      "source_code": "def test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.data == b''",
        "assert called == ['request', 'app']",
        "assert flask.request.environ['werkzeug.request'] is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_clean_pop",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 193,
      "end_line_number": 209,
      "source_code": "def test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert called == ['flask_test', 'TEARDOWN']",
        "assert not flask.current_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_request_debug_message",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 15,
      "end_line_number": 27,
      "source_code": "def test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "app",
        "client",
        "debug"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert contains == debug"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment. It is typically used in unit tests to test the behavior of web applications when they receive POST requests.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often provided by web frameworks like Flask, to facilitate testing of web applications. When invoked, it sends a POST request to a specified URL with optional data. In the context of the provided code snippets, `client.post` is used to test various endpoints of a web application. For example, it is used to test the update functionality by sending a POST request with updated data to the `/1/update` endpoint. It is also used to test validation by sending a POST request with empty data to check if the application correctly handles missing required fields. The method returns a response object, which can be used to assert the expected behavior, such as checking the status code or response data."
        }
      ]
    },
    {
      "name": "test_json_bad_requests",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 30,
      "end_line_number": 36,
      "source_code": "def test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment. It is typically used in unit tests to interact with web applications, allowing developers to test how the application handles POST requests.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often provided by web frameworks like Flask, to facilitate testing of web applications. When called, it sends a POST request to a specified URL endpoint with optional data payload. In the context of the provided code snippets, `client.post` is used to test various functionalities such as updating a post, validating input data, and deleting a post. The method returns a response object, which can be used to assert the expected outcomes, such as checking the status code, response data, or headers. This allows developers to verify that the application behaves correctly when handling POST requests."
        }
      ]
    },
    {
      "name": "test_json_custom_mimetypes",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 39,
      "end_line_number": 45,
      "source_code": "def test_json_custom_mimetypes(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.request.get_json()\n\n    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n    assert rv.data == b\"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It is part of a test client that mimics the behavior of a web browser, allowing developers to test the server-side logic of their web applications.\n\n**How It Works**:\nThe `client.post` method sends a POST request to a specified URL endpoint within the application being tested. It can include data payloads, such as form data, which are passed as a dictionary to the `data` parameter. The method returns a response object that contains the server's response to the request, including status codes and any data returned by the server. This allows developers to assert and verify the behavior of their application when handling POST requests, such as creating or updating resources, validating input, and ensuring correct redirection or error handling."
        }
      ]
    },
    {
      "name": "test_json_as_unicode",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 51,
      "end_line_number": 54,
      "source_code": "def test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_value,expected', [(True, '\"\\\\u2603\"'), (False, '\"\u2603\"')])"
      ],
      "arguments": [
        "test_value",
        "expected",
        "app",
        "app_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_dump_to_file",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 57,
      "end_line_number": 64,
      "source_code": "def test_json_dump_to_file(app, app_ctx):\n    test_data = {\"name\": \"Flask\"}\n    out = io.StringIO()\n\n    flask.json.dump(test_data, out)\n    out.seek(0)\n    rv = flask.json.load(out)\n    assert rv == test_data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == test_data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_jsonify_basic_types",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 70,
      "end_line_number": 75,
      "source_code": "def test_jsonify_basic_types(test_value, app, client):\n    url = \"/jsonify_basic_types\"\n    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n    rv = client.get(url)\n    assert rv.mimetype == \"application/json\"\n    assert flask.json.loads(rv.data) == test_value",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', 'longer string', True, False, None])"
      ],
      "arguments": [
        "test_value",
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == test_value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_jsonify_dicts",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 78,
      "end_line_number": 102,
      "source_code": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == d"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_jsonify_arrays",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 105,
      "end_line_number": 130,
      "source_code": "def test_jsonify_arrays(app, client):\n    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n    a_list = [\n        0,\n        42,\n        3.14,\n        \"t\",\n        \"hello\",\n        True,\n        False,\n        [\"test list\", 2, False],\n        {\"test\": \"dict\"},\n    ]\n\n    @app.route(\"/args_unpack\")\n    def return_args_unpack():\n        return flask.jsonify(*a_list)\n\n    @app.route(\"/array\")\n    def return_array():\n        return flask.jsonify(a_list)\n\n    for url in \"/args_unpack\", \"/array\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == a_list",
      "docstring": "Test jsonify of lists and args unpacking.",
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == a_list"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_jsonify_datetime",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 136,
      "end_line_number": 142,
      "source_code": "def test_jsonify_datetime(app, client, value):\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(value=value)\n\n    r = client.get()\n    assert r.json[\"value\"] == http_date(value)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)])"
      ],
      "arguments": [
        "app",
        "client",
        "value"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.json['value'] == http_date(value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_jsonify_aware_datetimes",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 167,
      "end_line_number": 173,
      "source_code": "def test_jsonify_aware_datetimes(tz):\n    \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n    tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n    gmt = FixedOffset(hours=0, name=\"GMT\")\n    expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n    assert flask.json.dumps(dt) == expected",
      "docstring": "Test if aware datetime.datetime objects are converted into GMT.",
      "decorators": [
        "pytest.mark.parametrize('tz', (('UTC', 0), ('PST', -8), ('KST', 9)))"
      ],
      "arguments": [
        "tz"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.json.dumps(dt) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_jsonify_uuid_types",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 176,
      "end_line_number": 188,
      "source_code": "def test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid",
      "docstring": "Test jsonify with uuid.UUID types",
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv_x == str(test_uuid)",
        "assert rv_uuid == test_uuid"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_json_decimal",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 191,
      "end_line_number": 193,
      "source_code": "def test_json_decimal():\n    rv = flask.json.dumps(decimal.Decimal(\"0.003\"))\n    assert rv == '\"0.003\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == '\"0.003\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_attr",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 196,
      "end_line_number": 207,
      "source_code": "def test_json_attr(app, client):\n    @app.route(\"/add\", methods=[\"POST\"])\n    def add():\n        json = flask.request.get_json()\n        return str(json[\"a\"] + json[\"b\"])\n\n    rv = client.post(\n        \"/add\",\n        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b\"3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests, such as form submissions or API calls.\n\n**How It Works**:\nThe `client.post` method is part of a test client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL with optional data, headers, and other parameters. In the provided code snippets, `client.post` is used to test various endpoints of a web application. For example, it is used to update a post, validate form submissions, and delete a post. The method returns a response object, which can be used to assert the expected behavior of the application, such as checking the status code, response data, or redirection headers."
        }
      ]
    },
    {
      "name": "test_tojson_filter",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 210,
      "end_line_number": 220,
      "source_code": "def test_tojson_filter(app, req_ctx):\n    # The tojson filter is tested in Jinja, this confirms that it's\n    # using Flask's dumps.\n    rv = flask.render_template_string(\n        \"const data = {{ data|tojson }};\",\n        data={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n    )\n    assert rv == (\n        'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n        ' \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'const data = {\"name\": \"\\\\u003c/script\\\\u003e\", \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_customization",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 223,
      "end_line_number": 257,
      "source_code": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'\"<42>\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is used to simulate an HTTP POST request in a testing environment, typically for testing web applications. It allows developers to test how their application handles POST requests, such as form submissions or API calls.\n\n**How It Works**:\nThe `client.post` method is part of a testing client, often used in conjunction with a web framework like Flask. It sends a POST request to a specified URL endpoint within the application being tested. The method can include additional data, such as form fields, in the request body. In the provided code snippets, `client.post` is used to test various endpoints, such as updating a post, validating form submissions, and deleting a post. The method returns a response object, which can be used to assert expected outcomes, such as checking response status codes, headers, or content."
        },
        {
          "name": "DefaultJSONProvider.default",
          "body": "def default(o):\n    if isinstance(o, X):\n        return f'<{o.val}>'\n    return DefaultJSONProvider.default(o)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `DefaultJSONProvider.default` method is designed to provide a custom serialization mechanism for objects that are not natively serializable by JSON. It specifically handles objects of type `X` by converting them into a string format suitable for JSON serialization.\n\n**How It Works**:\nThe method first checks if the object `o` is an instance of the class `X`. If it is, the method returns a string representation of the object in the format `<value>`, where `value` is the `val` attribute of the object `X`. If the object is not an instance of `X`, the method delegates the serialization task to the default implementation of `DefaultJSONProvider.default`, which handles other types of objects. This allows for extending the JSON serialization process to include custom object types while maintaining the default behavior for standard types."
        },
        {
          "name": "kwargs.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
          "code_explanation": "**Main Purpose of the Method**:\nThe `kwargs.setdefault` method is used to ensure that a key exists in a dictionary with a default value if it is not already present. In the context of the provided code, `flask.session.setdefault('test', 'default')` is used to ensure that the session has a key `'test'` with a default value `'default'` if it doesn't already exist.\n\n**How It Works**:\nThe `setdefault` method checks if the specified key (`'test'` in this case) is present in the dictionary (or session object). If the key is not present, it adds the key with the specified default value (`'default'`). If the key is already present, it simply returns the current value associated with the key without modifying the dictionary. This method is particularly useful for initializing session variables or configuration settings with default values, ensuring that the application has a consistent state. In the Flask application, this is used to manage session data, which is stored server-side and can be accessed across different requests."
        }
      ]
    },
    {
      "name": "test_json_key_sorting",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 270,
      "end_line_number": 337,
      "source_code": "def test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.json.sort_keys",
        "assert lines == sorted_by_int",
        "assert lines == sorted_by_str"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_html_method",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 340,
      "end_line_number": 346,
      "source_code": "def test_html_method():\n    class ObjectWithHTML:\n        def __html__(self):\n            return \"<p>test</p>\"\n\n    result = json.dumps(ObjectWithHTML())\n    assert result == '\"<p>test</p>\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == '\"<p>test</p>\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_logger",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 36,
      "end_line_number": 39,
      "source_code": "def test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.name == 'flask_test'",
        "assert app.logger.level == logging.NOTSET",
        "assert app.logger.handlers == [default_handler]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_logger_debug",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 42,
      "end_line_number": 45,
      "source_code": "def test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.level == logging.DEBUG",
        "assert app.logger.handlers == [default_handler]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_existing_handler",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 48,
      "end_line_number": 51,
      "source_code": "def test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.level == logging.NOTSET",
        "assert not app.logger.handlers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_wsgi_errors_stream",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 54,
      "end_line_number": 67,
      "source_code": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'ERROR in test_logging: test' in stream.getvalue()",
        "assert wsgi_errors_stream._get_current_object() is sys.stderr",
        "assert wsgi_errors_stream._get_current_object() is stream"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        },
        {
          "name": "app.logger.error",
          "body": "@app.route('/error')\ndef error():\n    raise ZeroDivisionError",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.logger.error` method is used to log error messages within a Flask application. It helps in recording error events, which can be useful for debugging and monitoring the application's behavior.\n\n**How It Works**:\nThe method is part of Flask's logging system, which is configured through the `create_logger` function. This function sets up a logger for the Flask app, adjusting its level based on the app's debug status and ensuring it has a handler to output logs. When an error occurs, such as a `ZeroDivisionError` in the `/error` route, Flask's error handling mechanism captures the exception. If no specific error handler is found, the exception is logged using `app.logger.error`, which records the error details. This logging is crucial for diagnosing issues, especially in production environments where direct debugging is not feasible."
        }
      ]
    },
    {
      "name": "test_has_level_handler",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 70,
      "end_line_number": 83,
      "source_code": "def test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert not has_level_handler(logger)",
        "assert has_level_handler(logger)",
        "assert not has_level_handler(logger)",
        "assert not has_level_handler(logger)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_log_view_exception",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 86,
      "end_line_number": 98,
      "source_code": "def test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert rv.data",
        "assert 'Exception on / [GET]' in err",
        "assert 'Exception: test' in err"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_cli_name",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 41,
      "end_line_number": 45,
      "source_code": "def test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name",
      "docstring": "Make sure the CLI object's name is the app's name and not the app itself",
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert testapp.cli.name == testapp.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_find_best_app",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 48,
      "end_line_number": 132,
      "source_code": "def test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert find_best_app(Module) == Module.app",
        "assert find_best_app(Module) == Module.application",
        "assert find_best_app(Module) == Module.myapp",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert find_best_app(Module) == Module.myapp",
        "assert find_best_app(Module) == Module.myapp"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_prepare_import",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 161,
      "end_line_number": 177,
      "source_code": "def test_prepare_import(request, value, path, result):\n    \"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"\n    original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == str(path)",
      "docstring": "Expect the correct path to be set and the correct import and app names\nto be returned.\n\n:func:`prepare_exec_for_file` has a side effect where the parent directory\nof the given import is added to :data:`sys.path`. This is reset after the\ntest runs.",
      "decorators": [
        "pytest.mark.parametrize('value,path,result', (('test', cwd, 'test'), ('test.py', cwd, 'test'), ('a/test', cwd / 'a', 'test'), ('test/__init__.py', cwd, 'test'), ('test/__init__', cwd, 'test'), (test_path / 'cliapp' / 'inner1' / '__init__', test_path, 'cliapp.inner1'), (test_path / 'cliapp' / 'inner1' / 'inner2', test_path, 'cliapp.inner1.inner2'), ('test.a.b', cwd, 'test.a.b'), (test_path / 'cliapp.app', test_path, 'cliapp.app'), (test_path / 'cliapp' / 'message.txt', test_path, 'cliapp.message.txt')))"
      ],
      "arguments": [
        "request",
        "value",
        "path",
        "result"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert prepare_import(value) == result",
        "assert sys.path[0] == str(path)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_locate_app",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 195,
      "end_line_number": 196,
      "source_code": "def test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('iname,aname,result', (('cliapp.app', None, 'testapp'), ('cliapp.app', 'testapp', 'testapp'), ('cliapp.factory', None, 'app'), ('cliapp.factory', 'create_app', 'app'), ('cliapp.factory', 'create_app()', 'app'), ('cliapp.factory', 'create_app2(\"foo\", \"bar\")', 'app2_foo_bar'), ('cliapp.factory', 'create_app2(\"foo\", \"bar\", )', 'app2_foo_bar'), ('cliapp.factory', ' create_app () ', 'app')))"
      ],
      "arguments": [
        "test_apps",
        "iname",
        "aname",
        "result"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert locate_app(iname, aname).name == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_locate_app_raises",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 217,
      "end_line_number": 219,
      "source_code": "def test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('iname,aname', (('notanapp.py', None), ('cliapp/app', None), ('cliapp.app', 'notanapp'), ('cliapp.factory', 'create_app2(\"foo\")'), ('cliapp.factory', 'create_app('), ('cliapp.factory', 'no_app'), ('cliapp.importerrorapp', None), ('cliapp.message.txt', None)))"
      ],
      "arguments": [
        "test_apps",
        "iname",
        "aname"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_locate_app_suppress_raise",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 222,
      "end_line_number": 228,
      "source_code": "def test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert app is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 231,
      "end_line_number": 244,
      "source_code": "def test_get_version(test_apps, capsys):\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {platform.python_version()}\" in out\n    assert f\"Flask {importlib.metadata.version('flask')}\" in out\n    assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "capsys"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'Python {platform.python_version()}' in out",
        "assert f\"Flask {importlib.metadata.version('flask')}\" in out",
        "assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_scriptinfo",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 247,
      "end_line_number": 286,
      "source_code": "def test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'createapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'hello'",
        "assert app.name == 'testapp'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_cli_has_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 289,
      "end_line_number": 304,
      "source_code": "def test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.return_value == (True, True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_with_appcontext",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 307,
      "end_line_number": 317,
      "source_code": "def test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'testapp\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `invoke` fixture is defined using the `partial` function, which pre-configures the `runner.invoke` method with the CLI group created by `FlaskGroup`. This setup allows tests to execute CLI commands by passing command arguments to the `invoke` function, capturing the output and exit code for assertions. The `CliRunner` from the `click.testing` module is used to simulate the command-line environment, making it possible to test the CLI commands without running an actual server."
        }
      ]
    },
    {
      "name": "test_appgroup_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 320,
      "end_line_number": 345,
      "source_code": "def test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'testappgroup\\n'",
        "assert result.exit_code == 0",
        "assert result.output == 'testappgroup\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        },
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_flaskgroup_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 348,
      "end_line_number": 362,
      "source_code": "def test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'flaskgroup\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_flaskgroup_debug",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 366,
      "end_line_number": 382,
      "source_code": "def test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('set_debug_flag', (True, False))"
      ],
      "arguments": [
        "runner",
        "set_debug_flag"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == f'{not set_debug_flag}\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_flaskgroup_nested",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 385,
      "end_line_number": 395,
      "source_code": "def test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == 'flask_test\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_no_command_echo_loading_error",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 398,
      "end_line_number": 410,
      "source_code": "def test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 2",
        "assert 'FLASK_APP' in result.stderr",
        "assert 'Usage:' in result.stderr"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_help_echo_loading_error",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 413,
      "end_line_number": 425,
      "source_code": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'FLASK_APP' in result.stderr",
        "assert 'Usage:' in result.stdout"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run in a terminal, capturing their output and exit codes for assertions in test cases. The method is typically used in conjunction with pytest to automate the testing of CLI functionality in Flask applications."
        }
      ]
    },
    {
      "name": "test_help_echo_exception",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 428,
      "end_line_number": 443,
      "source_code": "def test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Exception: oh no' in result.stderr",
        "assert 'Usage:' in result.stdout"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run in a terminal, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_simple",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 469,
      "end_line_number": 472,
      "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is a pytest fixture that takes two parameters: `app` and `runner`. The `app` parameter is a Flask application instance, and the `runner` parameter is an instance of `CliRunner`, which is a utility from the `click` library used for testing CLI applications. Inside the method, a `FlaskGroup` object is created, which is a specialized subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing tests to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by integrating Flask's CLI capabilities with pytest's testing framework."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines, which are presumably headers or irrelevant information. Then, it iterates over the `order` and the remaining lines of the `output` simultaneously using `zip`. For each pair, it asserts that the beginning of the line matches the expected string from `order`. This is done by comparing the slice of the line up to the length of the expected string with the expected string itself. If any line does not match, an assertion error is raised, indicating a mismatch in the expected order."
        }
      ]
    },
    {
      "name": "test_sort",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 474,
      "end_line_number": 487,
      "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert default_output == endpoint_output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines, which are presumably headers or irrelevant information. Then, it iterates over the `order` and the remaining lines of the `output` simultaneously using `zip`. For each pair, it checks if the beginning of the line matches the expected string from `order`. This is done by slicing the line to the length of the expected string and asserting equality. If any line does not match the expected start, an assertion error is raised, indicating a mismatch in the order."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines, which are presumably headers or irrelevant for the order check. Then, it iterates over the `order` list and the remaining lines of the output simultaneously using `zip`. For each pair, it asserts that the beginning of the line matches the expected string from `order`. This is done by comparing the slice of the line up to the length of the expected string with the expected string itself. If any line does not match, an assertion error is raised, indicating a mismatch in the expected order."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines (presumably headers or irrelevant information). Then, it iterates over the `order` and the remaining lines of the output simultaneously using `zip`. For each pair, it checks if the beginning of the line matches the expected string from `order`. This is done using slicing (`line[:len(expect)] == expect`) instead of `startswith` to provide more detailed output in case of assertion failures, which is useful for debugging in test environments."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a parameter in test functions to set up the necessary context for testing. It takes two arguments: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module.\n\n1. **FlaskGroup Creation**: The method creates an instance of `FlaskGroup`, a subclass of `AppGroup` that is specifically designed to work with Flask applications. The `create_app` parameter is set to a lambda function that returns the `app` instance, ensuring that the CLI commands are associated with the correct Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments to another function. In this case, it pre-fixes the `cli` object to the `runner.invoke` method. This allows the test functions to easily invoke CLI commands by simply passing the command arguments to this partial function.\n\nBy using this fixture, developers can write tests that simulate running CLI commands and check their output, exit codes, and other behaviors, ensuring that the application's CLI functionality works as expected."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application using the `CliRunner` from the `click` library.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a parameter in test functions to automatically set up and tear down the necessary testing environment. The method takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner`.\n\n1. **FlaskGroup Creation**: The method creates a `FlaskGroup` instance, which is a specialized subclass of `AppGroup` that integrates with Flask applications. The `create_app` parameter is set to a lambda function that returns the `app` instance, allowing the `FlaskGroup` to load commands from the given Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments to another function. In this case, it pre-fixes the `cli` object to the `runner.invoke` method. This allows test functions to easily invoke CLI commands by calling this partial function with the desired command arguments.\n\nBy using this fixture, developers can write tests that simulate running CLI commands in a controlled environment, making it easier to verify the behavior and output of those commands."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application using the `CliRunner` from the `click` library.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a parameter in test functions to automatically set up and tear down the necessary testing environment. The method takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner`.\n\n1. **FlaskGroup Creation**: The method creates a `FlaskGroup` instance, which is a specialized subclass of `AppGroup` that integrates with Flask applications. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. This setup allows the CLI to load commands from the Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments to another function. In this case, it pre-fixes the `cli` object to the `runner.invoke` method. This allows test functions to easily invoke CLI commands by calling the returned partial function with the desired command arguments.\n\nBy using this fixture, developers can write tests that simulate running CLI commands in a controlled environment, making it easier to verify the behavior and output of those commands."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is a pytest fixture that takes two parameters: `app` and `runner`. The `app` parameter is a Flask application instance, and the `runner` parameter is an instance of `CliRunner`, which is a utility from the `click` library used for testing command-line interfaces. Inside the method, a `FlaskGroup` object is created, which is a specialized subclass of `AppGroup` that can load commands from the Flask application. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing tests to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by integrating Flask's CLI capabilities with pytest's testing framework."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application using the `CliRunner` from the `click` library.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner`. Inside the method, a `FlaskGroup` object is created, which is a specialized subclass of `AppGroup` that can load commands from a Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a partially applied function using `functools.partial`, which binds the `runner.invoke` method to the `cli` object. This allows test functions to easily invoke CLI commands by calling the returned function with the desired command arguments."
        }
      ]
    },
    {
      "name": "test_all_methods",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 489,
      "end_line_number": 493,
      "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET, HEAD, OPTIONS, POST' not in output",
        "assert 'GET, HEAD, OPTIONS, POST' in output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application using the `CliRunner` from the `click` library.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app` and `runner`. The `app` parameter is a Flask application instance, and `runner` is an instance of `CliRunner`, which is used to simulate command-line interactions.\n\n1. **FlaskGroup Creation**: The method creates an instance of `FlaskGroup`, which is a subclass of `AppGroup` specifically designed to work with Flask applications. The `create_app` parameter is set to a lambda function that returns the `app` instance, allowing `FlaskGroup` to load commands from the given Flask app.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments of another function. In this case, it pre-fixes the `runner.invoke` method with the `cli` object (the `FlaskGroup` instance). This allows test functions to easily invoke CLI commands by calling the returned partial function with the desired command arguments.\n\nBy using this fixture, developers can write tests that simulate running CLI commands in a controlled environment, making it easier to verify the behavior of custom Flask CLI commands."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a partially applied function using `functools.partial`, which binds the `runner.invoke` method to the `cli` object. This allows test functions to easily invoke CLI commands by calling the `invoke` fixture with the desired command arguments, simulating how the commands would be run in a real CLI environment."
        }
      ]
    },
    {
      "name": "test_no_routes",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 495,
      "end_line_number": 500,
      "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'No routes were registered.' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands without needing to run them in a real terminal.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from a Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands in a controlled test environment, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_subdomain",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 502,
      "end_line_number": 509,
      "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Subdomain' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask app without needing to run the app in a live environment.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask app. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases. The `CliRunner` from the `click.testing` module is used to facilitate this process, providing a way to invoke commands and check their results in a controlled test environment."
        }
      ]
    },
    {
      "name": "test_host",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 511,
      "end_line_number": 518,
      "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Host' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask app without needing to run the app in a live environment.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask app. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases. The `CliRunner` from the `click.testing` module is used to facilitate this process, providing a way to invoke commands and check their results in a controlled test environment."
        }
      ]
    },
    {
      "name": "test_load_dotenv",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 536,
      "end_line_number": 556,
      "source_code": "def test_load_dotenv(monkeypatch):\n    # can't use monkeypatch.delitem since the keys don't exist yet\n    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(test_path)\n    assert load_dotenv()\n    assert Path.cwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n    # test env file encoding\n    assert os.environ[\"HAM\"] == \"\u706b\u817f\"\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\", load_defaults=False)",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert load_dotenv()",
        "assert Path.cwd() == test_path",
        "assert os.environ['FOO'] == 'env'",
        "assert os.environ['BAR'] == 'bar'",
        "assert os.environ['SPAM'] == '1'",
        "assert os.environ['EGGS'] == '3'",
        "assert os.environ['HAM'] == '\u706b\u817f'",
        "assert not load_dotenv('non-existent-file', load_defaults=False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dotenv_path",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 560,
      "end_line_number": 566,
      "source_code": "def test_dotenv_path(monkeypatch):\n    for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    load_dotenv(test_path / \".flaskenv\")\n    assert Path.cwd() == cwd\n    assert \"FOO\" in os.environ",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert Path.cwd() == cwd",
        "assert 'FOO' in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dotenv_optional",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 569,
      "end_line_number": 573,
      "source_code": "def test_dotenv_optional(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'FOO' not in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_disable_dotenv_from_env",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 577,
      "end_line_number": 581,
      "source_code": "def test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'FOO' not in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask app without needing to run the app in a live environment.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask app. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases. The `CliRunner` from the `click.testing` module is used to facilitate this process, providing a way to invoke commands and check their results in a controlled test environment."
        }
      ]
    },
    {
      "name": "test_run_cert_path",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 584,
      "end_line_number": 599,
      "source_code": "def test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] == (__file__, __file__)",
        "assert ctx.params['cert'] == (__file__, __file__)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_cert_adhoc",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 602,
      "end_line_number": 616,
      "source_code": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] == 'adhoc'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_cert_import",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 619,
      "end_line_number": 638,
      "source_code": "def test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] is ssl_context"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_cert_no_ssl",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 641,
      "end_line_number": 645,
      "source_code": "def test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_blueprints",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 648,
      "end_line_number": 688,
      "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
      "docstring": "Test blueprint commands register correctly to the application",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'custom_result' in result.output",
        "assert 'nested_result' in result.output",
        "assert 'merged_result' in result.output",
        "assert 'late_result' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app_runner.invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application and capture their output for assertions in tests.\n\n**How It Works**:\nThe method is defined as a pytest fixture named `invoke`. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. The method creates a `FlaskGroup` object, which is a specialized subclass of `AppGroup` that can load commands from a Flask application. The `FlaskGroup` is initialized with a lambda function that returns the `app` instance. The method then returns a partially applied function using `functools.partial`, which binds the `runner.invoke` method to the `cli` object. This allows tests to easily invoke CLI commands by calling the `invoke` fixture with the desired command arguments, and it will execute the command within the context of the provided Flask application."
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app_runner.invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application and capture their output for assertions in tests.\n\n**How It Works**:\nThe method is defined as a pytest fixture named `invoke`. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. The method creates a `FlaskGroup` object, which is a specialized subclass of `AppGroup` that can load commands from a Flask application. The `FlaskGroup` is initialized with a lambda function that returns the `app` instance, allowing it to manage the app's CLI commands. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, enabling the execution of CLI commands within the test environment. This setup allows developers to easily test the behavior and output of their Flask CLI commands by invoking them through the `invoke` fixture in their pytest test cases."
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app_runner.invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application and capture their output for assertions in tests.\n\n**How It Works**:\nThe method is defined as a pytest fixture named `invoke`. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. The method creates a `FlaskGroup` object, which is a specialized subclass of `AppGroup` that can load commands from a Flask application. The `FlaskGroup` is initialized with a lambda function that returns the `app` instance, allowing it to manage the app's CLI commands. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, enabling the execution of CLI commands in tests. This setup allows developers to easily test the behavior and output of their Flask application's CLI commands within a controlled testing environment."
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app_runner.invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application and capture their output for assertions in tests.\n\n**How It Works**:\nThe method is defined as a pytest fixture named `invoke`. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. The method creates a `FlaskGroup` object, which is a specialized subclass of `AppGroup` that can load commands from a Flask application. The `FlaskGroup` is initialized with a lambda function that returns the `app` instance. The method then returns a partially applied function using `functools.partial`, which binds the `runner.invoke` method to the `cli` object. This allows tests to easily invoke CLI commands by calling the `invoke` fixture with the desired command arguments, capturing the output and exit code for verification."
        }
      ]
    },
    {
      "name": "test_cli_empty",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 691,
      "end_line_number": 697,
      "source_code": "def test_cli_empty(app):\n    \"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"\n    bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"",
      "docstring": "If a Blueprint's CLI group is empty, do not register it.",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 2, f'Unexpected success:\\n\\n{result.output}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_exclude_patterns",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 700,
      "end_line_number": 702,
      "source_code": "def test_run_exclude_patterns():\n    ctx = run_command.make_context(\"run\", [\"--exclude-patterns\", __file__])\n    assert ctx.params[\"exclude_patterns\"] == [__file__]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['exclude_patterns'] == [__file__]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_simple",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 469,
      "end_line_number": 472,
      "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands against a Flask application using the `CliRunner` from the `click` library.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a parameter in test functions to automatically set up and tear down the necessary testing environment. The method takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner`.\n\n1. **FlaskGroup Creation**: The method creates a `FlaskGroup` instance, which is a specialized subclass of `AppGroup` that integrates with Flask applications. The `create_app` parameter is set to a lambda function that returns the `app` instance, allowing the `FlaskGroup` to load commands from the given Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments to another function. In this case, it pre-fixes the `cli` object to the `runner.invoke` method. This allows test functions to easily invoke CLI commands by calling this partial function with the desired command arguments.\n\nBy using this fixture, developers can write tests that simulate running CLI commands in a controlled environment, making it easier to verify the behavior and output of those commands."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines (presumably headers or irrelevant information). Then, it iterates over the `order` and the remaining lines of the output simultaneously using `zip`. For each pair, it asserts that the beginning of the line matches the expected string from `order`. This is done by comparing the slice of the line up to the length of the expected string with the expected string itself. If any line does not match, an assertion error is raised, indicating a mismatch in the expected order."
        }
      ]
    },
    {
      "name": "test_sort",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 474,
      "end_line_number": 487,
      "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert default_output == endpoint_output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines (presumably headers or irrelevant information). Then, it iterates over the `order` and the remaining lines of `output` simultaneously using `zip`. For each pair, it checks if the beginning of the line matches the expected string from `order`. This is done by slicing the line to the length of the expected string and using an equality assertion. If any line does not match the expected order, an assertion error is raised, indicating a test failure."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines, skipping the first two lines (presumably headers or irrelevant information). Then, it iterates over the `order` and the remaining lines of the output simultaneously using `zip`. For each pair, it asserts that the beginning of the line matches the expected string from `order`. This is done by comparing the substring of the line (up to the length of the expected string) with the expected string itself. If any line does not match, an assertion error is raised, indicating a mismatch in the expected order."
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
          "code_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the lines of a given output match a specified order. It is primarily used in testing scenarios to ensure that the output of a command or function is in the expected sequence.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected starting strings for each line, and `output`, a string containing multiple lines of text. It splits the `output` into lines and skips the first two lines (presumably headers or irrelevant information). Then, it iterates over the `order` and the remaining lines of the `output` in parallel using `zip`. For each pair, it asserts that the beginning of the line matches the expected string from `order`. This is done by comparing the substring of the line (up to the length of the expected string) with the expected string itself. If any line does not match, an assertion error is raised, indicating a mismatch in the expected order."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing test functions to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by abstracting the creation and invocation of the CLI environment."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing test functions to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by abstracting the creation and invocation of the CLI environment."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's command-line commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used in test functions to set up a specific testing context. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. \n\n1. **FlaskGroup Creation**: The method creates an instance of `FlaskGroup`, a subclass of `AppGroup` that is specifically designed to work with Flask applications. The `create_app` parameter is set to a lambda function that returns the `app` instance, ensuring that the CLI commands are executed in the context of the provided Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments of another function. In this case, it pre-fixes the `runner.invoke` method with the `cli` object, allowing test functions to easily invoke CLI commands by passing the command arguments to this partial function.\n\nBy using this fixture, developers can write tests that simulate running CLI commands and check their output, exit codes, and other behaviors, ensuring that the application's command-line interface works as expected."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing test functions to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by abstracting the creation and invocation of the CLI environment."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a partially applied function using `functools.partial`, which binds the `runner.invoke` method to the `cli` object. This allows test functions to easily invoke CLI commands by calling the returned function with the desired command arguments, simulating how the commands would be run in a real CLI environment."
        }
      ]
    },
    {
      "name": "test_all_methods",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 489,
      "end_line_number": 493,
      "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET, HEAD, OPTIONS, POST' not in output",
        "assert 'GET, HEAD, OPTIONS, POST' in output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a parameter in test functions to automatically set up and tear down the necessary test environment. The method takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module.\n\n1. **FlaskGroup Creation**: Inside the method, a `FlaskGroup` object is created. `FlaskGroup` is a subclass of `AppGroup` that is specifically designed to work with Flask applications. It allows the loading of additional commands from the Flask app. The `create_app` parameter is set to a lambda function that returns the `app` instance, ensuring that the CLI commands are executed in the context of the provided Flask application.\n\n2. **Partial Function**: The method returns a `partial` function, which is a callable that pre-fixes some arguments to another function. In this case, it pre-fixes the `cli` object to the `runner.invoke` method. This allows test functions to easily invoke CLI commands by calling this partial function with the desired command arguments.\n\nBy using this fixture, developers can write tests that simulate running CLI commands and assert their outputs or effects, ensuring that the application's command-line interface behaves as expected."
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is designed to facilitate the testing of Flask command-line interface (CLI) commands within a pytest testing environment. It provides a convenient way to execute CLI commands using a test runner, allowing developers to verify the behavior of their Flask application's CLI commands.\n\n**How It Works**:\nThe `invoke` method is defined as a pytest fixture, which means it can be used as a dependency in test functions. It takes two parameters: `app`, which is a Flask application instance, and `runner`, which is an instance of `CliRunner` from the `click.testing` module. Inside the method, a `FlaskGroup` object is created, which is a special subclass of `AppGroup` that can load commands from the Flask app. The `FlaskGroup` is initialized with a `create_app` lambda function that returns the provided `app` instance. The method then returns a `partial` function that binds the `runner.invoke` method to the `cli` object, allowing test functions to easily invoke CLI commands by calling this partial function with the desired command arguments. This setup streamlines the process of testing CLI commands by abstracting the creation and invocation of the CLI environment."
        }
      ]
    },
    {
      "name": "test_no_routes",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 495,
      "end_line_number": 500,
      "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'No routes were registered.' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask app without needing to run the app in a live environment.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask app. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases. The `CliRunner` from the `click.testing` module is used to facilitate this process, providing a way to invoke commands and check their results in a controlled test environment."
        }
      ]
    },
    {
      "name": "test_subdomain",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 502,
      "end_line_number": 509,
      "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Subdomain' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask application.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask application. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases."
        }
      ]
    },
    {
      "name": "test_host",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 511,
      "end_line_number": 518,
      "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Host' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
          "code_explanation": "**Main Purpose of the Method**:\nThe `runner.invoke` method is used to simulate command-line interface (CLI) commands for a Flask application within a testing environment. It allows developers to test the behavior and output of CLI commands defined in a Flask app without needing to run the app in a live environment.\n\n**How It Works**:\nThe `runner.invoke` method is part of a pytest fixture that sets up a testing environment for Flask CLI commands. It uses the `FlaskGroup` class to create a CLI group that can load commands from the Flask app. The `partial` function is used to bind the `runner.invoke` method to this CLI group, allowing it to be called with specific command arguments during tests. This setup enables the execution of CLI commands as if they were run from the command line, capturing their output and exit codes for assertions in test cases. The `CliRunner` from the `click.testing` module is used to facilitate this process, providing a way to invoke commands and check their results in a controlled test environment."
        }
      ]
    },
    {
      "name": "test_context_processing",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 11,
      "end_line_number": 21,
      "source_code": "def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<p>23|42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_original_win",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 24,
      "end_line_number": 30,
      "source_code": "def test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_simple_stream",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 33,
      "end_line_number": 39,
      "source_code": "def test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_request_less_rendering",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 42,
      "end_line_number": 50,
      "source_code": "def test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'Hello Special World 42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_standard_context",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 53,
      "end_line_number": 68,
      "source_code": "def test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.split() == [b'42', b'23', b'False', b'aha']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_escaping",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 71,
      "end_line_number": 88,
      "source_code": "def test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines == [b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_no_escaping",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 91,
      "end_line_number": 110,
      "source_code": "def test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines == [b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically used to maintain user-specific data across requests."
        }
      ]
    },
    {
      "name": "test_escaping_without_template_filename",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 113,
      "end_line_number": 115,
      "source_code": "def test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "req_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.render_template_string('{{ foo }}', foo='<test>') == '&lt;test&gt;'",
        "assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_macros",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 118,
      "end_line_number": 120,
      "source_code": "def test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert macro('World') == 'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_filter",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 123,
      "end_line_number": 130,
      "source_code": "def test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_filter",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 133,
      "end_line_number": 140,
      "source_code": "def test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_filter_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_filter_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 153,
      "end_line_number": 160,
      "source_code": "def test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_filter_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 163,
      "end_line_number": 173,
      "source_code": "def test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_filter_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 176,
      "end_line_number": 187,
      "source_code": "def test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 190,
      "end_line_number": 200,
      "source_code": "def test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 203,
      "end_line_number": 214,
      "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_test",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 217,
      "end_line_number": 224,
      "source_code": "def test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_test",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 227,
      "end_line_number": 234,
      "source_code": "def test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_test_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 237,
      "end_line_number": 244,
      "source_code": "def test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_template_test_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 247,
      "end_line_number": 254,
      "source_code": "def test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_test_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 257,
      "end_line_number": 267,
      "source_code": "def test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This functionality is useful for maintaining state across requests in a web application."
        }
      ]
    },
    {
      "name": "test_add_template_test_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 270,
      "end_line_number": 281,
      "source_code": "def test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which can be customized using a session interface, as shown in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_template_test_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 284,
      "end_line_number": 294,
      "source_code": "def test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 297,
      "end_line_number": 308,
      "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client making the request. This method relies on Flask's session management to persist data across requests for a particular user."
        }
      ]
    },
    {
      "name": "test_add_template_global",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 311,
      "end_line_number": 321,
      "source_code": "def test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'get_stuff' in app.jinja_env.globals.keys()",
        "assert app.jinja_env.globals['get_stuff'] == get_stuff",
        "assert app.jinja_env.globals['get_stuff'](), 42",
        "assert rv == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_template_loader",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 324,
      "end_line_number": 339,
      "source_code": "def test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello Custom World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data across requests. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the HTTP request. This method leverages Flask's session management to maintain state across requests for a user."
        }
      ]
    },
    {
      "name": "test_iterable_loader",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 342,
      "end_line_number": 359,
      "source_code": "def test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<h1>Jameson</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a GET request is made to this endpoint, the method accesses the session object using `flask.session.get('value', 'None')`. This line attempts to fetch the value associated with the key `'value'` from the session. If the key is not present, it defaults to returning `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve session data, which is typically stored on the client-side in a secure cookie."
        }
      ]
    },
    {
      "name": "test_templates_auto_reload",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 362,
      "end_line_number": 391,
      "source_code": "def test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.debug is False",
        "assert app.config['TEMPLATES_AUTO_RELOAD'] is None",
        "assert app.jinja_env.auto_reload is False",
        "assert app.debug is False",
        "assert app.jinja_env.auto_reload is False",
        "assert app.debug is False",
        "assert app.jinja_env.auto_reload is True",
        "assert app.config['TEMPLATES_AUTO_RELOAD'] is None",
        "assert app.jinja_env.auto_reload is True",
        "assert app.jinja_env.auto_reload is False",
        "assert app.jinja_env.auto_reload is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_auto_reload_debug_run",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 394,
      "end_line_number": 404,
      "source_code": "def test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.jinja_env.auto_reload",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not app.jinja_env.auto_reload",
        "assert app.jinja_env.auto_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template_loader_debugging",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 407,
      "end_line_number": 440,
      "source_code": "def test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(called) == 1",
        "assert 'missing_template.html' in str(excinfo.value)",
        "assert \"1: trying loader of application 'blueprintapp'\" in text",
        "assert \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\" in text",
        "assert \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\" in text",
        "assert 'Error: the template could not be found' in text",
        "assert \"looked up from an endpoint that belongs to the blueprint 'frontend'\" in text",
        "assert 'See https://flask.palletsprojects.com/blueprints/#templates' in text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `c.get` method is designed to retrieve a value from the Flask session, specifically the value associated with the key `'value'`. If the key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nThe method is defined as a route handler for the `/get` endpoint in a Flask application. When a request is made to this endpoint, the method accesses the session object provided by Flask, which acts like a dictionary to store user-specific data. It uses the `get` method of the session object to attempt to retrieve the value associated with the key `'value'`. If the key is not found, it defaults to returning `'None'`. The retrieved value is then returned as the response to the HTTP request. This method relies on Flask's session management, which can be customized through session interfaces, as seen in the provided code snippets."
        }
      ]
    },
    {
      "name": "test_custom_jinja_env",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 443,
      "end_line_number": 451,
      "source_code": "def test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.jinja_env, CustomEnvironment)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_open_session_with_endpoint",
      "module": "test_session_interface",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_session_interface.py",
      "line_number": 6,
      "end_line_number": 28,
      "source_code": "def test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            request_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200",
      "docstring": "If request.endpoint (or other URL matching behavior) is needed\nwhile loading the session, RequestContext.match_request() can be\ncalled manually.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SessionInterface"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert request.endpoint is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
          "code_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask application that handles HTTP GET requests. Specifically, it is a decorator that maps a URL endpoint to a Python function, allowing the application to respond to requests made to that endpoint.\n\n**How It Works**:\nIn the provided code snippet, the `app.get` method is used to define a route for the root URL (`\"/\"`). When a GET request is made to this URL, the `index` function is executed, returning the string \"Hello, World!\". The `app.get` method is a shorthand for `app.route` with the `methods` parameter set to `[\"GET\"]`, simplifying the process of setting up GET routes. In the context of the `/get` route, the method retrieves a value from the session using `flask.session.get('value', 'None')` and returns it, defaulting to 'None' if the session key 'value' is not set."
        }
      ]
    }
  ]
}