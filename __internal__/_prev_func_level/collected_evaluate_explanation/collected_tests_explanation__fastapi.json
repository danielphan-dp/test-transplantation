{
  "tests": [
    {
      "repo_name": "fastapi",
      "name": "test_dummy_webhook",
      "module": "test_webhooks_security",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_webhooks_security.py",
      "line_number": 33,
      "end_line_number": 35,
      "source_code": "def test_dummy_webhook():\n    # Just for coverage\n    new_subscription(body={}, token=\"Bearer 123\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "fastapi.FastAPI",
        "fastapi.Security",
        "fastapi.security.HTTPBearer",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "typing_extensions.Annotated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "new_subscription",
          "body": "@app.webhooks.post('new-subscription')\ndef new_subscription(body: Subscription, token: Annotated[str, Security(bearer_scheme)]):\n    \"\"\"\n    When a new user subscribes to your service we'll send you a POST request with this\n    data to the URL that you register for the event `new-subscription` in the dashboard.\n    \"\"\"",
          "method_explanation": "**Main Purpose of the Method**:\nThe `new_subscription` method is designed to handle incoming POST requests when a new user subscribes to a service. It processes the subscription data sent in the request body, which includes the user's username, monthly fee, and subscription start date.\n\n**How It Works**:\nThe method is decorated with `@app.webhooks.post('new-subscription')`, indicating that it listens for POST requests at the specified endpoint. It accepts two parameters: `body`, which is expected to be an instance of the `Subscription` model (validated against the defined schema), and `token`, which is a security token for authentication. When a new subscription event occurs, the service sends a POST request to this endpoint with the relevant subscription data, allowing the application to handle the subscription logic accordingly."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dummy_webhook` is to ensure code coverage for the `new_subscription` function. It is not designed to verify any specific functionality or behavior but rather to execute the function to include it in the test coverage metrics.\n\n**Specific Functionality or Behavior Verified**:  \nThis test does not verify any specific functionality or behavior. It simply calls the `new_subscription` function with minimal input to ensure that the function is executed during testing, contributing to overall code coverage.\n\n**Code Being Tested and How It Works**:  \nThe `new_subscription` function is a FastAPI endpoint designed to handle POST requests for new user subscriptions. It expects a `Subscription` model as the body and a security token. The function is decorated with `@app.webhooks.post('new-subscription')`, indicating it is a webhook endpoint. The test calls this function directly with an empty dictionary for the `body` and a placeholder token, bypassing the usual HTTP request mechanism.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses a direct function call rather than simulating an HTTP request through the FastAPI `TestClient`. This approach is atypical for testing FastAPI endpoints, as it does not validate the HTTP layer or the integration of the endpoint with the FastAPI application. The test is labeled as \"Just for coverage,\" indicating its sole purpose is to ensure the function is executed during tests, without any assertions or validation of outcomes."
    },
    {
      "repo_name": "fastapi",
      "name": "test_custom_enum_encoders",
      "module": "test_jsonable_encoder",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_jsonable_encoder.py",
      "line_number": 224,
      "end_line_number": 236,
      "source_code": "def test_custom_enum_encoders():\n    def custom_enum_encoder(v: Enum):\n        return v.value.lower()\n\n    class MyEnum(Enum):\n        ENUM_VAL_1 = \"ENUM_VAL_1\"\n\n    instance = MyEnum.ENUM_VAL_1\n\n    encoded_instance = jsonable_encoder(\n        instance, custom_encoder={MyEnum: custom_enum_encoder}\n    )\n    assert encoded_instance == custom_enum_encoder(instance)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "dataclasses.dataclass",
        "datetime.datetime",
        "datetime.timezone",
        "decimal.Decimal",
        "enum.Enum",
        "pathlib.PurePath",
        "pathlib.PurePosixPath",
        "pathlib.PureWindowsPath",
        "typing.Optional",
        "pytest",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.Undefined",
        "fastapi.encoders.jsonable_encoder",
        "pydantic.BaseModel",
        "pydantic.Field",
        "pydantic.ValidationError",
        "utils.needs_pydanticv1",
        "utils.needs_pydanticv2",
        "pydantic.field_serializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded_instance == custom_enum_encoder(instance)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "custom_enum_encoder",
          "body": "def custom_enum_encoder(v: Enum):\n    return v.value.lower()",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `custom_enum_encoder` method is designed to convert an instance of an `Enum` into a string representation by returning the lowercase value of the enum member.\n\n**How It Works**:  \nThe method takes a single argument `v`, which is expected to be an instance of an `Enum`. It accesses the `value` attribute of the enum member and applies the `lower()` method to convert it to lowercase. This is particularly useful when encoding enum values for JSON serialization, ensuring a consistent and standardized string format. The method can be used as a custom encoder in functions like `jsonable_encoder`, allowing for tailored serialization of enum types."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_custom_enum_encoders` unit test is to verify that the `jsonable_encoder` function in FastAPI can correctly utilize a custom encoder for enumerations, specifically ensuring that the custom encoding logic is applied to instances of an `Enum` class.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a custom encoder is provided for an `Enum` type, the `jsonable_encoder` function uses this encoder to transform the `Enum` instance into its desired serialized form. The test ensures that the custom encoder function, which converts the enum value to lowercase, is correctly applied.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `jsonable_encoder` function from FastAPI, which is designed to serialize Python objects into JSON-compatible data types. In this test, a custom encoder function `custom_enum_encoder` is defined to convert an `Enum` value to lowercase. The test creates an instance of `MyEnum`, passes it to `jsonable_encoder` with the custom encoder, and asserts that the output matches the expected lowercase value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses a straightforward pattern of defining a custom encoder function and passing it to the `jsonable_encoder` via a dictionary that maps the `Enum` type to the custom function. This pattern allows for flexible serialization logic tailored to specific types. The test also uses an assertion to compare the encoded result with the expected output, ensuring the custom logic is correctly applied."
    },
    {
      "repo_name": "fastapi",
      "name": "test_call_api",
      "module": "test_schema_extra_examples",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_schema_extra_examples.py",
      "line_number": 223,
      "end_line_number": 257,
      "source_code": "def test_call_api():\n    app = create_app()\n    client = TestClient(app)\n    response = client.post(\"/schema_extra/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example_examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example_examples/\")\n    assert response.status_code == 200, response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Union",
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.Body",
        "fastapi.Cookie",
        "fastapi.FastAPI",
        "fastapi.Header",
        "fastapi.Path",
        "fastapi.Query",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "pydantic.ConfigDict"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_app",
          "body": "def create_app():\n    app = FastAPI()\n\n    class Item(BaseModel):\n        data: str\n        if PYDANTIC_V2:\n            model_config = ConfigDict(json_schema_extra={'example': {'data': 'Data in schema_extra'}})\n        else:\n\n            class Config:\n                schema_extra = {'example': {'data': 'Data in schema_extra'}}\n\n    @app.post('/schema_extra/')\n    def schema_extra(item: Item):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example/')\n        def example(item: Item=Body(example={'data': 'Data in Body example'})):\n            return item\n\n    @app.post('/examples/')\n    def examples(item: Item=Body(examples=[{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}])):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example_examples/')\n        def example_examples(item: Item=Body(example={'data': 'Overridden example'}, examples=[{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}])):\n            return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example/{item_id}')\n        def path_example(item_id: str=Path(example='item_1')):\n            return item_id\n\n    @app.get('/path_examples/{item_id}')\n    def path_examples(item_id: str=Path(examples=['item_1', 'item_2'])):\n        return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example_examples/{item_id}')\n        def path_example_examples(item_id: str=Path(example='item_overridden', examples=['item_1', 'item_2'])):\n            return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example/')\n        def query_example(data: Union[str, None]=Query(default=None, example='query1')):\n            return data\n\n    @app.get('/query_examples/')\n    def query_examples(data: Union[str, None]=Query(default=None, examples=['query1', 'query2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example_examples/')\n        def query_example_examples(data: Union[str, None]=Query(default=None, example='query_overridden', examples=['query1', 'query2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example/')\n        def header_example(data: Union[str, None]=Header(default=None, example='header1')):\n            return data\n\n    @app.get('/header_examples/')\n    def header_examples(data: Union[str, None]=Header(default=None, examples=['header1', 'header2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example_examples/')\n        def header_example_examples(data: Union[str, None]=Header(default=None, example='header_overridden', examples=['header1', 'header2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example/')\n        def cookie_example(data: Union[str, None]=Cookie(default=None, example='cookie1')):\n            return data\n\n    @app.get('/cookie_examples/')\n    def cookie_examples(data: Union[str, None]=Cookie(default=None, examples=['cookie1', 'cookie2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example_examples/')\n        def cookie_example_examples(data: Union[str, None]=Cookie(default=None, example='cookie_overridden', examples=['cookie1', 'cookie2'])):\n            return data\n    return app",
          "method_explanation": "**Main Purpose of the Method**:\nThe `create_app` method is designed to initialize a FastAPI application, define data models using Pydantic, and set up various API endpoints that demonstrate the use of request and response examples, including handling of different types of input (body, path, query, header, and cookie).\n\n**How It Works**:\n1. **FastAPI Initialization**: The method starts by creating an instance of the FastAPI application.\n2. **Data Model Definition**: It defines a Pydantic model `Item` with a `data` field, and configures it to include example data for JSON schema generation, depending on whether Pydantic v2 is used.\n3. **Endpoint Creation**: Several POST and GET endpoints are defined:\n   - `/schema_extra/`: Accepts an `Item` and returns it.\n   - `/example/`, `/examples/`, and similar endpoints: Demonstrate how to provide examples in request bodies, path parameters, query parameters, headers, and cookies, while also issuing deprecation warnings for certain patterns.\n4. **Deprecation Warnings**: The use of `pytest.warns(DeprecationWarning)` indicates that some of the patterns used in the endpoints are deprecated, signaling to developers that they should consider alternative approaches in future implementations.\n5. **Return the App**: Finally, the method returns the configured FastAPI application instance, ready to handle incoming requests. \n\nThis structure allows developers to see practical examples of how to use FastAPI with Pydantic for data validation and API documentation."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_call_api` function is to verify that various API endpoints in a FastAPI application respond with a status code of 200, indicating successful handling of requests. This test ensures that the endpoints are correctly set up and can process requests as expected.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that each endpoint in the FastAPI application returns a 200 OK status code when accessed with appropriate HTTP methods and data. It covers both POST and GET requests across different endpoints, ensuring that the application can handle requests with JSON bodies, path parameters, query parameters, headers, and cookies.\n\n**Code Being Tested and How It Works**:\nThe code under test is the `create_app` function, which sets up a FastAPI application with multiple endpoints. Each endpoint is designed to demonstrate the use of Pydantic models and FastAPI's request body, path, query, header, and cookie parameters. The endpoints include:\n- `/schema_extra/`: Accepts a POST request with a JSON body.\n- `/example/`, `/examples/`, `/example_examples/`: POST requests with different configurations of examples in the request body.\n- `/path_example/{item_id}`, `/path_examples/{item_id}`, `/path_example_examples/{item_id}`: GET requests with path parameters.\n- `/query_example/`, `/query_examples/`, `/query_example_examples/`: GET requests with query parameters.\n- `/header_example/`, `/header_examples/`, `/header_example_examples/`: GET requests with header parameters.\n- `/cookie_example/`, `/cookie_examples/`, `/cookie_example_examples/`: GET requests with cookie parameters.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test uses the `TestClient` from FastAPI's `testclient` module to simulate HTTP requests to the application. This allows for testing the application in a manner similar to how it would be used in production. The test employs a straightforward pattern of making requests and asserting that the response status code is 200, which is a common practice for verifying that endpoints are functioning correctly. Additionally, the use of `pytest.warns` in the application code indicates that some endpoints are expected to trigger deprecation warnings, which are acknowledged during the test setup."
    },
    {
      "repo_name": "fastapi",
      "name": "test_openapi_schema",
      "module": "test_schema_extra_examples",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_schema_extra_examples.py",
      "line_number": 260,
      "end_line_number": 966,
      "source_code": "def test_openapi_schema():\n    \"\"\"\n    Test that example overrides work:\n\n    * pydantic model schema_extra is included\n    * Body(example={}) overrides schema_extra in pydantic model\n    * Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model\n    \"\"\"\n    app = create_app()\n    client = TestClient(app)\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/schema_extra/\": {\n                \"post\": {\n                    \"summary\": \"Schema Extra\",\n                    \"operationId\": \"schema_extra_schema_extra__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/example/\": {\n                \"post\": {\n                    \"summary\": \"Example\",\n                    \"operationId\": \"example_example__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                                \"example\": {\"data\": \"Data in Body example\"},\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/examples/\": {\n                \"post\": {\n                    \"summary\": \"Examples\",\n                    \"operationId\": \"examples_examples__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"$ref\": \"#/components/schemas/Item\",\n                                        \"examples\": [\n                                            {\"data\": \"Data in Body examples, example1\"},\n                                            {\"data\": \"Data in Body examples, example2\"},\n                                        ],\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove this when deprecating Pydantic v1\n                                    {\n                                        \"allOf\": [\n                                            {\"$ref\": \"#/components/schemas/Item\"}\n                                        ],\n                                        \"title\": \"Item\",\n                                        \"examples\": [\n                                            {\"data\": \"Data in Body examples, example1\"},\n                                            {\"data\": \"Data in Body examples, example2\"},\n                                        ],\n                                    }\n                                )\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/example_examples/\": {\n                \"post\": {\n                    \"summary\": \"Example Examples\",\n                    \"operationId\": \"example_examples_example_examples__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"$ref\": \"#/components/schemas/Item\",\n                                        \"examples\": [\n                                            {\"data\": \"examples example_examples 1\"},\n                                            {\"data\": \"examples example_examples 2\"},\n                                        ],\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove this when deprecating Pydantic v1\n                                    {\n                                        \"allOf\": [\n                                            {\"$ref\": \"#/components/schemas/Item\"}\n                                        ],\n                                        \"title\": \"Item\",\n                                        \"examples\": [\n                                            {\"data\": \"examples example_examples 1\"},\n                                            {\"data\": \"examples example_examples 2\"},\n                                        ],\n                                    },\n                                ),\n                                \"example\": {\"data\": \"Overridden example\"},\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_example/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Example\",\n                    \"operationId\": \"path_example_path_example__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                            \"example\": \"item_1\",\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_examples/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Examples\",\n                    \"operationId\": \"path_examples_path_examples__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\n                                \"title\": \"Item Id\",\n                                \"type\": \"string\",\n                                \"examples\": [\"item_1\", \"item_2\"],\n                            },\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_example_examples/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Example Examples\",\n                    \"operationId\": \"path_example_examples_path_example_examples__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\n                                \"title\": \"Item Id\",\n                                \"type\": \"string\",\n                                \"examples\": [\"item_1\", \"item_2\"],\n                            },\n                            \"example\": \"item_overridden\",\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_example/\": {\n                \"get\": {\n                    \"summary\": \"Query Example\",\n                    \"operationId\": \"query_example_query_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"query1\",\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_examples/\": {\n                \"get\": {\n                    \"summary\": \"Query Examples\",\n                    \"operationId\": \"query_examples_query_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Query Example Examples\",\n                    \"operationId\": \"query_example_examples_query_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            ),\n                            \"example\": \"query_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_example/\": {\n                \"get\": {\n                    \"summary\": \"Header Example\",\n                    \"operationId\": \"header_example_header_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"header1\",\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_examples/\": {\n                \"get\": {\n                    \"summary\": \"Header Examples\",\n                    \"operationId\": \"header_examples_header_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Header Example Examples\",\n                    \"operationId\": \"header_example_examples_header_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            ),\n                            \"example\": \"header_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_example/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Example\",\n                    \"operationId\": \"cookie_example_cookie_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"cookie1\",\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_examples/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Examples\",\n                    \"operationId\": \"cookie_examples_cookie_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Example Examples\",\n                    \"operationId\": \"cookie_example_examples_cookie_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            ),\n                            \"example\": \"cookie_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"title\": \"HTTPValidationError\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"detail\": {\n                            \"title\": \"Detail\",\n                            \"type\": \"array\",\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                        }\n                    },\n                },\n                \"Item\": {\n                    \"title\": \"Item\",\n                    \"required\": [\"data\"],\n                    \"type\": \"object\",\n                    \"properties\": {\"data\": {\"title\": \"Data\", \"type\": \"string\"}},\n                    \"example\": {\"data\": \"Data in schema_extra\"},\n                },\n                \"ValidationError\": {\n                    \"title\": \"ValidationError\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"loc\": {\n                            \"title\": \"Location\",\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                        },\n                        \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                        \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                    },\n                },\n            }\n        },\n    }",
      "docstring": "Test that example overrides work:\n\n* pydantic model schema_extra is included\n* Body(example={}) overrides schema_extra in pydantic model\n* Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model",
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Union",
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.Body",
        "fastapi.Cookie",
        "fastapi.FastAPI",
        "fastapi.Header",
        "fastapi.Path",
        "fastapi.Query",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "pydantic.ConfigDict"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/schema_extra/': {'post': {'summary': 'Schema Extra', 'operationId': 'schema_extra_schema_extra__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/example/': {'post': {'summary': 'Example', 'operationId': 'example_example__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}, 'example': {'data': 'Data in Body example'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/examples/': {'post': {'summary': 'Examples', 'operationId': 'examples_examples__post', 'requestBody': {'content': {'application/json': {'schema': IsDict({'$ref': '#/components/schemas/Item', 'examples': [{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}]}) | IsDict({'allOf': [{'$ref': '#/components/schemas/Item'}], 'title': 'Item', 'examples': [{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}]})}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/example_examples/': {'post': {'summary': 'Example Examples', 'operationId': 'example_examples_example_examples__post', 'requestBody': {'content': {'application/json': {'schema': IsDict({'$ref': '#/components/schemas/Item', 'examples': [{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}]}) | IsDict({'allOf': [{'$ref': '#/components/schemas/Item'}], 'title': 'Item', 'examples': [{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}]}), 'example': {'data': 'Overridden example'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_example/{item_id}': {'get': {'summary': 'Path Example', 'operationId': 'path_example_path_example__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string'}, 'example': 'item_1', 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_examples/{item_id}': {'get': {'summary': 'Path Examples', 'operationId': 'path_examples_path_examples__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string', 'examples': ['item_1', 'item_2']}, 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_example_examples/{item_id}': {'get': {'summary': 'Path Example Examples', 'operationId': 'path_example_examples_path_example_examples__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string', 'examples': ['item_1', 'item_2']}, 'example': 'item_overridden', 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_example/': {'get': {'summary': 'Query Example', 'operationId': 'query_example_query_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'query1', 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_examples/': {'get': {'summary': 'Query Examples', 'operationId': 'query_examples_query_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['query1', 'query2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['query1', 'query2']}), 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_example_examples/': {'get': {'summary': 'Query Example Examples', 'operationId': 'query_example_examples_query_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['query1', 'query2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['query1', 'query2']}), 'example': 'query_overridden', 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_example/': {'get': {'summary': 'Header Example', 'operationId': 'header_example_header_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'header1', 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_examples/': {'get': {'summary': 'Header Examples', 'operationId': 'header_examples_header_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['header1', 'header2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['header1', 'header2']}), 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_example_examples/': {'get': {'summary': 'Header Example Examples', 'operationId': 'header_example_examples_header_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['header1', 'header2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['header1', 'header2']}), 'example': 'header_overridden', 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_example/': {'get': {'summary': 'Cookie Example', 'operationId': 'cookie_example_cookie_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'cookie1', 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_examples/': {'get': {'summary': 'Cookie Examples', 'operationId': 'cookie_examples_cookie_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['cookie1', 'cookie2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['cookie1', 'cookie2']}), 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_example_examples/': {'get': {'summary': 'Cookie Example Examples', 'operationId': 'cookie_example_examples_cookie_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['cookie1', 'cookie2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['cookie1', 'cookie2']}), 'example': 'cookie_overridden', 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'title': 'HTTPValidationError', 'type': 'object', 'properties': {'detail': {'title': 'Detail', 'type': 'array', 'items': {'$ref': '#/components/schemas/ValidationError'}}}}, 'Item': {'title': 'Item', 'required': ['data'], 'type': 'object', 'properties': {'data': {'title': 'Data', 'type': 'string'}}, 'example': {'data': 'Data in schema_extra'}}, 'ValidationError': {'title': 'ValidationError', 'required': ['loc', 'msg', 'type'], 'type': 'object', 'properties': {'loc': {'title': 'Location', 'type': 'array', 'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}}, 'msg': {'title': 'Message', 'type': 'string'}, 'type': {'title': 'Error Type', 'type': 'string'}}}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_app",
          "body": "def create_app():\n    app = FastAPI()\n\n    class Item(BaseModel):\n        data: str\n        if PYDANTIC_V2:\n            model_config = ConfigDict(json_schema_extra={'example': {'data': 'Data in schema_extra'}})\n        else:\n\n            class Config:\n                schema_extra = {'example': {'data': 'Data in schema_extra'}}\n\n    @app.post('/schema_extra/')\n    def schema_extra(item: Item):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example/')\n        def example(item: Item=Body(example={'data': 'Data in Body example'})):\n            return item\n\n    @app.post('/examples/')\n    def examples(item: Item=Body(examples=[{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}])):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example_examples/')\n        def example_examples(item: Item=Body(example={'data': 'Overridden example'}, examples=[{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}])):\n            return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example/{item_id}')\n        def path_example(item_id: str=Path(example='item_1')):\n            return item_id\n\n    @app.get('/path_examples/{item_id}')\n    def path_examples(item_id: str=Path(examples=['item_1', 'item_2'])):\n        return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example_examples/{item_id}')\n        def path_example_examples(item_id: str=Path(example='item_overridden', examples=['item_1', 'item_2'])):\n            return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example/')\n        def query_example(data: Union[str, None]=Query(default=None, example='query1')):\n            return data\n\n    @app.get('/query_examples/')\n    def query_examples(data: Union[str, None]=Query(default=None, examples=['query1', 'query2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example_examples/')\n        def query_example_examples(data: Union[str, None]=Query(default=None, example='query_overridden', examples=['query1', 'query2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example/')\n        def header_example(data: Union[str, None]=Header(default=None, example='header1')):\n            return data\n\n    @app.get('/header_examples/')\n    def header_examples(data: Union[str, None]=Header(default=None, examples=['header1', 'header2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example_examples/')\n        def header_example_examples(data: Union[str, None]=Header(default=None, example='header_overridden', examples=['header1', 'header2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example/')\n        def cookie_example(data: Union[str, None]=Cookie(default=None, example='cookie1')):\n            return data\n\n    @app.get('/cookie_examples/')\n    def cookie_examples(data: Union[str, None]=Cookie(default=None, examples=['cookie1', 'cookie2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example_examples/')\n        def cookie_example_examples(data: Union[str, None]=Cookie(default=None, example='cookie_overridden', examples=['cookie1', 'cookie2'])):\n            return data\n    return app",
          "method_explanation": "**Main Purpose of the Method**:\nThe `create_app` method is designed to instantiate a FastAPI application, define a Pydantic model for data validation, and set up various API endpoints that demonstrate the use of examples and schemas in request and response bodies, query parameters, headers, and cookies.\n\n**How It Works**:\n1. **FastAPI Initialization**: The method starts by creating an instance of the FastAPI application.\n2. **Pydantic Model Definition**: A class `Item` is defined using Pydantic's `BaseModel`, which includes a string field `data`. Depending on the version of Pydantic (V2 or not), it configures JSON schema examples differently.\n3. **API Endpoints**: Several POST and GET endpoints are defined:\n   - `/schema_extra/`: Accepts an `Item` and returns it.\n   - `/example/`, `/examples/`, `/example_examples/`: Demonstrate how to use examples in request bodies.\n   - `/path_example/{item_id}`, `/path_examples/{item_id}`, etc.: Show how to use examples in path parameters.\n   - `/query_example/`, `/query_examples/`: Illustrate examples in query parameters.\n   - `/header_example/`, `/header_examples/`: Demonstrate examples in headers.\n   - `/cookie_example/`, `/cookie_examples/`: Show examples in cookies.\n4. **Deprecation Warnings**: The method uses `pytest.warns` to indicate that certain features are deprecated, signaling to developers that they should be cautious when using these endpoints.\n5. **Return Statement**: Finally, the method returns the configured FastAPI application instance, making it ready for use. \n\nThis structure allows developers to see practical examples of how to implement and document API endpoints effectively using FastAPI and Pydantic."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_openapi_schema` is to verify that the OpenAPI schema generated by a FastAPI application correctly reflects the example and examples overrides specified in the Pydantic models and request bodies. This ensures that the API documentation accurately represents the intended usage and data structures.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that:\n- The `schema_extra` attribute in Pydantic models is included in the OpenAPI schema.\n- The `Body(example={})` parameter can override the `schema_extra` in Pydantic models.\n- The `Body(examples={})` parameter can override both `Body(example={})` and `schema_extra` in Pydantic models.\n- The OpenAPI schema correctly reflects these overrides in the generated JSON.\n\n**Code Being Tested and How It Works**:\nThe code under test is the `create_app` function, which sets up a FastAPI application with several endpoints. Each endpoint demonstrates different ways of specifying examples for request bodies, path parameters, query parameters, headers, and cookies using Pydantic models and FastAPI's `Body`, `Path`, `Query`, `Header`, and `Cookie` parameters. The test uses a `TestClient` to make a GET request to the `/openapi.json` endpoint, which returns the OpenAPI schema. The test then asserts that the response status is 200 and that the JSON response matches the expected schema, which includes the correct examples and overrides.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Use of `TestClient`**: The test uses FastAPI's `TestClient` to simulate HTTP requests to the application, allowing for testing of the OpenAPI schema generation.\n- **Assertions on JSON Structure**: The test includes detailed assertions on the structure and content of the JSON response, ensuring that the OpenAPI schema is generated as expected.\n- **Deprecation Warnings**: The test code includes `pytest.warns(DeprecationWarning)` to handle expected deprecation warnings, indicating a transition in the codebase (e.g., from Pydantic v1 to v2).\n- **Use of `IsDict`**: The test uses `IsDict` from the `dirty_equals` library to allow for flexible matching of dictionary structures, accommodating potential variations in the schema due to different Pydantic versions."
    },
    {
      "repo_name": "fastapi",
      "name": "test_depend_validation",
      "module": "test_ws_router",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
      "line_number": 210,
      "end_line_number": 233,
      "source_code": "def test_depend_validation():\n    \"\"\"\n    Verify that a validation in a dependency invokes the correct exception handler\n    \"\"\"\n    caught = []\n\n    @websocket_middleware\n    async def catcher(websocket, call_next):\n        try:\n            return await call_next()\n        except Exception as e:  # pragma: no cover\n            caught.append(e)\n            raise\n\n    myapp = make_app(middleware=[Middleware(catcher)])\n\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/depends-validate/\"):\n            pass  # pragma: no cover\n    # the validation error does produce a close message\n    assert e.value.code == status.WS_1008_POLICY_VIOLATION\n    # and no error is leaked\n    assert caught == []",
      "docstring": "Verify that a validation in a dependency invokes the correct exception handler",
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "pytest",
        "fastapi.APIRouter",
        "fastapi.Depends",
        "fastapi.FastAPI",
        "fastapi.Header",
        "fastapi.WebSocket",
        "fastapi.WebSocketDisconnect",
        "fastapi.status",
        "fastapi.middleware.Middleware",
        "fastapi.testclient.TestClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.value.code == status.WS_1008_POLICY_VIOLATION",
        "assert caught == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_app",
          "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
          "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router.\n   - `prefix_router`: A router that is included with a specified URL prefix (`/prefix`).\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be used to handle incoming requests and define additional routes. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration steps."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_depend_validation` unit test is to ensure that when a validation error occurs within a dependency of a FastAPI WebSocket route, the correct exception handler is invoked, and the error is appropriately managed without leaking.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically verifies that a validation error in a WebSocket dependency results in a WebSocket disconnect with a specific status code (`WS_1008_POLICY_VIOLATION`) and that the error is caught and handled without being leaked outside the middleware.\n\n**Code Being Tested and How It Works**:\nThe test is examining the behavior of a FastAPI application created by the `make_app` function, which sets up the application with specific middleware. The middleware, `catcher`, is designed to catch exceptions during WebSocket connections. The test uses `TestClient` to simulate a WebSocket connection to the `/depends-validate/` endpoint. If a validation error occurs, it should trigger a `WebSocketDisconnect` with the expected status code, and the middleware should catch the exception without adding it to the `caught` list, indicating proper handling.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Middleware Testing**: The test uses a custom middleware to intercept and handle exceptions, verifying that the middleware logic is correctly implemented.\n- **Exception Handling Verification**: By using `pytest.raises`, the test ensures that the expected exception (`WebSocketDisconnect`) is raised and checks the specific status code to confirm correct behavior.\n- **WebSocket Simulation**: The `TestClient` is used to simulate WebSocket connections, allowing the test to verify WebSocket-specific behavior in a controlled environment.\n- **Assertion of Side Effects**: The test asserts that the `caught` list remains empty, confirming that no unexpected exceptions are leaked beyond the middleware."
    },
    {
      "repo_name": "fastapi",
      "name": "test_depend_err_middleware",
      "module": "test_ws_router",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
      "line_number": 236,
      "end_line_number": 254,
      "source_code": "def test_depend_err_middleware():\n    \"\"\"\n    Verify that it is possible to write custom WebSocket middleware to catch errors\n    \"\"\"\n\n    @websocket_middleware\n    async def errorhandler(websocket: WebSocket, call_next):\n        try:\n            return await call_next()\n        except Exception as e:\n            await websocket.close(code=status.WS_1006_ABNORMAL_CLOSURE, reason=repr(e))\n\n    myapp = make_app(middleware=[Middleware(errorhandler)])\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/depends-err/\"):\n            pass  # pragma: no cover\n    assert e.value.code == status.WS_1006_ABNORMAL_CLOSURE\n    assert \"NotImplementedError\" in e.value.reason",
      "docstring": "Verify that it is possible to write custom WebSocket middleware to catch errors",
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "pytest",
        "fastapi.APIRouter",
        "fastapi.Depends",
        "fastapi.FastAPI",
        "fastapi.Header",
        "fastapi.WebSocket",
        "fastapi.WebSocketDisconnect",
        "fastapi.status",
        "fastapi.middleware.Middleware",
        "fastapi.testclient.TestClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.value.code == status.WS_1006_ABNORMAL_CLOSURE",
        "assert 'NotImplementedError' in e.value.reason"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_app",
          "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
          "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router that is included without a prefix.\n   - `prefix_router`: This router is included with a specified prefix (`/prefix`), allowing for namespacing of routes.\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be run or further modified as needed. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration patterns."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_depend_err_middleware` is to verify that a custom WebSocket middleware can effectively catch and handle errors during WebSocket connections in a FastAPI application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an error occurs during a WebSocket connection, the custom middleware can catch the exception, close the WebSocket connection with a specific status code (`WS_1006_ABNORMAL_CLOSURE`), and provide a reason for the closure that includes the exception message.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves a custom WebSocket middleware function `errorhandler` that wraps WebSocket connections. This middleware attempts to execute the next middleware or endpoint in the chain (`call_next`). If an exception is raised, it catches the exception, closes the WebSocket connection with an abnormal closure status code, and includes the exception's string representation as the reason for closure. The `make_app` function is used to create a FastAPI application with this middleware applied, and a `TestClient` is used to simulate a WebSocket connection to test the middleware's behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `pytest.raises` context manager to assert that a `WebSocketDisconnect` exception is raised during the WebSocket connection attempt. This pattern is useful for verifying that specific exceptions are triggered under certain conditions. Additionally, the test checks the exception's attributes (`code` and `reason`) to ensure they match the expected values, demonstrating a thorough validation of the middleware's error handling behavior. The use of `TestClient` allows for integration-style testing of WebSocket connections in a controlled test environment."
    },
    {
      "repo_name": "fastapi",
      "name": "test_depend_err_handler",
      "module": "test_ws_router",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
      "line_number": 257,
      "end_line_number": 271,
      "source_code": "def test_depend_err_handler():\n    \"\"\"\n    Verify that it is possible to write custom WebSocket middleware to catch errors\n    \"\"\"\n\n    async def custom_handler(websocket: WebSocket, exc: CustomError) -> None:\n        await websocket.close(1002, \"foo\")\n\n    myapp = make_app(exception_handlers={CustomError: custom_handler})\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/custom_error/\"):\n            pass  # pragma: no cover\n    assert e.value.code == 1002\n    assert \"foo\" in e.value.reason",
      "docstring": "Verify that it is possible to write custom WebSocket middleware to catch errors",
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "pytest",
        "fastapi.APIRouter",
        "fastapi.Depends",
        "fastapi.FastAPI",
        "fastapi.Header",
        "fastapi.WebSocket",
        "fastapi.WebSocketDisconnect",
        "fastapi.status",
        "fastapi.middleware.Middleware",
        "fastapi.testclient.TestClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.value.code == 1002",
        "assert 'foo' in e.value.reason"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_app",
          "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
          "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router that is included without a prefix.\n   - `prefix_router`: This router is included with a specified prefix (`/prefix`), allowing for namespacing of routes.\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be run or further modified as needed. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration patterns."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_depend_err_handler` is to verify that a custom WebSocket middleware can be implemented to handle specific exceptions, in this case, a `CustomError`, and to ensure that the middleware correctly closes the WebSocket connection with a specified code and reason.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a `CustomError` is raised during a WebSocket connection, the custom error handler (`custom_handler`) is invoked, which should close the WebSocket connection with the code `1002` and the reason containing the string \"foo\". It ensures that the application can handle WebSocket errors gracefully using custom logic.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `make_app` function, which creates a FastAPI application and includes routers. The test sets up a custom exception handler for `CustomError` using this function. The `custom_handler` is an asynchronous function that closes the WebSocket connection with a specific code and reason when a `CustomError` is encountered. The test uses `TestClient` to simulate a WebSocket connection to the endpoint `/custom_error/`, expecting a `WebSocketDisconnect` exception to be raised with the specified code and reason.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `pytest.raises` context manager to assert that a `WebSocketDisconnect` exception is raised, which is a common pattern for testing exception handling in Python. It also uses the `TestClient` from FastAPI to simulate WebSocket connections, allowing for integration-style testing of WebSocket endpoints. The use of `async` functions and `await` statements reflects the asynchronous nature of WebSocket communication in FastAPI. Additionally, the test includes assertions to verify both the code and reason of the WebSocket disconnection, ensuring comprehensive validation of the custom error handling logic."
    },
    {
      "repo_name": "fastapi",
      "name": "test_fastapi_cli_not_installed",
      "module": "test_fastapi_cli",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_fastapi_cli.py",
      "line_number": 28,
      "end_line_number": 32,
      "source_code": "def test_fastapi_cli_not_installed():\n    with patch.object(fastapi.cli, \"cli_main\", None):\n        with pytest.raises(RuntimeError) as exc_info:\n            fastapi.cli.main()\n        assert \"To use the fastapi command, please install\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "subprocess",
        "sys",
        "unittest.mock.patch",
        "fastapi.cli",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'To use the fastapi command, please install' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fastapi.cli.main",
          "body": "def main(some_arg, q: Optional[str]=None):\n    return {'some_arg': some_arg, 'q': q}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `main` method serves as a simple function that accepts a required argument `some_arg` and an optional query parameter `q`. It returns a dictionary containing these parameters, which can be useful for handling requests in a FastAPI application.\n\n**How It Works**:\nThe method takes two parameters: `some_arg`, which is mandatory, and `q`, which is optional and defaults to `None`. When called, it constructs and returns a dictionary with the values of `some_arg` and `q`. In the provided code snippets, this method is partially applied using `functools.partial` to create an endpoint that always uses \"foo\" as the value for `some_arg`. The FastAPI application then defines a GET endpoint that utilizes this partial function, allowing it to respond to requests with the specified parameters. The test client verifies that the endpoint correctly returns the expected dictionary when a query parameter `q` is provided."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_fastapi_cli_not_installed` is to verify that a `RuntimeError` is raised with a specific error message when the FastAPI CLI is not installed or available. This ensures that users receive a clear and informative error message guiding them to install the necessary CLI tools.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `cli_main` function of the `fastapi.cli` module is set to `None`, invoking `fastapi.cli.main()` raises a `RuntimeError`. It also verifies that the error message contains the phrase \"To use the fastapi command, please install\", indicating the absence of the CLI.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `main` function within the `fastapi.cli` module. The test uses `unittest.mock.patch` to temporarily set `cli_main` to `None`, simulating a scenario where the CLI is not installed. When `fastapi.cli.main()` is called under these conditions, it is expected to raise a `RuntimeError` with a specific message, which the test checks for.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock.patch` technique to modify the behavior of the `fastapi.cli` module during the test execution. This allows the test to simulate the absence of the CLI without altering the actual codebase. Additionally, the test uses `pytest.raises` to assert that a `RuntimeError` is raised, and it checks the exception message to ensure it contains the expected guidance for the user. This combination of mocking and exception handling is a common pattern in unit testing to verify error handling and user feedback."
    },
    {
      "repo_name": "fastapi",
      "name": "test_query_params_str_validations_no_query",
      "module": "test_regex_deprecated_params",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
      "line_number": 28,
      "end_line_number": 32,
      "source_code": "def test_query_params_str_validations_no_query():\n    client = get_client()\n    response = client.get(\"/items/\")\n    assert response.status_code == 200\n    assert response.json() == \"Hello World\"",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Query",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == 'Hello World'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is particularly useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_query_params_str_validations_no_query` is to verify that the FastAPI application correctly handles a GET request to the `/items/` endpoint without any query parameters, ensuring it returns a successful response with the expected content.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that when a GET request is made to the `/items/` endpoint, the server responds with a status code of 200 (indicating success) and a JSON response body containing the string \"Hello World\". This ensures that the endpoint is accessible and returns the correct default response when no query parameters are provided.\n\n**Code Being Tested and How It Works**:\nThe code being tested is part of a FastAPI application defined in the `get_client` fixture. This fixture sets up a FastAPI app with a couple of endpoints, although the `/items/` endpoint is not explicitly defined in the provided code snippet. The test uses the `TestClient` to simulate a client making a GET request to the `/items/` endpoint. The test checks the response status and content to ensure the endpoint behaves as expected.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test uses the `TestClient` from FastAPI's testing utilities, which is a common pattern for testing FastAPI applications. This allows for simulating HTTP requests to the application without needing to run a live server. The use of assertions to check both the status code and the response content is a standard practice in unit testing to ensure that the application behaves correctly under the tested conditions. Additionally, the test is structured to be simple and direct, focusing on a specific endpoint and its expected behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_query_params_str_validations_q_fixedquery",
      "module": "test_regex_deprecated_params",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
      "line_number": 36,
      "end_line_number": 40,
      "source_code": "def test_query_params_str_validations_q_fixedquery():\n    client = get_client()\n    response = client.get(\"/items/\", params={\"q\": \"fixedquery\"})\n    assert response.status_code == 200\n    assert response.json() == \"Hello fixedquery\"",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Query",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == 'Hello fixedquery'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_query_params_str_validations_q_fixedquery` test is to verify that the FastAPI application correctly handles query parameters and returns the expected response when a specific query parameter value is provided.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the `/items/` endpoint with the query parameter `q` set to `\"fixedquery\"`, the server responds with a status code of 200 and a JSON response of `\"Hello fixedquery\"`.\n\n**Code Being Tested and How It Works**:  \nThe test uses a FastAPI application client, created by the `get_client` fixture, to send a GET request to the `/items/` endpoint. The `get_client` function sets up a FastAPI application with various endpoints, although the specific `/items/` endpoint is not detailed in the provided code snippets. The test checks the response to ensure it matches the expected status code and JSON content, indicating that the application correctly processes the query parameter.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `TestClient` from `fastapi.testclient` to simulate HTTP requests to the FastAPI application, a common pattern for testing web applications. It uses assertions to verify both the HTTP status code and the content of the response, ensuring that the application behaves as expected when handling query parameters. The test is straightforward, focusing on a specific input and output scenario, which is a typical approach in unit testing to isolate and verify individual functionalities."
    },
    {
      "repo_name": "fastapi",
      "name": "test_query_params_str_validations_item_query_nonregexquery",
      "module": "test_regex_deprecated_params",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
      "line_number": 44,
      "end_line_number": 72,
      "source_code": "def test_query_params_str_validations_item_query_nonregexquery():\n    client = get_client()\n    response = client.get(\"/items/\", params={\"q\": \"nonregexquery\"})\n    assert response.status_code == 422\n    assert response.json() == IsDict(\n        {\n            \"detail\": [\n                {\n                    \"type\": \"string_pattern_mismatch\",\n                    \"loc\": [\"query\", \"q\"],\n                    \"msg\": \"String should match pattern '^fixedquery$'\",\n                    \"input\": \"nonregexquery\",\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                }\n            ]\n        }\n    ) | IsDict(\n        # TODO: remove when deprecating Pydantic v1\n        {\n            \"detail\": [\n                {\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                    \"loc\": [\"query\", \"q\"],\n                    \"msg\": 'string does not match regex \"^fixedquery$\"',\n                    \"type\": \"value_error.str.regex\",\n                }\n            ]\n        }\n    )",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Query",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 422",
        "assert response.json() == IsDict({'detail': [{'type': 'string_pattern_mismatch', 'loc': ['query', 'q'], 'msg': \"String should match pattern '^fixedquery$'\", 'input': 'nonregexquery', 'ctx': {'pattern': '^fixedquery$'}}]}) | IsDict({'detail': [{'ctx': {'pattern': '^fixedquery$'}, 'loc': ['query', 'q'], 'msg': 'string does not match regex \"^fixedquery$\"', 'type': 'value_error.str.regex'}]})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, which can be used in test functions to simulate API calls and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_query_params_str_validations_item_query_nonregexquery` is to verify that the FastAPI application correctly enforces string pattern validation on query parameters, specifically ensuring that a query parameter `q` matches a predefined regex pattern.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a query parameter `q` with a value that does not match the expected regex pattern `^fixedquery$` is provided, the application responds with a 422 Unprocessable Entity status code. It also verifies that the error message in the response details the pattern mismatch.\n\n**Code Being Tested and How It Works**:  \nThe test uses a FastAPI client to send a GET request to the `/items/` endpoint with a query parameter `q` set to \"nonregexquery\". The application is expected to validate this parameter against the regex pattern `^fixedquery$`. Since \"nonregexquery\" does not match the pattern, the application should return a 422 status code with a detailed error message indicating the pattern mismatch.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `TestClient` from FastAPI to simulate HTTP requests to the application. It uses assertions to check both the status code and the JSON response content. The test also uses the `IsDict` utility from the `dirty_equals` library to flexibly match the error response, accommodating potential differences in error message formats between Pydantic versions. This approach ensures the test remains valid across different Pydantic versions, as indicated by the conditional logic in the assertions."
    },
    {
      "repo_name": "fastapi",
      "name": "test_openapi_schema",
      "module": "test_regex_deprecated_params",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
      "line_number": 76,
      "end_line_number": 163,
      "source_code": "def test_openapi_schema():\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    # insert_assert(response.json())\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"q\",\n                            \"in\": \"query\",\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [\n                                        {\"type\": \"string\", \"pattern\": \"^fixedquery$\"},\n                                        {\"type\": \"null\"},\n                                    ],\n                                    \"title\": \"Q\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: remove when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"pattern\": \"^fixedquery$\",\n                                    \"title\": \"Q\",\n                                }\n                            ),\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            }\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Query",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'parameters': [{'name': 'q', 'in': 'query', 'required': False, 'schema': IsDict({'anyOf': [{'type': 'string', 'pattern': '^fixedquery$'}, {'type': 'null'}], 'title': 'Q'}) | IsDict({'type': 'string', 'pattern': '^fixedquery$', 'title': 'Q'})}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_openapi_schema` is to verify that the FastAPI application correctly generates and serves the OpenAPI schema at the `/openapi.json` endpoint. This ensures that the API documentation is accurate and conforms to the expected OpenAPI specification.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that the OpenAPI schema returned by the FastAPI application matches a predefined structure. It verifies the HTTP status code of the response is 200, indicating a successful request, and that the JSON content of the response matches the expected OpenAPI schema, including paths, parameters, and response structures.\n\n**Code Being Tested and How It Works**:\nThe test uses a `TestClient` instance, created by the `get_client` fixture, to send a GET request to the `/openapi.json` endpoint of a FastAPI application. The application is defined within the `get_client` function, which includes endpoints and models that contribute to the OpenAPI schema. The test checks the response status code and compares the JSON response against an expected schema, which includes details about API paths, parameters, and response models.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Fixture Usage**: The test uses a pytest fixture (`get_client`) to set up the FastAPI application and client, promoting reusability and separation of setup logic from test logic.\n- **Assertion of JSON Structure**: The test uses assertions to compare the entire JSON response against a predefined schema, ensuring comprehensive validation of the OpenAPI document.\n- **Conditional Schema Validation**: The test uses `IsDict` from `dirty_equals` to handle potential variations in the schema, particularly for handling deprecated parameters, which allows for flexible matching of expected JSON structures."
    },
    {
      "repo_name": "fastapi",
      "name": "test_no_query",
      "module": "test_regex_deprecated_body",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
      "line_number": 28,
      "end_line_number": 32,
      "source_code": "def test_no_query():\n    client = get_client()\n    response = client.post(\"/items/\")\n    assert response.status_code == 200\n    assert response.json() == \"Hello World\"",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Form",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == 'Hello World'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Pydantic Model Definition**: It defines a `Rectangle` model using Pydantic, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and assertions."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_no_query` unit test is to verify that a POST request to the `/items/` endpoint of a FastAPI application returns a successful response with a status code of 200 and a JSON response body containing the string \"Hello World\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint `/items/` is correctly configured to handle POST requests without any query parameters and that it returns the expected response. It ensures that the endpoint is accessible and behaves as intended when no additional data is provided in the request.\n\n**Code Being Tested and How It Works**:  \nThe test uses a `TestClient` instance, which is a part of FastAPI's testing utilities, to simulate HTTP requests to the FastAPI application. The `get_client` fixture sets up a FastAPI app with defined routes, but the `/items/` endpoint is not explicitly shown in the provided code snippets. The test assumes that this endpoint exists and is configured to return a 200 status code with the response \"Hello World\" when accessed via a POST request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of FastAPI's `TestClient` to perform integration testing by simulating HTTP requests to the application. This approach allows for testing the application in a manner similar to how it would be used in production. The test uses assertions to verify both the HTTP status code and the content of the response, ensuring that the endpoint behaves as expected. The absence of a docstring and the use of direct assertions are typical in straightforward unit tests where the behavior is simple and well-understood."
    },
    {
      "repo_name": "fastapi",
      "name": "test_q_fixedquery",
      "module": "test_regex_deprecated_body",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
      "line_number": 36,
      "end_line_number": 40,
      "source_code": "def test_q_fixedquery():\n    client = get_client()\n    response = client.post(\"/items/\", data={\"q\": \"fixedquery\"})\n    assert response.status_code == 200\n    assert response.json() == \"Hello fixedquery\"",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Form",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == 'Hello fixedquery'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_q_fixedquery` unit test is to verify that the FastAPI application correctly handles a POST request to the `/items/` endpoint with a specific query parameter (`q`) and returns the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a POST request is made to the `/items/` endpoint with the data `{\"q\": \"fixedquery\"}`, the server responds with a status code of 200 and a JSON response of `\"Hello fixedquery\"`.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes a FastAPI application client, created by the `get_client` fixture, which sets up a FastAPI app with defined endpoints. However, the provided code snippets do not show the `/items/` endpoint implementation, which is crucial for understanding the test. The test assumes that the `/items/` endpoint is designed to accept a POST request with a form data parameter `q` and respond with a greeting message incorporating the value of `q`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from `fastapi.testclient` to simulate HTTP requests to the FastAPI application. It employs assertions to verify both the HTTP status code and the content of the response, ensuring that the endpoint behaves as expected. The use of a fixture (`get_client`) to set up the test client is a common pattern in pytest to manage test dependencies and setup code."
    },
    {
      "repo_name": "fastapi",
      "name": "test_query_nonregexquery",
      "module": "test_regex_deprecated_body",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
      "line_number": 44,
      "end_line_number": 72,
      "source_code": "def test_query_nonregexquery():\n    client = get_client()\n    response = client.post(\"/items/\", data={\"q\": \"nonregexquery\"})\n    assert response.status_code == 422\n    assert response.json() == IsDict(\n        {\n            \"detail\": [\n                {\n                    \"type\": \"string_pattern_mismatch\",\n                    \"loc\": [\"body\", \"q\"],\n                    \"msg\": \"String should match pattern '^fixedquery$'\",\n                    \"input\": \"nonregexquery\",\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                }\n            ]\n        }\n    ) | IsDict(\n        # TODO: remove when deprecating Pydantic v1\n        {\n            \"detail\": [\n                {\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                    \"loc\": [\"body\", \"q\"],\n                    \"msg\": 'string does not match regex \"^fixedquery$\"',\n                    \"type\": \"value_error.str.regex\",\n                }\n            ]\n        }\n    )",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Form",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 422",
        "assert response.json() == IsDict({'detail': [{'type': 'string_pattern_mismatch', 'loc': ['body', 'q'], 'msg': \"String should match pattern '^fixedquery$'\", 'input': 'nonregexquery', 'ctx': {'pattern': '^fixedquery$'}}]}) | IsDict({'detail': [{'ctx': {'pattern': '^fixedquery$'}, 'loc': ['body', 'q'], 'msg': 'string does not match regex \"^fixedquery$\"', 'type': 'value_error.str.regex'}]})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to interact with the API and assert expected behaviors."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_query_nonregexquery` is to verify that the FastAPI application correctly enforces a regex pattern constraint on a query parameter. Specifically, it ensures that when a query parameter does not match the expected regex pattern, the application returns a 422 Unprocessable Entity status code along with a detailed error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the API endpoint `/items/` correctly validates the `q` parameter against the regex pattern `^fixedquery$`. If the input does not match this pattern, the test confirms that the response includes an appropriate error message indicating the mismatch.\n\n**Code Being Tested and How It Works**:  \nThe test uses a FastAPI `TestClient` to simulate a POST request to the `/items/` endpoint with a `data` payload containing `{\"q\": \"nonregexquery\"}`. The expected behavior is that the server will reject this input because it does not match the regex pattern `^fixedquery$`. The test checks that the response status code is 422 and that the response body contains a detailed error message about the pattern mismatch.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `IsDict` utility from the `dirty_equals` library to assert that the response JSON matches one of two possible error message formats. This approach is used to accommodate potential differences in error message formats between Pydantic v1 and v2, as indicated by the comment in the test. The use of `|` in the assertion allows for flexibility in matching either format, which is a useful technique when dealing with multiple versions of a dependency."
    },
    {
      "repo_name": "fastapi",
      "name": "test_openapi_schema",
      "module": "test_regex_deprecated_body",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
      "line_number": 76,
      "end_line_number": 180,
      "source_code": "def test_openapi_schema():\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    # insert_assert(response.json())\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"post\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/x-www-form-urlencoded\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"allOf\": [\n                                            {\n                                                \"$ref\": \"#/components/schemas/Body_read_items_items__post\"\n                                            }\n                                        ],\n                                        \"title\": \"Body\",\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove when deprecating Pydantic v1\n                                    {\n                                        \"$ref\": \"#/components/schemas/Body_read_items_items__post\"\n                                    }\n                                )\n                            }\n                        }\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            }\n        },\n        \"components\": {\n            \"schemas\": {\n                \"Body_read_items_items__post\": {\n                    \"properties\": {\n                        \"q\": IsDict(\n                            {\n                                \"anyOf\": [\n                                    {\"type\": \"string\", \"pattern\": \"^fixedquery$\"},\n                                    {\"type\": \"null\"},\n                                ],\n                                \"title\": \"Q\",\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"type\": \"string\", \"pattern\": \"^fixedquery$\", \"title\": \"Q\"}\n                        )\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"Body_read_items_items__post\",\n                },\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "fastapi.FastAPI",
        "fastapi.Form",
        "fastapi.testclient.TestClient",
        "typing_extensions.Annotated",
        "utils.needs_py310"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'post': {'summary': 'Read Items', 'operationId': 'read_items_items__post', 'requestBody': {'content': {'application/x-www-form-urlencoded': {'schema': IsDict({'allOf': [{'$ref': '#/components/schemas/Body_read_items_items__post'}], 'title': 'Body'}) | IsDict({'$ref': '#/components/schemas/Body_read_items_items__post'})}}}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'Body_read_items_items__post': {'properties': {'q': IsDict({'anyOf': [{'type': 'string', 'pattern': '^fixedquery$'}, {'type': 'null'}], 'title': 'Q'}) | IsDict({'type': 'string', 'pattern': '^fixedquery$', 'title': 'Q'})}, 'type': 'object', 'title': 'Body_read_items_items__post'}, 'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to interact with the API and assert expected behaviors."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_openapi_schema` is to verify that the FastAPI application correctly generates and serves the OpenAPI schema at the `/openapi.json` endpoint. This ensures that the API documentation is accurate and conforms to the expected OpenAPI specification.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that the OpenAPI schema returned by the FastAPI application matches a predefined structure. It verifies the HTTP status code of the response is 200, indicating a successful request, and that the JSON content of the response matches the expected OpenAPI schema, including paths, components, and schemas.\n\n**Code Being Tested and How It Works**:\nThe code under test is the FastAPI application created in the `get_client` fixture. This fixture sets up a FastAPI app with endpoints and a TestClient to simulate HTTP requests. The test sends a GET request to the `/openapi.json` endpoint using this client. The response is expected to contain the OpenAPI schema, which is a JSON document describing the API's endpoints, request/response formats, and other metadata.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Fixture Usage**: The test uses a pytest fixture (`get_client`) to set up the FastAPI application and client, promoting reusability and separation of setup logic from test logic.\n- **Assertion of JSON Structure**: The test uses assertions to compare the actual JSON response against an expected schema. The use of `IsDict` from `dirty_equals` allows for flexible matching, accommodating potential variations in the schema (e.g., supporting both Pydantic v1 and v2).\n- **HTTP Status Code Verification**: The test asserts that the response status code is 200, ensuring that the endpoint is accessible and functioning correctly."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 52,
      "end_line_number": 62,
      "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient` instance, which can be used in tests to make requests and assert responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_create_item` unit test is to verify that the FastAPI application correctly handles the creation of an item via a POST request to the `/items/` endpoint, ensuring consistent behavior regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the POST request to the `/items/` endpoint returns a status code of 200, indicating success, and that the response JSON matches the expected structure and content. It verifies that the item is created with the correct default values for optional fields (`description` and `sub`) when they are not provided.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `create_item` function within a FastAPI application, which is defined to handle POST requests to the `/items/` endpoint. The function takes an `Item` object as input and returns it. The `Item` class is a Pydantic model with fields `name`, `description`, and `sub`, where `description` and `sub` are optional. The test uses the `get_app_client` function to create two test clients: one with separate input and output schemas enabled and one without. It then sends POST requests with the same payload to both clients and compares the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of FastAPI's `TestClient` to simulate HTTP requests to the application, which is a common pattern for testing web applications. It uses assertions to ensure that both the status code and the response content are as expected. The test also demonstrates testing with different configurations (separate input/output schemas) to ensure consistent behavior across different application settings."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 52,
      "end_line_number": 62,
      "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_create_item` unit test is to verify that the FastAPI application correctly handles the creation of an item via a POST request to the `/items/` endpoint, ensuring consistent behavior regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the POST request to the `/items/` endpoint returns a status code of 200, indicating success, and that the response JSON matches the expected structure and content, which includes the item name and default values for optional fields (`description` and `sub`).\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `get_app_client` function, which sets up a FastAPI application with an endpoint `/items/` that accepts an `Item` model. The `Item` model includes a `name` field and optional `description` and `sub` fields. The test sends a POST request with a JSON payload containing the `name` \"Plumbus\" to this endpoint using two different configurations of the FastAPI app: one with separate input/output schemas and one without. The test checks that both configurations yield the same successful response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application. It employs assertions to compare both the status codes and the JSON responses from two different client configurations, ensuring that the application behaves consistently regardless of schema separation settings. This approach helps verify that the application's behavior is robust and not dependent on specific schema configurations."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item_with_sub",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 65,
      "end_line_number": 83,
      "source_code": "def test_create_item_with_sub():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = {\n        \"name\": \"Plumbus\",\n        \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\"},\n    }\n    response = client.post(\"/items/\", json=data)\n    response2 = client_no.post(\"/items/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\n            \"name\": \"Plumbus\",\n            \"description\": None,\n            \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\", \"tags\": []},\n        }\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': {'subname': 'SubPlumbus', 'sub_description': 'Sub WTF', 'tags': []}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing FastAPI applications, allowing developers to verify the behavior of their API endpoints in isolation."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_create_item_with_sub` is to verify that the FastAPI application correctly handles the creation of an item with a nested sub-item structure, ensuring consistent behavior regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an item with a nested sub-item is posted to the `/items/` endpoint, the response is consistent and correct, both in terms of HTTP status code and JSON response content, regardless of the `separate_input_output_schemas` configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `get_app_client` function, which sets up a FastAPI application with an endpoint `/items/` that accepts and returns an `Item` model. The `Item` model includes a nested `SubItem`. The test posts a JSON payload representing an item with a sub-item to this endpoint using two different configurations of the app: one with separate input/output schemas and one without. The test checks that both configurations return a 200 status code and the expected JSON structure.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application. It employs assertions to compare both the status codes and the JSON responses from two different configurations of the app, ensuring that the behavior is consistent. This approach effectively tests the impact of the `separate_input_output_schemas` setting on the API's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item_with_sub",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 65,
      "end_line_number": 83,
      "source_code": "def test_create_item_with_sub():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = {\n        \"name\": \"Plumbus\",\n        \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\"},\n    }\n    response = client.post(\"/items/\", json=data)\n    response2 = client_no.post(\"/items/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\n            \"name\": \"Plumbus\",\n            \"description\": None,\n            \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\", \"tags\": []},\n        }\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': {'subname': 'SubPlumbus', 'sub_description': 'Sub WTF', 'tags': []}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing FastAPI applications, allowing developers to verify the behavior of their API endpoints in isolation."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_create_item_with_sub` unit test is to verify that the FastAPI application correctly handles the creation of an item with a nested sub-item structure, ensuring consistent behavior regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an item with a nested sub-item is posted to the `/items/` endpoint, the response is consistent and correct in both scenarios: when separate input and output schemas are enabled and when they are not. It ensures that the response status code is 200 and that the JSON response matches the expected structure, including default values for optional fields.\n\n**Code Being Tested and How It Works**:  \nThe test targets the `create_item` endpoint of a FastAPI application, which is defined to accept an `Item` model. The `Item` model includes a nested `SubItem` model. The `get_app_client` function initializes the FastAPI app with a configurable option for separate input and output schemas. The test sends a POST request with JSON data representing an item with a sub-item to the `/items/` endpoint using two different clients: one with separate schemas and one without. The test then compares the responses from both clients to ensure they are identical and correct.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a comparative approach by using two clients to test the same endpoint under different configurations, ensuring that the application's behavior remains consistent. It uses assertions to verify both the HTTP status code and the JSON response content. This pattern is useful for testing feature toggles or configuration options that might affect the application's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item_list",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 86,
      "end_line_number": 110,
      "source_code": "def test_create_item_list():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = [\n        {\"name\": \"Plumbus\"},\n        {\n            \"name\": \"Portal Gun\",\n            \"description\": \"Device to travel through the multi-rick-verse\",\n        },\n    ]\n    response = client.post(\"/items-list/\", json=data)\n    response2 = client_no.post(\"/items-list/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": None,\n            },\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == [{'name': 'Plumbus', 'description': None, 'sub': None}, {'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': None}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to interact with the API. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_create_item_list` is to verify that the FastAPI application correctly handles the creation of a list of items via a POST request to the `/items-list/` endpoint. It ensures that the application processes the input data consistently, regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks two main aspects: \n1. The HTTP status code returned by the POST request to the `/items-list/` endpoint is 200, indicating a successful operation.\n2. The JSON response from the server matches the expected structure, which includes default values for optional fields (`description` and `sub`) when they are not provided in the input data.\n\n**Code Being Tested and How It Works**:\nThe code under test is the `create_item_list` function within a FastAPI application. This function is designed to accept a list of `Item` objects and return them. The `Item` class is a Pydantic model with fields `name`, `description`, and `sub`, where `description` and `sub` are optional. The test uses the `get_app_client` function to create two test clients: one with separate input/output schemas and one without. It then sends POST requests with the same data to both clients and compares the responses.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Use of TestClient**: The test utilizes FastAPI's `TestClient` to simulate HTTP requests to the application, allowing for testing of the API endpoints without needing a running server.\n- **Comparison of Responses**: The test compares responses from two configurations of the application (with and without separate input/output schemas) to ensure consistent behavior.\n- **Assertion of JSON Structure**: The test asserts that the JSON response matches the expected structure, including default values for optional fields, which is crucial for validating the API's data handling logic."
    },
    {
      "repo_name": "fastapi",
      "name": "test_create_item_list",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 86,
      "end_line_number": 110,
      "source_code": "def test_create_item_list():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = [\n        {\"name\": \"Plumbus\"},\n        {\n            \"name\": \"Portal Gun\",\n            \"description\": \"Device to travel through the multi-rick-verse\",\n        },\n    ]\n    response = client.post(\"/items-list/\", json=data)\n    response2 = client_no.post(\"/items-list/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": None,\n            },\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == [{'name': 'Plumbus', 'description': None, 'sub': None}, {'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': None}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**:\n   - A POST endpoint `/items/` is defined to create an item, returning the item as a response.\n   - A POST endpoint `/items-list/` is defined to create a list of items, returning the list.\n   - A GET endpoint `/items/` is defined to retrieve a predefined list of items.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to send requests and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_create_item_list` is to verify that the FastAPI application correctly handles the creation of a list of items via a POST request to the `/items-list/` endpoint. It ensures that the application processes the input data consistently, regardless of whether separate input and output schemas are used.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks two main aspects: \n1. The HTTP status code returned by the POST request to the `/items-list/` endpoint is 200, indicating a successful operation.\n2. The JSON response from the server matches the expected structure, which includes default values for optional fields (`description` and `sub`) when they are not provided in the input data.\n\n**Code Being Tested and How It Works**:\nThe test targets the `create_item_list` function within the FastAPI application, which is responsible for handling POST requests to the `/items-list/` endpoint. The function accepts a list of `Item` objects, defined using Pydantic models, and returns the same list. The `Item` model includes fields for `name`, `description`, and `sub`, with the latter two being optional. The test uses the `get_app_client` function to create two test clients: one with separate input/output schemas and one without, to ensure consistent behavior in both configurations.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Use of TestClient**: The test employs FastAPI's `TestClient` to simulate HTTP requests to the application, allowing for testing without a running server.\n- **Parameterization**: By using two clients with different schema configurations, the test effectively parameterizes the input conditions to verify consistent behavior across different application settings.\n- **Assertions**: The test uses assertions to compare both the status codes and the JSON responses, ensuring that the application behaves as expected in terms of both HTTP protocol and data processing."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 113,
      "end_line_number": 130,
      "source_code": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/items/\")\n    response2 = client_no.get(\"/items/\")\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": {\"subname\": \"subname\", \"sub_description\": None, \"tags\": []},\n            },\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run a server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The `TestClient` instance is returned for use in tests, allowing developers to easily test the API's functionality."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the FastAPI application correctly handles GET requests to the `/items/` endpoint and returns the expected list of items. It ensures that the endpoint behaves consistently regardless of whether separate input/output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main aspects:  \n1. The HTTP status code returned by the `/items/` endpoint is 200, indicating a successful request.\n2. The JSON response from the endpoint matches the expected list of items, which includes a \"Portal Gun\" and a \"Plumbus\", with their respective attributes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_app_client` function, which sets up a FastAPI application with an endpoint `/items/` that returns a predefined list of `Item` objects. The `read_items` function within this setup is responsible for returning this list. The test uses the `TestClient` to simulate HTTP requests to this endpoint, both with and without separate input/output schemas, to ensure consistent behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of TestClient**: The test utilizes FastAPI's `TestClient` to simulate HTTP requests, which is a common practice for testing web applications.\n- **Comparison of Responses**: The test compares responses from two different configurations of the application (with and without separate input/output schemas) to ensure they are identical, highlighting the importance of consistent API behavior.\n- **Assertion of Status Code and JSON Content**: The test asserts both the status code and the JSON content of the response, ensuring that the endpoint not only responds successfully but also returns the correct data structure."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 113,
      "end_line_number": 130,
      "source_code": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/items/\")\n    response2 = client_no.get(\"/items/\")\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": {\"subname\": \"subname\", \"sub_description\": None, \"tags\": []},\n            },\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == response2.status_code == 200, response.text",
        "assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and validate responses."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_read_items` unit test is to verify that the FastAPI application correctly handles GET requests to the `/items/` endpoint and returns the expected list of items, regardless of whether separate input/output schemas are used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/items/` endpoint returns a status code of 200 and a JSON response containing a predefined list of items. It ensures that the response is consistent whether the application is configured with separate input/output schemas or not.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `read_items` function within a FastAPI application, which is defined to return a list of `Item` objects. The `get_app_client` function creates a `TestClient` for the FastAPI app, allowing the test to simulate HTTP requests. The `read_items` function is expected to return a list containing two items: \"Portal Gun\" and \"Plumbus\", each with specific attributes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application. It performs assertions on both the status code and the JSON response to ensure correctness. The test also compares responses from two different configurations of the app (with and without separate input/output schemas) to ensure consistent behavior across configurations. This approach helps verify that the application's functionality is robust to different schema settings."
    },
    {
      "repo_name": "fastapi",
      "name": "test_openapi_schema",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 134,
      "end_line_number": 348,
      "source_code": "def test_openapi_schema():\n    client = get_app_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"items\": {\n                                            \"$ref\": \"#/components/schemas/Item-Output\"\n                                        },\n                                        \"type\": \"array\",\n                                        \"title\": \"Response Read Items Items  Get\",\n                                    }\n                                }\n                            },\n                        }\n                    },\n                },\n                \"post\": {\n                    \"summary\": \"Create Item\",\n                    \"operationId\": \"create_item_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item-Input\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"402\": {\n                            \"description\": \"Payment Required\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                },\n            },\n            \"/items-list/\": {\n                \"post\": {\n                    \"summary\": \"Create Item List\",\n                    \"operationId\": \"create_item_list_items_list__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Item-Input\"\n                                    },\n                                    \"type\": \"array\",\n                                    \"title\": \"Item\",\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"Item-Input\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Input\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"title\": \"Item\",\n                },\n                \"Item-Output\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Output\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\", \"description\", \"sub\"],\n                    \"title\": \"Item\",\n                },\n                \"SubItem-Input\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\"],\n                    \"title\": \"SubItem\",\n                },\n                \"SubItem-Output\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\", \"sub_description\", \"tags\"],\n                    \"title\": \"SubItem\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Output'}, 'type': 'array', 'title': 'Response Read Items Items  Get'}}}}}}, 'post': {'summary': 'Create Item', 'operationId': 'create_item_items__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Input'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '402': {'description': 'Payment Required', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/items-list/': {'post': {'summary': 'Create Item List', 'operationId': 'create_item_list_items_list__post', 'requestBody': {'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Input'}, 'type': 'array', 'title': 'Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'Item-Input': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Input'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name'], 'title': 'Item'}, 'Item-Output': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Output'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name', 'description', 'sub'], 'title': 'Item'}, 'SubItem-Input': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname'], 'title': 'SubItem'}, 'SubItem-Output': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname', 'sub_description', 'tags'], 'title': 'SubItem'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_openapi_schema` unit test is to verify that the OpenAPI schema generated by the FastAPI application is correct and matches the expected structure. This ensures that the API documentation is accurate and conforms to the OpenAPI specification.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that the OpenAPI schema returned by the FastAPI application at the `/openapi.json` endpoint has a status code of 200, indicating a successful response, and that the JSON content of the response matches the expected OpenAPI schema. This includes verifying the API version, endpoint paths, operations, and the associated request and response schemas.\n\n**Code Being Tested and How It Works**:\nThe code being tested is the FastAPI application created by the `get_app_client` function. This function initializes a FastAPI app with separate input and output schemas enabled and defines several endpoints (`/items/`, `/items-list/`) with different HTTP methods (GET, POST). The test uses the `TestClient` to simulate a client making a GET request to the `/openapi.json` endpoint, which is expected to return the OpenAPI schema of the application. The test then asserts that the response matches the expected schema structure, including paths, operations, and components.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs the use of the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It uses assertions to compare the actual response against the expected OpenAPI schema, ensuring that the API documentation is generated correctly. This test is a form of integration testing, as it verifies the behavior of the application as a whole, rather than focusing on individual units of code. The test also demonstrates the use of JSON schema validation to ensure the correctness of API documentation."
    },
    {
      "repo_name": "fastapi",
      "name": "test_openapi_schema_no_separate",
      "module": "test_openapi_separate_input_output_schemas",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
      "line_number": 352,
      "end_line_number": 522,
      "source_code": "def test_openapi_schema_no_separate():\n    client = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"items\": {\"$ref\": \"#/components/schemas/Item\"},\n                                        \"type\": \"array\",\n                                        \"title\": \"Response Read Items Items  Get\",\n                                    }\n                                }\n                            },\n                        }\n                    },\n                },\n                \"post\": {\n                    \"summary\": \"Create Item\",\n                    \"operationId\": \"create_item_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                                }\n                            },\n                        },\n                        \"402\": {\n                            \"description\": \"Payment Required\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                },\n            },\n            \"/items-list/\": {\n                \"post\": {\n                    \"summary\": \"Create Item List\",\n                    \"operationId\": \"create_item_list_items_list__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"items\": {\"$ref\": \"#/components/schemas/Item\"},\n                                    \"type\": \"array\",\n                                    \"title\": \"Item\",\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"Item\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"title\": \"Item\",\n                },\n                \"SubItem\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\"],\n                    \"title\": \"SubItem\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [],
      "imports": [
        "typing.List",
        "typing.Optional",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "pydantic.BaseModel",
        "utils.PYDANTIC_V2",
        "utils.needs_pydanticv2"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item'}, 'type': 'array', 'title': 'Response Read Items Items  Get'}}}}}}, 'post': {'summary': 'Create Item', 'operationId': 'create_item_items__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}}, '402': {'description': 'Payment Required', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/items-list/': {'post': {'summary': 'Create Item List', 'operationId': 'create_item_list_items_list__post', 'requestBody': {'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item'}, 'type': 'array', 'title': 'Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'Item': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name'], 'title': 'Item'}, 'SubItem': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname'], 'title': 'SubItem'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app_client",
          "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**:\n   - A POST endpoint `/items/` is defined to create an `Item` and return it.\n   - A POST endpoint `/items-list/` is defined to accept a list of `Item` objects and return them.\n   - A GET endpoint `/items/` is defined to return a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to interact with the API. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe test `test_openapi_schema_no_separate` is designed to verify that the OpenAPI schema generated by a FastAPI application is correct when the `separate_input_output_schemas` option is set to `False`. This ensures that the OpenAPI documentation reflects the expected structure and content of the API endpoints.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that the OpenAPI schema returned by the FastAPI application matches a predefined JSON structure. It verifies that the schema includes the correct paths, operations, and components, such as schemas for `Item`, `SubItem`, and `HTTPValidationError`, without separating input and output schemas.\n\n**Code Being Tested and How It Works**:\nThe code being tested is the `get_app_client` function, which creates a FastAPI application with specific endpoints and returns a `TestClient` for testing. The application includes endpoints for creating and reading items, and the test checks the OpenAPI schema generated by this application. The `separate_input_output_schemas` parameter is set to `False`, meaning the input and output schemas are not separated in the OpenAPI documentation.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application. It performs a GET request to the `/openapi.json` endpoint and asserts that the response status is 200 and the JSON content matches the expected OpenAPI schema. This approach ensures that the API documentation is correctly generated and adheres to the specified structure. The test also uses direct JSON comparison to validate the schema, which is a straightforward and effective way to ensure accuracy."
    },
    {
      "repo_name": "fastapi",
      "name": "test_ws",
      "module": "test_tutorial002",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_tutorial002.py",
      "line_number": 8,
      "end_line_number": 9,
      "source_code": "def test_ws():\n    test_websocket()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "docs_src.app_testing.tutorial002.test_read_main",
        "docs_src.app_testing.tutorial002.test_websocket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_websocket",
          "body": "def test_websocket():\n    with client.websocket_connect('/items/portal-gun') as websocket:\n        data = websocket.receive_json()\n        assert data == {'item_id': 'portal-gun', 'path': '/items/{item_id}'}",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `test_websocket` method is designed to test the WebSocket connection functionality of a FastAPI application. It verifies that when a WebSocket connection is established to a specific endpoint, the server sends back the expected JSON response.\n\n**How It Works**:  \n1. A `TestClient` instance is created to simulate requests to the FastAPI application.\n2. The method establishes a WebSocket connection to the `/ws` endpoint using `client.websocket_connect()`.\n3. It then waits to receive a JSON message from the server using `websocket.receive_json()`.\n4. Finally, it asserts that the received data matches the expected JSON object `{\"msg\": \"Hello WebSocket\"}`, ensuring that the WebSocket communication is functioning correctly."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_ws` is to verify the functionality of a WebSocket connection in a FastAPI application. It ensures that the WebSocket endpoint correctly handles connections and returns the expected data format when a client connects to a specific URL.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a WebSocket client connects to the `/items/portal-gun` endpoint, the server responds with a JSON object containing the correct `item_id` and `path`. This verifies that the WebSocket endpoint is correctly processing the URL path and returning the expected structured data.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `test_websocket` function, which uses a `TestClient` to establish a WebSocket connection to the `/items/portal-gun` endpoint. The WebSocket server, defined in the FastAPI application, is expected to accept the connection and send a JSON response. The test asserts that this response matches the expected dictionary `{'item_id': 'portal-gun', 'path': '/items/{item_id}'}`. This involves the server correctly parsing the URL and sending back the appropriate data.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate a WebSocket connection. This is a common pattern for testing WebSocket endpoints, allowing the test to interact with the server as a real client would. The use of `websocket_connect` and `receive_json` methods provides a straightforward way to test the WebSocket communication, ensuring that the server's response is correctly formatted and contains the expected data. The test is simple and direct, focusing on the core functionality of the WebSocket endpoint without additional complexities."
    },
    {
      "repo_name": "fastapi",
      "name": "test_app",
      "module": "test_main_b_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py39.py",
      "line_number": 5,
      "end_line_number": 13,
      "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py39 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [],
      "imports": [
        "utils.needs_py39",
        "docs_src.app_testing.app_b_an_py39.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_create_item",
          "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_app` function is to execute a series of unit tests that verify the behavior of a FastAPI application, specifically focusing on the creation and retrieval of items through API endpoints.\n\n**Specific Functionality or Behavior Verified**:\nThe test verifies several functionalities: creating an item, handling attempts to create an existing item, managing item creation with invalid tokens, and reading both existing and non-existent items. It ensures that the API responds correctly to these operations, including proper status codes and response content.\n\n**Code Being Tested and How It Works**:\nThe code under test involves API endpoints for item management. For instance, `test_create_item` checks the POST request to the `/items/` endpoint, ensuring that an item named \"Plumbus\" is created successfully with a 200 status code and the expected JSON response. The test uses two clients, one with separate input/output schemas and one without, to ensure consistent behavior across different configurations.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs a modular approach by importing and executing individual test functions from `test_main`. This allows for reusability and organization of test cases. It uses assertions to compare status codes and JSON responses, ensuring that the API behaves as expected. The use of two clients to test different schema configurations is a notable technique to verify consistent API behavior under varying conditions."
    },
    {
      "repo_name": "fastapi",
      "name": "test_app",
      "module": "test_main_b_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an.py",
      "line_number": 4,
      "end_line_number": 10,
      "source_code": "def test_app():\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "docs_src.app_testing.app_b_an.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_create_item",
          "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_app` function is to execute a series of unit tests that verify the behavior of an API built with FastAPI. These tests ensure that various endpoints and functionalities of the application work as expected, particularly focusing on item creation and retrieval.\n\n**Specific Functionality or Behavior Verified**:\nThe test suite checks several key functionalities:\n1. Creating an item with valid data.\n2. Attempting to create an item that already exists.\n3. Handling item creation with an invalid token.\n4. Reading an item that does not exist.\n5. Successfully reading an existing item.\n6. Attempting to read an item with an invalid token.\n\n**Code Being Tested and How It Works**:\nThe `test_create_item` function, for example, tests the `/items/` endpoint by sending a POST request with a JSON payload to create an item named \"Plumbus\". It uses two clients: one with separate input/output schemas and one without. The test asserts that both clients receive a 200 status code and that the response JSON matches the expected structure. This ensures that the endpoint correctly handles item creation and that the schema configuration does not affect the outcome.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Client Abstraction**: The use of `get_app_client()` abstracts the client creation, allowing for easy testing with different configurations (e.g., separate input/output schemas).\n- **Assertion of Status Codes and JSON Responses**: The tests consistently assert both the HTTP status code and the JSON response content, ensuring that the API not only responds successfully but also returns the correct data structure.\n- **Parameterized Testing**: Although not explicitly shown, the structure suggests a pattern where similar tests are grouped, potentially allowing for parameterization to reduce redundancy and improve maintainability."
    },
    {
      "repo_name": "fastapi",
      "name": "test_app",
      "module": "test_main_b",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b.py",
      "line_number": 4,
      "end_line_number": 10,
      "source_code": "def test_app():\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "docs_src.app_testing.app_b.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_create_item",
          "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_app` function is to execute a series of unit tests that verify the behavior of a FastAPI application, specifically focusing on the creation and retrieval of items through API endpoints.\n\n**Specific Functionality or Behavior Verified**:\nThe test suite checks several functionalities: creating an item, handling attempts to create an existing item, managing item creation with invalid tokens, and reading both existing and non-existent items. It ensures that the API responds correctly to these operations, including status codes and response content.\n\n**Code Being Tested and How It Works**:\nThe `test_create_item` function, one of the methods under test, uses a test client to send POST requests to the `/items/` endpoint with JSON payloads. It verifies that the response status code is 200 and that the returned JSON matches the expected structure. The test uses two clients: one with separate input/output schemas and one without, ensuring consistent behavior across different configurations.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs the use of a test client to simulate HTTP requests, a common pattern in testing web applications. It uses assertions to compare response status codes and JSON content, ensuring that the API behaves as expected. The test also demonstrates testing with different configurations (separate input/output schemas) to ensure robustness across various setups."
    },
    {
      "repo_name": "fastapi",
      "name": "test_main",
      "module": "test_tutorial003",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_tutorial003.py",
      "line_number": 4,
      "end_line_number": 7,
      "source_code": "def test_main():\n    with pytest.warns(DeprecationWarning):\n        from docs_src.app_testing.tutorial003 import test_read_items\n    test_read_items()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "docs_src.app_testing.tutorial003.test_read_items"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_read_items",
          "body": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get('/items/')\n    response2 = client_no.get('/items/')\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_read_items` method is designed to verify that the API endpoint `/items/` returns the expected HTTP status code and JSON response structure when accessed by two different clients. It ensures that both clients, regardless of their configuration, receive consistent results.\n\n**How It Works**:\n1. Two clients are created using the `get_app_client()` function: `client` and `client_no`. The second client is configured with `separate_input_output_schemas=False`, which may affect how data is processed.\n2. Both clients send a GET request to the `/items/` endpoint.\n3. The method asserts that both responses have a status code of 200, indicating a successful request. If the status codes differ, the response text is provided for debugging.\n4. It then checks that the JSON responses from both clients are identical and match the expected list of items, which includes details about \"Portal Gun\" and \"Plumbus\". This ensures that the API behaves consistently across different client configurations."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_main` function is to ensure that the `test_read_items` function from the `docs_src.app_testing.tutorial003` module executes without errors and to verify that it raises a `DeprecationWarning` when imported. This test is part of the FastAPI repository's unit tests, focusing on validating the behavior of the application when handling item retrieval requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: first, that the import of `test_read_items` triggers a `DeprecationWarning`, indicating that the code or feature being tested is deprecated. Second, it verifies that the `test_read_items` function correctly tests the API endpoint `/items/` for consistent responses when using different client configurations.\n\n**Code Being Tested and How It Works**:  \nThe `test_read_items` function is designed to test the `/items/` endpoint of a FastAPI application. It uses two clients: one with separate input/output schemas and one without. The function sends GET requests to the `/items/` endpoint using both clients and asserts that both responses have a status code of 200 and that their JSON payloads match the expected list of items. This ensures that the endpoint behaves consistently regardless of the client configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `pytest.warns` context manager to assert that a `DeprecationWarning` is raised during the import of `test_read_items`, which is a common pattern for testing deprecated features. Additionally, the test employs assertions to compare both the status codes and the JSON responses of the API calls, ensuring that the endpoint's output is as expected. This approach helps verify both the correctness and consistency of the API's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_app",
      "module": "test_main_b_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py310.py",
      "line_number": 5,
      "end_line_number": 13,
      "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py310 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "utils.needs_py310",
        "docs_src.app_testing.app_b_an_py310.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_create_item",
          "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_app` function is to execute a series of unit tests from the `test_main` module to verify the correct behavior of various API endpoints in a FastAPI application. This test acts as a wrapper to ensure that all individual tests are executed together, providing a comprehensive check of the application's functionality.\n\n**Specific Functionality or Behavior Verified**:\nThe test verifies several key functionalities of the API, including the creation of items, handling of existing items, and access control through token validation. It checks that the API correctly handles both valid and invalid requests, ensuring that the endpoints return the expected status codes and response data.\n\n**Code Being Tested and How It Works**:\nThe code being tested involves API endpoints for creating and reading items. For instance, `test_create_item` tests the `/items/` endpoint by sending a POST request with a JSON payload to create an item named \"Plumbus\". It uses two clients: one with separate input/output schemas and one without, to ensure consistent behavior across different configurations. The test asserts that both clients receive a 200 status code and the expected JSON response, confirming that the item creation process works as intended.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs a pattern of using multiple clients to verify consistent behavior across different API configurations. This is particularly useful for testing schema-related features. Additionally, the test uses assertions to compare both the status codes and the JSON responses, ensuring that the API not only responds successfully but also returns the correct data structure. This approach helps catch discrepancies in API behavior that might arise from different schema settings."
    },
    {
      "repo_name": "fastapi",
      "name": "test_app",
      "module": "test_main_b_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_py310.py",
      "line_number": 5,
      "end_line_number": 13,
      "source_code": "def test_app():\n    from docs_src.app_testing.app_b_py310 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [],
      "imports": [
        "utils.needs_py310",
        "docs_src.app_testing.app_b_py310.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_create_item",
          "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_app` function is to execute a suite of unit tests that verify the behavior of a FastAPI application, specifically focusing on item creation and retrieval functionalities. It ensures that the application correctly handles various scenarios related to item management.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies several key functionalities: creating an item, handling attempts to create an existing item, managing item creation with invalid tokens, and reading both existing and non-existent items. It checks for correct HTTP status codes and response content to ensure the API behaves as expected under different conditions.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes functions like `test_create_item` from the `test_main` module. This function uses a test client to send POST requests to the `/items/` endpoint with JSON payloads. It checks that the response status code is 200 and that the returned JSON matches the expected structure. The test uses two clients: one with separate input/output schemas and one without, to ensure consistent behavior across different configurations.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a pattern of using a test client to simulate HTTP requests to the FastAPI application, a common technique in API testing. It uses assertions to compare response status codes and JSON content, ensuring the API's output matches expectations. The use of multiple clients to test different schema configurations is a notable technique to verify consistent behavior across different application setups."
    },
    {
      "repo_name": "fastapi",
      "name": "test_disable_openapi",
      "module": "test_tutorial001",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
      "line_number": 18,
      "end_line_number": 27,
      "source_code": "def test_disable_openapi(monkeypatch):\n    monkeypatch.setenv(\"OPENAPI_URL\", \"\")\n    # Load the client after setting the env var\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 404, response.text\n    response = client.get(\"/docs\")\n    assert response.status_code == 404, response.text\n    response = client.get(\"/redoc\")\n    assert response.status_code == 404, response.text",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib",
        "fastapi.testclient.TestClient",
        "utils.needs_pydanticv2",
        "docs_src.conditional_openapi.tutorial001"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404, response.text",
        "assert response.status_code == 404, response.text",
        "assert response.status_code == 404, response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_disable_openapi` unit test is to verify that the OpenAPI documentation endpoints are correctly disabled when the `OPENAPI_URL` environment variable is set to an empty string. This ensures that the application does not expose its API documentation when it is not desired.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the OpenAPI JSON schema (`/openapi.json`), Swagger UI (`/docs`), and ReDoc (`/redoc`) endpoints return a 404 status code, indicating that these resources are not available when the `OPENAPI_URL` is set to an empty string.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves a FastAPI application setup where the OpenAPI documentation can be conditionally disabled based on an environment variable. The `get_client` function creates a FastAPI app with a couple of endpoints and returns a `TestClient` for testing. The test uses the `monkeypatch` fixture to set the `OPENAPI_URL` environment variable to an empty string before initializing the client. This simulates the condition where OpenAPI documentation should be disabled.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `monkeypatch` fixture from pytest to temporarily modify the environment variable, ensuring that the test environment is isolated and does not affect other tests. The use of `TestClient` from FastAPI allows for easy HTTP request simulation to the application endpoints. The test asserts the HTTP status code to verify the expected behavior, which is a common pattern in testing RESTful APIs."
    },
    {
      "repo_name": "fastapi",
      "name": "test_root",
      "module": "test_tutorial001",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
      "line_number": 31,
      "end_line_number": 35,
      "source_code": "def test_root():\n    client = get_client()\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello World\"}",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [],
      "imports": [
        "importlib",
        "fastapi.testclient.TestClient",
        "utils.needs_pydanticv2",
        "docs_src.conditional_openapi.tutorial001"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'message': 'Hello World'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to simulate requests and validate responses. \n\nThis setup allows developers to easily test the API's behavior and ensure that it returns the expected data structures."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_root` function is to verify that the FastAPI application correctly handles a GET request to the root endpoint (\"/\") and returns the expected HTTP status code and JSON response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the root endpoint (\"/\") of the FastAPI application returns a status code of 200, indicating a successful request, and that the JSON response body matches the expected output: `{\"message\": \"Hello World\"}`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the FastAPI application defined in the `get_client` fixture. This fixture sets up a FastAPI app with a root endpoint (\"/\") that returns a `Rectangle` object with predefined dimensions. The `Rectangle` class uses Pydantic for data validation and includes a computed property `area`. However, the test expects a simple JSON response with a message, which suggests that the actual application code might differ from the test setup or that the test is outdated or misaligned with the current application logic.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. This is a common pattern for testing web applications, allowing the test to interact with the app as if it were a real client. The use of assertions to check both the status code and the response content ensures that the endpoint behaves as expected. The test does not use any advanced testing techniques like parameterization or mocking, focusing instead on a straightforward validation of the endpoint's response."
    },
    {
      "repo_name": "fastapi",
      "name": "test_default_openapi",
      "module": "test_tutorial001",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
      "line_number": 39,
      "end_line_number": 63,
      "source_code": "def test_default_openapi():\n    client = get_client()\n    response = client.get(\"/docs\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/redoc\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/openapi.json\")\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/\": {\n                \"get\": {\n                    \"summary\": \"Root\",\n                    \"operationId\": \"root__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        }\n                    },\n                }\n            }\n        },\n    }",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [],
      "imports": [
        "importlib",
        "fastapi.testclient.TestClient",
        "utils.needs_pydanticv2",
        "docs_src.conditional_openapi.tutorial001"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/': {'get': {'summary': 'Root', 'operationId': 'root__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}}}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_client",
          "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is particularly useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_default_openapi` unit test is to verify that the FastAPI application correctly generates and serves the default OpenAPI documentation. This includes ensuring that the OpenAPI schema is accessible and correctly formatted at the specified endpoints.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three main aspects:  \n1. The `/docs` endpoint returns a successful HTTP 200 status code, indicating that the Swagger UI documentation is accessible.\n2. The `/redoc` endpoint also returns a successful HTTP 200 status code, confirming the availability of the ReDoc documentation.\n3. The `/openapi.json` endpoint returns a JSON response that matches the expected OpenAPI schema, verifying the correctness of the OpenAPI specification generated by the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the FastAPI application created in the `get_client` fixture. This application defines two endpoints: `/` and `/responses`, both returning a `Rectangle` model. The OpenAPI schema is automatically generated by FastAPI based on these endpoints and their associated models. The test uses the `TestClient` to simulate HTTP requests to the application and validate the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The `get_client` function is defined as a pytest fixture, providing a reusable `TestClient` instance for making requests to the FastAPI application.\n- **Assertion of HTTP Status Codes**: The test asserts that the status codes for the `/docs` and `/redoc` endpoints are 200, ensuring these documentation interfaces are available.\n- **JSON Response Validation**: The test asserts that the JSON response from the `/openapi.json` endpoint matches the expected OpenAPI schema, ensuring the schema's accuracy and completeness.\n- **Use of FastAPI's TestClient**: This allows for easy testing of FastAPI applications by simulating HTTP requests and inspecting responses."
    },
    {
      "repo_name": "fastapi",
      "name": "test_override_settings",
      "module": "test_app02",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_settings/test_app02.py",
      "line_number": 17,
      "end_line_number": 20,
      "source_code": "def test_override_settings():\n    from docs_src.settings.app02 import test_main\n\n    test_main.test_app()",
      "docstring": null,
      "decorators": [
        "needs_pydanticv2"
      ],
      "arguments": [],
      "imports": [
        "pytest.MonkeyPatch",
        "utils.needs_pydanticv2",
        "docs_src.settings.app02.main",
        "docs_src.settings.app02.test_main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_main.test_app",
          "body": "def test_app():\n    with client:\n        response = client.get('/')\n    assert response.json() == {'msg': 'Hello World'}\n    assert response.headers['content-type'] == json_type",
          "method_explanation": "**Main Purpose of the Method**:\nThe `test_app` method is designed to verify the functionality of the root endpoint (`/`) of a FastAPI application. It checks that the response is as expected, specifically that it returns a JSON object with a message and the correct content type.\n\n**How It Works**:\n1. The method uses a context manager (`with client:`) to ensure that the test client is properly set up for making requests to the FastAPI application.\n2. It sends a GET request to the root endpoint (`/`) using `client.get('/')`.\n3. The response is then validated with two assertions:\n   - It checks that the JSON response matches the expected dictionary `{'msg': 'Hello World'}`.\n   - It verifies that the `content-type` header of the response matches a predefined variable `json_type`, ensuring the response is in the correct format."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_override_settings` unit test is to verify that the application settings can be overridden correctly and that the application behaves as expected when these settings are applied. This ensures that the application can be configured dynamically, which is crucial for environments where settings might change based on context or deployment.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the FastAPI application responds with the expected JSON payload and content type when accessed at the root endpoint (`'/'`). It verifies that the application returns a JSON response with the message `{'msg': 'Hello World'}` and that the content type of the response is as expected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `test_app` function from the `test_main` module. This function uses a test client to send a GET request to the root endpoint of the FastAPI application. It then asserts that the response JSON matches the expected output and that the content type header is correct. The test ensures that the application is correctly set up to return the expected response when accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses a context manager (`with client:`) to manage the lifecycle of the test client, ensuring that resources are properly handled. Assertions are used to verify both the content of the response and the headers, which is a common pattern in testing to ensure that both data and metadata are correct. The test is part of a suite that likely uses `pytest` for running tests, as indicated by the import of `pytest.MonkeyPatch`, although it is not directly used in this specific test."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
      "line_number": 62,
      "end_line_number": 73,
      "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_an_py39.app",
        "docs_src.security.tutorial005_an_py39.fake_users_db",
        "docs_src.security.tutorial005_an_py39.verify_password",
        "docs_src.security.tutorial005_an_py39.get_password_hash",
        "docs_src.security.tutorial005_an_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user can obtain an access token with the correct scope and use it to access the `/users/me` endpoint. It verifies that the endpoint returns a successful HTTP 200 status code and the expected user information in the JSON response.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_access_token` function, which simulates a login by sending a POST request to the `/token` endpoint with user credentials and an optional scope. The function retrieves and returns the access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, checking if the response is successful and contains the expected user data. The underlying code uses JWTs for token creation and validation, ensuring that the token includes the necessary scopes and user information.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to verify both the HTTP status code and the JSON response content, ensuring that the endpoint behaves as expected when accessed with a valid token. This approach effectively tests the integration of authentication and authorization mechanisms within the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_an_py39.app",
        "docs_src.security.tutorial005_an_py39.fake_users_db",
        "docs_src.security.tutorial005_an_py39.verify_password",
        "docs_src.security.tutorial005_an_py39.get_password_hash",
        "docs_src.security.tutorial005_an_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_token_no_scope` is to verify that the API correctly handles access tokens that do not include the required scope for accessing a specific endpoint. It ensures that the system enforces scope-based access control by returning an appropriate error response when a token without the necessary scope is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a client attempts to access the `/users/me` endpoint with a token that lacks the required \"me\" scope, the server responds with a 401 Unauthorized status code. Additionally, it verifies that the response includes a JSON message indicating \"Not enough permissions\" and a `WWW-Authenticate` header specifying the required scope.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_access_token` function, which generates an access token by posting credentials to the `/token` endpoint. The token is then used to make a GET request to the `/users/me` endpoint. The `get_current_user` function in the application code is responsible for decoding the token, checking the user's credentials, and verifying that the token includes the necessary scopes. If the required scope is missing, it raises an HTTP 401 error with a message about insufficient permissions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to check the response status code, JSON content, and headers, ensuring that the application behaves as expected when handling tokens without the necessary scopes. This approach effectively tests the security and access control mechanisms of the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
      "line_number": 167,
      "end_line_number": 175,
      "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_an_py39.app",
        "docs_src.security.tutorial005_an_py39.fake_users_db",
        "docs_src.security.tutorial005_an_py39.verify_password",
        "docs_src.security.tutorial005_an_py39.get_password_hash",
        "docs_src.security.tutorial005_an_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_inactive_user` is to verify that the system correctly handles authentication attempts by users who are marked as inactive. It ensures that such users cannot access protected resources even if they provide valid credentials.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access a protected endpoint using a valid access token, the system responds with a 400 status code and a JSON message indicating that the user is inactive.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token for a user named \"alice\" using the `get_access_token` function. This function sends a POST request to the `/token` endpoint with the user's credentials and retrieves the access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, which is protected and requires authentication. The `get_current_active_user` function, part of the application code, checks if the user is active. If the user is marked as inactive, it raises an HTTPException with a 400 status code and a \"Inactive user\" detail.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to verify both the HTTP status code and the response content, ensuring that the application behaves as expected when an inactive user attempts to access a protected resource. This pattern of testing both the status code and the response body is a common practice in API testing to ensure comprehensive validation of the application's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
      "line_number": 179,
      "end_line_number": 185,
      "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_an_py39.app",
        "docs_src.security.tutorial005_an_py39.fake_users_db",
        "docs_src.security.tutorial005_an_py39.verify_password",
        "docs_src.security.tutorial005_an_py39.get_password_hash",
        "docs_src.security.tutorial005_an_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint returns a successful HTTP status code (200) and the expected JSON response, which includes a list of items with specific attributes (`item_id` and `owner`). It ensures that the authentication mechanism and the scope-based access control are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls the `get_access_token` function to obtain a valid access token with the scope \"me items\". This token is then used to authenticate a GET request to the `/users/me/items/` endpoint. The `get_access_token` function works by sending a POST request to the `/token` endpoint with user credentials and scope, receiving a JWT token in response. The test checks that the response from the items endpoint is a 200 status code and matches the expected JSON structure.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses token-based authentication to test access control, ensuring that the endpoint is protected and only accessible with the correct permissions. The test includes assertions to validate both the HTTP response status and the content of the response, which are standard practices in unit testing to ensure the correctness of the application behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005_an_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
      "line_number": 189,
      "end_line_number": 195,
      "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_an_py39.app",
        "docs_src.security.tutorial005_an_py39.fake_users_db",
        "docs_src.security.tutorial005_an_py39.verify_password",
        "docs_src.security.tutorial005_an_py39.get_password_hash",
        "docs_src.security.tutorial005_an_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. Upon receiving the response, it parses the JSON content to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_read_system_status` is to verify that the `/status/` endpoint of the FastAPI application is functioning correctly and returns the expected status response when accessed with a valid authorization token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/status/` endpoint returns a 200 HTTP status code and a JSON response containing `{\"status\": \"ok\"}` when accessed with a valid bearer token. This ensures that the endpoint is accessible and returns the correct status information.\n\n**Code Being Tested and How It Works**:  \nThe test is indirectly testing the FastAPI application's authentication and status-checking mechanisms. It uses the `get_access_token` function to obtain a valid JWT access token by posting credentials to the `/token` endpoint. This token is then used to authenticate a GET request to the `/status/` endpoint. The `get_access_token` function constructs a POST request with user credentials, retrieves the token from the response, and returns it for use in subsequent requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It uses assertions to verify both the HTTP status code and the JSON response content, ensuring that the endpoint behaves as expected. The use of a helper function (`get_access_token`) to handle authentication setup is a common pattern to reduce redundancy and improve test clarity."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
      "line_number": 62,
      "end_line_number": 73,
      "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_py39.app",
        "docs_src.security.tutorial005_py39.fake_users_db",
        "docs_src.security.tutorial005_py39.verify_password",
        "docs_src.security.tutorial005_py39.get_password_hash",
        "docs_src.security.tutorial005_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user with the correct credentials can obtain an access token and use it to access the `/users/me` endpoint. It verifies that the response from this endpoint is successful (HTTP status code 200) and that the returned JSON data matches the expected user information.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_access_token` function, which simulates a login by sending a POST request to the `/token` endpoint with user credentials. This function returns an access token if the credentials are valid. The test then uses this token to make a GET request to the `/users/me` endpoint, which is protected and requires a valid token for access. The endpoint is expected to return user details, which are checked against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests, which is a common pattern for testing web applications. It employs assertions to verify both the HTTP status code and the JSON response content, ensuring that the authentication and authorization processes work as intended. The test also demonstrates the use of token-based authentication by including the token in the request headers."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_py39.app",
        "docs_src.security.tutorial005_py39.fake_users_db",
        "docs_src.security.tutorial005_py39.verify_password",
        "docs_src.security.tutorial005_py39.get_password_hash",
        "docs_src.security.tutorial005_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in further API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_no_scope` unit test is to verify that the FastAPI application correctly handles access token requests that lack the necessary scope permissions. It ensures that the application returns an appropriate error response when a user attempts to access a protected endpoint without the required scope.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an access token is used without the required \"me\" scope, the application responds with a 401 Unauthorized status code. It also verifies that the response includes a JSON message indicating \"Not enough permissions\" and that the `WWW-Authenticate` header specifies the missing scope.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `/users/me` endpoint, which is protected by a security mechanism requiring a specific scope. The `get_access_token` function is used to obtain an access token without any scope. The `get_current_user` function in the application code checks the token's scopes against the required scopes for the endpoint. If the required scope is missing, it raises an HTTP 401 error with a message about insufficient permissions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application. It employs assertions to verify the HTTP status code, response content, and headers. This pattern ensures that the test is both comprehensive and specific, checking multiple aspects of the response to confirm that the application behaves as expected when scope permissions are not met."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
      "line_number": 167,
      "end_line_number": 175,
      "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_py39.app",
        "docs_src.security.tutorial005_py39.fake_users_db",
        "docs_src.security.tutorial005_py39.verify_password",
        "docs_src.security.tutorial005_py39.get_password_hash",
        "docs_src.security.tutorial005_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_inactive_user` is to verify that the system correctly handles authentication attempts by users who are marked as inactive. It ensures that such users cannot access protected resources even if they have valid credentials.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access a protected endpoint using a valid access token, the system responds with a 400 status code and a JSON message indicating that the user is inactive.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token for a user named \"alice\" using the `get_access_token` function. This function sends a POST request to the `/token` endpoint with the user's credentials and retrieves the access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, which is protected and requires authentication. The `get_current_active_user` function, part of the application code, checks if the user is active. If the user is inactive, it raises an HTTPException with a 400 status code and a \"Inactive user\" detail, which the test verifies.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to check both the HTTP status code and the response content, ensuring that the application behaves as expected when an inactive user attempts to access a protected resource. This pattern of testing both the status code and the response body is a common practice in API testing to ensure comprehensive validation of the application's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
      "line_number": 179,
      "end_line_number": 185,
      "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_py39.app",
        "docs_src.security.tutorial005_py39.fake_users_db",
        "docs_src.security.tutorial005_py39.verify_password",
        "docs_src.security.tutorial005_py39.get_password_hash",
        "docs_src.security.tutorial005_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. This token can then be used in authorization headers for accessing protected routes in the application."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the API endpoint responds with a status code of 200 (indicating success) and returns the expected JSON payload, which is a list containing a dictionary with `item_id` as \"Foo\" and `owner` as \"johndoe\".\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls `get_access_token` to obtain a valid access token with the scope \"me items\". This token is then used to authenticate a GET request to the `/users/me/items/` endpoint. The `get_access_token` function works by sending a POST request to the `/token` endpoint with the user's credentials and scope, and it retrieves the access token from the response. The endpoint under test is expected to decode the token, verify the user's identity and permissions, and return the user's items.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses assertions to verify both the HTTP status code and the response content, ensuring that the endpoint behaves as expected. The test indirectly verifies the token creation and validation process by relying on the `get_access_token` function to provide a valid token for the request."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005_py39",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
      "line_number": 189,
      "end_line_number": 195,
      "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [
        "needs_py39"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py39",
        "docs_src.security.tutorial005_py39.app",
        "docs_src.security.tutorial005_py39.fake_users_db",
        "docs_src.security.tutorial005_py39.verify_password",
        "docs_src.security.tutorial005_py39.get_password_hash",
        "docs_src.security.tutorial005_py39.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_read_system_status` unit test is to verify that the `/status/` endpoint of a FastAPI application is functioning correctly and returns the expected status code and response content when accessed with a valid authorization token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/status/` endpoint returns a 200 HTTP status code and a JSON response containing `{\"status\": \"ok\"}` when accessed with a valid Bearer token. This ensures that the endpoint is accessible and returns the correct status information when the user is authenticated.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls the `get_access_token` function to obtain a valid access token by sending a POST request to the `/token` endpoint with default credentials. The token is then used to authenticate a GET request to the `/status/` endpoint. The `get_access_token` function works by sending user credentials to the `/token` endpoint, receiving a JSON response, and extracting the `access_token` from it.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of the `TestClient` from FastAPI's testing utilities, which allows for simulating HTTP requests in a test environment. It also uses assertions to verify both the HTTP status code and the JSON response content, ensuring that the endpoint behaves as expected. The test demonstrates a common pattern of obtaining an access token for authentication before making requests to protected endpoints, which is typical in testing secure API endpoints."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
      "line_number": 54,
      "end_line_number": 65,
      "source_code": "def test_token():\n    access_token = get_access_token(scope=\"me\")\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005_an.app",
        "docs_src.security.tutorial005_an.create_access_token",
        "docs_src.security.tutorial005_an.fake_users_db",
        "docs_src.security.tutorial005_an.get_password_hash",
        "docs_src.security.tutorial005_an.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the credentials are valid, the returned token can be used for authorization in subsequent API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user with the correct credentials can obtain an access token and use it to access the `/users/me` endpoint. It verifies that the response status code is 200 (indicating success) and that the returned JSON data matches the expected user information.\n\n**Code Being Tested and How It Works**:  \nThe test is primarily testing the `get_access_token` function and the `/users/me` endpoint. The `get_access_token` function sends a POST request to the `/token` endpoint with user credentials and retrieves an access token from the response. This token is then used in a GET request to the `/users/me` endpoint, which is protected and requires a valid token. The endpoint uses the `get_current_user` and `get_current_active_user` functions to validate the token and retrieve user information. If the token is valid and the user is active, the endpoint returns the user's details.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application, which is a common pattern for testing web applications. It also employs assertions to check both the HTTP status code and the content of the response, ensuring that the endpoint behaves as expected when accessed with a valid token. The use of a bearer token in the `Authorization` header is a standard practice for testing token-based authentication systems."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
      "line_number": 121,
      "end_line_number": 128,
      "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005_an.app",
        "docs_src.security.tutorial005_an.create_access_token",
        "docs_src.security.tutorial005_an.fake_users_db",
        "docs_src.security.tutorial005_an.get_password_hash",
        "docs_src.security.tutorial005_an.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. Upon receiving a response, it parses the JSON content to extract the `access_token`, which it returns. If the request is successful, this token can be used in the `Authorization` header for accessing protected routes."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_no_scope` unit test is to verify that the FastAPI application correctly handles access token requests that lack the necessary scope for accessing a protected endpoint. Specifically, it ensures that the application returns an appropriate error response when a user attempts to access the `/users/me` endpoint without the required \"me\" scope in their access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an access token without the required scope is used to access a protected endpoint, the server responds with a 401 Unauthorized status code. It also verifies that the response includes a JSON body with a \"detail\" message indicating \"Not enough permissions\" and that the `WWW-Authenticate` header specifies the required scope.\n\n**Code Being Tested and How It Works**:  \nThe test exercises the `get_current_user` function, which is responsible for validating the access token and checking the required scopes. The `get_access_token` function is used to obtain an access token without any scopes. When the token is used to access the `/users/me` endpoint, the `get_current_user` function checks the token's scopes against the required scopes for the endpoint. Since the token lacks the \"me\" scope, the function raises an HTTP 401 Unauthorized exception with the appropriate error message and headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application, allowing for end-to-end testing of the authentication and authorization logic. Assertions are used to verify the HTTP status code, response body, and headers, ensuring that the application behaves as expected when access is denied due to insufficient permissions. This approach effectively tests the integration of security mechanisms within the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
      "line_number": 143,
      "end_line_number": 151,
      "source_code": "def test_token_inactive_user():\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\"\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005_an.app",
        "docs_src.security.tutorial005_an.create_access_token",
        "docs_src.security.tutorial005_an.fake_users_db",
        "docs_src.security.tutorial005_an.get_password_hash",
        "docs_src.security.tutorial005_an.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_token_inactive_user` is designed to verify that the FastAPI application correctly handles authentication attempts by users who are marked as inactive. It ensures that the system responds appropriately when an inactive user tries to access protected resources.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access their own user information using a valid access token, the API returns a 400 status code with a JSON response indicating that the user is inactive. This behavior is crucial for maintaining security and ensuring that only active users can access certain endpoints.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `get_access_token` function to simulate obtaining an access token for a user named \"alice\" with the password \"secretalice\" and a scope of \"me\". The token is then used to make a GET request to the `/users/me` endpoint. The `get_current_active_user` function in the application code is responsible for checking if the user is active. If the user is marked as inactive (i.e., `current_user.disabled` is `True`), it raises an HTTP 400 error with the message \"Inactive user\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the FastAPI `TestClient` to simulate HTTP requests, which is a common pattern for testing web applications. It also employs assertions to verify both the HTTP status code and the response content, ensuring that the API behaves as expected in terms of both status and message. This approach helps in validating both the functional and user-facing aspects of the API's response."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
      "line_number": 154,
      "end_line_number": 160,
      "source_code": "def test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005_an.app",
        "docs_src.security.tutorial005_an.create_access_token",
        "docs_src.security.tutorial005_an.fake_users_db",
        "docs_src.security.tutorial005_an.get_password_hash",
        "docs_src.security.tutorial005_an.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint returns a successful HTTP 200 status code and the expected JSON response, which includes a list of items with their `item_id` and `owner` attributes. The expected response in this test is a single item with `item_id` \"Foo\" and `owner` \"johndoe\".\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using the `TestClient` to simulate HTTP requests. It first obtains an access token by calling `get_access_token` with the scope \"me items\". This function sends a POST request to the `/token` endpoint with the user's credentials and scope, and retrieves the access token from the response. The test then uses this token to authenticate a GET request to the `/users/me/items/` endpoint. The endpoint's logic, as seen in the relevant code, involves verifying the token, checking user permissions, and returning the user's items if the token is valid and the user is active.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client (`TestClient`) to simulate HTTP requests, which is a common pattern in testing web applications. It also uses assertions to verify both the HTTP status code and the JSON response content. The test relies on a helper function (`get_access_token`) to handle authentication, demonstrating a modular approach to testing by reusing code for obtaining access tokens. This approach helps in maintaining clean and readable test code."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005_an",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
      "line_number": 163,
      "end_line_number": 169,
      "source_code": "def test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005_an.app",
        "docs_src.security.tutorial005_an.create_access_token",
        "docs_src.security.tutorial005_an.fake_users_db",
        "docs_src.security.tutorial005_an.get_password_hash",
        "docs_src.security.tutorial005_an.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_system_status` unit test is to verify that the `/status/` endpoint of the FastAPI application correctly returns a successful response indicating the system's operational status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/status/` endpoint returns a status code of 200, indicating a successful HTTP request, and that the JSON response body contains the expected content `{\"status\": \"ok\"}`. This ensures that the endpoint is functioning correctly and providing the expected status information.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application using a `TestClient` to simulate HTTP requests. It first retrieves an access token by calling the `get_access_token` function, which authenticates a user by sending a POST request to the `/token` endpoint with the user's credentials. The access token is then used to authorize a GET request to the `/status/` endpoint. The test checks the response's status code and JSON content to ensure they match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses token-based authentication to access protected endpoints, demonstrating how to test endpoints that require authentication. The test includes assertions to validate both the HTTP status code and the response content, ensuring comprehensive verification of the endpoint's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
      "line_number": 62,
      "end_line_number": 73,
      "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_py310.app",
        "docs_src.security.tutorial005_py310.fake_users_db",
        "docs_src.security.tutorial005_py310.verify_password",
        "docs_src.security.tutorial005_py310.get_password_hash",
        "docs_src.security.tutorial005_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are incorrect or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user with the correct credentials can obtain an access token with the appropriate scope (\"me\") and use it to successfully access the `/users/me` endpoint. It ensures that the response contains the expected user details and that the HTTP status code is 200, indicating successful authentication and authorization.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_access_token` function, which simulates a login by sending a POST request to the `/token` endpoint with user credentials and an optional scope. The function retrieves and returns the access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, checking if the token grants access to the user's information. The relevant code in the application includes functions for creating access tokens (`create_access_token`) and verifying user credentials (`get_current_user` and `get_current_active_user`), which handle token encoding, decoding, and user validation.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It employs assertions to verify both the HTTP status code and the JSON response content, ensuring that the endpoint behaves as expected when accessed with a valid token. The test also implicitly checks the integration of several components, such as token creation, user authentication, and endpoint protection, providing a comprehensive validation of the authentication flow."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_py310.app",
        "docs_src.security.tutorial005_py310.fake_users_db",
        "docs_src.security.tutorial005_py310.verify_password",
        "docs_src.security.tutorial005_py310.get_password_hash",
        "docs_src.security.tutorial005_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_token_no_scope` is to verify that the API correctly handles access tokens that lack the necessary scope for accessing a protected endpoint, ensuring that unauthorized access is appropriately denied.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a user attempts to access the `/users/me` endpoint without the required \"me\" scope in their access token, the server responds with a 401 Unauthorized status. It also verifies that the response includes a message indicating insufficient permissions and the correct `WWW-Authenticate` header specifying the required scope.\n\n**Code Being Tested and How It Works**:  \nThe test exercises the `get_access_token` function to obtain an access token without specifying any scope. It then uses this token to make a GET request to the `/users/me` endpoint. The relevant code in the application involves the `get_current_user` function, which checks the token's scopes against the required scopes for the endpoint. If the token lacks the necessary scope, it raises an HTTP 401 error with a message about insufficient permissions and includes the required scope in the `WWW-Authenticate` header.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to verify the HTTP status code, response content, and headers, ensuring that the application behaves as expected when handling tokens without the required scope. This approach effectively tests the security and authorization logic of the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
      "line_number": 167,
      "end_line_number": 175,
      "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_py310.app",
        "docs_src.security.tutorial005_py310.fake_users_db",
        "docs_src.security.tutorial005_py310.verify_password",
        "docs_src.security.tutorial005_py310.get_password_hash",
        "docs_src.security.tutorial005_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_inactive_user` is to verify that the system correctly handles authentication attempts by users who are marked as inactive. It ensures that such users cannot access protected resources even if they provide valid credentials.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access a protected endpoint using a valid access token, the system responds with a 400 status code and a JSON message indicating that the user is inactive.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `get_access_token` function to simulate the process of obtaining an access token for a user named \"alice\" with the password \"secretalice\". The token is then used to make a GET request to the `/users/me` endpoint. The `get_current_active_user` function, which is part of the FastAPI application, checks if the user is active. If the user is marked as inactive (i.e., `current_user.disabled` is `True`), it raises an HTTP 400 error with the message \"Inactive user\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests, which is a common pattern for testing web applications. It also employs assertions to verify both the HTTP status code and the response content, ensuring that the system behaves as expected when an inactive user attempts to access a resource. This approach helps in validating both the status and the error message returned by the API."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
      "line_number": 179,
      "end_line_number": 185,
      "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_py310.app",
        "docs_src.security.tutorial005_py310.fake_users_db",
        "docs_src.security.tutorial005_py310.verify_password",
        "docs_src.security.tutorial005_py310.get_password_hash",
        "docs_src.security.tutorial005_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint returns a successful HTTP status code (200) and the expected JSON response, which includes a list of items owned by the user. The expected response is a JSON array containing a dictionary with `item_id` and `owner` fields.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first obtains an access token by calling `get_access_token`, which posts credentials to the `/token` endpoint to receive a JWT. This token is then used to authenticate a GET request to the `/users/me/items/` endpoint. The test checks that the response status code is 200 and that the JSON response matches the expected data structure, indicating that the endpoint correctly handles authentication and returns the user's items.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses assertions to verify both the HTTP status code and the content of the JSON response, ensuring that both the response structure and data are correct. The test relies on a helper function, `get_access_token`, to handle authentication, demonstrating a modular approach to testing by reusing code for obtaining access tokens."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
      "line_number": 189,
      "end_line_number": 195,
      "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_py310.app",
        "docs_src.security.tutorial005_py310.fake_users_db",
        "docs_src.security.tutorial005_py310.verify_password",
        "docs_src.security.tutorial005_py310.get_password_hash",
        "docs_src.security.tutorial005_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_system_status` unit test is to verify that the `/status/` endpoint of a FastAPI application correctly returns a status code of 200 and a JSON response indicating the system status as \"ok\". This ensures that the endpoint is functioning as expected and is accessible with valid authentication.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks two things: first, that the HTTP response status code is 200, indicating a successful request; and second, that the JSON response body contains the expected data `{\"status\": \"ok\"}`. This confirms that the endpoint is correctly implemented and returns the expected output when accessed with a valid token.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls the `get_access_token` function to obtain a valid JWT access token by posting credentials to the `/token` endpoint. This token is then used to authenticate a GET request to the `/status/` endpoint. The `get_access_token` function constructs a POST request with user credentials, retrieves the token from the response, and returns it for use in subsequent requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses token-based authentication to test secured endpoints, demonstrating how to handle authentication in tests. Assertions are used to verify both the status code and the content of the response, ensuring comprehensive validation of the endpoint's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
      "line_number": 62,
      "end_line_number": 73,
      "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_an_py310.app",
        "docs_src.security.tutorial005_an_py310.fake_users_db",
        "docs_src.security.tutorial005_an_py310.verify_password",
        "docs_src.security.tutorial005_an_py310.get_password_hash",
        "docs_src.security.tutorial005_an_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user with valid credentials can obtain an access token and use it to access the `/users/me` endpoint. It ensures that the endpoint returns the expected user information and a successful HTTP status code (200).\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_access_token` function, which simulates a login by sending a POST request to the `/token` endpoint with user credentials. The function retrieves an access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, including the token in the Authorization header. The endpoint is expected to return a JSON response with user details, confirming that the token is valid and the user is authenticated.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to verify both the HTTP status code and the JSON response content, ensuring that the endpoint behaves as expected when accessed with a valid token. This approach effectively tests the integration of authentication and authorization logic within the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_an_py310.app",
        "docs_src.security.tutorial005_an_py310.fake_users_db",
        "docs_src.security.tutorial005_an_py310.verify_password",
        "docs_src.security.tutorial005_an_py310.get_password_hash",
        "docs_src.security.tutorial005_an_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_token_no_scope` is to verify that the FastAPI application correctly handles access token requests that lack the necessary scope for accessing a protected endpoint. Specifically, it ensures that a user without the required scope receives an appropriate unauthorized response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an access token is used to access the `/users/me` endpoint without the required \"me\" scope, the server responds with a 401 Unauthorized status code. It also verifies that the response includes a specific error message indicating insufficient permissions and the correct `WWW-Authenticate` header.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token using the `get_access_token` function, which simulates a login by posting credentials to the `/token` endpoint. The token is then used to make a GET request to the `/users/me` endpoint. The `get_current_user` function in the application code checks the token's scopes against the required scopes for the endpoint. If the token lacks the necessary scope, it raises an HTTP 401 error with a \"Not enough permissions\" message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. Assertions are made on the response status code, JSON content, and headers to ensure the application behaves as expected when access is attempted without the required scope. This pattern of testing is common in API testing to validate authentication and authorization mechanisms."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
      "line_number": 167,
      "end_line_number": 175,
      "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_an_py310.app",
        "docs_src.security.tutorial005_an_py310.fake_users_db",
        "docs_src.security.tutorial005_an_py310.verify_password",
        "docs_src.security.tutorial005_an_py310.get_password_hash",
        "docs_src.security.tutorial005_an_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token by sending a POST request to the `/token` endpoint with user credentials (username and password) and an optional scope. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary containing the username and password, and if a scope is provided, it adds that to the dictionary. It then sends a POST request to the `/token` endpoint using the provided `client`, passing the data as form data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, this token can be used for authorization in subsequent API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_inactive_user` is to verify that the system correctly handles authentication attempts by users who are marked as inactive. It ensures that such users cannot access protected resources even if they provide valid credentials.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access a protected endpoint using a valid access token, the system responds with a 400 status code and a JSON message indicating that the user is inactive.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token for a user named \"alice\" using the `get_access_token` function. This function sends a POST request to the `/token` endpoint with the user's credentials and retrieves the access token from the response. The test then uses this token to make a GET request to the `/users/me` endpoint, which is protected and requires authentication. The `get_current_active_user` function, part of the application code, checks if the user is active. If the user is marked as inactive, it raises an HTTPException with a 400 status code and a \"Inactive user\" detail.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs assertions to verify both the HTTP status code and the response content, ensuring that the application behaves as expected when an inactive user attempts to access a protected resource. This pattern of testing both the status code and the response body is a common practice in API testing to ensure comprehensive validation of the application's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
      "line_number": 179,
      "end_line_number": 185,
      "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_an_py310.app",
        "docs_src.security.tutorial005_an_py310.fake_users_db",
        "docs_src.security.tutorial005_an_py310.verify_password",
        "docs_src.security.tutorial005_an_py310.get_password_hash",
        "docs_src.security.tutorial005_an_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint returns a successful HTTP status code (200) and the expected JSON response, which includes a list of items with specific attributes (`item_id` and `owner`). It ensures that the authentication mechanism and the scope-based access control are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls the `get_access_token` function to obtain a valid JWT access token with the required scope (\"me items\"). This token is then used to authenticate a GET request to the `/users/me/items/` endpoint. The `get_access_token` function posts credentials to the `/token` endpoint, retrieves the token from the response, and returns it for use in subsequent requests. The endpoint's logic involves verifying the token, checking user permissions, and returning the user's items if the token is valid and the user has the necessary permissions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of dependency injection via the `TestClient` to simulate client-server interactions in a controlled test environment. It also uses assertions to validate both the HTTP response status and the content of the JSON response, ensuring that the endpoint behaves as expected under the given conditions. The test indirectly verifies the integration of authentication and authorization mechanisms by requiring a valid token with specific scopes to access the endpoint."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005_an_py310",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
      "line_number": 189,
      "end_line_number": 195,
      "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [
        "needs_py310"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "pytest",
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "utils.needs_py310",
        "docs_src.security.tutorial005_an_py310.app",
        "docs_src.security.tutorial005_an_py310.fake_users_db",
        "docs_src.security.tutorial005_an_py310.verify_password",
        "docs_src.security.tutorial005_an_py310.get_password_hash",
        "docs_src.security.tutorial005_an_py310.create_access_token"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_read_system_status` unit test is to verify that the `/status/` endpoint of a FastAPI application correctly returns a status code of 200 and a JSON response indicating the system status as \"ok\" when accessed with a valid authorization token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/status/` endpoint is functioning correctly by ensuring it is accessible with a valid bearer token and that it returns the expected JSON response. It verifies both the HTTP status code and the content of the response.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by using a `TestClient` to simulate HTTP requests. It first calls the `get_access_token` function to obtain a valid access token by posting credentials to the `/token` endpoint. This token is then used to authenticate a GET request to the `/status/` endpoint. The `get_access_token` function works by sending a POST request with user credentials to obtain a JWT token, which is then used for authorization in subsequent requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a `TestClient` from FastAPI's testing utilities to simulate HTTP requests, which is a common pattern for testing web applications. It also uses assertions to verify both the status code and the JSON response content, ensuring that the endpoint behaves as expected. The test demonstrates the use of token-based authentication by obtaining and using a JWT token to access a protected endpoint."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token",
      "module": "test_tutorial005",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
      "line_number": 54,
      "end_line_number": 65,
      "source_code": "def test_token():\n    access_token = get_access_token(scope=\"me\")\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005.app",
        "docs_src.security.tutorial005.create_access_token",
        "docs_src.security.tutorial005.fake_users_db",
        "docs_src.security.tutorial005.get_password_hash",
        "docs_src.security.tutorial005.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). It optionally allows for a scope to be specified, which can define the permissions associated with the token.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. This token can then be used for authenticated requests to other endpoints, ensuring that the user has the necessary permissions based on the provided scope."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token` unit test is to verify that the authentication mechanism in the FastAPI application correctly issues a valid access token and allows access to a protected endpoint when the token is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a user with the correct credentials can obtain an access token and use it to access the `/users/me` endpoint. It verifies that the response from this endpoint is successful (HTTP status code 200) and that the returned JSON data matches the expected user information.\n\n**Code Being Tested and How It Works**:  \nThe test calls the `get_access_token` function, which simulates a login by sending a POST request to the `/token` endpoint with the user's credentials. This function returns an access token if the credentials are valid. The test then uses this token to make a GET request to the `/users/me` endpoint, which is protected and requires a valid token for access. The endpoint uses the `get_current_user` and `get_current_active_user` functions to validate the token and retrieve the user information. If the token is valid and the user is active, the endpoint returns the user's details.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests, which is a common pattern for testing web applications. It also uses assertions to verify both the HTTP status code and the content of the response, ensuring that the endpoint behaves as expected when accessed with a valid token. This approach helps ensure that both the authentication process and the endpoint's response are functioning correctly."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_no_scope",
      "module": "test_tutorial005",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
      "line_number": 121,
      "end_line_number": 128,
      "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005.app",
        "docs_src.security.tutorial005.create_access_token",
        "docs_src.security.tutorial005.fake_users_db",
        "docs_src.security.tutorial005.get_password_hash",
        "docs_src.security.tutorial005.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401, response.text",
        "assert response.json() == {'detail': 'Not enough permissions'}",
        "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_no_scope` unit test is to verify that the FastAPI application correctly handles access token requests that lack the necessary scope permissions. It ensures that the application returns an appropriate error response when a user attempts to access a protected endpoint without the required scope.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an access token is used without the required scope, the API responds with a 401 Unauthorized status code, a JSON error message indicating \"Not enough permissions,\" and a `WWW-Authenticate` header specifying the required scope.\n\n**Code Being Tested and How It Works**:  \nThe test targets the `/users/me` endpoint, which requires a specific scope (\"me\") for access. The `get_access_token` function is used to obtain an access token without any scope. The test then makes a GET request to the endpoint using this token. The `get_current_user` function in the application code checks the token's scopes against the required scopes for the endpoint. If the token lacks the necessary scope, it raises an HTTP 401 error with a message and header indicating the missing permissions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI to simulate HTTP requests to the application, which is a common pattern for testing web applications. Assertions are used to verify the response status code, JSON content, and headers, ensuring that the application behaves as expected when access is denied due to insufficient permissions. This approach effectively tests the security and authorization logic of the application."
    },
    {
      "repo_name": "fastapi",
      "name": "test_token_inactive_user",
      "module": "test_tutorial005",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
      "line_number": 143,
      "end_line_number": 151,
      "source_code": "def test_token_inactive_user():\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\"\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005.app",
        "docs_src.security.tutorial005.create_access_token",
        "docs_src.security.tutorial005.fake_users_db",
        "docs_src.security.tutorial005.get_password_hash",
        "docs_src.security.tutorial005.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400, response.text",
        "assert response.json() == {'detail': 'Inactive user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in further API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_token_inactive_user` is to verify that the system correctly identifies and handles requests made by users who are marked as inactive in the system. It ensures that such users cannot access protected resources even if they possess a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an inactive user attempts to access a protected endpoint using a valid access token, the system responds with a 400 status code and a JSON message indicating that the user is inactive. This behavior is crucial for maintaining security by preventing inactive users from accessing sensitive information.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `get_current_active_user` function, which is responsible for checking if the current user is active. It uses the `get_current_user` function to retrieve user details from the token. If the user is marked as disabled, an HTTP 400 error with the message \"Inactive user\" is raised. The test simulates this scenario by first obtaining an access token for a user (presumably inactive) and then attempting to access the `/users/me` endpoint with this token.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the FastAPI `TestClient` to simulate HTTP requests, which is a common pattern for testing web applications. It checks both the HTTP status code and the response content to ensure the correct error handling behavior. The use of assertions to verify both the status code and the response body ensures that the test is comprehensive in validating the expected behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_items",
      "module": "test_tutorial005",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
      "line_number": 154,
      "end_line_number": 160,
      "source_code": "def test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005.app",
        "docs_src.security.tutorial005.create_access_token",
        "docs_src.security.tutorial005.fake_users_db",
        "docs_src.security.tutorial005.get_password_hash",
        "docs_src.security.tutorial005.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token by sending a POST request to the `/token` endpoint with user credentials (username and password) and an optional scope. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \n1. The method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`.\n2. It constructs a dictionary `data` containing the `username` and `password`. If a `scope` is provided, it adds this to the `data` dictionary.\n3. It sends a POST request to the `/token` endpoint using the provided `client`, passing the `data` as the request body.\n4. The response is parsed as JSON to extract the `access_token`.\n5. Finally, it returns the `access_token`, which can be used for authenticating further API requests."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_read_items` unit test is to verify that the API endpoint `/users/me/items/` correctly returns a list of items associated with the authenticated user when accessed with a valid access token.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the endpoint returns a successful HTTP status code (200) and the expected JSON response, which includes a list of items with their respective `item_id` and `owner` attributes. The expected response in this test is a single item with `item_id` \"Foo\" and `owner` \"johndoe\".\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token using the `get_access_token` function. This function simulates a login by sending a POST request to the `/token` endpoint with the user's credentials and requested scope. The token is then used to authenticate a GET request to the `/users/me/items/` endpoint. The test checks that the response status code is 200 and that the JSON response matches the expected data structure.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. This allows for testing the API endpoints in an isolated environment. The use of an access token to authenticate requests demonstrates testing of security features, ensuring that the endpoint correctly handles authentication and authorization. The test also employs assertions to validate both the status code and the content of the response, ensuring comprehensive verification of the endpoint's behavior."
    },
    {
      "repo_name": "fastapi",
      "name": "test_read_system_status",
      "module": "test_tutorial005",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
      "line_number": 163,
      "end_line_number": 169,
      "source_code": "def test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "dirty_equals.IsOneOf",
        "fastapi.testclient.TestClient",
        "docs_src.security.tutorial005.app",
        "docs_src.security.tutorial005.create_access_token",
        "docs_src.security.tutorial005.fake_users_db",
        "docs_src.security.tutorial005.get_password_hash",
        "docs_src.security.tutorial005.verify_password"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response.json() == {'status': 'ok'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_access_token",
          "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in subsequent API calls."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_read_system_status` unit test is to verify that the `/status/` endpoint of the FastAPI application correctly returns a status code of 200 and a JSON response indicating that the system is operational.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `/status/` endpoint is accessible with a valid access token and that it returns the expected JSON response `{\"status\": \"ok\"}`. It ensures that the endpoint is functioning correctly and that the authentication mechanism is working as intended.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the FastAPI application by first obtaining an access token using the `get_access_token` function. This function simulates a login by sending a POST request to the `/token` endpoint with a username and password, and retrieves an access token from the response. The test then uses this token to make an authenticated GET request to the `/status/` endpoint. The test checks that the response status code is 200, indicating success, and that the response body matches the expected JSON structure.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test uses the `TestClient` from FastAPI's testing utilities to simulate HTTP requests to the application. It employs the pattern of obtaining an access token before making an authenticated request, which is common in testing secured endpoints. The test uses assertions to verify both the HTTP status code and the content of the JSON response, ensuring that both the endpoint's availability and its output are correct."
    },
    {
      "repo_name": "fastapi",
      "name": "test_dummy_callback",
      "module": "test_tutorial001",
      "class_name": null,
      "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_openapi_callbacks/test_tutorial001.py",
      "line_number": 17,
      "end_line_number": 19,
      "source_code": "def test_dummy_callback():\n    # Just for coverage\n    invoice_notification({})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "dirty_equals.IsDict",
        "fastapi.testclient.TestClient",
        "docs_src.openapi_callbacks.tutorial001.app",
        "docs_src.openapi_callbacks.tutorial001.invoice_notification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoice_notification",
          "body": "@invoices_callback_router.post('{$callback_url}/invoices/{$request.body.id}', response_model=InvoiceEventReceived)\ndef invoice_notification(body: InvoiceEvent):\n    pass",
          "method_explanation": "**Main Purpose of the Method**:  \nThe `invoice_notification` method is designed to handle incoming POST requests that notify the API about events related to invoices, such as payment status updates. It serves as a callback endpoint that external systems can use to inform the API of changes in invoice status.\n\n**How It Works**:  \nThe method is defined as a POST endpoint within the `invoices_callback_router`, which is part of a FastAPI application. It expects a request body that conforms to the `InvoiceEvent` model, which includes details about the invoice event (e.g., whether it has been paid). Upon receiving a valid request, the method is intended to process the notification (though the actual implementation is currently a placeholder). The response model for this endpoint is `InvoiceEventReceived`, which indicates whether the notification was successfully processed. The URL for this endpoint is dynamically constructed using the callback URL and the invoice ID from the request body."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dummy_callback` is to ensure code coverage for the `invoice_notification` function. This test is not designed to verify any specific functionality or behavior but rather to include the function in the test suite for coverage purposes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test does not verify any specific functionality or behavior of the `invoice_notification` function. It simply calls the function with an empty dictionary to ensure that the function is executed and included in the coverage report.\n\n**Code Being Tested and How It Works**:  \nThe `invoice_notification` function is a placeholder function defined to handle POST requests to a callback URL for invoice notifications. It is part of a FastAPI application that simulates the process of creating an invoice and sending a notification back to an API user. The function currently has no implementation (`pass` statement), indicating that it is either a stub for future development or intentionally left without logic for demonstration purposes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a minimalistic approach by directly invoking the function without any assertions or setup. This pattern is often used when the primary goal is to achieve code coverage rather than validate functionality. The test does not utilize any advanced testing techniques or frameworks beyond a simple function call, reflecting its purpose as a coverage tool rather than a functional test."
    }
  ]
}