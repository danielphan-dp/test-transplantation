{
    "tests": [
        {
            "repo_name": "aiohttp",
            "name": "test_ten_web_middlewares",
            "module": "test_benchmarks_web_middleware",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_middleware.py",
            "line_number": 12,
            "end_line_number": 43,
            "source_code": "def test_ten_web_middlewares(\n    benchmark: BenchmarkFixture,\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n) -> None:\n    \"\"\"Benchmark 100 requests with 10 middlewares.\"\"\"\n    message_count = 100\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    class MiddlewareClass:\n        async def call(\n            self, request: web.Request, handler: Handler\n        ) -> web.StreamResponse:\n            return await handler(request)\n\n    for _ in range(10):\n        app.middlewares.append(MiddlewareClass().call)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            await client.get(\"/\")\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 requests with 10 middlewares.",
            "decorators": [],
            "arguments": [
                "benchmark",
                "loop",
                "aiohttp_client"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.typedefs.Handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets it to `None`, effectively closing the connection. This method is idempotent, meaning that calling it multiple times will have no additional effect after the first call. It also ensures that the client cannot be used after closure, as indicated by the `closed` property."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ten_web_middlewares",
            "module": "test_benchmarks_web_middleware",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_middleware.py",
            "line_number": 12,
            "end_line_number": 43,
            "source_code": "def test_ten_web_middlewares(\n    benchmark: BenchmarkFixture,\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n) -> None:\n    \"\"\"Benchmark 100 requests with 10 middlewares.\"\"\"\n    message_count = 100\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    class MiddlewareClass:\n        async def call(\n            self, request: web.Request, handler: Handler\n        ) -> web.StreamResponse:\n            return await handler(request)\n\n    for _ in range(10):\n        app.middlewares.append(MiddlewareClass().call)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            await client.get(\"/\")\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 requests with 10 middlewares.",
            "decorators": [],
            "arguments": [
                "benchmark",
                "loop",
                "aiohttp_client"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.typedefs.Handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "handler",
                    "body": "def handler(request: web.Request) -> NoReturn:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `handler` method is designed to process incoming HTTP requests in a web application. However, its current implementation contains an assertion that always fails, indicating that it is not intended to be used in its current form. This could serve as a placeholder or a way to signal that the handler is not yet implemented.\n\n**How It Works**:\nThe method takes a single parameter, `request`, which is an instance of `web.Request`. The method body contains an assertion (`assert False`), which will raise an `AssertionError` whenever the method is called. This effectively prevents any further processing of the request and indicates that the handler is not functional. In the context of the tests provided, this method is used to verify that custom expectation handlers can be set up for routes, but the actual logic for handling requests is not implemented in this placeholder."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_multipart",
            "class_name": "TestMultipartResponseWrapper",
            "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
            "line_number": 104,
            "end_line_number": 109,
            "source_code": "def test_at_eof(self) -> None:\n        m_resp = mock.create_autospec(aiohttp.ClientResponse, spec_set=True)\n        m_stream = mock.create_autospec(MultipartReader, spec_set=True)\n        wrapper = MultipartResponseWrapper(m_resp, m_stream)\n        wrapper.at_eof()\n        assert m_resp.content.at_eof.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "io",
                "json",
                "pathlib",
                "sys",
                "zlib",
                "types.TracebackType",
                "typing.Dict",
                "typing.Optional",
                "typing.Tuple",
                "typing.Type",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "aiohttp",
                "aiohttp.payload",
                "aiohttp.hdrs.CONTENT_DISPOSITION",
                "aiohttp.hdrs.CONTENT_ENCODING",
                "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
                "aiohttp.hdrs.CONTENT_TYPE",
                "aiohttp.helpers.parse_mimetype",
                "aiohttp.multipart.BodyPartReader",
                "aiohttp.multipart.MultipartReader",
                "aiohttp.multipart.MultipartResponseWrapper",
                "aiohttp.streams.StreamReader",
                "typing.Self",
                "typing.TypeVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert m_resp.content.at_eof.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "wrapper.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the end of the file (EOF) has been reached in a stream or buffer. It returns `True` if the EOF has been reached and the buffer is empty, indicating that no more data can be read.\n\n**How It Works**:  \nThe method uses the `tell()` function to get the current position in the content stream and compares it to the total length of the content (obtained via `len(self.content.getbuffer())`). If both values are equal, it means that the reading position is at the end of the content, thus confirming that EOF has been reached. Additionally, it checks the `_eof` attribute to ensure that the `feed_eof` method has been called, which signifies that the stream has been marked as finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_multipart",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
            "line_number": 104,
            "end_line_number": 109,
            "source_code": "def test_at_eof(self) -> None:\n        m_resp = mock.create_autospec(aiohttp.ClientResponse, spec_set=True)\n        m_stream = mock.create_autospec(MultipartReader, spec_set=True)\n        wrapper = MultipartResponseWrapper(m_resp, m_stream)\n        wrapper.at_eof()\n        assert m_resp.content.at_eof.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "io",
                "json",
                "pathlib",
                "sys",
                "zlib",
                "types.TracebackType",
                "typing.Dict",
                "typing.Optional",
                "typing.Tuple",
                "typing.Type",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "aiohttp",
                "aiohttp.payload",
                "aiohttp.hdrs.CONTENT_DISPOSITION",
                "aiohttp.hdrs.CONTENT_ENCODING",
                "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
                "aiohttp.hdrs.CONTENT_TYPE",
                "aiohttp.helpers.parse_mimetype",
                "aiohttp.multipart.BodyPartReader",
                "aiohttp.multipart.MultipartReader",
                "aiohttp.multipart.MultipartResponseWrapper",
                "aiohttp.streams.StreamReader",
                "typing.Self",
                "typing.TypeVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert m_resp.content.at_eof.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "wrapper.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the end of the file (EOF) has been reached in a stream or buffer. It returns `True` if the EOF has been reached and the buffer is empty, indicating that no more data can be read.\n\n**How It Works**:  \nThe method uses the `tell()` function to get the current position in the content stream and compares it to the total length of the content (obtained via `getbuffer()`). If the current position equals the total length, it means the end of the content has been reached, and the method returns `True`. If not, it returns `False`. This is useful for managing asynchronous data streams where knowing the EOF state is crucial for proper data handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_root_route",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 55,
            "end_line_number": 84,
            "source_code": "def test_resolve_root_route(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve top level PlainResources route 100 times.\"\"\"\n    resolve_count = 100\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n    app.freeze()\n    router = app.router\n    request = _mock_request(method=\"GET\", path=\"/\")\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for _ in range(resolve_count):\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == \"/\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve top level PlainResources route 100 times.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:\nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual implementations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_root_route_with_many_fixed_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 87,
            "end_line_number": 122,
            "source_code": "def test_resolve_root_route_with_many_fixed_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve top level PlainResources route 100 times.\"\"\"\n    resolve_count = 100\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n    for count in range(250):\n        app.router.add_route(\"GET\", f\"/api/server/dispatch/{count}/update\", handler)\n        app.router.add_route(\"GET\", f\"/api/server/dispatch/{count}\", handler)\n    app.router.add_route(\"GET\", \"/api/server/dispatch\", handler)\n    app.router.add_route(\"GET\", \"/api/server\", handler)\n    app.router.add_route(\"GET\", \"/api\", handler)\n    app.freeze()\n    router = app.router\n    request = _mock_request(method=\"GET\", path=\"/\")\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for _ in range(resolve_count):\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == \"/\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve top level PlainResources route 100 times.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:\nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_static_root_route",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 125,
            "end_line_number": 152,
            "source_code": "def test_resolve_static_root_route(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve top level StaticResource route 100 times.\"\"\"\n    resolve_count = 100\n\n    app = web.Application()\n    here = pathlib.Path(aiohttp.__file__).parent\n    app.router.add_static(\"/\", here)\n    app.freeze()\n    router = app.router\n    request = _mock_request(method=\"GET\", path=\"/\")\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for _ in range(resolve_count):\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"directory\"] == here, ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve top level StaticResource route 100 times.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['directory'] == here, ret.get_info()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:\nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_single_fixed_url_with_many_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 155,
            "end_line_number": 185,
            "source_code": "def test_resolve_single_fixed_url_with_many_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve PlainResources route 100 times.\"\"\"\n    resolve_count = 100\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_route(\"GET\", f\"/api/server/dispatch/{count}/update\", handler)\n    app.freeze()\n    router = app.router\n    request = _mock_request(method=\"GET\", path=\"/api/server/dispatch/1/update\")\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for _ in range(resolve_count):\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == \"/api/server/dispatch/1/update\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve PlainResources route 100 times.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/api/server/dispatch/1/update', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\", \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_multiple_fixed_url_with_many_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 188,
            "end_line_number": 220,
            "source_code": "def test_resolve_multiple_fixed_url_with_many_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve 250 different PlainResources routes.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_route(\"GET\", f\"/api/server/dispatch/{count}/update\", handler)\n    app.freeze()\n    router = app.router\n\n    requests = [\n        _mock_request(method=\"GET\", path=f\"/api/server/dispatch/{count}/update\")\n        for count in range(250)\n    ]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == \"/api/server/dispatch/249/update\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve 250 different PlainResources routes.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/api/server/dispatch/249/update', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_multiple_level_fixed_url_with_many_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 223,
            "end_line_number": 261,
            "source_code": "def test_resolve_multiple_level_fixed_url_with_many_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve 1024 different PlainResources routes.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    urls = [\n        f\"/api/{a}/{b}/{c}/{d}/{e}/update\"\n        for a in (\"a\", \"b\", \"c\", \"d\")\n        for b in (\"e\", \"f\", \"g\", \"h\")\n        for c in (\"i\", \"j\", \"k\", \"l\")\n        for d in (\"m\", \"n\", \"o\", \"p\")\n        for e in (\"n\", \"o\", \"p\", \"q\")\n    ]\n    for url in urls:\n        app.router.add_route(\"GET\", url, handler)\n    app.freeze()\n    router = app.router\n\n    requests = [(_mock_request(method=\"GET\", path=url), url) for url in urls]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request, path in requests:\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == url, ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve 1024 different PlainResources routes.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == url, ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:\nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\", \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_dynamic_resource_url_with_many_static_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 264,
            "end_line_number": 300,
            "source_code": "def test_resolve_dynamic_resource_url_with_many_static_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve different a DynamicResource when there are 250 PlainResources registered.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_route(\"GET\", f\"/api/server/other/{count}/update\", handler)\n    app.router.add_route(\"GET\", \"/api/server/dispatch/{customer}/update\", handler)\n    app.freeze()\n    router = app.router\n\n    requests = [\n        _mock_request(method=\"GET\", path=f\"/api/server/dispatch/{customer}/update\")\n        for customer in range(250)\n    ]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert (\n        ret.get_info()[\"formatter\"] == \"/api/server/dispatch/{customer}/update\"\n    ), ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve different a DynamicResource when there are 250 PlainResources registered.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['formatter'] == '/api/server/dispatch/{customer}/update', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_dynamic_resource_url_with_many_dynamic_routes",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 303,
            "end_line_number": 341,
            "source_code": "def test_resolve_dynamic_resource_url_with_many_dynamic_routes(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve different a DynamicResource when there are 250 DynamicResources registered.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_route(\n            \"GET\", f\"/api/server/other/{{customer}}/update{count}\", handler\n        )\n    app.router.add_route(\"GET\", \"/api/server/dispatch/{customer}/update\", handler)\n    app.freeze()\n    router = app.router\n\n    requests = [\n        _mock_request(method=\"GET\", path=f\"/api/server/dispatch/{customer}/update\")\n        for customer in range(250)\n    ]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert (\n        ret.get_info()[\"formatter\"] == \"/api/server/dispatch/{customer}/update\"\n    ), ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve different a DynamicResource when there are 250 DynamicResources registered.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['formatter'] == '/api/server/dispatch/{customer}/update', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\", \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_dynamic_resource_url_with_many_dynamic_routes_with_common_prefix",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 344,
            "end_line_number": 378,
            "source_code": "def test_resolve_dynamic_resource_url_with_many_dynamic_routes_with_common_prefix(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve different a DynamicResource when there are 250 DynamicResources registered with the same common prefix.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_route(\"GET\", f\"/api/{{customer}}/show_{count}\", handler)\n    app.router.add_route(\"GET\", \"/api/{customer}/update\", handler)\n    app.freeze()\n    router = app.router\n\n    requests = [\n        _mock_request(method=\"GET\", path=f\"/api/{customer}/update\")\n        for customer in range(250)\n    ]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"formatter\"] == \"/api/{customer}/update\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve different a DynamicResource when there are 250 DynamicResources registered with the same common prefix.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['formatter'] == '/api/{customer}/update', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_gitapi",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 381,
            "end_line_number": 429,
            "source_code": "def test_resolve_gitapi(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n    github_urls: list[str],\n) -> None:\n    \"\"\"Resolve DynamicResource for simulated github API.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for url in github_urls:\n        app.router.add_get(url, handler)\n    app.freeze()\n    router = app.router\n\n    # PR reviews API was selected absolutely voluntary.\n    # It is not any special but sits somewhere in the middle of the urls list.\n    # If anybody has better idea please suggest.\n\n    alnums = string.ascii_letters + string.digits\n\n    requests = []\n    for i in range(250):\n        owner = \"\".join(random.sample(alnums, 10))\n        repo = \"\".join(random.sample(alnums, 10))\n        pull_number = random.randint(0, 250)\n        requests.append(\n            _mock_request(\n                method=\"GET\", path=f\"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\"\n            )\n        )\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert (\n        ret.get_info()[\"formatter\"]\n        == \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\"\n    ), ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve DynamicResource for simulated github API.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark",
                "github_urls"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['formatter'] == '/repos/{owner}/{repo}/pulls/{pull_number}/reviews', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_gitapi_subapps",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 432,
            "end_line_number": 500,
            "source_code": "def test_resolve_gitapi_subapps(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n    github_urls: list[str],\n) -> None:\n    \"\"\"Resolve DynamicResource for simulated github API, grouped in subapps.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    subapps = {\n        \"gists\": web.Application(),\n        \"orgs\": web.Application(),\n        \"projects\": web.Application(),\n        \"repos\": web.Application(),\n        \"teams\": web.Application(),\n        \"user\": web.Application(),\n        \"users\": web.Application(),\n    }\n\n    app = web.Application()\n    for url in github_urls:\n        parts = url.split(\"/\")\n        subapp = subapps.get(parts[1])\n        if subapp is not None:\n            sub_url = \"/\".join([\"\"] + parts[2:])\n            if not sub_url:\n                sub_url = \"/\"\n            subapp.router.add_get(sub_url, handler)\n        else:\n            app.router.add_get(url, handler)\n    for key, subapp in subapps.items():\n        app.add_subapp(\"/\" + key, subapp)\n    app.freeze()\n    router = app.router\n\n    # PR reviews API was selected absolutely voluntary.\n    # It is not any special but sits somewhere in the middle of the urls list.\n    # If anybody has better idea please suggest.\n\n    alnums = string.ascii_letters + string.digits\n\n    requests = []\n    for i in range(250):\n        owner = \"\".join(random.sample(alnums, 10))\n        repo = \"\".join(random.sample(alnums, 10))\n        pull_number = random.randint(0, 250)\n        requests.append(\n            _mock_request(\n                method=\"GET\", path=f\"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\"\n            )\n        )\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert (\n        ret.get_info()[\"formatter\"]\n        == \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\"\n    ), ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve DynamicResource for simulated github API, grouped in subapps.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark",
                "github_urls"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['formatter'] == '/repos/{owner}/{repo}/pulls/{pull_number}/reviews', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_gitapi_root",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 503,
            "end_line_number": 533,
            "source_code": "def test_resolve_gitapi_root(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n    github_urls: list[str],\n) -> None:\n    \"\"\"Resolve the plain root for simulated github API.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for url in github_urls:\n        app.router.add_get(url, handler)\n    app.freeze()\n    router = app.router\n\n    request = _mock_request(method=\"GET\", path=\"/\")\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for i in range(250):\n            ret = await router.resolve(request)\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert ret.get_info()[\"path\"] == \"/\", ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve the plain root for simulated github API.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark",
                "github_urls"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual implementations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_resolve_prefix_resources_many_prefix_many_plain",
            "module": "test_benchmarks_web_urldispatcher",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_web_urldispatcher.py",
            "line_number": 536,
            "end_line_number": 575,
            "source_code": "def test_resolve_prefix_resources_many_prefix_many_plain(\n    loop: asyncio.AbstractEventLoop,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Resolve prefix resource (sub_app) whene 250 PlainResources registered and there are 250 subapps that shares the same sub_app path prefix.\"\"\"\n\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    app = web.Application()\n    for count in range(250):\n        app.router.add_get(f\"/api/server/other/{count}/update\", handler)\n    for count in range(250):\n        subapp = web.Application()\n        # sub_apps exists for handling deep enough nested route trees\n        subapp.router.add_get(\"/deep/enough/sub/path\", handler)\n        app.add_subapp(f\"/api/path/to/plugin/{count}\", subapp)\n    app.freeze()\n    router = app.router\n\n    requests = [\n        _mock_request(method=\"GET\", path=\"/api/path/to/plugin/249/deep/enough/sub/path\")\n        for customer in range(250)\n    ]\n\n    async def run_url_dispatcher_benchmark() -> Optional[web.UrlMappingMatchInfo]:\n        ret = None\n        for request in requests:\n            ret = await router.resolve(request)\n        return ret\n\n    ret = loop.run_until_complete(run_url_dispatcher_benchmark())\n    assert ret is not None\n    assert (\n        ret.get_info()[\"path\"] == \"/api/path/to/plugin/249/deep/enough/sub/path\"\n    ), ret.get_info()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_url_dispatcher_benchmark())",
            "docstring": "Resolve prefix resource (sub_app) whene 250 PlainResources registered and there are 250 subapps that shares the same sub_app path prefix.",
            "decorators": [],
            "arguments": [
                "loop",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "json",
                "pathlib",
                "random",
                "string",
                "pathlib.Path",
                "typing.NoReturn",
                "typing.Optional",
                "typing.cast",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_codspeed.BenchmarkFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.http.HttpVersion",
                "aiohttp.http.RawRequestMessage"
            ],
            "fixtures": [],
            "assertions": [
                "assert ret is not None",
                "assert ret.get_info()['path'] == '/api/path/to/plugin/249/deep/enough/sub/path', ret.get_info()",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mock_request",
                    "body": "def _mock_request(method: str, path: str) -> web.Request:\n    message = RawRequestMessage(method, path, HttpVersion(1, 1), CIMultiDictProxy(CIMultiDict()), (), False, None, False, False, URL(path))\n    return web.Request(message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mock_request` method is designed to create a mock `web.Request` object for testing purposes. It allows developers to simulate HTTP requests without needing to spin up a full web server, making it easier to test specific conditions and behaviors in unit tests.\n\n**How It Works**:  \nThe method takes two parameters: `method` (the HTTP method, e.g., \"GET\" or \"POST\") and `path` (the request URL path). It constructs a `RawRequestMessage` using these parameters along with default values for HTTP version and headers. This message is then used to instantiate a `web.Request` object, which is returned. The method utilizes `mock.Mock()` to create mock objects for various components of the request, ensuring that the resulting `web.Request` can be used in tests without relying on actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_import_time",
            "module": "test_imports",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_imports.py",
            "line_number": 53,
            "end_line_number": 83,
            "source_code": "def test_import_time(pytester: pytest.Pytester) -> None:\n    \"\"\"Check that importing aiohttp doesn't take too long.\n\n    Obviously, the time may vary on different machines and may need to be adjusted\n    from time to time, but this should provide an early warning if something is\n    added that significantly increases import time.\n    \"\"\"\n    root = Path(__file__).parent.parent\n    old_path = os.environ.get(\"PYTHONPATH\")\n    os.environ[\"PYTHONPATH\"] = os.pathsep.join([str(root)] + sys.path)\n\n    best_time_ms = 1000\n    cmd = \"import timeit; print(int(timeit.timeit('import aiohttp', number=1) * 1000))\"\n    try:\n        for _ in range(3):\n            r = pytester.run(sys.executable, \"-We\", \"-c\", cmd)\n\n            assert not r.stderr.str()\n            runtime_ms = int(r.stdout.str())\n            if runtime_ms < best_time_ms:\n                best_time_ms = runtime_ms\n    finally:\n        if old_path is None:\n            os.environ.pop(\"PYTHONPATH\")\n        else:\n            os.environ[\"PYTHONPATH\"] = old_path\n\n    expected_time = _TARGET_TIMINGS_BY_PYTHON_VERSION.get(\n        f\"{sys.version_info.major}.{sys.version_info.minor}\", 200\n    )\n    assert best_time_ms < expected_time",
            "docstring": "Check that importing aiohttp doesn't take too long.\n\nObviously, the time may vary on different machines and may need to be adjusted\nfrom time to time, but this should provide an early warning if something is\nadded that significantly increases import time.",
            "decorators": [
                "pytest.mark.internal",
                "pytest.mark.dev_mode",
                "pytest.mark.skipif(not sys.platform.startswith('linux') or platform.python_implementation() == 'PyPy', reason='Timing is more reliable on Linux')"
            ],
            "arguments": [
                "pytester"
            ],
            "imports": [
                "os",
                "platform",
                "sys",
                "pathlib.Path",
                "pytest"
            ],
            "fixtures": [],
            "assertions": [
                "assert best_time_ms < expected_time",
                "assert not r.stderr.str()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "pytester.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `pytester.run` method is designed to create and configure a `ClientResponse` object, which represents the response from an HTTP request. It sets up the response with a specific connection and prepares it for further operations, such as reading the response content.\n\n**How It Works**:  \nThe method takes a `Connection` object as an argument and initializes a `ClientResponse` instance with predefined parameters, including the HTTP method ('get') and a URL. It also mocks various components like the request information and writer. After creating the response, it sets the `_closed` attribute to `False` and assigns the provided connection to the `_connection` attribute, indicating that the response is still open and associated with the given connection. This setup allows for subsequent operations on the response, such as reading its content or releasing the connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 524,
            "end_line_number": 537,
            "source_code": "def test_domain_filter_same_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to manage cookies by updating the cookie jar with cookies to send and receive for a specific URL, and then returning the cookies that were sent and received.\n\n**How It Works**:\n1. **Update Cookies to Send**: It first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies based on the provided URL to determine which cookies are applicable to send, storing them in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies.\n4. **Update Cookies to Receive**: It updates the jar again with the cookies that are expected to be received, using the same URL.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object, `cookies_received`.\n6. **Final Cleanup**: The jar is cleared again to ensure no residual cookies remain.\n7. **Return Values**: Finally, it returns a tuple containing the sent cookies and the received cookies. \n\nThis method is useful for simulating a request-response cycle where cookies are exchanged based on the same URL context."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host_and_subdomain",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 539,
            "end_line_number": 562,
            "source_code": "def test_domain_filter_same_host_and_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://test1.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Cookies Sent**: It filters the cookies that are applicable to the specified URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the domain and path of the URL.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received, again using the specified URL.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the cookies sent and the cookies received.\n\nThis method is useful in testing scenarios where you need to verify the behavior of cookie handling in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host_diff_subdomain",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 564,
            "end_line_number": 577,
            "source_code": "def test_domain_filter_same_host_diff_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request, storing the result in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request, using the same URL for context.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to collect the received cookies, iterating through the jar to populate this object.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing both the sent cookies and the received cookies. \n\nThis method is useful for testing and simulating cookie behavior in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_diff_host",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 579,
            "end_line_number": 591,
            "source_code": "def test_domain_filter_diff_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.org/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()), {\"shared-cookie\", \"different-domain-cookie\"}\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"different-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Sent Cookies**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object.\n6. **Return Cookies**: Finally, it returns a tuple containing the filtered sent cookies and the collected received cookies. \n\nThis method is useful for testing and simulating cookie behavior in a controlled environment, ensuring that both sent and received cookies are handled correctly based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_secure_filter",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 602,
            "end_line_number": 609,
            "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies that are applicable for the specified URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the domain and path of the URL.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received, again using the specified URL.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method is useful in scenarios where cookie management is essential, such as in web client implementations that need to handle cookies for session management or state persistence."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_secure_filter",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 602,
            "end_line_number": 609,
            "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using the same URL for context.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Final Clear**: The jar is cleared once more before returning.\n7. **Return Values**: Finally, it returns a tuple containing the cookies sent and the cookies received.\n\nThis method is useful in scenarios where you need to manage cookies in a controlled manner, particularly in testing or simulating HTTP interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_root",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 611,
            "end_line_number": 617,
            "source_code": "def test_path_filter_root(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies that are applicable for the specified URL using `self.jar.filter_cookies(URL(url))`, storing the result in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next operation.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing both the sent cookies and the received cookies. \n\nThis method effectively manages the lifecycle of cookies in a simulated request-response cycle, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_folder",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 619,
            "end_line_number": 625,
            "source_code": "def test_path_filter_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/one/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\", \"path2-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle where cookies are sent and received using the same URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the request URL, and then updates the jar with cookies received in the response.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL, retrieving only those that are applicable for that URL with `self.jar.filter_cookies(URL(url))`.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to store the received cookies and iterates through the jar to populate this object.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method is useful for testing and simulating cookie behavior in web requests, ensuring that both sent and received cookies are handled correctly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_file",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 627,
            "end_line_number": 641,
            "source_code": "def test_path_filter_file(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request (`self.cookies_to_send`).\n2. **Filter Sent Cookies**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request, storing the result in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response (`self.cookies_to_receive`), using the same URL for context.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to collect the received cookies, iterating through the jar to populate this object.\n6. **Final Clear**: The jar is cleared again to ensure no residual cookies remain.\n7. **Return Values**: Finally, the method returns a tuple containing the sent cookies and the received cookies. \n\nThis method is useful for testing and simulating cookie behavior in a controlled environment, ensuring that both sent and received cookies are handled correctly according to the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_subfolder",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 643,
            "end_line_number": 658,
            "source_code": "def test_path_filter_subfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle where cookies are sent and received using the same URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the request URL, and then updates the jar with cookies received in the response.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Cookies Sent**: It filters the cookies that are applicable for the given URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the request's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received from the response using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to store the received cookies and iterates through the jar to populate this object.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the cookies sent and the cookies received.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that the correct cookies are sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_subsubfolder",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 660,
            "end_line_number": 675,
            "source_code": "def test_path_filter_subsubfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/three/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request, storing them in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object, `cookies_received`.\n6. **Final Clear and Return**: The jar is cleared again, and the method returns a tuple containing both `cookies_sent` and `cookies_received`. \n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_different_folder",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 677,
            "end_line_number": 685,
            "source_code": "def test_path_filter_different_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/hundred/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object.\n6. **Return Cookies**: Finally, it returns a tuple containing the cookies that were sent and the cookies that were received.\n\nThis method is useful for testing and simulating cookie behavior in web requests, ensuring that the correct cookies are sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_value",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 687,
            "end_line_number": 702,
            "source_code": "def test_path_value(self) -> None:\n        _, cookies_received = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"no-path-cookie\",\n                \"path-cookie\",\n                \"wrong-path-cookie\",\n            },\n        )\n\n        self.assertEqual(cookies_received[\"no-path-cookie\"][\"path\"], \"/\")\n        self.assertEqual(cookies_received[\"path-cookie\"][\"path\"], \"/somepath\")\n        self.assertEqual(cookies_received[\"wrong-path-cookie\"][\"path\"], \"/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Cookies Sent**: It filters the cookies that are applicable to the given URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received, again using the provided URL.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Final Clear**: The jar is cleared again to ensure no residual cookies remain.\n7. **Return Values**: Finally, the method returns a tuple containing the cookies sent and the cookies received. \n\nThis method is useful in testing scenarios where you want to verify the behavior of cookie handling in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_expires",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 704,
            "end_line_number": 723,
            "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to send and filters the cookies based on the provided URL, returning the cookies that would be sent at the specified time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update the cookies), and `send_time` (the time to filter the cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either a `datetime.timedelta` or a `datetime.datetime` object.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the system time to `freeze_update_time` to update the cookies in the jar and then to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: During the frozen time, it updates the cookie jar with `self.cookies_to_send` and filters the cookies for the specified URL, storing the result in `cookies_sent`.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the filtered cookies that would be sent to the specified URL at the given time."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_expires",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 704,
            "end_line_number": 723,
            "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to send and filters the cookies based on the provided URL, returning the cookies that would be sent at the specified time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update the cookies), and `send_time` (the time to filter the cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either a `datetime.timedelta` or a `datetime.datetime`.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the current time to `freeze_update_time` to update the cookies in the jar with `self.cookies_to_send`.\n4. **Filtering Cookies**: It then freezes the time to `freeze_send_time` to filter the cookies in the jar based on the specified URL, capturing the cookies that would be sent.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the cookies that were sent, encapsulated in a `BaseCookie` object. \n\nThis method is particularly useful for testing scenarios where cookie expiration and behavior need to be validated under controlled time conditions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_age",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 725,
            "end_line_number": 732,
            "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to be sent and filters the cookies based on the provided URL, returning the cookies that are valid at the simulated send time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update the cookies), and `send_time` (the time to filter the cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either `datetime.timedelta` or `datetime.datetime`.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the current time to `freeze_update_time` to update the cookies in the jar, and then to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: It updates the cookie jar with the cookies to send and filters the cookies that are valid at the specified send time.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the cookies that were sent, which are valid at the simulated send time."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_age",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 725,
            "end_line_number": 732,
            "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specified timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to send and filters the cookies based on the provided URL, returning the cookies that would be sent at the specified time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update the cookies), and `send_time` (the time to filter the cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either a `datetime.timedelta` or a `datetime.datetime` object.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the current time to `freeze_update_time` to update the cookies in the jar. Then, it sets the time to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: The method updates the cookie jar with the cookies to send and filters the cookies that are valid at the frozen send time.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the cookies that were sent, encapsulated in a `BaseCookie` object. \n\nThis method is particularly useful for testing scenarios where cookie behavior needs to be validated against specific timestamps."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_invalid_values",
            "module": "test_cookiejar",
            "class_name": "TestCookieJarSafe",
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 734,
            "end_line_number": 748,
            "source_code": "def test_invalid_values(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://invalid-values.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"invalid-max-age-cookie\", \"invalid-expires-cookie\"},\n        )\n\n        cookie = cookies_sent[\"invalid-max-age-cookie\"]\n        self.assertEqual(cookie[\"max-age\"], \"\")\n\n        cookie = cookies_sent[\"invalid-expires-cookie\"]\n        self.assertEqual(cookie[\"expires\"], \"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object.\n6. **Return Cookies**: Finally, it returns a tuple containing the cookies that were sent and the cookies that were received.\n\nThis method is useful for testing and simulating cookie behavior in a controlled environment, ensuring that the correct cookies are sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 524,
            "end_line_number": 537,
            "source_code": "def test_domain_filter_same_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies before processing the received cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are received in response, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to collect the received cookies, iterating through the jar to add each cookie to this object.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the filtered sent cookies and the collected received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host_and_subdomain",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 539,
            "end_line_number": 562,
            "source_code": "def test_domain_filter_same_host_and_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://test1.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the sent cookies and the received cookies. \n\nThis method is useful for testing and simulating cookie behavior in a controlled environment, ensuring that both sent and received cookies are handled correctly based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_same_host_diff_subdomain",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 564,
            "end_line_number": 577,
            "source_code": "def test_domain_filter_same_host_diff_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies that are applicable for the specified URL using `self.jar.filter_cookies(URL(url))`, storing the result in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next operation.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies currently in the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing both the sent cookies and the received cookies. \n\nThis method effectively simulates a round-trip of cookie handling for a specific URL, allowing for testing and validation of cookie behavior in a controlled manner."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_domain_filter_diff_host",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 579,
            "end_line_number": 591,
            "source_code": "def test_domain_filter_diff_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.org/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()), {\"shared-cookie\", \"different-domain-cookie\"}\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"different-domain-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle where cookies are sent and received using the same URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the request URL, and then updates the jar with cookies received in the response.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies that are applicable to the given URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received from the response using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies stored in the jar after the update.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method is useful for testing and simulating cookie behavior in web applications, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_secure_filter",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 602,
            "end_line_number": 609,
            "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response. It returns both the cookies sent and the cookies received.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the cookies sent and the cookies received. \n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_secure_filter",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 602,
            "end_line_number": 609,
            "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies. \n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_root",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 611,
            "end_line_number": 617,
            "source_code": "def test_path_filter_root(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle where cookies are sent and received using the same URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the request URL, and then updates the jar with cookies received in the response.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL, retrieving only those that are applicable for that URL with `self.jar.filter_cookies(URL(url))`.\n3. **Clear the Jar**: The cookie jar is cleared to remove any existing cookies before processing the received cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received from the response using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to store the received cookies and iterates through the jar to populate this object.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_folder",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 619,
            "end_line_number": 625,
            "source_code": "def test_path_filter_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/one/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\", \"path2-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It filters the cookies that are applicable for the specified URL using `self.jar.filter_cookies(URL(url))`, storing the result in `cookies_sent`.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next operation.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies currently in the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing both the sent cookies and the received cookies. \n\nThis method effectively manages the lifecycle of cookies during a simulated request-response cycle for a specific URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_file",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 627,
            "end_line_number": 641,
            "source_code": "def test_path_filter_file(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that are applicable for that URL.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_subfolder",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 643,
            "end_line_number": 658,
            "source_code": "def test_path_filter_subfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next operation.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using the same URL for context.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies from the jar.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies. \n\nThis method effectively manages cookie state across a simulated request-response cycle, ensuring that cookies are correctly handled according to their attributes."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_subsubfolder",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 660,
            "end_line_number": 675,
            "source_code": "def test_path_filter_subsubfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/three/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate the process of sending and receiving cookies for a given URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that are applicable for that URL.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object and populates it with the cookies currently in the jar.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated request-response cycle, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_filter_different_folder",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 677,
            "end_line_number": 685,
            "source_code": "def test_path_filter_different_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/hundred/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns only the cookies that match the URL's domain and path.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are received in response, using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to collect the received cookies, iterating through the jar to add each cookie to this object.\n6. **Return Cookies**: Finally, the method clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that cookies are correctly sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_value",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 687,
            "end_line_number": 702,
            "source_code": "def test_path_value(self) -> None:\n        _, cookies_received = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"no-path-cookie\",\n                \"path-cookie\",\n                \"wrong-path-cookie\",\n            },\n        )\n\n        self.assertEqual(cookies_received[\"no-path-cookie\"][\"path\"], \"/\")\n        self.assertEqual(cookies_received[\"path-cookie\"][\"path\"], \"/somepath\")\n        self.assertEqual(cookies_received[\"wrong-path-cookie\"][\"path\"], \"/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle where cookies are sent and received using the same URL. It updates the cookie jar with cookies to be sent, filters the cookies based on the request URL, and then updates the jar with cookies received in the response.\n\n**How It Works**:  \n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that need to be sent using `self.jar.update_cookies(self.cookies_to_send)`.\n2. **Filter Sent Cookies**: It then filters the cookies based on the provided URL using `self.jar.filter_cookies(URL(url))`, which returns the cookies that are applicable for that URL.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method updates the jar again with the cookies that are expected to be received from the response using `self.jar.update_cookies(self.cookies_to_receive, URL(url))`.\n5. **Collect Received Cookies**: It initializes a `SimpleCookie` object to store the received cookies and iterates through the jar to populate this object.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method effectively manages the lifecycle of cookies during a simulated HTTP request and response, ensuring that the correct cookies are sent and received based on the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_expires",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 704,
            "end_line_number": 723,
            "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to send and filters the cookies based on the provided URL, returning the cookies that would be sent at the specified time.\n\n**How It Works**:  \n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update cookies), and `send_time` (the time to filter cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either `datetime.timedelta` or `datetime.datetime`.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the system time to `freeze_update_time` to update the cookies in the jar and then to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: During the frozen times, it updates the cookie jar with `self.cookies_to_send` and retrieves the cookies that would be sent for the specified URL.\n5. **Cleanup**: After filtering, it clears the cookie jar to reset its state.\n6. **Return Value**: Finally, it returns the cookies that were sent, encapsulated in a `BaseCookie` object. \n\nThis method is particularly useful for testing scenarios where cookie behavior needs to be validated against specific timestamps."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_expires",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 704,
            "end_line_number": 723,
            "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to be sent and filters cookies based on the provided URL, returning the cookies that are valid at the simulated send time.\n\n**How It Works**:  \n1. **Input Parameters**: The method takes a URL, an update time, and a send time. Both times can be provided as either integers (representing seconds) or as timestamps.\n2. **Time Conversion**: It converts the `update_time` and `send_time` into either `datetime.timedelta` (if given as seconds) or `datetime.datetime` (if given as a timestamp).\n3. **Freezing Time**: Using a context manager (`freeze_time`), it temporarily sets the system time to `freeze_update_time` to update the cookies in the jar, and then to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: During the frozen times, it updates the cookie jar with the cookies to send and filters the cookies that are valid for the specified URL.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the cookies that were sent, which are valid at the simulated send time."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_age",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 725,
            "end_line_number": 732,
            "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to be sent and filters the cookies based on the provided URL, returning the cookies that are valid at the simulated send time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes a URL, an update time, and a send time. Both times can be provided as either integers (representing seconds) or as timestamps.\n2. **Time Conversion**: It converts the update and send times into either `datetime.timedelta` (if given as seconds) or `datetime.datetime` (if given as timestamps).\n3. **Freezing Time**: Using a context manager (`freeze_time`), it temporarily sets the system time to the update time to update the cookies in the jar.\n4. **Updating Cookies**: The method updates the cookie jar with the cookies specified in `self.cookies_to_send`.\n5. **Filtering Cookies**: It then freezes the time to the send time and filters the cookies in the jar based on the provided URL, determining which cookies are valid at that time.\n6. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n7. **Return Value**: Finally, it returns the cookies that were sent, which are valid at the simulated send time."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_age",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 725,
            "end_line_number": 732,
            "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.timed_request",
                    "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `timed_request` method is designed to simulate a web request at specific timestamps, allowing for the testing of cookie behavior based on their expiration and max-age attributes. It updates the cookie jar with cookies to be sent and filters the cookies based on the provided URL, returning the cookies that are valid at the simulated send time.\n\n**How It Works**:\n1. **Input Parameters**: The method takes three parameters: `url` (the target URL), `update_time` (the time to update the cookies), and `send_time` (the time to filter the cookies).\n2. **Time Handling**: It checks if `update_time` and `send_time` are integers (representing seconds) or timestamps. Depending on the type, it converts them into either `datetime.timedelta` or `datetime.datetime`.\n3. **Freezing Time**: Using the `freeze_time` context manager, it temporarily sets the current time to `freeze_update_time` to update the cookies in the jar and then to `freeze_send_time` to filter the cookies based on the URL.\n4. **Cookie Operations**: During the frozen times, it updates the cookie jar with `self.cookies_to_send` and retrieves the valid cookies for the specified URL.\n5. **Cleanup**: After filtering, it clears the cookie jar to remove any stale cookies.\n6. **Return Value**: Finally, it returns the cookies that were sent, which are valid at the simulated send time."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_invalid_values",
            "module": "test_cookiejar",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
            "line_number": 734,
            "end_line_number": 748,
            "source_code": "def test_invalid_values(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://invalid-values.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"invalid-max-age-cookie\", \"invalid-expires-cookie\"},\n        )\n\n        cookie = cookies_sent[\"invalid-max-age-cookie\"]\n        self.assertEqual(cookie[\"max-age\"], \"\")\n\n        cookie = cookies_sent[\"invalid-expires-cookie\"]\n        self.assertEqual(cookie[\"expires\"], \"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self"
            ],
            "imports": [
                "asyncio",
                "datetime",
                "heapq",
                "itertools",
                "pickle",
                "unittest",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "operator.not_",
                "pathlib.Path",
                "typing.List",
                "typing.Set",
                "typing.Tuple",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "freezegun.freeze_time",
                "yarl.URL",
                "aiohttp.CookieJar",
                "aiohttp.DummyCookieJar",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.request_reply_with_same_url",
                    "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_reply_with_same_url` method is designed to simulate a request-response cycle for cookies, where it updates the cookie jar with cookies to send, filters the cookies based on the provided URL, and then updates the jar with cookies received in response, returning both the sent and received cookies.\n\n**How It Works**:\n1. **Update Cookies to Send**: The method first updates the cookie jar with the cookies that are intended to be sent in the request.\n2. **Filter Cookies Sent**: It filters the cookies based on the provided URL to determine which cookies are applicable for that request.\n3. **Clear the Jar**: The cookie jar is cleared to prepare for the next set of cookies.\n4. **Update Cookies to Receive**: The method then updates the jar with the cookies that are expected to be received in response to the request.\n5. **Collect Received Cookies**: It iterates through the jar to collect the received cookies into a `SimpleCookie` object.\n6. **Return Cookies**: Finally, it clears the jar again and returns a tuple containing the sent cookies and the received cookies.\n\nThis method is useful for testing and simulating cookie behavior in a controlled environment, ensuring that both sent and received cookies are handled correctly according to the specified URL."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_no_warnings",
            "module": "test_circular_imports",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_circular_imports.py",
            "line_number": 91,
            "end_line_number": 118,
            "source_code": "def test_no_warnings(import_path: str) -> None:\n    \"\"\"Verify that exploding importables doesn't explode.\n\n    This is seeking for any import errors including ones caused\n    by circular imports.\n    \"\"\"\n    imp_cmd = (\n        # fmt: off\n        sys.executable,\n        \"-W\", \"error\",\n        # The following deprecation warning is triggered by importing\n        # `gunicorn.util`. Hopefully, it'll get fixed in the future. See\n        # https://github.com/benoitc/gunicorn/issues/2840 for detail.\n        \"-W\", \"ignore:module 'sre_constants' is \"\n        \"deprecated:DeprecationWarning:pkg_resources._vendor.pyparsing\",\n        # Also caused by `gunicorn.util` importing `pkg_resources`:\n        \"-W\", \"ignore:Creating a LegacyVersion has been deprecated and \"\n        \"will be removed in the next major release:\"\n        \"DeprecationWarning:\",\n        # Deprecation warning emitted by setuptools v67.5.0+ triggered by importing\n        # `gunicorn.util`.\n        \"-W\", \"ignore:pkg_resources is deprecated as an API:\"\n        \"DeprecationWarning\",\n        \"-c\", f\"import {import_path!s}\",\n        # fmt: on\n    )\n\n    subprocess.check_call(imp_cmd)",
            "docstring": "Verify that exploding importables doesn't explode.\n\nThis is seeking for any import errors including ones caused\nby circular imports.",
            "decorators": [
                "pytest.mark.parametrize('import_path', _mark_aiohttp_worker_for_skipping(_find_all_importables(aiohttp)))"
            ],
            "arguments": [
                "import_path"
            ],
            "imports": [
                "os",
                "pkgutil",
                "socket",
                "subprocess",
                "sys",
                "itertools.chain",
                "pathlib.Path",
                "types.ModuleType",
                "typing.TYPE_CHECKING",
                "typing.Generator",
                "typing.List",
                "typing.Union",
                "pytest",
                "aiohttp",
                "_pytest.mark.structures.ParameterSet"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_mark_aiohttp_worker_for_skipping",
                    "body": "def _mark_aiohttp_worker_for_skipping(importables: List[str]) -> List[Union[str, 'ParameterSet']]:\n    return [pytest.param(importable, marks=pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason=\"It's a UNIX-only module\")) if importable == 'aiohttp.worker' else importable for importable in importables]",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_mark_aiohttp_worker_for_skipping` method is designed to modify a list of importable module names by conditionally marking the `aiohttp.worker` module for skipping in tests if the current environment does not support UNIX domain sockets.\n\n**How It Works**:  \nThe method takes a list of strings (`importables`) as input. It iterates over each importable name and checks if it is equal to `aiohttp.worker`. If it is, it wraps it in a `pytest.param` object with a `skipif` marker that checks for the presence of `socket.AF_UNIX`. If `socket.AF_UNIX` is not available, the test will be skipped with a specified reason. If the importable is not `aiohttp.worker`, it is returned unchanged. The result is a new list that includes the modified or original importable names, which can be used in pytest parameterization."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_no_warnings",
            "module": "test_circular_imports",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_circular_imports.py",
            "line_number": 91,
            "end_line_number": 118,
            "source_code": "def test_no_warnings(import_path: str) -> None:\n    \"\"\"Verify that exploding importables doesn't explode.\n\n    This is seeking for any import errors including ones caused\n    by circular imports.\n    \"\"\"\n    imp_cmd = (\n        # fmt: off\n        sys.executable,\n        \"-W\", \"error\",\n        # The following deprecation warning is triggered by importing\n        # `gunicorn.util`. Hopefully, it'll get fixed in the future. See\n        # https://github.com/benoitc/gunicorn/issues/2840 for detail.\n        \"-W\", \"ignore:module 'sre_constants' is \"\n        \"deprecated:DeprecationWarning:pkg_resources._vendor.pyparsing\",\n        # Also caused by `gunicorn.util` importing `pkg_resources`:\n        \"-W\", \"ignore:Creating a LegacyVersion has been deprecated and \"\n        \"will be removed in the next major release:\"\n        \"DeprecationWarning:\",\n        # Deprecation warning emitted by setuptools v67.5.0+ triggered by importing\n        # `gunicorn.util`.\n        \"-W\", \"ignore:pkg_resources is deprecated as an API:\"\n        \"DeprecationWarning\",\n        \"-c\", f\"import {import_path!s}\",\n        # fmt: on\n    )\n\n    subprocess.check_call(imp_cmd)",
            "docstring": "Verify that exploding importables doesn't explode.\n\nThis is seeking for any import errors including ones caused\nby circular imports.",
            "decorators": [
                "pytest.mark.parametrize('import_path', _mark_aiohttp_worker_for_skipping(_find_all_importables(aiohttp)))"
            ],
            "arguments": [
                "import_path"
            ],
            "imports": [
                "os",
                "pkgutil",
                "socket",
                "subprocess",
                "sys",
                "itertools.chain",
                "pathlib.Path",
                "types.ModuleType",
                "typing.TYPE_CHECKING",
                "typing.Generator",
                "typing.List",
                "typing.Union",
                "pytest",
                "aiohttp",
                "_pytest.mark.structures.ParameterSet"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_find_all_importables",
                    "body": "def _find_all_importables(pkg: ModuleType) -> List[str]:\n    \"\"\"Find all importables in the project.\n\n    Return them in order.\n    \"\"\"\n    return sorted(set(chain.from_iterable((_discover_path_importables(Path(p), pkg.__name__) for p in pkg.__path__))))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_find_all_importables` method is designed to discover and return a sorted list of all importable modules or packages within a given Python package. It ensures that the results are unique by using a set.\n\n**How It Works**:  \nThe method takes a `pkg` argument, which is expected to be a module type. It iterates over the paths defined in `pkg.__path__`, calling the `_discover_path_importables` function for each path. This function yields all importable modules found under the specified path. The results from all paths are combined using `chain.from_iterable`, converted to a set to eliminate duplicates, and finally sorted before being returned as a list. This process allows for efficient discovery of all importable components within the package structure."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 44,
            "end_line_number": 99,
            "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the associated connector to close the connection and release resources. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 44,
            "end_line_number": 99,
            "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to close a connection associated with a connector, ensuring that any resources are properly released and that the connection is no longer active.\n\n**How It Works**:  \nThe method is defined but currently does not contain any implementation (`pass` statement). However, it is typically called in the context of asynchronous operations, as indicated by its usage in the `__aexit__` method of an asynchronous context manager. When invoked, it is expected to handle cleanup tasks, such as closing any open connections and releasing associated resources. The method may also trigger warnings if the connection is not closed properly, as seen in the `__del__` method, which warns about unclosed connectors. The method's design suggests that it should be implemented to ensure proper resource management in asynchronous applications."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_headers",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 107,
            "end_line_number": 163,
            "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the associated connector to close the connection and release resources. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_headers",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 107,
            "end_line_number": 163,
            "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to close a connection associated with a connector. It ensures that resources are properly released and that any ongoing operations related to the connection are terminated.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass` statement). In the context of the surrounding code, it is called during the cleanup process, particularly in the `__aexit__` method of an asynchronous context manager. This indicates that when the context manager is exited, `conn.close` will be invoked to close the connection. Additionally, the method is referenced in the destructor (`__del__`), which warns if the connector is not closed properly, highlighting the importance of calling `close` to prevent resource leaks. The method is expected to handle any necessary cleanup tasks, such as notifying the event loop and releasing associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_dns_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 189,
            "end_line_number": 213,
            "source_code": "def test_proxy_dns_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        with mock.patch.object(\n            connector,\n            \"_resolve_host\",\n            autospec=True,\n            side_effect=OSError(\"dont take it serious\"),\n        ):\n            req = ClientRequest(\n                \"GET\",\n                URL(\"http://www.python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                loop=self.loop,\n            )\n            expected_headers = dict(req.headers)\n            with self.assertRaises(aiohttp.ClientConnectorError):\n                self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n            self.assertEqual(req.url.path, \"/\")\n            self.assertEqual(dict(req.headers), expected_headers)\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any active connections are properly closed and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to close the connection associated with the protocol. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are released when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_connection_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 220,
            "end_line_number": 252,
            "source_code": "def test_proxy_connection_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"www.python.org\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            with mock.patch.object(\n                connector._loop,\n                \"create_connection\",\n                autospec=True,\n                side_effect=OSError(\"dont take it serious\"),\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://www.python.org\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                with self.assertRaises(aiohttp.ClientProxyConnectionError):\n                    self.loop.run_until_complete(\n                        connector.connect(req, [], aiohttp.ClientTimeout())\n                    )\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:  \nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with asynchronous context management to ensure that resources are released when they are no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:  \nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly terminate all open connections and resources associated with a network transport, ensuring that no lingering connections remain after the operation.\n\n**How It Works**:  \nWhen invoked, the `close` method first checks if the transport is already closed. If not, it marks the transport as closed and cancels any ongoing cleanup tasks. It then iterates through all active connections, closing each one and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This method is crucial for resource management in asynchronous applications, preventing memory leaks and ensuring that all network resources are properly released."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly terminate all open connections and resources associated with a network transport, ensuring that no lingering connections remain active.\n\n**How It Works**:  \nWhen invoked, the `close` method first checks if the transport is already closed. If not, it marks the transport as closed and cancels any ongoing cleanup tasks. It then iterates through all active connections, closing each one and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This method is crucial for resource management in asynchronous applications, preventing memory leaks and ensuring that all network resources are properly released."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_certificate_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 616,
            "end_line_number": 685,
            "source_code": "def test_https_connect_certificate_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.CertificateError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(\n                                aiohttp.ClientConnectorCertificateError\n                            ):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_ssl_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 693,
            "end_line_number": 760,
            "source_code": "def test_https_connect_ssl_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.SSLError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(aiohttp.ClientConnectorSSLError):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:  \nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly terminate all open connections and resources associated with a network transport or stream response. It ensures that any ongoing operations are properly concluded and that resources are released.\n\n**How It Works**:  \nThe method is asynchronous and typically involves several steps:\n1. It checks if the transport is already closed; if so, it returns early.\n2. It marks the transport as closed to prevent further operations.\n3. It cancels any scheduled cleanup tasks to avoid unnecessary processing.\n4. It iterates through all active connections and protocols, invoking their `close` methods and collecting any associated futures that indicate when the closing operations are complete.\n5. Finally, it awaits the completion of these closing operations, handling any exceptions that may arise during the process. This ensures that all resources are properly released and that the application can safely shut down."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_resp_start_error",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 844,
            "end_line_number": 906,
            "source_code": "def test_https_connect_resp_start_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(\n                proxy_resp, \"start\", autospec=True, side_effect=OSError(\"error message\")\n            ):\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(OSError, \"error message\"):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_request_port",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 914,
            "end_line_number": 953,
            "source_code": "def test_request_port(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            tr, proto = mock.Mock(), mock.Mock()\n            tr.get_extra_info.return_value = None\n            # Called on connection to http://proxy.example.com\n            with mock.patch.object(\n                self.loop, \"create_connection\", autospec=True, return_value=(tr, proto)\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://localhost:1234/path\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                self.loop.run_until_complete(\n                    connector._create_connection(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://localhost:1234/path\"))\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any active connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and no further data can be sent or received.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any ongoing cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during the process. This ensures that the application can shut down gracefully without leaving any hanging connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": "TestProxy",
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during the process. This ensures that the application can shut down gracefully without leaving any hanging connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 44,
            "end_line_number": 99,
            "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `connector.close` method is designed to cleanly release resources associated with the connector, ensuring that any active connections are properly closed and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to close the connection associated with the protocol. After these operations, the protocol reference is set to `None`, indicating that the connector is no longer active. This method is typically used to ensure that resources are freed when the connector is no longer needed, preventing resource leaks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 44,
            "end_line_number": 99,
            "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to close a connection associated with a connector. It ensures that resources are properly released and that any ongoing operations related to the connection are terminated.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass` statement), indicating that it is a placeholder for future functionality. In the context of the surrounding code, it is called during the cleanup process, particularly in the `__aexit__` method of an asynchronous context manager, which ensures that connections are closed when exiting the context. Additionally, the method is referenced in the destructor (`__del__`), which warns if a connector is not closed properly, highlighting the importance of invoking `close` to prevent resource leaks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_headers",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 107,
            "end_line_number": 163,
            "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_headers",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 107,
            "end_line_number": 163,
            "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock(**{'transport.get_extra_info.return_value': False})"
            ],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to properly close a connection associated with a connector, ensuring that resources are released and any necessary cleanup is performed.\n\n**How It Works**:  \nThe method is defined but currently does not contain any implementation (`pass` statement). It is typically called in asynchronous contexts, such as within the `__aexit__` method of an asynchronous context manager, to ensure that the connection is closed when exiting the context. The method is expected to handle the cleanup of resources, potentially setting flags or invoking other cleanup methods to manage the state of the connection and prevent resource leaks. Additionally, if the connection is not closed properly, a warning is issued in the destructor (`__del__`), indicating that the connector was not closed, which helps in debugging resource management issues."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_dns_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 189,
            "end_line_number": 213,
            "source_code": "def test_proxy_dns_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        with mock.patch.object(\n            connector,\n            \"_resolve_host\",\n            autospec=True,\n            side_effect=OSError(\"dont take it serious\"),\n        ):\n            req = ClientRequest(\n                \"GET\",\n                URL(\"http://www.python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                loop=self.loop,\n            )\n            expected_headers = dict(req.headers)\n            with self.assertRaises(aiohttp.ClientConnectorError):\n                self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n            self.assertEqual(req.url.path, \"/\")\n            self.assertEqual(dict(req.headers), expected_headers)\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any active connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with asynchronous context management to ensure that resources are properly cleaned up when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_connection_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 220,
            "end_line_number": 252,
            "source_code": "def test_proxy_connection_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"www.python.org\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            with mock.patch.object(\n                connector._loop,\n                \"create_connection\",\n                autospec=True,\n                side_effect=OSError(\"dont take it serious\"),\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://www.python.org\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                with self.assertRaises(aiohttp.ClientProxyConnectionError):\n                    self.loop.run_until_complete(\n                        connector.connect(req, [], aiohttp.ClientTimeout())\n                    )\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any active connections are properly closed and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the associated connector to close the connection and release resources. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically used to gracefully shut down connections in a networked application, ensuring that resources are released properly and that no new messages are processed after the close request."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_default",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 260,
            "end_line_number": 333,
            "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate all open transports associated with a web application or connection, ensuring that resources are properly released and no further data can be sent or received.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if any cleanup tasks are pending and cancels them if necessary. It then marks the connection as closed and iterates through all active connections, calling their `close` methods to initiate the closing process. It collects any resulting futures (awaitable objects) that indicate the closure status of these connections. Finally, it uses `asyncio.gather` to wait for all closure operations to complete, handling any exceptions that may arise during this process. This method is crucial for maintaining resource integrity and preventing memory leaks in asynchronous applications."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the associated connector to close the connection and release resources. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:  \nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_proxy_server_hostname_override",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 341,
            "end_line_number": 417,
            "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate all open transports associated with a web application or connection, ensuring that resources are properly released and no further data can be sent or received.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any ongoing cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during the process. This method is typically used in the context of shutting down a web server or cleaning up resources when they are no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically used to gracefully shut down connections in a networked application, ensuring that resources are released properly and that no new messages are accepted after the close request."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 534,
            "end_line_number": 608,
            "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_certificate_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 616,
            "end_line_number": 685,
            "source_code": "def test_https_connect_certificate_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.CertificateError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(\n                                aiohttp.ClientConnectorCertificateError\n                            ):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `connector.close` method is designed to cleanly release resources associated with the connector, ensuring that any active connections are properly closed and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to close the connection associated with the protocol. After these operations, the protocol reference is set to `None`, indicating that the connector is no longer active. This method is typically used to ensure that resources are freed when the connector is no longer needed, preventing resource leaks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_ssl_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 693,
            "end_line_number": 760,
            "source_code": "def test_https_connect_ssl_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.SSLError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(aiohttp.ClientConnectorSSLError):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any active connections are properly closed and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the connector to close the connection associated with the protocol. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are released when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_http_proxy_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 768,
            "end_line_number": 836,
            "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_resp_start_error",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 844,
            "end_line_number": 906,
            "source_code": "def test_https_connect_resp_start_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(\n                proxy_resp, \"start\", autospec=True, side_effect=OSError(\"error message\")\n            ):\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(OSError, \"error message\"):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_request_port",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 914,
            "end_line_number": 953,
            "source_code": "def test_request_port(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            tr, proto = mock.Mock(), mock.Mock()\n            tr.get_extra_info.return_value = None\n            # Called on connection to http://proxy.example.com\n            with mock.patch.object(\n                self.loop, \"create_connection\", autospec=True, return_value=(tr, proto)\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://localhost:1234/path\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                self.loop.run_until_complete(\n                    connector._create_connection(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://localhost:1234/path\"))\n        self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_connect_pass_ssl_context",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 980,
            "end_line_number": 1062,
            "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open connections and resources associated with a network transport, ensuring that no lingering connections remain after the operation.\n\n**How It Works**:\nThe method initiates the closing process by marking the transport as closed and canceling any ongoing cleanup tasks. It then iterates through all active connections, invoking their `close` methods and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This ensures that all resources are properly released and that the application can safely shut down or transition to a different state."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and marks it as `None`, effectively closing the connection. This method is typically used in conjunction with asynchronous context management (via `__aexit__`) to ensure that resources are released when a session or connection is no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "proxy_req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for some condition), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_https_auth",
            "module": "test_proxy",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
            "line_number": 1070,
            "end_line_number": 1156,
            "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
            ],
            "arguments": [
                "self",
                "start_connection",
                "ClientRequestMock"
            ],
            "imports": [
                "asyncio",
                "gc",
                "socket",
                "ssl",
                "unittest",
                "unittest.mock",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.patch('aiohttp.connector.ClientRequest')",
                "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "req.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open connections and resources associated with a network transport or stream response. It ensures that any ongoing operations are properly concluded and that resources are released.\n\n**How It Works**:\nThe method is asynchronous and typically involves several steps:\n1. It checks if the transport is already closed; if so, it returns early.\n2. It marks the transport as closed to prevent further operations.\n3. It cancels any scheduled cleanup tasks to avoid unnecessary processing.\n4. It iterates through all active connections and protocols, invoking their `close` methods and collecting any associated futures (waiters) that indicate when the closure is complete.\n5. Finally, it awaits the completion of these futures, handling any exceptions that may arise during the closure process, ensuring that errors are logged appropriately.\n\nThis method is crucial for maintaining resource integrity and preventing memory leaks in applications that manage multiple network connections."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_simple_get_requests",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 11,
            "end_line_number": 33,
            "source_code": "def test_one_hundred_simple_get_requests(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 simple GET requests.\"\"\"\n    message_count = 100\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            await client.get(\"/\")\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 simple GET requests.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_simple_get_requests_multiple_methods_route",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 36,
            "end_line_number": 61,
            "source_code": "def test_one_hundred_simple_get_requests_multiple_methods_route(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 simple GET requests on a route with multiple methods.\"\"\"\n    message_count = 100\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()\n\n    app = web.Application()\n    # GET intentionally registered last to ensure time complexity\n    # of the route lookup is benchmarked\n    for method in (\"DELETE\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\", \"GET\"):\n        app.router.add_route(method, \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            await client.get(\"/\")\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 simple GET requests on a route with multiple methods.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning that calling it multiple times will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_1024_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 64,
            "end_line_number": 90,
            "source_code": "def test_one_hundred_get_requests_with_1024_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a small payload of 1024 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 1024\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a small payload of 1024 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen invoked, the `close` method first calls `_notify_release`, which executes any registered callbacks and clears the callback list. It then checks if a protocol is active; if so, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_1024_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 64,
            "end_line_number": 90,
            "source_code": "def test_one_hundred_get_requests_with_1024_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a small payload of 1024 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 1024\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a small payload of 1024 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In the context of the surrounding code snippets, this method is likely part of a larger class that handles reading from a data stream, potentially involving content transfer encoding and decoding. The method's implementation suggests that it may be a placeholder or a simplified version for demonstration purposes, as it does not currently process any actual stream data or handle the decoding logic."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_30000_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 93,
            "end_line_number": 119,
            "source_code": "def test_one_hundred_get_requests_with_30000_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 30000 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 30000\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 30000 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_30000_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 93,
            "end_line_number": 119,
            "source_code": "def test_one_hundred_get_requests_with_30000_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 30000 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 30000\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 30000 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It can optionally decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In the context of the surrounding code snippets, this method is likely part of a larger class that handles reading data from a stream, potentially with support for different content transfer encodings. The method's implementation suggests that it may be a placeholder or a simplified version of a more complex reading mechanism that would handle actual data processing in a complete implementation."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_512kib_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 122,
            "end_line_number": 148,
            "source_code": "def test_one_hundred_get_requests_with_512kib_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 512KiB.\"\"\"\n    message_count = 100\n    payload = b\"a\" * (2**19)\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 512KiB.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_512kib_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 122,
            "end_line_number": 148,
            "source_code": "def test_one_hundred_get_requests_with_512kib_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 512KiB.\"\"\"\n    message_count = 100\n    payload = b\"a\" * (2**19)\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload)\n        resp.enable_chunked_encoding()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 512KiB.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In the context of the surrounding code snippets, this method is likely part of a larger class that handles reading from a data stream, potentially involving content transfer encoding. The method's implementation suggests that it may be a placeholder or a simplified version for demonstration purposes, as it does not currently process any actual stream data or handle the decoding logic."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_get_request_with_251308_compressed_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 151,
            "end_line_number": 182,
            "source_code": "def test_get_request_with_251308_compressed_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark compressed GET requests with a payload of 251308.\"\"\"\n    # This payload compresses to 251308 bytes\n    payload = b\"\".join(\n        [\n            bytes((*range(0, i), *range(i, 0, -1)))\n            for _ in range(255)\n            for i in range(255)\n        ]\n    )\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload, zlib_executor_size=16384)\n        resp.enable_compression()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.get(\"/\")\n        await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark compressed GET requests with a payload of 251308.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In the context of the surrounding code snippets, this method is likely part of a larger class that handles reading from a data stream, potentially involving content transfer encoding and handling different data formats. The method's implementation suggests that it may be a placeholder or a simplified version of a more complex reading mechanism that would typically involve decoding the stream's content based on the specified encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_get_request_with_251308_compressed_chunked_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 151,
            "end_line_number": 182,
            "source_code": "def test_get_request_with_251308_compressed_chunked_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark compressed GET requests with a payload of 251308.\"\"\"\n    # This payload compresses to 251308 bytes\n    payload = b\"\".join(\n        [\n            bytes((*range(0, i), *range(i, 0, -1)))\n            for _ in range(255)\n            for i in range(255)\n        ]\n    )\n\n    async def handler(request: web.Request) -> web.Response:\n        resp = web.Response(body=payload, zlib_executor_size=16384)\n        resp.enable_compression()\n        return resp\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.get(\"/\")\n        await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark compressed GET requests with a payload of 251308.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it instructs the connector to release the protocol, indicating that it should be closed. The protocol reference is then set to `None`, effectively marking the client as closed. This method is idempotent, meaning that calling it multiple times will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_1024_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 185,
            "end_line_number": 210,
            "source_code": "def test_one_hundred_get_requests_with_1024_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a small payload of 1024 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 1024\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a small payload of 1024 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_1024_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 185,
            "end_line_number": 210,
            "source_code": "def test_one_hundred_get_requests_with_1024_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a small payload of 1024 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 1024\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a small payload of 1024 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In a broader context, this method would typically be used to read and process data from a body part of a multipart message, potentially applying decoding if the `decode` parameter is set to `True`. The relevant tests indicate that the method interacts with various content transfer encodings, ensuring that the data is read correctly based on the specified encoding type."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_30000_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 213,
            "end_line_number": 238,
            "source_code": "def test_one_hundred_get_requests_with_30000_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 30000 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 30000\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 30000 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_30000_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 213,
            "end_line_number": 238,
            "source_code": "def test_one_hundred_get_requests_with_30000_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 30000 bytes.\"\"\"\n    message_count = 100\n    payload = b\"a\" * 30000\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 30000 bytes.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In a broader context, this method would typically be used to read and process data from a stream, potentially applying decoding if the `decode` parameter is set to `True`. However, in its current implementation, it does not perform any actual reading or decoding of data."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_512kib_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 241,
            "end_line_number": 266,
            "source_code": "def test_one_hundred_get_requests_with_512kib_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 512KiB.\"\"\"\n    message_count = 100\n    payload = b\"a\" * (2**19)\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 512KiB.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_get_requests_with_512kib_content_length_payload",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 241,
            "end_line_number": 266,
            "source_code": "def test_one_hundred_get_requests_with_512kib_content_length_payload(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 GET requests with a payload of 512KiB.\"\"\"\n    message_count = 100\n    payload = b\"a\" * (2**19)\n    headers = {hdrs.CONTENT_LENGTH: str(len(payload))}\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response(body=payload, headers=headers)\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            resp = await client.get(\"/\")\n            await resp.read()\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 GET requests with a payload of 512KiB.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.read",
                    "body": "def read(self, decode: bool=False) -> str:\n    return 'customized!'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `read` method is designed to read data from a stream and return it as a string. It includes an option to decode the data based on the specified encoding.\n\n**How It Works**:  \nThe method takes a single optional parameter, `decode`, which defaults to `False`. When called, it returns a hardcoded string `'customized!'`. In the context of the surrounding code snippets, this method is likely part of a larger class that handles reading from a data stream, potentially involving content transfer encoding and other processing. The actual reading and decoding logic would be implemented elsewhere, as this method currently serves as a placeholder or a simplified version for demonstration purposes."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_hundred_simple_post_requests",
            "module": "test_benchmarks_client",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client.py",
            "line_number": 269,
            "end_line_number": 291,
            "source_code": "def test_one_hundred_simple_post_requests(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark 100 simple POST requests.\"\"\"\n    message_count = 100\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()\n\n    app = web.Application()\n    app.router.add_route(\"POST\", \"/\", handler)\n\n    async def run_client_benchmark() -> None:\n        client = await aiohttp_client(app)\n        for _ in range(message_count):\n            await client.post(\"/\", data=b\"any\")\n        await client.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_client_benchmark())",
            "docstring": "Benchmark 100 simple POST requests.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen invoked, the `close` method first calls `_notify_release`, which executes any registered callbacks and clears the callback list. It then checks if a protocol is active; if so, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_can_prepare_ok",
            "module": "test_web_websocket",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
            "line_number": 206,
            "end_line_number": 209,
            "source_code": "def test_can_prepare_ok(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\", protocols=True)\n    ws = web.WebSocketResponse(protocols=(\"chat\",))\n    assert WebSocketReady(True, \"chat\") == ws.can_prepare(req)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "time",
                "typing.Optional",
                "typing.Protocol",
                "unittest.mock",
                "aiosignal",
                "pytest",
                "multidict.CIMultiDict",
                "pytest_mock.MockerFixture",
                "aiohttp.WSMessageTypeError",
                "aiohttp.WSMsgType",
                "aiohttp.web",
                "aiohttp.http.WS_CLOSED_MESSAGE",
                "aiohttp.http.WS_CLOSING_MESSAGE",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.streams.EofStream",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_ws.WebSocketReady"
            ],
            "fixtures": [],
            "assertions": [
                "assert WebSocketReady(True, 'chat') == ws.can_prepare(req)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_can_prepare_unknown_protocol",
            "module": "test_web_websocket",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
            "line_number": 212,
            "end_line_number": 215,
            "source_code": "def test_can_prepare_unknown_protocol(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\")\n    ws = web.WebSocketResponse()\n    assert WebSocketReady(True, None) == ws.can_prepare(req)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "time",
                "typing.Optional",
                "typing.Protocol",
                "unittest.mock",
                "aiosignal",
                "pytest",
                "multidict.CIMultiDict",
                "pytest_mock.MockerFixture",
                "aiohttp.WSMessageTypeError",
                "aiohttp.WSMsgType",
                "aiohttp.web",
                "aiohttp.http.WS_CLOSED_MESSAGE",
                "aiohttp.http.WS_CLOSING_MESSAGE",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.streams.EofStream",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_ws.WebSocketReady"
            ],
            "fixtures": [],
            "assertions": [
                "assert WebSocketReady(True, None) == ws.can_prepare(req)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_can_prepare_without_upgrade",
            "module": "test_web_websocket",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
            "line_number": 218,
            "end_line_number": 221,
            "source_code": "def test_can_prepare_without_upgrade(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\", headers=CIMultiDict({}))\n    ws = web.WebSocketResponse()\n    assert WebSocketReady(False, None) == ws.can_prepare(req)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "time",
                "typing.Optional",
                "typing.Protocol",
                "unittest.mock",
                "aiosignal",
                "pytest",
                "multidict.CIMultiDict",
                "pytest_mock.MockerFixture",
                "aiohttp.WSMessageTypeError",
                "aiohttp.WSMsgType",
                "aiohttp.web",
                "aiohttp.http.WS_CLOSED_MESSAGE",
                "aiohttp.http.WS_CLOSING_MESSAGE",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.streams.EofStream",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_ws.WebSocketReady"
            ],
            "fixtures": [],
            "assertions": [
                "assert WebSocketReady(False, None) == ws.can_prepare(req)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_register_uncommon_http_methods",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 59,
            "end_line_number": 73,
            "source_code": "def test_register_uncommon_http_methods(router: web.UrlDispatcher) -> None:\n    uncommon_http_methods = {\n        \"PROPFIND\",\n        \"PROPPATCH\",\n        \"COPY\",\n        \"LOCK\",\n        \"UNLOCK\",\n        \"MOVE\",\n        \"SUBSCRIBE\",\n        \"UNSUBSCRIBE\",\n        \"NOTIFY\",\n    }\n\n    for method in uncommon_http_methods:\n        router.add_route(method, \"/handler/to/path\", make_handler())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:\nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_invalid_path",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 218,
            "end_line_number": 221,
            "source_code": "def test_add_invalid_path(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"GET\", \"/{/\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_url_invalid1",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 224,
            "end_line_number": 227,
            "source_code": "def test_add_url_invalid1(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_url_invalid2",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 230,
            "end_line_number": 233,
            "source_code": "def test_add_url_invalid2(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id{}}\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_url_invalid3",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 236,
            "end_line_number": 239,
            "source_code": "def test_add_url_invalid3(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id{}\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_url_invalid4",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 242,
            "end_line_number": 245,
            "source_code": "def test_add_url_invalid4(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", '/post/{id\"}', handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_double_add_url_with_the_same_name",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 328,
            "end_line_number": 335,
            "source_code": "def test_double_add_url_with_the_same_name(router: web.UrlDispatcher) -> None:\n    handler1 = make_handler()\n    handler2 = make_handler()\n    router.add_route(\"GET\", \"/get\", handler1, name=\"name\")\n\n    with pytest.raises(ValueError) as ctx:\n        router.add_route(\"GET\", \"/get_other\", handler2, name=\"name\")\n    assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the request's application context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_double_add_url_with_the_same_name",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 328,
            "end_line_number": 335,
            "source_code": "def test_double_add_url_with_the_same_name(router: web.UrlDispatcher) -> None:\n    handler1 = make_handler()\n    handler2 = make_handler()\n    router.add_route(\"GET\", \"/get\", handler1, name=\"name\")\n\n    with pytest.raises(ValueError) as ctx:\n        router.add_route(\"GET\", \"/get_other\", handler2, name=\"name\")\n    assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_plain",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 338,
            "end_line_number": 344,
            "source_code": "def test_route_plain(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", \"/get\", handler, name=\"name\")\n    route2 = next(iter(router[\"name\"]))\n    url = route2.url_for()\n    assert \"/get\" == str(url)\n    assert route is route2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/get' == str(url)",
                "assert route is route2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_dynamic",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 352,
            "end_line_number": 359,
            "source_code": "def test_route_dynamic(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", \"/get/{name}\", handler, name=\"name\")\n\n    route2 = next(iter(router[\"name\"]))\n    url = route2.url_for(name=\"John\")\n    assert \"/get/John\" == str(url)\n    assert route is route2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/get/John' == str(url)",
                "assert route is route2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_plain_not_match",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 503,
            "end_line_number": 508,
            "source_code": "def test_plain_not_match(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/path\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert route._match(\"/another/path\") is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(route, web.Resource)",
                "assert route._match('/another/path') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_dynamic_not_match",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 511,
            "end_line_number": 516,
            "source_code": "def test_dynamic_not_match(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/{name}\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert route._match(\"/another/path\") is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(route, web.Resource)",
                "assert route._match('/another/path') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and processes incoming requests while appending specific application-related information to a shared list.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `web.Request` object. When a request is received, the handler appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this inner handler function, allowing it to be used as a route handler in an aiohttp web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_dynamic_with_trailing_slash",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 562,
            "end_line_number": 567,
            "source_code": "def test_dynamic_with_trailing_slash(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/{name}/\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert {\"name\": \"John\"} == route._match(\"/get/John/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(route, web.Resource)",
                "assert {'name': 'John'} == route._match('/get/John/')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_len",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 570,
            "end_line_number": 574,
            "source_code": "def test_len(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert 2 == len(router)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert 2 == len(router)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_iter",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 577,
            "end_line_number": 581,
            "source_code": "def test_iter(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert {\"name1\", \"name2\"} == set(iter(router))",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert {'name1', 'name2'} == set(iter(router))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the request's application context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_contains",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 584,
            "end_line_number": 589,
            "source_code": "def test_contains(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert \"name1\" in router\n    assert \"name3\" not in router",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'name1' in router",
                "assert 'name3' not in router"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method ultimately returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_route_with_invalid_re",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 663,
            "end_line_number": 675,
            "source_code": "def test_add_route_with_invalid_re(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError) as ctx:\n        router.add_route(\"GET\", r\"/handler/{to:+++}\", handler)\n    s = str(ctx.value)\n    assert s.startswith(\n        \"Bad pattern '\"\n        + PATH_SEP\n        + \"handler\"\n        + PATH_SEP\n        + \"(?P<to>+++)': nothing to repeat\"\n    )\n    assert ctx.value.__cause__ is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert s.startswith(\"Bad pattern '\" + PATH_SEP + 'handler' + PATH_SEP + \"(?P<to>+++)': nothing to repeat\")",
                "assert ctx.value.__cause__ is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_dynamic_with_regex_spec",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 678,
            "end_line_number": 683,
            "source_code": "def test_route_dynamic_with_regex_spec(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/get/{num:^\\d+}\", handler, name=\"name\")\n\n    url = route.url_for(num=\"123\")\n    assert \"/get/123\" == str(url)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/get/123' == str(url)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_dynamic_with_regex_spec_and_trailing_slash",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 686,
            "end_line_number": 693,
            "source_code": "def test_route_dynamic_with_regex_spec_and_trailing_slash(\n    router: web.UrlDispatcher,\n) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/get/{num:^\\d+}/\", handler, name=\"name\")\n\n    url = route.url_for(num=\"123\")\n    assert \"/get/123/\" == str(url)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/get/123/' == str(url)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_dynamic_with_regex",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 696,
            "end_line_number": 701,
            "source_code": "def test_route_dynamic_with_regex(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/{one}/{two:.+}\", handler)\n\n    url = route.url_for(one=\"1\", two=\"2\")\n    assert \"/1/2\" == str(url)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/1/2' == str(url)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_route_dynamic_quoting",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 704,
            "end_line_number": 713,
            "source_code": "def test_route_dynamic_quoting(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/\u043f\u0440\u0435 %2F\u0444\u0438\u043a\u0441/{arg}\", handler)\n\n    url = route.url_for(arg=\"1 2/\u0442\u0435\u043a\u0441\u0442%2F\")\n    assert url.path == \"/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0442\u0435\u043a\u0441\u0442%2F\"\n    assert str(url) == (\n        \"/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81\"\n        \"/1%202/%D1%82%D0%B5%D0%BA%D1%81%D1%82%252F\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert url.path == '/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0442\u0435\u043a\u0441\u0442%2F'",
                "assert str(url) == '/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81/1%202/%D1%82%D0%B5%D0%BA%D1%81%D1%82%252F'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_default_expect_handler",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 754,
            "end_line_number": 756,
            "source_code": "def test_default_expect_handler(router: web.UrlDispatcher) -> None:\n    route = router.add_route(\"GET\", \"/\", make_handler())\n    assert route._expect_handler is _default_expect_handler",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert route._expect_handler is _default_expect_handler"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:\nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_custom_expect_handler_plain",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 759,
            "end_line_number": 765,
            "source_code": "def test_custom_expect_handler_plain(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    route = router.add_route(\"GET\", \"/\", make_handler(), expect_handler=handler)\n    assert route._expect_handler is handler\n    assert isinstance(route, web.ResourceRoute)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert route._expect_handler is handler",
                "assert isinstance(route, web.ResourceRoute)",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_custom_expect_handler_dynamic",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 768,
            "end_line_number": 776,
            "source_code": "def test_custom_expect_handler_dynamic(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    route = router.add_route(\n        \"GET\", \"/get/{name}\", make_handler(), expect_handler=handler\n    )\n    assert route._expect_handler is handler\n    assert isinstance(route, web.ResourceRoute)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert route._expect_handler is handler",
                "assert isinstance(route, web.ResourceRoute)",
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_expect_handler_non_coroutine",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 779,
            "end_line_number": 784,
            "source_code": "def test_expect_handler_non_coroutine(router: web.UrlDispatcher) -> None:\n    def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    with pytest.raises(AssertionError):\n        router.add_route(\"GET\", \"/\", make_handler(), expect_handler=handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_route_not_started_with_slash",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 833,
            "end_line_number": 836,
            "source_code": "def test_add_route_not_started_with_slash(router: web.UrlDispatcher) -> None:\n    with pytest.raises(ValueError):\n        handler = make_handler()\n        router.add_route(\"GET\", \"invalid_path\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_add_route_invalid_method",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 839,
            "end_line_number": 852,
            "source_code": "def test_add_route_invalid_method(router: web.UrlDispatcher) -> None:\n    sample_bad_methods = {\n        \"BAD METHOD\",\n        \"B@D_METHOD\",\n        \"[BAD_METHOD]\",\n        \"{BAD_METHOD}\",\n        \"(BAD_METHOD)\",\n        \"B?D_METHOD\",\n    }\n\n    for bad_method in sample_bad_methods:\n        with pytest.raises(ValueError):\n            handler = make_handler()\n            router.add_route(bad_method, \"/path\", handler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_routes_view_len",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 855,
            "end_line_number": 859,
            "source_code": "def test_routes_view_len(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    fill_routes()\n    assert 4 == len(router.routes())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router",
                "fill_routes"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert 4 == len(router.routes())"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fill_routes",
                    "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `fill_routes` method is a pytest fixture designed to set up and return a list of routes for an `aiohttp` web application. It adds specific routes to a `UrlDispatcher` instance, which can be used in tests to verify routing behavior.\n\n**How It Works**:\nThe method defines an inner function `go` that adds two GET routes (`/plain` and `/variable/{name}`) to the provided `router` instance. It also adds a static resource route that serves files from a specified directory. The `go` function returns a list containing the created routes, which can be utilized in test cases to ensure that the routing is correctly configured. The outer function `fill_routes` is decorated with `@pytest.fixture`, allowing it to be used as a fixture in pytest tests, providing a consistent setup for route testing."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_routes_view_iter",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 862,
            "end_line_number": 866,
            "source_code": "def test_routes_view_iter(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    routes = fill_routes()\n    assert list(routes) == list(router.routes())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router",
                "fill_routes"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(routes) == list(router.routes())"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fill_routes",
                    "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `fill_routes` method is a pytest fixture designed to set up and return a list of routes for an `aiohttp` web application. It adds specific routes to a `UrlDispatcher` instance, which can be used in tests to verify routing behavior.\n\n**How It Works**:\nThe method defines an inner function `go` that adds two GET routes (`/plain` and `/variable/{name}`) to the provided `router` instance. It also adds a static resource route pointing to a directory containing static files. The `go` function returns a list of the created routes, which includes both the dynamic routes and the static resource. The outer function, decorated with `@pytest.fixture`, allows it to be used in test cases, providing a pre-configured router with the specified routes for testing purposes."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_routes_view_contains",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 869,
            "end_line_number": 874,
            "source_code": "def test_routes_view_contains(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    routes = fill_routes()\n    for route in routes:\n        assert route in router.routes()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router",
                "fill_routes"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert route in router.routes()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fill_routes",
                    "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `fill_routes` method is a pytest fixture designed to set up and return a list of routes for an `aiohttp` web application. It adds specific routes to a `UrlDispatcher` instance, which can be used in tests to verify routing behavior.\n\n**How It Works**:\nThe method defines an inner function `go` that adds two GET routes (`/plain` and `/variable/{name}`) to the provided `router` instance. It also adds a static resource route pointing to a directory containing static files. The `go` function returns a list of all the added routes, which includes the two dynamic routes and any static routes. The outer function `fill_routes` is decorated with `@pytest.fixture`, allowing it to be used in test functions to provide a pre-configured router with the specified routes."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_named_resources",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 888,
            "end_line_number": 901,
            "source_code": "def test_named_resources(router: web.UrlDispatcher) -> None:\n    route1 = router.add_route(\"GET\", \"/plain\", make_handler(), name=\"route1\")\n    route2 = router.add_route(\"GET\", \"/variable/{name}\", make_handler(), name=\"route2\")\n    route3 = router.add_static(\n        \"/static\", pathlib.Path(aiohttp.__file__).parent, name=\"route3\"\n    )\n    names = {route1.name, route2.name, route3.name}\n\n    assert 3 == len(router.named_resources())\n\n    for name in names:\n        assert name is not None\n        assert name in router.named_resources()\n        assert isinstance(router.named_resources()[name], web.AbstractResource)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert 3 == len(router.named_resources())",
                "assert name is not None",
                "assert name in router.named_resources()",
                "assert isinstance(router.named_resources()[name], web.AbstractResource)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:\nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_named_resources",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 888,
            "end_line_number": 901,
            "source_code": "def test_named_resources(router: web.UrlDispatcher) -> None:\n    route1 = router.add_route(\"GET\", \"/plain\", make_handler(), name=\"route1\")\n    route2 = router.add_route(\"GET\", \"/variable/{name}\", make_handler(), name=\"route2\")\n    route3 = router.add_static(\n        \"/static\", pathlib.Path(aiohttp.__file__).parent, name=\"route3\"\n    )\n    names = {route1.name, route2.name, route3.name}\n\n    assert 3 == len(router.named_resources())\n\n    for name in names:\n        assert name is not None\n        assert name in router.named_resources()\n        assert isinstance(router.named_resources()[name], web.AbstractResource)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert 3 == len(router.named_resources())",
                "assert name is not None",
                "assert name in router.named_resources()",
                "assert isinstance(router.named_resources()[name], web.AbstractResource)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_url_for_in_resource_route",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1101,
            "end_line_number": 1103,
            "source_code": "def test_url_for_in_resource_route(router: web.UrlDispatcher) -> None:\n    route = router.add_route(\"GET\", \"/get/{name}\", make_handler(), name=\"name\")\n    assert URL(\"/get/John\") == route.url_for(name=\"John\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert URL('/get/John') == route.url_for(name='John')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_subapp_rule_resource",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1158,
            "end_line_number": 1172,
            "source_code": "def test_subapp_rule_resource(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.router.add_get(\"/\", make_handler())\n    rule = Domain(\"example.com\")\n    assert rule.get_info() == {\"domain\": \"example.com\"}\n    resource = app.add_domain(\"example.com\", subapp)\n    assert resource.canonical == \"example.com\"\n    assert resource.get_info() == {\"rule\": resource._rule, \"app\": subapp}\n    resource.add_prefix(\"/a\")\n    resource.raw_match(\"/b\")\n    assert len(resource)\n    assert list(resource)\n    assert repr(resource).startswith(\"<MatchedSubAppResource\")\n    with pytest.raises(RuntimeError):\n        resource.url_for()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert rule.get_info() == {'domain': 'example.com'}",
                "assert resource.canonical == 'example.com'",
                "assert resource.get_info() == {'rule': resource._rule, 'app': subapp}",
                "assert len(resource)",
                "assert list(resource)",
                "assert repr(resource).startswith('<MatchedSubAppResource')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_subapp_len",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1231,
            "end_line_number": 1236,
            "source_code": "def test_subapp_len(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert len(resource) == 2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(resource) == 2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_subapp_len",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1231,
            "end_line_number": 1236,
            "source_code": "def test_subapp_len(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert len(resource) == 2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(resource) == 2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_subapp_iter",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1239,
            "end_line_number": 1244,
            "source_code": "def test_subapp_iter(app: web.Application) -> None:\n    subapp = web.Application()\n    r1 = subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    r2 = subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert list(resource) == [r1, r2]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(resource) == [r1, r2]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the request's application context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_subapp_iter",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1239,
            "end_line_number": 1244,
            "source_code": "def test_subapp_iter(app: web.Application) -> None:\n    subapp = web.Application()\n    r1 = subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    r2 = subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert list(resource) == [r1, r2]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(resource) == [r1, r2]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_invalid_route_name",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1254,
            "end_line_number": 1256,
            "source_code": "def test_invalid_route_name(router: web.UrlDispatcher, route_name: str) -> None:\n    with pytest.raises(ValueError):\n        router.add_get(\"/\", make_handler(), name=route_name)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('route_name', ('invalid name', 'class'))"
            ],
            "arguments": [
                "router",
                "route_name"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the request's application context to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application. This pattern is useful for creating customized handlers that maintain state or context based on the provided `appname`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_frozen_router",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1259,
            "end_line_number": 1262,
            "source_code": "def test_frozen_router(router: web.UrlDispatcher) -> None:\n    router.freeze()\n    with pytest.raises(RuntimeError):\n        router.add_get(\"/\", make_handler())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_set_options_route",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1279,
            "end_line_number": 1293,
            "source_code": "def test_set_options_route(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/static\", pathlib.Path(aiohttp.__file__).parent)\n    options = None\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is None\n    resource.set_options_route(make_handler())\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is not None\n\n    with pytest.raises(RuntimeError):\n        resource.set_options_route(make_handler())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert options is None",
                "assert options is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes an application name (`appname`) as an argument and defines an inner asynchronous function `handler`. This `handler` function processes incoming web requests, appending a formatted string containing the `appname` and a value from the request's application context (`request.app[my_value]`) to a list called `values`. It then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_set_options_route",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1279,
            "end_line_number": 1293,
            "source_code": "def test_set_options_route(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/static\", pathlib.Path(aiohttp.__file__).parent)\n    options = None\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is None\n    resource.set_options_route(make_handler())\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is not None\n\n    with pytest.raises(RuntimeError):\n        resource.set_options_route(make_handler())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert options is None",
                "assert options is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs a specific value associated with the application name whenever a request is received.\n\n**How It Works**:\nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler` that accepts a `request` object. Inside this handler, it appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`. The handler then returns a simple HTTP response with the text 'Ok'. Finally, `make_handler` returns the `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_dynamic_url_with_name_started_from_underscore",
            "module": "test_urldispatch",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
            "line_number": 1296,
            "end_line_number": 1300,
            "source_code": "def test_dynamic_url_with_name_started_from_underscore(\n    router: web.UrlDispatcher,\n) -> None:\n    route = router.add_route(\"GET\", \"/get/{_name}\", make_handler())\n    assert URL(\"/get/John\") == route.url_for(_name=\"John\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "router"
            ],
            "imports": [
                "asyncio",
                "pathlib",
                "re",
                "collections.abc.Container",
                "collections.abc.Iterable",
                "collections.abc.Mapping",
                "collections.abc.MutableMapping",
                "collections.abc.Sized",
                "functools.partial",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Type",
                "urllib.parse.quote",
                "urllib.parse.unquote",
                "pytest",
                "yarl.URL",
                "aiohttp",
                "aiohttp.hdrs",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_urldispatcher.PATH_SEP",
                "aiohttp.web_urldispatcher.Domain",
                "aiohttp.web_urldispatcher.MaskDomain",
                "aiohttp.web_urldispatcher.SystemRoute",
                "aiohttp.web_urldispatcher._default_expect_handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert URL('/get/John') == route.url_for(_name='John')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_handler",
                    "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `make_handler` method is designed to create an asynchronous request handler for a web application, which captures and logs specific application-related values from incoming requests.\n\n**How It Works**:  \nThe method takes a string parameter `appname` and defines an inner asynchronous function `handler`. This `handler` function accepts a `request` object, appends a formatted string containing the `appname` and a value from the application's context (retrieved using `request.app[my_value]`) to a list called `values`, and then returns a simple HTTP response with the text 'Ok'. The `make_handler` method returns this `handler` function, allowing it to be used as a route handler in a web application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 141,
            "end_line_number": 144,
            "source_code": "def test_basic_auth_decode(header: str) -> None:\n    auth = helpers.BasicAuth.decode(header)\n    assert auth.login == \"nkim\"\n    assert auth.password == \"pwd\"",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('header', ('Basic bmtpbTpwd2Q=', 'basic bmtpbTpwd2Q='))"
            ],
            "arguments": [
                "header"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [
                "assert auth.login == 'nkim'",
                "assert auth.password == 'pwd'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The encoded credentials are decoded from base64. If the decoding fails, it raises a `ValueError`.\n5. The decoded string is split into a username and password using a colon (`:`) as the delimiter. If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` object initialized with the extracted username, password, and encoding. \n\nThis method is crucial for handling basic authentication in web applications, allowing for secure user credential management."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_invalid",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 147,
            "end_line_number": 149,
            "source_code": "def test_basic_auth_invalid() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"bmtpbTpwd2Q=\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header, validating the format and encoding.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header is improperly formatted, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The encoded credentials are decoded from base64. If the decoding fails, it raises a `ValueError`.\n5. The decoded string is split into a username and password using a colon (`:`). If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` instance initialized with the extracted username, password, and encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode_not_basic",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 152,
            "end_line_number": 154,
            "source_code": "def test_basic_auth_decode_not_basic() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"Complex bmtpbTpwd2Q=\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The encoded credentials are then base64-decoded. If the decoding fails, it raises a `ValueError`.\n5. The decoded string is split into a username and password using a colon (`:`) as the delimiter. If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` object initialized with the extracted username, password, and encoding. \n\nThis method is crucial for handling HTTP basic authentication by converting the encoded credentials from the header into a usable format."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode_bad_base64",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 157,
            "end_line_number": 159,
            "source_code": "def test_basic_auth_decode_bad_base64() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"Basic bmtpbTpwd2Q\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The method decodes the base64-encoded credentials into a string using the specified encoding. If decoding fails, it raises a `ValueError`.\n5. It then splits the decoded string into a username and password using a colon as the delimiter. If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` object initialized with the extracted username, password, and encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode_illegal_chars_base64",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 163,
            "end_line_number": 165,
            "source_code": "def test_basic_auth_decode_illegal_chars_base64(header: str) -> None:\n    with pytest.raises(ValueError, match=\"Invalid base64 encoding.\"):\n        helpers.BasicAuth.decode(header)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('header', ('Basic ???', 'Basic   '))"
            ],
            "arguments": [
                "header"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The method then decodes the base64-encoded credentials and decodes them using the specified encoding. If the base64 decoding fails, it raises a `ValueError`.\n5. Finally, it splits the decoded string into a username and password, raising a `ValueError` if the format is invalid, and returns a new `BasicAuth` object initialized with the extracted credentials."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode_invalid_credentials",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 168,
            "end_line_number": 171,
            "source_code": "def test_basic_auth_decode_invalid_credentials() -> None:\n    with pytest.raises(ValueError, match=\"Invalid credentials.\"):\n        header = \"Basic {}\".format(base64.b64encode(b\"username\").decode())\n        helpers.BasicAuth.decode(header)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The method decodes the base64-encoded credentials into a string using the specified encoding. If decoding fails, it raises a `ValueError`.\n5. It then splits the decoded string into a username and password using a colon as the delimiter. If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` object initialized with the extracted username, password, and encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_decode_blank_username",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 192,
            "end_line_number": 196,
            "source_code": "def test_basic_auth_decode_blank_username(\n    credentials: str, expected_auth: helpers.BasicAuth\n) -> None:\n    header = f\"Basic {base64.b64encode(credentials.encode()).decode()}\"\n    assert helpers.BasicAuth.decode(header) == expected_auth",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('credentials, expected_auth', ((':', helpers.BasicAuth(login='', password='', encoding='latin1')), ('username:', helpers.BasicAuth(login='username', password='', encoding='latin1')), (':password', helpers.BasicAuth(login='', password='password', encoding='latin1')), ('username:password', helpers.BasicAuth(login='username', password='password', encoding='latin1'))))"
            ],
            "arguments": [
                "credentials",
                "expected_auth"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [
                "assert helpers.BasicAuth.decode(header) == expected_auth"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "helpers.BasicAuth.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts the username and password from the header for use in HTTP basic authentication.\n\n**How It Works**:\n1. The method takes an `auth_header` string and an optional `encoding` parameter (defaulting to \"latin1\").\n2. It splits the `auth_header` into the authentication type and the encoded credentials. If the header cannot be parsed correctly, it raises a `ValueError`.\n3. It checks if the authentication type is \"basic\". If not, it raises a `ValueError`.\n4. The encoded credentials are then base64-decoded. If the decoding fails, it raises a `ValueError`.\n5. The decoded string is split into a username and password using a colon (`:`) as the delimiter. If this fails, it raises a `ValueError`.\n6. Finally, it returns a new `BasicAuth` instance initialized with the extracted username, password, and encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_timeout_handle",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 286,
            "end_line_number": 292,
            "source_code": "def test_timeout_handle(loop: asyncio.AbstractEventLoop) -> None:\n    handle = helpers.TimeoutHandle(loop, 10.2)\n    cb = mock.Mock()\n    handle.register(cb)\n    assert cb == handle._callbacks[0][0]\n    handle.close()\n    assert not handle._callbacks",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [
                "assert cb == handle._callbacks[0][0]",
                "assert not handle._callbacks"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "handle.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to release resources associated with a connection or protocol, ensuring that any callbacks are executed and the connection is properly terminated.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it calls the `_release` method on the associated connector to cleanly close the connection, setting `should_close` to `True`. Finally, it sets the protocol to `None`, indicating that the connection is no longer active. This method is crucial for managing resource cleanup and preventing memory leaks in asynchronous applications."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_when_timeout_smaller_second",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 295,
            "end_line_number": 307,
            "source_code": "def test_when_timeout_smaller_second(loop: asyncio.AbstractEventLoop) -> None:\n    timeout = 0.1\n    timer = loop.time() + timeout\n\n    handle = helpers.TimeoutHandle(loop, timeout)\n    assert handle is not None\n    start_handle = handle.start()\n    assert start_handle is not None\n    when = start_handle.when()\n    handle.close()\n\n    assert isinstance(when, float)\n    assert when - timer == pytest.approx(0, abs=0.001)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [
                "assert handle is not None",
                "assert start_handle is not None",
                "assert isinstance(when, float)",
                "assert when - timer == pytest.approx(0, abs=0.001)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "handle.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with an object, ensuring that any ongoing operations are properly terminated and that the underlying protocol connections are closed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol connection exists, it calls the `_release` method on the connector to close the connection, passing a flag to indicate that it should be closed. Finally, it sets the protocol attribute to `None`, indicating that the object is no longer connected. This method is crucial for managing resource cleanup, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_when_timeout_smaller_second_with_low_threshold",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
            "line_number": 310,
            "end_line_number": 324,
            "source_code": "def test_when_timeout_smaller_second_with_low_threshold(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    timeout = 0.1\n    timer = loop.time() + timeout\n\n    handle = helpers.TimeoutHandle(loop, timeout, 0.01)\n    assert handle is not None\n    start_handle = handle.start()\n    assert start_handle is not None\n    when = start_handle.when()\n    handle.close()\n\n    assert isinstance(when, int)\n    assert when == ceil(timer)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "base64",
                "datetime",
                "gc",
                "sys",
                "weakref",
                "math.ceil",
                "math.modf",
                "pathlib.Path",
                "typing.Dict",
                "typing.Iterator",
                "typing.Optional",
                "typing.Union",
                "unittest.mock",
                "urllib.request.getproxies_environment",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "multidict.MultiDictProxy",
                "yarl.URL",
                "aiohttp.helpers",
                "aiohttp.web",
                "aiohttp.helpers.EMPTY_BODY_METHODS",
                "aiohttp.helpers.is_expected_content_type",
                "aiohttp.helpers.must_be_empty_body",
                "aiohttp.helpers.parse_http_date",
                "aiohttp.helpers.should_remove_content_length"
            ],
            "fixtures": [],
            "assertions": [
                "assert handle is not None",
                "assert start_handle is not None",
                "assert isinstance(when, int)",
                "assert when == ceil(timer)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "handle.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with an object, ensuring that any ongoing operations are properly terminated and that the underlying protocol connections are closed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol connection exists, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol reference to `None`, indicating that the object is no longer connected. This method is crucial for managing resource cleanup, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connector_loop",
            "module": "test_client_session",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_session.py",
            "line_number": 351,
            "end_line_number": 369,
            "source_code": "def test_connector_loop(loop: asyncio.AbstractEventLoop) -> None:\n    with contextlib.ExitStack() as stack:\n        another_loop = asyncio.new_event_loop()\n        stack.enter_context(contextlib.closing(another_loop))\n\n        async def make_connector() -> TCPConnector:\n            return TCPConnector()\n\n        connector = another_loop.run_until_complete(make_connector())\n\n        with pytest.raises(RuntimeError) as ctx:\n\n            async def make_sess() -> ClientSession:\n                return ClientSession(connector=connector)\n\n            loop.run_until_complete(make_sess())\n        expected = \"Session and connector have to use same event loop\"\n        assert str(ctx.value).startswith(expected)\n        another_loop.run_until_complete(connector.close())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "gc",
                "io",
                "json",
                "collections.deque",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.TypedDict",
                "typing.Union",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client",
                "aiohttp.hdrs",
                "aiohttp.tracing",
                "aiohttp.web",
                "aiohttp.client.ClientSession",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector.UnixConnector",
                "aiohttp.cookiejar.CookieJar",
                "aiohttp.http.RawResponseMessage",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(ctx.value).startswith(expected)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "connector.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to cleanly release resources associated with a connector, ensuring that any ongoing connections are properly terminated and that callbacks are executed.\n\n**How It Works**:  \nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is currently active, it calls the `_release` method on the associated connector to close the connection and release resources. Finally, it sets the protocol to `None`, indicating that the connector is no longer active. This method is typically used in conjunction with context management (via `__aexit__`) to ensure that resources are cleaned up when a session is finished."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_detach",
            "module": "test_client_session",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_session.py",
            "line_number": 372,
            "end_line_number": 382,
            "source_code": "def test_detach(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    conn = session.connector\n    assert conn is not None\n    try:\n        assert not conn.closed\n        session.detach()\n        assert session.connector is None\n        assert session.closed\n        assert not conn.closed\n    finally:\n        loop.run_until_complete(conn.close())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "gc",
                "io",
                "json",
                "collections.deque",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.TypedDict",
                "typing.Union",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.MultiDict",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.client",
                "aiohttp.hdrs",
                "aiohttp.tracing",
                "aiohttp.web",
                "aiohttp.client.ClientSession",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector.UnixConnector",
                "aiohttp.cookiejar.CookieJar",
                "aiohttp.http.RawResponseMessage",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert conn is not None",
                "assert not conn.closed",
                "assert session.connector is None",
                "assert session.closed",
                "assert not conn.closed"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to properly close a connection associated with a connector, ensuring that resources are released and any necessary cleanup is performed.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass`), indicating that it is a placeholder for future functionality. In the context of the surrounding code, it is called during the asynchronous exit of a context manager (`__aexit__`), which suggests that it will be responsible for handling the closure of connections when the connector is no longer needed. Additionally, the method may trigger cleanup processes, such as warning about unclosed connections if the connector is deleted without being closed properly. The method's design implies that it will manage the state of the connection and ensure that any associated resources are released appropriately."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": "TestDataQueue",
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of its content, indicating that no more data can be read. It returns `True` if the end of the file (EOF) has been reached and the buffer is empty.\n\n**How It Works**:  \nThe method compares the current position of the file pointer (obtained using `self.content.tell()`) with the total length of the content (retrieved using `len(self.content.getbuffer())`). If both values are equal, it means that the reading has reached the end of the content, and thus it returns `True`. If they are not equal, it returns `False`, indicating that there is still data to be read."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": "TestDataQueue",
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of the file (EOF) state, indicating that no more data can be read and that the `feed_eof` method has been called.\n\n**How It Works**:  \nThe method returns `True` if two conditions are met: the `_eof` attribute is `True`, meaning the end-of-file state has been signaled, and the `_buffer` is empty, indicating that there is no remaining data to read. If either condition is not satisfied, it returns `False`. This method is useful for determining whether the reading process has completed and no further data is available."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": "TestDataQueue",
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of the file (EOF) state, which indicates that no more data can be read and that the `feed_eof` method has been called.\n\n**How It Works**:  \nThe method returns `True` if two conditions are met: the `_eof` attribute is `True`, indicating that the end-of-file state has been reached, and the `_buffer` is empty, meaning there is no remaining data in the buffer. If either condition is not satisfied, it returns `False`. This method is useful for determining whether the reading process has completed and no further data is available."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of its content, indicating that no more data can be read. It returns `True` if the end of the file (EOF) has been reached and the buffer is empty.\n\n**How It Works**:  \nThe method compares the current position of the file pointer (obtained using `self.content.tell()`) with the total length of the content (retrieved using `len(self.content.getbuffer())`). If both values are equal, it means that the reading has reached the end of the content, and thus it returns `True`. If they are not equal, it returns `False`, indicating that there is still data to be read."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of the file (EOF) condition, indicating that no more data can be read and that the `feed_eof` method has been called.\n\n**How It Works**:  \nThe method returns `True` if two conditions are met: the `_eof` attribute is `True`, meaning the end-of-file has been signaled, and the `_buffer` is empty, indicating there is no remaining data to read. If either condition is not satisfied, it returns `False`. This method is useful for determining the state of the buffer in asynchronous data processing scenarios."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_at_eof",
            "module": "test_streams",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
            "line_number": 1144,
            "end_line_number": 1149,
            "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "buffer"
            ],
            "imports": [
                "abc",
                "asyncio",
                "gc",
                "types",
                "collections.defaultdict",
                "itertools.groupby",
                "typing.DefaultDict",
                "typing.Iterator",
                "typing.Sequence",
                "typing.TypeVar",
                "unittest.mock",
                "pytest",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert not buffer.at_eof()",
                "assert buffer.at_eof()",
                "assert not buffer.at_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "buffer.at_eof",
                    "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `at_eof` method checks if the buffer has reached the end of the file (EOF) condition, indicating that no more data can be read and that the `feed_eof` method has been called.\n\n**How It Works**:  \nThe method returns `True` if two conditions are met: the `_eof` attribute is `True`, meaning the end-of-file has been signaled, and the `_buffer` is empty, indicating there is no remaining data to read. If either condition is not satisfied, it returns `False`. This method is useful for determining the state of the buffer in asynchronous data processing scenarios."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 12,
            "end_line_number": 40,
            "source_code": "def test_one_thousand_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket text messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `ws.prepare` method is designed to take a bytes input and return it unchanged. This method serves as a placeholder for potential preprocessing or validation of the data before it is used elsewhere in the application.\n\n**How It Works**:\nThe method accepts a single parameter, `data`, which is expected to be of type `bytes`. It simply returns this data without any modifications. This straightforward implementation suggests that the method may be intended for future enhancements, such as adding logging, validation, or transformation of the input data."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 12,
            "end_line_number": 40,
            "source_code": "def test_one_thousand_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket text messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `ws.close` method is designed to close an active WebSocket connection gracefully. It ensures that all resources associated with the WebSocket are released and that the connection is terminated properly.\n\n**How It Works**:\nThe method is defined as an asynchronous function (`async def close(self) -> None:`) but currently contains no implementation (`pass`). In the context of the WebSocket handling code, it is invoked when a close message is received or when the connection is being closed. The method is expected to handle the cleanup of any ongoing operations, close the WebSocket connection, and release associated resources. In other parts of the code, similar `close` methods are implemented to manage the closure of connections and cleanup tasks, ensuring that all related resources are handled correctly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 12,
            "end_line_number": 40,
            "source_code": "def test_one_thousand_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket text messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to release resources and clean up any associated connections or callbacks when an object is no longer needed. This is particularly important in network programming to prevent resource leaks.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. Then, if a protocol connection exists, it calls the `_release` method on the connector to properly close the connection and set the protocol reference to `None`. This ensures that all resources are released and the object is in a clean state, ready for garbage collection if necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_binary_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 43,
            "end_line_number": 71,
            "source_code": "def test_one_thousand_round_trip_websocket_binary_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket binary messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_bytes(b\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket binary messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.prepare` method is designed to take a bytes input and return it unchanged. It serves as a placeholder for potential preprocessing or validation of the data before it is used elsewhere in the application.\n\n**How It Works**:  \nThe method accepts a single parameter, `data`, which is expected to be of type `bytes`. It simply returns this data without any modifications. This can be useful in scenarios where a consistent interface is required, even if the current implementation does not alter the input."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_binary_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 43,
            "end_line_number": 71,
            "source_code": "def test_one_thousand_round_trip_websocket_binary_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket binary messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_bytes(b\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket binary messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.close` method is designed to close an active WebSocket connection, ensuring that all associated resources are properly released and that the connection is terminated gracefully.\n\n**How It Works**:  \nThe method is defined as an asynchronous function (`async def close(self) -> None:`) but currently contains no implementation (`pass`). In the context of the WebSocket handling code, it is invoked when a close message is received or when the connection is in the process of closing. The method is expected to handle the cleanup of any ongoing operations, close the WebSocket connection, and manage any related resources, such as waiting for responses or closing any open transports. The method is also idempotent, meaning that calling it multiple times will not have additional effects, which is useful for ensuring that the connection is closed without causing errors if it has already been closed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_round_trip_websocket_binary_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 43,
            "end_line_number": 71,
            "source_code": "def test_one_thousand_round_trip_websocket_binary_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 1000 WebSocket binary messages.\"\"\"\n    message_count = 1000\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_bytes(b\"answer\")\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 1000 WebSocket binary messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to release resources and perform cleanup operations associated with an object, ensuring that any ongoing processes or connections are properly terminated.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If the object has an active protocol (e.g., a network connection), it calls the `_release` method on its connector to release the protocol and mark it for closure. Finally, it sets the protocol attribute to `None`, indicating that the object is no longer connected. This method is crucial for preventing resource leaks and ensuring that all associated resources are properly cleaned up when they are no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_large_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 74,
            "end_line_number": 103,
            "source_code": "def test_one_thousand_large_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 100 large WebSocket text messages.\"\"\"\n    message_count = 100\n    raw_message = \"x\" * MSG_SIZE * 4\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(raw_message)\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 100 large WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.prepare` method is designed to take a bytes input and return it unchanged. It serves as a placeholder for potential preprocessing or validation of the data before it is used elsewhere in the application.\n\n**How It Works**:  \nThe method accepts a single parameter, `data`, which is expected to be of type `bytes`. It simply returns this data without any modifications. This method can be useful in scenarios where a consistent interface is required, even if no actual processing is needed at this stage."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_large_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 74,
            "end_line_number": 103,
            "source_code": "def test_one_thousand_large_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 100 large WebSocket text messages.\"\"\"\n    message_count = 100\n    raw_message = \"x\" * MSG_SIZE * 4\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(raw_message)\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 100 large WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.close` method is designed to close an active WebSocket connection. It ensures that all resources associated with the connection are properly released and that the connection is terminated gracefully.\n\n**How It Works**:  \nThe method is defined as an asynchronous function (`async def close(self) -> None:`) but currently contains no implementation (`pass`). In the context of the WebSocket handling code, it is invoked when a close message is received or when the connection is being closed. The method is expected to handle the cleanup of any ongoing operations, close the WebSocket connection, and release associated resources. In other parts of the code, similar `close` methods are implemented to manage the closure of connections and cleanup tasks, ensuring that multiple calls to close do not lead to errors or resource leaks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_one_thousand_large_round_trip_websocket_text_messages",
            "module": "test_benchmarks_client_ws",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_ws.py",
            "line_number": 74,
            "end_line_number": 103,
            "source_code": "def test_one_thousand_large_round_trip_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop,\n    aiohttp_client: AiohttpClient,\n    benchmark: BenchmarkFixture,\n) -> None:\n    \"\"\"Benchmark round trip of 100 large WebSocket text messages.\"\"\"\n    message_count = 100\n    raw_message = \"x\" * MSG_SIZE * 4\n\n    async def handler(request: web.Request) -> web.WebSocketResponse:\n        ws = web.WebSocketResponse()\n        await ws.prepare(request)\n        for _ in range(message_count):\n            await ws.send_str(raw_message)\n        await ws.close()\n        return ws\n\n    app = web.Application()\n    app.router.add_route(\"GET\", \"/\", handler)\n\n    async def run_websocket_benchmark() -> None:\n        client = await aiohttp_client(app)\n        resp = await client.ws_connect(\"/\")\n        for _ in range(message_count):\n            await resp.receive()\n        await resp.close()\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(run_websocket_benchmark())",
            "docstring": "Benchmark round trip of 100 large WebSocket text messages.",
            "decorators": [],
            "arguments": [
                "loop",
                "aiohttp_client",
                "benchmark"
            ],
            "imports": [
                "asyncio",
                "pytest_codspeed.BenchmarkFixture",
                "aiohttp.web",
                "aiohttp._websocket.helpers.MSG_SIZE",
                "aiohttp.pytest_plugin.AiohttpClient"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to release resources and perform cleanup operations associated with an object, ensuring that any ongoing processes or connections are properly terminated.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If the object has an active protocol (e.g., a network connection), it calls the `_release` method on its connector to release the protocol and mark it for closure. Finally, it sets the protocol attribute to `None`, indicating that the object is no longer connected. This method is crucial for preventing resource leaks and ensuring that all associated resources are properly cleaned up when they are no longer needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_client",
            "module": "test_test_utils",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
            "line_number": 76,
            "end_line_number": 86,
            "source_code": "def test_client(\n    loop: asyncio.AbstractEventLoop, app: web.Application\n) -> Iterator[_TestClient]:\n    async def make_client() -> TestClient[web.Request, web.Application]:\n        return TestClient(TestServer(app))\n\n    client = loop.run_until_complete(make_client())\n\n    loop.run_until_complete(client.start_server())\n    yield client\n    loop.run_until_complete(client.close())",
            "docstring": null,
            "decorators": [
                "pytest.fixture"
            ],
            "arguments": [
                "loop",
                "app"
            ],
            "imports": [
                "asyncio",
                "gzip",
                "socket",
                "sys",
                "typing.Iterator",
                "typing.Mapping",
                "typing.NoReturn",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.AioHTTPTestCase",
                "aiohttp.test_utils.RawTestServer",
                "aiohttp.test_utils.TestClient",
                "aiohttp.test_utils.TestServer",
                "aiohttp.test_utils.get_port_socket",
                "aiohttp.test_utils.loop_context",
                "aiohttp.test_utils.make_mocked_request",
                "typing.assert_type"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a client connection, ensuring that any associated resources are released and callbacks are executed. It marks the client as closed, preventing further interactions.\n\n**How It Works**:\nWhen `close` is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. If a protocol is active, it instructs the connector to release the protocol and sets the protocol reference to `None`. This effectively cleans up the client's state, making it unusable for further operations. The method is idempotent, meaning multiple calls will have no additional effect after the first call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_get_route",
            "module": "test_test_utils",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
            "line_number": 124,
            "end_line_number": 131,
            "source_code": "def test_get_route(loop: asyncio.AbstractEventLoop, test_client: _TestClient) -> None:\n    async def test_get_route() -> None:\n        resp = await test_client.request(\"GET\", \"/\")\n        assert resp.status == 200\n        text = await resp.text()\n        assert _hello_world_str == text\n\n    loop.run_until_complete(test_get_route())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "test_client"
            ],
            "imports": [
                "asyncio",
                "gzip",
                "socket",
                "sys",
                "typing.Iterator",
                "typing.Mapping",
                "typing.NoReturn",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.AioHTTPTestCase",
                "aiohttp.test_utils.RawTestServer",
                "aiohttp.test_utils.TestClient",
                "aiohttp.test_utils.TestServer",
                "aiohttp.test_utils.get_port_socket",
                "aiohttp.test_utils.loop_context",
                "aiohttp.test_utils.make_mocked_request",
                "typing.assert_type"
            ],
            "fixtures": [],
            "assertions": [
                "assert resp.status == 200",
                "assert _hello_world_str == text"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_get_route",
                    "body": "def test_get_route(loop: asyncio.AbstractEventLoop, test_client: _TestClient) -> None:\n\n    async def test_get_route() -> None:\n        resp = await test_client.request('GET', '/')\n        assert resp.status == 200\n        text = await resp.text()\n        assert _hello_world_str == text\n    loop.run_until_complete(test_get_route())",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_get_route` method is designed to test the functionality of a GET request to the root endpoint (\"/\") of a web application. It verifies that the response status is 200 (indicating success) and that the response body matches a predefined string (`_hello_world_str`).\n\n**How It Works**:\nThe method defines an asynchronous inner function `test_get_route`, which performs the following steps:\n1. It sends a GET request to the root URL (\"/\") using the provided `test_client`.\n2. It asserts that the response status is 200, confirming that the request was successful.\n3. It retrieves the response text and asserts that it matches the expected string `_hello_world_str`.\nFinally, the outer function uses `loop.run_until_complete` to execute the asynchronous inner function, ensuring that the test runs within the provided event loop."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_make_mocked_request_sslcontext",
            "module": "test_test_utils",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
            "line_number": 185,
            "end_line_number": 188,
            "source_code": "def test_make_mocked_request_sslcontext() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.transport is not None\n    assert req.transport.get_extra_info(\"sslcontext\") is None",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "gzip",
                "socket",
                "sys",
                "typing.Iterator",
                "typing.Mapping",
                "typing.NoReturn",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.AioHTTPTestCase",
                "aiohttp.test_utils.RawTestServer",
                "aiohttp.test_utils.TestClient",
                "aiohttp.test_utils.TestServer",
                "aiohttp.test_utils.get_port_socket",
                "aiohttp.test_utils.loop_context",
                "aiohttp.test_utils.make_mocked_request",
                "typing.assert_type"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.transport is not None",
                "assert req.transport.get_extra_info('sslcontext') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "req.transport.get_extra_info",
                    "body": "def get_extra_info(name: str, default: object=None) -> object:\n    return {valid_key: valid_value}.get(name, default)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_extra_info` method is designed to retrieve additional information from the transport layer of a network protocol, such as SSL context or other transport-specific details. It allows users to access optional metadata that may be relevant for handling network requests.\n\n**How It Works**:  \nThe method takes two parameters: `name`, a string representing the key of the extra information to retrieve, and `default`, an optional object that will be returned if the requested information is not available. It attempts to fetch the value associated with `name` from a predefined dictionary of valid keys. If the key does not exist, it returns the `default` value. In the context of the surrounding code, this method is called on the transport object associated with a request, allowing the request handler to access transport-specific details safely. If the transport is `None`, it directly returns the `default` value."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_make_mocked_request_unknown_extra_info",
            "module": "test_test_utils",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
            "line_number": 191,
            "end_line_number": 194,
            "source_code": "def test_make_mocked_request_unknown_extra_info() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.transport is not None\n    assert req.transport.get_extra_info(\"unknown_extra_info\") is None",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "gzip",
                "socket",
                "sys",
                "typing.Iterator",
                "typing.Mapping",
                "typing.NoReturn",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "yarl.URL",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.AioHTTPTestCase",
                "aiohttp.test_utils.RawTestServer",
                "aiohttp.test_utils.TestClient",
                "aiohttp.test_utils.TestServer",
                "aiohttp.test_utils.get_port_socket",
                "aiohttp.test_utils.loop_context",
                "aiohttp.test_utils.make_mocked_request",
                "typing.assert_type"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.transport is not None",
                "assert req.transport.get_extra_info('unknown_extra_info') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "req.transport.get_extra_info",
                    "body": "def get_extra_info(name: str, default: object=None) -> object:\n    return {valid_key: valid_value}.get(name, default)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_extra_info` method retrieves additional information from the transport layer of a network protocol, such as SSL context or other transport-specific details. It allows users to access optional metadata associated with the transport.\n\n**How It Works**:\nThe method takes two parameters: `name`, a string representing the key of the desired extra information, and `default`, an optional object that is returned if the requested information is not available. It attempts to fetch the value associated with `name` from a predefined dictionary of valid keys. If the key does not exist, it returns the `default` value. In the context of the surrounding code, it first checks if the transport is available; if not, it directly returns the `default` value. This method is useful for handling various transport configurations and ensuring that the application can gracefully handle missing information."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_server_notakeover",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 194,
            "end_line_number": 207,
            "source_code": "def test_handshake_compress_server_notakeover() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, server_notakeover=True)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert compress == 15\n    assert notakeover is True\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\n        \"permessage-deflate; server_no_context_takeover\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert compress == 15",
                "assert notakeover is True",
                "assert 'Sec-Websocket-Extensions' in headers",
                "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate; server_no_context_takeover'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:\nThe method takes several parameters: `protocols` (a string for WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It creates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it builds the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_client_notakeover",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 210,
            "end_line_number": 221,
            "source_code": "def test_handshake_compress_client_notakeover() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, client_notakeover=True)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\"permessage-deflate\"), hdrs\n\n    assert compress == 15",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' in headers",
                "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate', hdrs",
                "assert compress == 15"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:  \nThe method takes several parameters: `protocols` (a string for the WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It generates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it constructs the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_wbits",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 224,
            "end_line_number": 236,
            "source_code": "def test_handshake_compress_wbits() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=9)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\n        \"permessage-deflate; server_max_window_bits=9\"\n    )\n    assert compress == 9",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' in headers",
                "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate; server_max_window_bits=9'",
                "assert compress == 9"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:  \nThe method takes several parameters: `protocols` (a string for the WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It creates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it builds the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_wbits_error",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 239,
            "end_line_number": 248,
            "source_code": "def test_handshake_compress_wbits_error() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=6)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" not in headers\n    assert compress == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' not in headers",
                "assert compress == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:  \nThe method takes several parameters: `protocols` (a string for the WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It creates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it builds the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_bad_ext",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 251,
            "end_line_number": 260,
            "source_code": "def test_handshake_compress_bad_ext() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, extension_text=\"bad\")\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" not in headers\n    assert compress == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' not in headers",
                "assert compress == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:\nThe method takes several parameters: `protocols` (a string for WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It generates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If protocols are specified, it adds the `Sec-Websocket-Protocol` header. If compression is enabled, it constructs the `Sec-Websocket-Extensions` header based on the provided parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_multi_ext_bad",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 263,
            "end_line_number": 274,
            "source_code": "def test_handshake_compress_multi_ext_bad() -> None:\n    hdrs, sec_key = gen_ws_headers(\n        compress=15, extension_text=\"bad, permessage-deflate\"\n    )\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == \"permessage-deflate\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' in headers",
                "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:\nThe method takes several parameters: `protocols` (a string for WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It generates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If protocols are specified, it adds the `Sec-Websocket-Protocol` header. If compression is enabled, it constructs the `Sec-Websocket-Extensions` header based on the provided parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_compress_multi_ext_wbits",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 277,
            "end_line_number": 287,
            "source_code": "def test_handshake_compress_multi_ext_wbits() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=6, extension_text=\", permessage-deflate\")\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == \"permessage-deflate\"\n    assert compress == 15",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Sec-Websocket-Extensions' in headers",
                "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate'",
                "assert compress == 15"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:\nThe method takes several parameters: `protocols` (a string for the WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It creates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it builds the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_handshake_no_transfer_encoding",
            "module": "test_websocket_handshake",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
            "line_number": 290,
            "end_line_number": 297,
            "source_code": "def test_handshake_no_transfer_encoding() -> None:\n    hdrs, sec_key = gen_ws_headers()\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Transfer-Encoding\" not in headers",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "base64",
                "os",
                "typing.List",
                "typing.Tuple",
                "pytest",
                "aiohttp.web",
                "aiohttp.test_utils.make_mocked_request"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Transfer-Encoding' not in headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen_ws_headers",
                    "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen_ws_headers` method generates the necessary headers for establishing a WebSocket connection, including optional parameters for protocols and compression.\n\n**How It Works**:\nThe method takes several parameters: `protocols` (a string for WebSocket subprotocols), `compress` (an integer for compression settings), `extension_text` (additional extension parameters), and two booleans (`server_notakeover` and `client_notakeover`) to control context takeover behavior. It generates a unique WebSocket key using `os.urandom` and encodes it in base64. The method constructs a list of headers, starting with mandatory WebSocket headers. If `protocols` is provided, it adds the `Sec-Websocket-Protocol` header. If `compress` is greater than zero, it constructs the `Sec-Websocket-Extensions` header based on the compression settings and any additional parameters. Finally, it returns a tuple containing the list of headers and the generated key."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run",
            "module": "test_worker",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
            "line_number": 75,
            "end_line_number": 89,
            "source_code": "def test_run(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n    worker.cfg.is_ssl = False\n    worker.cfg.graceful_timeout = 100\n    worker.sockets = []\n\n    worker.loop = loop\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_not_called()\n    assert loop.is_closed()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "worker",
                "loop"
            ],
            "imports": [
                "asyncio",
                "os",
                "socket",
                "ssl",
                "typing.TYPE_CHECKING",
                "typing.Dict",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "_pytest.fixtures.SubRequest",
                "aiohttp.web",
                "aiohttp.worker",
                "uvloop"
            ],
            "fixtures": [],
            "assertions": [
                "assert loop.is_closed()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "worker.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `worker.run` method is designed to initiate the worker process for handling incoming requests in an asynchronous web server environment, specifically using the `aiohttp` framework. It sets up a `ClientResponse` object to manage HTTP responses.\n\n**How It Works**:\nThe method takes a `Connection` object as an argument and creates a `ClientResponse` instance with predefined parameters, including the HTTP method, URL, and various mock objects for request handling. It initializes the response as not closed and associates it with the provided connection. The method is typically called within a testing context to simulate the worker's behavior and ensure proper handling of requests and responses in an asynchronous environment. The tests validate that the worker can run without errors and that the event loop is properly managed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_async_factory",
            "module": "test_worker",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
            "line_number": 92,
            "end_line_number": 113,
            "source_code": "def test_run_async_factory(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n    worker.cfg.is_ssl = False\n    worker.cfg.graceful_timeout = 100\n    worker.sockets = []\n    app = worker.wsgi\n\n    async def make_app() -> web.Application:\n        return app  # type: ignore[no-any-return]\n\n    worker.wsgi = make_app\n\n    worker.loop = loop\n    worker.alive = False\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_not_called()\n    assert loop.is_closed()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "worker",
                "loop"
            ],
            "imports": [
                "asyncio",
                "os",
                "socket",
                "ssl",
                "typing.TYPE_CHECKING",
                "typing.Dict",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "_pytest.fixtures.SubRequest",
                "aiohttp.web",
                "aiohttp.worker",
                "uvloop"
            ],
            "fixtures": [],
            "assertions": [
                "assert loop.is_closed()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "worker.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `worker.run` method is designed to initiate the worker process for handling incoming requests in an asynchronous web server environment, specifically using the `aiohttp` framework. It sets up a `ClientResponse` object to manage HTTP responses.\n\n**How It Works**:\nThe method takes a `Connection` object as an argument and creates a `ClientResponse` instance with predefined parameters, including the HTTP method, URL, and various mock objects for request handling. It initializes the response as not closed and associates it with the provided connection. The method is typically called within a testing context to simulate the worker's behavior and ensure proper handling of requests and responses in an asynchronous environment. The tests validate that the worker can run without errors and that the event loop is properly managed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_not_app",
            "module": "test_worker",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
            "line_number": 116,
            "end_line_number": 129,
            "source_code": "def test_run_not_app(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n\n    worker.loop = loop\n    worker.wsgi = \"not-app\"\n    worker.alive = False\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_called_with(\"Exception in gunicorn worker\")\n    assert loop.is_closed()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "worker",
                "loop"
            ],
            "imports": [
                "asyncio",
                "os",
                "socket",
                "ssl",
                "typing.TYPE_CHECKING",
                "typing.Dict",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "_pytest.fixtures.SubRequest",
                "aiohttp.web",
                "aiohttp.worker",
                "uvloop"
            ],
            "fixtures": [],
            "assertions": [
                "assert loop.is_closed()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "worker.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `worker.run` method is designed to initiate the worker process for handling incoming requests in an asynchronous web server environment, specifically using the `aiohttp` framework. It sets up a `ClientResponse` object to manage HTTP responses.\n\n**How It Works**:\nThe method takes a `Connection` object as an argument and creates a `ClientResponse` instance with predefined parameters, including the HTTP method, URL, and various mock objects for request handling. It initializes the response as not closed and associates it with the provided connection. The method is typically called within a testing context to simulate the worker's behavior and ensure proper handling of requests and responses in an asynchronous environment. The tests validate that the worker can run without errors and that the event loop is properly managed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_using_gzip_if_header_present_and_file_available",
            "module": "test_web_sendfile",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
            "line_number": 13,
            "end_line_number": 39,
            "source_code": "def test_using_gzip_if_header_present_and_file_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\n        \"GET\",\n        \"http://python.org/logo.png\",\n        # Header uses some uppercase to ensure case-insensitive treatment\n        headers={hdrs.ACCEPT_ENCODING: \"GZip\"},\n    )\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.return_value.st_size = 1024\n    gz_filepath.lstat.return_value.st_mtime_ns = 1603733507222449291\n    gz_filepath.lstat.return_value.st_mode = MOCK_MODE\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert not filepath.open.called\n    assert gz_filepath.open.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "pathlib.Path",
                "stat.S_IFREG",
                "stat.S_IRUSR",
                "stat.S_IWUSR",
                "unittest.mock",
                "aiohttp.hdrs",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_fileresponse.FileResponse"
            ],
            "fixtures": [],
            "assertions": [
                "assert not filepath.open.called",
                "assert gz_filepath.open.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "file_sender.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `file_sender.prepare` method is designed to accept a bytes-like object as input and return it unchanged. This method serves as a simple preparatory step in a file-sending process, ensuring that the data is in the correct format for further handling.\n\n**How It Works**:  \nThe method takes a single parameter, `data`, which is expected to be of type `bytes`. It directly returns this input without any modifications. This can be useful in scenarios where you need to ensure that the data is processed or validated before being sent, even if no actual transformation occurs in this specific implementation."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_gzip_if_header_not_present_and_file_available",
            "module": "test_web_sendfile",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
            "line_number": 42,
            "end_line_number": 66,
            "source_code": "def test_gzip_if_header_not_present_and_file_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.return_value.st_size = 1024\n    gz_filepath.lstat.return_value.st_mtime_ns = 1603733507222449291\n    gz_filepath.lstat.return_value.st_mode = MOCK_MODE\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "pathlib.Path",
                "stat.S_IFREG",
                "stat.S_IRUSR",
                "stat.S_IWUSR",
                "unittest.mock",
                "aiohttp.hdrs",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_fileresponse.FileResponse"
            ],
            "fixtures": [],
            "assertions": [
                "assert filepath.open.called",
                "assert not gz_filepath.open.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "file_sender.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `file_sender.prepare` method is designed to accept a bytes-like object as input and return it unchanged. This method serves as a simple preparatory step in a file-sending process, ensuring that the data is in the correct format for further handling.\n\n**How It Works**:  \nThe method takes a single parameter, `data`, which is expected to be of type `bytes`. It directly returns this input without any modifications. This can be useful in scenarios where you need to ensure that the data is processed or validated before being sent, even if no actual transformation is applied in this case. The method's simplicity allows it to be easily integrated into larger workflows where data preparation is necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_gzip_if_header_not_present_and_file_not_available",
            "module": "test_web_sendfile",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
            "line_number": 69,
            "end_line_number": 91,
            "source_code": "def test_gzip_if_header_not_present_and_file_not_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.stat.side_effect = OSError(2, \"No such file or directory\")\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "pathlib.Path",
                "stat.S_IFREG",
                "stat.S_IRUSR",
                "stat.S_IWUSR",
                "unittest.mock",
                "aiohttp.hdrs",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_fileresponse.FileResponse"
            ],
            "fixtures": [],
            "assertions": [
                "assert filepath.open.called",
                "assert not gz_filepath.open.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "file_sender.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `file_sender.prepare` method is designed to accept a bytes-like object as input and return it unchanged. This method serves as a simple preparatory step in a file-sending process, ensuring that the data is in the correct format for further handling.\n\n**How It Works**:  \nThe method takes a single parameter, `data`, which is expected to be of type `bytes`. It directly returns this data without any modifications. This can be useful in scenarios where you need to ensure that the data is in bytes format before sending it over a network or processing it further, acting as a placeholder for potential future enhancements or validations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_gzip_if_header_present_and_file_not_available",
            "module": "test_web_sendfile",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
            "line_number": 94,
            "end_line_number": 118,
            "source_code": "def test_gzip_if_header_present_and_file_not_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\n        \"GET\", \"http://python.org/logo.png\", headers={hdrs.ACCEPT_ENCODING: \"gzip\"}\n    )\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.side_effect = OSError(2, \"No such file or directory\")\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "pathlib.Path",
                "stat.S_IFREG",
                "stat.S_IRUSR",
                "stat.S_IWUSR",
                "unittest.mock",
                "aiohttp.hdrs",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_fileresponse.FileResponse"
            ],
            "fixtures": [],
            "assertions": [
                "assert filepath.open.called",
                "assert not gz_filepath.open.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "file_sender.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `file_sender.prepare` method is designed to accept a bytes-like object as input and return it unchanged. This method serves as a simple preparatory step in a file-sending process, ensuring that the data is in the correct format for further handling.\n\n**How It Works**:  \nThe method takes a single parameter, `data`, which is expected to be of type `bytes`. It directly returns this input without any modifications. This can be useful in scenarios where you need to ensure that the data is processed or validated before being sent, even if no actual transformation is applied in this case. The method's simplicity allows it to be easily integrated into larger workflows where data preparation is necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_status_controlled_by_user",
            "module": "test_web_sendfile",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
            "line_number": 121,
            "end_line_number": 136,
            "source_code": "def test_status_controlled_by_user(loop: asyncio.AbstractEventLoop) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath, status=203)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert file_sender._status == 203",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "pathlib.Path",
                "stat.S_IFREG",
                "stat.S_IRUSR",
                "stat.S_IWUSR",
                "unittest.mock",
                "aiohttp.hdrs",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.web_fileresponse.FileResponse"
            ],
            "fixtures": [],
            "assertions": [
                "assert file_sender._status == 203"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "file_sender.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `file_sender.prepare` method is designed to accept a bytes-like object as input and return it unchanged. This method serves as a simple preparatory step in a file-sending process, ensuring that the data is in the correct format for further handling.\n\n**How It Works**:  \nThe method takes a single parameter, `data`, which is expected to be of type `bytes`. It directly returns this input without any modifications. This can be useful in scenarios where you need to ensure that the data is in bytes format before sending it over a network or processing it further, acting as a placeholder for potential future enhancements or validations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close_frame_invalid_2",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 293,
            "end_line_number": 301,
            "source_code": "def test_close_frame_invalid_2(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    data = build_close_frame(code=1)\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_close_frame",
                    "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_close_frame` method is designed to create a WebSocket close frame, which is used to gracefully terminate a WebSocket connection. It packages a close code and an optional message into a specific byte format required by the WebSocket protocol.\n\n**How It Works**:  \nThe method takes three parameters: `code`, `message`, and `noheader`. The `code` parameter specifies the close code (defaulting to 1000, which indicates a normal closure), while `message` allows for an optional byte message to accompany the close frame. The `noheader` parameter determines whether to include a header in the frame. The method constructs the close frame by calling `build_frame`, which combines the packed close code (using `PACK_CLOSE_CODE`) and the message, and specifies the opcode as `WSMsgType.CLOSE`. The result is a byte sequence that represents the close frame, ready to be sent over the WebSocket connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close_frame_unicode_err",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 304,
            "end_line_number": 310,
            "source_code": "def test_close_frame_unicode_err(parser: WebSocketReader) -> None:\n    data = build_close_frame(code=1000, message=b\"\\xf4\\x90\\x80\\x80\")\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.INVALID_TEXT",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_close_frame",
                    "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_close_frame` method is designed to create a WebSocket close frame, which is used to gracefully terminate a WebSocket connection. It packages a close code and an optional message into a specific byte format required by the WebSocket protocol.\n\n**How It Works**:  \nThe method takes three parameters: `code`, `message`, and `noheader`. The `code` parameter specifies the close code (defaulting to 1000, which indicates a normal closure), while `message` allows for an optional byte string to be sent along with the close frame. The `noheader` parameter determines whether to include a header in the frame. The method constructs the close frame by concatenating the packed close code (using `PACK_CLOSE_CODE`) with the message and then calls `build_frame` to create the final byte representation of the close frame, specifying the opcode as `WSMsgType.CLOSE`. This byte representation can then be sent over the WebSocket connection to signal closure to the other party."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_simple_text",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 321,
            "end_line_number": 325,
            "source_code": "def test_simple_text(out: WebSocketDataQueue, parser: WebSocketReader) -> None:\n    data = build_frame(b\"text\", WSMsgType.TEXT)\n    parser._feed_data(data)\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"text\", size=4, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessageText(data='text', size=4, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is constructed (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_simple_text_unicode_err",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 328,
            "end_line_number": 334,
            "source_code": "def test_simple_text_unicode_err(parser: WebSocketReader) -> None:\n    data = build_frame(b\"\\xf4\\x90\\x80\\x80\", WSMsgType.TEXT)\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.INVALID_TEXT",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_fragmentation_header",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 346,
            "end_line_number": 352,
            "source_code": "def test_fragmentation_header(out: WebSocketDataQueue, parser: WebSocketReader) -> None:\n    data = build_frame(b\"a\", WSMsgType.TEXT)\n    parser._feed_data(data[:1])\n    parser._feed_data(data[1:])\n\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"a\", size=1, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessageText(data='a', size=1, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Header Construction**: The first byte of the header is constructed based on the `opcode`, `is_fin` (final frame flag), and `compress` status. Depending on the message length, the header is built using one of three packing functions (`PACK_LEN1`, `PACK_LEN2`, or `PACK_LEN3`).\n4. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks. The masked message is then combined with the header and mask.\n5. **Return Value**: The method returns the complete frame, which may include the header, mask, and the (possibly compressed) message, or just the message if `noheader` is set to true."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 355,
            "end_line_number": 363,
            "source_code": "def test_continuation(out: WebSocketDataQueue, parser: WebSocketReader) -> None:\n    data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n    parser._feed_data(data1)\n\n    data2 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n    parser._feed_data(data2)\n\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 355,
            "end_line_number": 363,
            "source_code": "def test_continuation(out: WebSocketDataQueue, parser: WebSocketReader) -> None:\n    data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n    parser._feed_data(data1)\n\n    data2 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n    parser._feed_data(data2)\n\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Header Construction**: The first byte of the header is constructed based on the `opcode`, `is_fin` (final frame flag), and `compress` status. Depending on the message length, the header is built using one of three packing functions (`PACK_LEN1`, `PACK_LEN2`, or `PACK_LEN3`).\n4. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks. The masked message is then combined with the header and mask.\n5. **Return Value**: The method returns the complete frame, which may include the header, mask, and the (possibly compressed) message, or just the message if `noheader` is set to true."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_ping",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 366,
            "end_line_number": 388,
            "source_code": "def test_continuation_with_ping(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.PING, b\"\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n        parser._feed_data(data1)\n\n        data2 = build_frame(b\"\", WSMsgType.PING)\n        parser._feed_data(data2)\n\n        data3 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n        parser._feed_data(data3)\n\n        res = out._buffer[0]\n        assert res == WSMessagePing(data=b\"\", size=0, extra=\"\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessagePing(data=b'', size=0, extra='')",
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The header is then built differently based on the message length:\n   - Less than 126 bytes: Use a simple header.\n   - Between 126 and 65535 bytes: Use a longer header.\n   - Greater than 65535 bytes: Use the longest header.\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the message (if no header is needed) or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_ping",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 366,
            "end_line_number": 388,
            "source_code": "def test_continuation_with_ping(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.PING, b\"\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n        parser._feed_data(data1)\n\n        data2 = build_frame(b\"\", WSMsgType.PING)\n        parser._feed_data(data2)\n\n        data3 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n        parser._feed_data(data3)\n\n        res = out._buffer[0]\n        assert res == WSMessagePing(data=b\"\", size=0, extra=\"\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessagePing(data=b'', size=0, extra='')",
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_ping",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 366,
            "end_line_number": 388,
            "source_code": "def test_continuation_with_ping(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.PING, b\"\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n        parser._feed_data(data1)\n\n        data2 = build_frame(b\"\", WSMsgType.PING)\n        parser._feed_data(data2)\n\n        data3 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n        parser._feed_data(data3)\n\n        res = out._buffer[0]\n        assert res == WSMessagePing(data=b\"\", size=0, extra=\"\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessagePing(data=b'', size=0, extra='')",
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_close",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 402,
            "end_line_number": 421,
            "source_code": "def test_continuation_with_close(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (\n                0,\n                WSMsgType.CLOSE,\n                build_close_frame(1002, b\"test\", noheader=True),\n                False,\n            ),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageClose(data=1002, size=6, extra=\"test\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", size=10, extra=\"\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert res == WSMessageClose(data=1002, size=6, extra='test')",
                "assert res == WSMessageText(data='line1line2', size=10, extra='')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_close_frame",
                    "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_close_frame` method is designed to create a WebSocket close frame, which is used to gracefully terminate a WebSocket connection. It packages a close code and an optional message into a specific byte format required by the WebSocket protocol.\n\n**How It Works**:  \nThe method takes three parameters: `code`, `message`, and `noheader`. The `code` parameter specifies the close code (defaulting to 1000, which indicates a normal closure), while `message` allows for an optional byte message to accompany the close frame. The `noheader` parameter determines whether to include a header in the frame. The method constructs the close frame by calling `build_frame`, which combines the packed close code (using `PACK_CLOSE_CODE`) and the message, and specifies the opcode as `WSMsgType.CLOSE`. The result is a byte sequence that represents the close frame, ready to be sent over the WebSocket connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_close_unicode_err",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 424,
            "end_line_number": 442,
            "source_code": "def test_continuation_with_close_unicode_err(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (\n                0,\n                WSMsgType.CLOSE,\n                build_close_frame(1000, b\"\\xf4\\x90\\x80\\x80\", noheader=True),\n                False,\n            ),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError) as ctx:\n            parser._feed_data(b\"\")\n\n        assert ctx.value.code == WSCloseCode.INVALID_TEXT",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_close_frame",
                    "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_close_frame` method is designed to create a WebSocket close frame, which is used to gracefully terminate a WebSocket connection. It packages a close code and an optional message into a specific byte format required by the WebSocket protocol.\n\n**How It Works**:  \nThe method takes three parameters: `code`, `message`, and `noheader`. The `code` parameter specifies the close code (defaulting to 1000, which indicates a normal closure), while `message` allows for an optional byte string to be included with the close frame. The `noheader` parameter determines whether to include a header in the frame. The method constructs the close frame by concatenating the packed close code (using `PACK_CLOSE_CODE`) with the message and then calls `build_frame` to create the final byte representation of the close frame, specifying the opcode as `WSMsgType.CLOSE`. This byte representation can then be sent over the WebSocket connection to signal closure to the other party."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_continuation_with_close_bad_code",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 445,
            "end_line_number": 458,
            "source_code": "def test_continuation_with_close_bad_code(\n    out: WebSocketDataQueue, parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.CLOSE, build_close_frame(1, b\"test\", noheader=True), False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError) as ctx:\n            parser._feed_data(b\"\")\n\n        assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out",
                "parser"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_close_frame",
                    "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_close_frame` method is designed to create a WebSocket close frame, which is used to gracefully terminate a WebSocket connection. It packages a close code and an optional message into a specific byte format required by the WebSocket protocol.\n\n**How It Works**:  \nThe method takes three parameters: `code`, `message`, and `noheader`. The `code` parameter specifies the close code (defaulting to 1000, which indicates a normal closure), while `message` allows for an optional byte message to accompany the close frame. The `noheader` parameter determines whether to include a header in the frame. The method constructs the close frame by calling `build_frame`, which combines the packed close code (using `PACK_CLOSE_CODE`) and the message, and specifies the opcode as `WSMsgType.CLOSE`. The result is a byte sequence that represents the close frame, ready to be sent over the WebSocket connection."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_msg_too_large",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 582,
            "end_line_number": 587,
            "source_code": "def test_msg_too_large(out: WebSocketDataQueue) -> None:\n    parser = WebSocketReader(out, 256, compress=False)\n    data = build_frame(b\"text\" * 256, WSMsgType.TEXT)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `opcode`, `is_fin` (final frame flag), and `compress` status. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_msg_too_large_not_fin",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 590,
            "end_line_number": 595,
            "source_code": "def test_msg_too_large_not_fin(out: WebSocketDataQueue) -> None:\n    parser = WebSocketReader(out, 256, compress=False)\n    data = build_frame(b\"text\" * 256, WSMsgType.TEXT, is_fin=False)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks (only applicable for clients).\n4. **Header Construction**: The first byte of the header is constructed based on the `is_fin` flag (indicating if this is the final fragment of a message) and the opcode. The length of the message determines how the rest of the header is formatted (using different packing functions for lengths < 126, < 65536, or >= 65536).\n5. **Return Value**: Depending on the `noheader` flag, the method returns either just the masked message or the complete frame consisting of the header, mask (if used), and the message."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_compressed_msg_too_large",
            "module": "test_websocket_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
            "line_number": 598,
            "end_line_number": 603,
            "source_code": "def test_compressed_msg_too_large(out: WebSocketDataQueue) -> None:\n    parser = WebSocketReader(out, 256, compress=True)\n    data = build_frame(b\"aaa\" * 256, WSMsgType.TEXT, compress=True)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "out"
            ],
            "imports": [
                "asyncio",
                "pickle",
                "random",
                "struct",
                "zlib",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp._websocket.helpers",
                "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
                "aiohttp._websocket.helpers.PACK_LEN1",
                "aiohttp._websocket.helpers.PACK_LEN2",
                "aiohttp._websocket.helpers.PACK_LEN3",
                "aiohttp._websocket.helpers.websocket_mask",
                "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
                "aiohttp._websocket.reader.WebSocketDataQueue",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.http.WebSocketError",
                "aiohttp.http.WSCloseCode",
                "aiohttp.http.WSMsgType",
                "aiohttp.http_websocket.WebSocketReader",
                "aiohttp.http_websocket.WSMessageBinary",
                "aiohttp.http_websocket.WSMessageClose",
                "aiohttp.http_websocket.WSMessagePing",
                "aiohttp.http_websocket.WSMessagePong",
                "aiohttp.http_websocket.WSMessageText"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "build_frame",
                    "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `build_frame` method constructs a WebSocket frame from a given message, opcode, and various optional parameters, preparing it for transmission over a WebSocket connection. It handles message compression, masking, and the appropriate framing based on the message length.\n\n**How It Works**:  \n1. **Compression**: If the `compress` flag is set, the method compresses the message using zlib and removes any trailing bytes specific to the WebSocket deflate extension.\n2. **Message Length**: It calculates the length of the message to determine how to format the frame header.\n3. **Header Construction**: The first byte of the header is constructed based on the `opcode`, `is_fin` (final frame flag), and `compress` status. The length of the message determines which packing function (`PACK_LEN1`, `PACK_LEN2`, or `PACK_LEN3`) is used to create the header.\n4. **Masking**: If `use_mask` is true, a random mask is generated and applied to the message to prevent certain attacks. The masked message is then combined with the header and mask.\n5. **Return Value**: Depending on the `noheader` flag, the method returns either the complete frame (header + message) or just the message if no header is needed."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_after_asyncio_run",
            "module": "test_web_runner",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_runner.py",
            "line_number": 262,
            "end_line_number": 284,
            "source_code": "def test_run_after_asyncio_run() -> None:\n    called = False\n\n    async def nothing() -> None:\n        pass\n\n    def spy() -> None:\n        nonlocal called\n        called = True\n\n    async def shutdown() -> NoReturn:\n        spy()\n        raise web.GracefulExit()\n\n    # asyncio.run() creates a new loop and closes it.\n    asyncio.run(nothing())\n\n    app = web.Application()\n    # create_task() will delay the function until app is run.\n    app.on_startup.append(lambda a: asyncio.create_task(shutdown()))\n\n    web.run_app(app)\n    assert called, \"run_app() should work after asyncio.run().\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "platform",
                "signal",
                "typing.Any",
                "typing.Iterator",
                "typing.NoReturn",
                "typing.Protocol",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.test_utils.get_unused_port_socket",
                "aiohttp.web_log.AccessLogger"
            ],
            "fixtures": [],
            "assertions": [
                "assert called, 'run_app() should work after asyncio.run().'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_after_asyncio_run",
            "module": "test_web_runner",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_runner.py",
            "line_number": 262,
            "end_line_number": 284,
            "source_code": "def test_run_after_asyncio_run() -> None:\n    called = False\n\n    async def nothing() -> None:\n        pass\n\n    def spy() -> None:\n        nonlocal called\n        called = True\n\n    async def shutdown() -> NoReturn:\n        spy()\n        raise web.GracefulExit()\n\n    # asyncio.run() creates a new loop and closes it.\n    asyncio.run(nothing())\n\n    app = web.Application()\n    # create_task() will delay the function until app is run.\n    app.on_startup.append(lambda a: asyncio.create_task(shutdown()))\n\n    web.run_app(app)\n    assert called, \"run_app() should work after asyncio.run().\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "platform",
                "signal",
                "typing.Any",
                "typing.Iterator",
                "typing.NoReturn",
                "typing.Protocol",
                "typing.Union",
                "unittest.mock",
                "pytest",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.test_utils.get_unused_port_socket",
                "aiohttp.web_log.AccessLogger"
            ],
            "fixtures": [],
            "assertions": [
                "assert called, 'run_app() should work after asyncio.run().'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "spy",
                    "body": "def spy() -> None:\n    nonlocal called\n    called = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `spy` method is designed to set a flag (`called`) to `True`, indicating that it has been invoked. This is typically used in testing scenarios to verify that certain functions are called during the execution of asynchronous code.\n\n**How It Works**:\nThe method uses the `nonlocal` keyword to access the `called` variable defined in the enclosing scope (in this case, within the `test_run_after_asyncio_run` function). When `spy` is called, it updates the `called` variable to `True`. This allows the test to assert that the `spy` function was executed as part of the application's shutdown process, confirming that the application behaves as expected after an `asyncio.run()` call."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_method1",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 106,
            "end_line_number": 108,
            "source_code": "def test_method1(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.method == \"GET\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.method == 'GET'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_method2",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 111,
            "end_line_number": 113,
            "source_code": "def test_method2(make_request: _RequestMaker) -> None:\n    req = make_request(\"head\", \"http://python.org/\")\n    assert req.method == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.method == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_method3",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 116,
            "end_line_number": 118,
            "source_code": "def test_method3(make_request: _RequestMaker) -> None:\n    req = make_request(\"HEAD\", \"http://python.org/\")\n    assert req.method == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.method == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_method_invalid",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 121,
            "end_line_number": 123,
            "source_code": "def test_method_invalid(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError, match=\"Method cannot contain non-token characters\"):\n        make_request(\"METHOD WITH\\nWHITESPACES\", \"http://python.org/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_version_1_0",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 126,
            "end_line_number": 128,
            "source_code": "def test_version_1_0(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", version=\"1.0\")\n    assert req.version == (1, 0)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.version == (1, 0)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_version_default",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 131,
            "end_line_number": 133,
            "source_code": "def test_version_default(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.version == (1, 1)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.version == (1, 1)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_request_info",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 136,
            "end_line_number": 140,
            "source_code": "def test_request_info(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    url = URL(\"http://python.org/\")\n    h = CIMultiDictProxy(req.headers)\n    assert req.request_info == aiohttp.RequestInfo(url, \"GET\", h, url)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.request_info == aiohttp.RequestInfo(url, 'GET', h, url)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_request_info_with_fragment",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 143,
            "end_line_number": 151,
            "source_code": "def test_request_info_with_fragment(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/#urlfragment\")\n    h = CIMultiDictProxy(req.headers)\n    assert req.request_info == aiohttp.RequestInfo(\n        URL(\"http://python.org/\"),\n        \"GET\",\n        h,\n        URL(\"http://python.org/#urlfragment\"),\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.request_info == aiohttp.RequestInfo(URL('http://python.org/'), 'GET', h, URL('http://python.org/#urlfragment'))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_version_err",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 154,
            "end_line_number": 156,
            "source_code": "def test_version_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://python.org/\", version=\"1.c\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_default_http",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 159,
            "end_line_number": 163,
            "source_code": "def test_host_port_default_http(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 80\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 80",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_default_https",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 166,
            "end_line_number": 170,
            "source_code": "def test_host_port_default_https(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 443\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 443",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_nondefault_http",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 173,
            "end_line_number": 177,
            "source_code": "def test_host_port_nondefault_http(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 960",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_nondefault_https",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 180,
            "end_line_number": 184,
            "source_code": "def test_host_port_nondefault_https(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 960",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_default_ws",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 187,
            "end_line_number": 191,
            "source_code": "def test_host_port_default_ws(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"ws://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 80\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 80",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_default_wss",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 194,
            "end_line_number": 198,
            "source_code": "def test_host_port_default_wss(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"wss://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 443\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 443",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. The outer function returns this `maker` function, allowing it to be used in tests to generate requests easily."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_nondefault_ws",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 201,
            "end_line_number": 205,
            "source_code": "def test_host_port_nondefault_ws(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"ws://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 960",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_nondefault_wss",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 208,
            "end_line_number": 212,
            "source_code": "def test_host_port_nondefault_wss(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"wss://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == 'python.org'",
                "assert req.port == 960",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_none_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 215,
            "end_line_number": 217,
            "source_code": "def test_host_port_none_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"unix://localhost/path\")\n    assert req.headers[\"Host\"] == \"localhost\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['Host'] == 'localhost'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_port_err",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 220,
            "end_line_number": 222,
            "source_code": "def test_host_port_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://python.org:123e/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_hostname_err",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 225,
            "end_line_number": 227,
            "source_code": "def test_hostname_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://:8080/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_first",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 230,
            "end_line_number": 232,
            "source_code": "def test_host_header_host_first(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert list(req.headers)[0] == \"Host\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(req.headers)[0] == 'Host'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_without_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 235,
            "end_line_number": 237,
            "source_code": "def test_host_header_host_without_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.headers[\"HOST\"] == \"python.org\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'python.org'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to set up a real server."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_with_default_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 240,
            "end_line_number": 242,
            "source_code": "def test_host_header_host_with_default_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:80/\")\n    assert req.headers[\"HOST\"] == \"python.org\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'python.org'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_with_nondefault_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 245,
            "end_line_number": 247,
            "source_code": "def test_host_header_host_with_nondefault_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:99/\")\n    assert req.headers[\"HOST\"] == \"python.org:99\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'python.org:99'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_idna_encode",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 250,
            "end_line_number": 252,
            "source_code": "def test_host_header_host_idna_encode(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://xn--9caa.com\")\n    assert req.headers[\"HOST\"] == \"xn--9caa.com\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'xn--9caa.com'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_host_unicode",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 255,
            "end_line_number": 257,
            "source_code": "def test_host_header_host_unicode(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://\u00e9\u00e9.com\")\n    assert req.headers[\"HOST\"] == \"xn--9caa.com\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'xn--9caa.com'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_explicit_host",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 260,
            "end_line_number": 262,
            "source_code": "def test_host_header_explicit_host(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", headers={\"host\": \"example.com\"})\n    assert req.headers[\"HOST\"] == \"example.com\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'example.com'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_explicit_host_with_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 265,
            "end_line_number": 267,
            "source_code": "def test_host_header_explicit_host_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", headers={\"host\": \"example.com:99\"})\n    assert req.headers[\"HOST\"] == \"example.com:99\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == 'example.com:99'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_ipv4",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 270,
            "end_line_number": 272,
            "source_code": "def test_host_header_ipv4(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://127.0.0.2\")\n    assert req.headers[\"HOST\"] == \"127.0.0.2\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '127.0.0.2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_ipv6",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 275,
            "end_line_number": 277,
            "source_code": "def test_host_header_ipv6(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[::2]\")\n    assert req.headers[\"HOST\"] == \"[::2]\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '[::2]'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to generate and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_ipv4_with_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 280,
            "end_line_number": 282,
            "source_code": "def test_host_header_ipv4_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://127.0.0.2:99\")\n    assert req.headers[\"HOST\"] == \"127.0.0.2:99\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '127.0.0.2:99'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_ipv6_with_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 285,
            "end_line_number": 287,
            "source_code": "def test_host_header_ipv6_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[::2]:99\")\n    assert req.headers[\"HOST\"] == \"[::2]:99\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '[::2]:99'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_host_header_fqdn",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 320,
            "end_line_number": 324,
            "source_code": "def test_host_header_fqdn(\n    make_request: _RequestMaker, url: str, headers: Dict[str, str], expected: str\n) -> None:\n    req = make_request(\"get\", url, headers=headers)\n    assert req.headers[\"HOST\"] == expected",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('url', 'headers', 'expected'), (pytest.param('http://localhost.', None, 'localhost', id='dot only at the end'), pytest.param('http://python.org.', None, 'python.org', id='single dot'), pytest.param('http://python.org.:99', None, 'python.org:99', id='single dot with port'), pytest.param('http://python.org...:99', None, 'python.org:99', id='multiple dots with port'), pytest.param('http://python.org.:99', {'host': 'example.com.:99'}, 'example.com.:99', id='explicit host header'), pytest.param('https://python.org.', None, 'python.org', id='https'), pytest.param('https://...', None, '', id='only dots'), pytest.param('http://pr\u00edklad.example.org.:99', None, 'xn--prklad-4va.example.org:99', id='single dot with port idna')))"
            ],
            "arguments": [
                "make_request",
                "url",
                "headers",
                "expected"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == expected"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_default_headers_useragent",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 327,
            "end_line_number": 331,
            "source_code": "def test_default_headers_useragent(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n\n    assert \"SERVER\" not in req.headers\n    assert \"USER-AGENT\" in req.headers",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'SERVER' not in req.headers",
                "assert 'USER-AGENT' in req.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions. The outer function returns this inner `maker` function, allowing it to be used in test cases."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_default_headers_useragent_custom",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 334,
            "end_line_number": 340,
            "source_code": "def test_default_headers_useragent_custom(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", headers={\"user-agent\": \"my custom agent\"}\n    )\n\n    assert \"USER-Agent\" in req.headers\n    assert \"my custom agent\" == req.headers[\"User-Agent\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'USER-Agent' in req.headers",
                "assert 'my custom agent' == req.headers['User-Agent']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this `maker` function, allowing it to be used in tests to generate requests easily."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_skip_default_useragent_header",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 343,
            "end_line_number": 348,
            "source_code": "def test_skip_default_useragent_header(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", skip_auto_headers={istr(\"user-agent\")}\n    )\n\n    assert \"User-Agent\" not in req.headers",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'User-Agent' not in req.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_headers",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 351,
            "end_line_number": 358,
            "source_code": "def test_headers(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"post\", \"http://python.org/\", headers={\"Content-Type\": \"text/plain\"}\n    )\n\n    assert \"CONTENT-TYPE\" in req.headers\n    assert req.headers[\"CONTENT-TYPE\"] == \"text/plain\"\n    assert req.headers[\"ACCEPT-ENCODING\"] == \"gzip, deflate, br\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'CONTENT-TYPE' in req.headers",
                "assert req.headers['CONTENT-TYPE'] == 'text/plain'",
                "assert req.headers['ACCEPT-ENCODING'] == 'gzip, deflate, br'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_headers_list",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 361,
            "end_line_number": 366,
            "source_code": "def test_headers_list(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"post\", \"http://python.org/\", headers=[(\"Content-Type\", \"text/plain\")]\n    )\n    assert \"CONTENT-TYPE\" in req.headers\n    assert req.headers[\"CONTENT-TYPE\"] == \"text/plain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'CONTENT-TYPE' in req.headers",
                "assert req.headers['CONTENT-TYPE'] == 'text/plain'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_headers_default",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 369,
            "end_line_number": 373,
            "source_code": "def test_headers_default(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", headers={\"ACCEPT-ENCODING\": \"deflate\"}\n    )\n    assert req.headers[\"ACCEPT-ENCODING\"] == \"deflate\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['ACCEPT-ENCODING'] == 'deflate'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_invalid_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 376,
            "end_line_number": 378,
            "source_code": "def test_invalid_url(make_request: _RequestMaker) -> None:\n    with pytest.raises(aiohttp.InvalidURL):\n        make_request(\"get\", \"hiwpefhipowhefopw\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to set up a real server."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_no_path",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 381,
            "end_line_number": 383,
            "source_code": "def test_no_path(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org\")\n    assert \"/\" == req.url.path",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert '/' == req.url.path"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ipv6_default_http_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 386,
            "end_line_number": 390,
            "source_code": "def test_ipv6_default_http_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[2001:db8::1]/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 80\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == '2001:db8::1'",
                "assert req.port == 80",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. The outer function returns this `maker` function, allowing it to be used in tests to generate requests easily."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ipv6_default_https_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 393,
            "end_line_number": 397,
            "source_code": "def test_ipv6_default_https_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://[2001:db8::1]/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 443\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == '2001:db8::1'",
                "assert req.port == 443",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ipv6_nondefault_http_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 400,
            "end_line_number": 404,
            "source_code": "def test_ipv6_nondefault_http_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[2001:db8::1]:960/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 960\n    assert not req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == '2001:db8::1'",
                "assert req.port == 960",
                "assert not req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ipv6_nondefault_https_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 407,
            "end_line_number": 411,
            "source_code": "def test_ipv6_nondefault_https_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://[2001:db8::1]:960/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 960\n    assert req.is_ssl()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.host == '2001:db8::1'",
                "assert req.port == 960",
                "assert req.is_ssl()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 414,
            "end_line_number": 419,
            "source_code": "def test_basic_auth(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"1234\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'AUTHORIZATION' in req.headers",
                "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to set up actual server requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_utf8",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 422,
            "end_line_number": 427,
            "source_code": "def test_basic_auth_utf8(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"\u0441\u0435\u043a\u0440\u0435\u0442\", \"utf-8\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbTrRgdC10LrRgNC10YI=\" == req.headers[\"AUTHORIZATION\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'AUTHORIZATION' in req.headers",
                "assert 'Basic bmtpbTrRgdC10LrRgNC10YI=' == req.headers['AUTHORIZATION']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_tuple_forbidden",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 430,
            "end_line_number": 432,
            "source_code": "def test_basic_auth_tuple_forbidden(make_request: _RequestMaker) -> None:\n    with pytest.raises(TypeError):\n        make_request(\"get\", \"http://python.org\", auth=(\"nkim\", \"1234\"))",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_from_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 435,
            "end_line_number": 439,
            "source_code": "def test_basic_auth_from_url(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://nkim:1234@python.org\")\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'AUTHORIZATION' in req.headers",
                "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']",
                "assert 'python.org' == req.host"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_no_user_from_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 442,
            "end_line_number": 446,
            "source_code": "def test_basic_auth_no_user_from_url(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://:1234@python.org\")\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic OjEyMzQ=\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'AUTHORIZATION' in req.headers",
                "assert 'Basic OjEyMzQ=' == req.headers['AUTHORIZATION']",
                "assert 'python.org' == req.host"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basic_auth_from_url_overridden",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 449,
            "end_line_number": 455,
            "source_code": "def test_basic_auth_from_url_overridden(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://garbage@python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"1234\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'AUTHORIZATION' in req.headers",
                "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']",
                "assert 'python.org' == req.host"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket communication. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to generate and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_is_not_double_encoded1",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 458,
            "end_line_number": 460,
            "source_code": "def test_path_is_not_double_encoded1(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test case\")\n    assert req.url.raw_path == \"/get/test%20case\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.url.raw_path == '/get/test%20case'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_is_not_double_encoded2",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 463,
            "end_line_number": 465,
            "source_code": "def test_path_is_not_double_encoded2(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test%2fcase\")\n    assert req.url.raw_path == \"/get/test%2Fcase\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.url.raw_path == '/get/test%2Fcase'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to generate and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_is_not_double_encoded3",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 468,
            "end_line_number": 470,
            "source_code": "def test_path_is_not_double_encoded3(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test%20case\")\n    assert req.url.raw_path == \"/get/test%20case\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.url.raw_path == '/get/test%20case'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_safe_chars_preserved",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 473,
            "end_line_number": 475,
            "source_code": "def test_path_safe_chars_preserved(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/:=+/%2B/\")\n    assert req.url.path == \"/get/:=+/+/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.url.path == '/get/:=+/+/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions. The outer function returns this `maker` function, allowing it to be used in test cases."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_params_are_added_before_fragment1",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 478,
            "end_line_number": 480,
            "source_code": "def test_params_are_added_before_fragment1(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path#fragment\", params={\"a\": \"b\"})\n    assert str(req.url) == \"http://example.com/path?a=b\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://example.com/path?a=b'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_params_are_added_before_fragment2",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 483,
            "end_line_number": 487,
            "source_code": "def test_params_are_added_before_fragment2(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"GET\", \"http://example.com/path?key=value#fragment\", params={\"a\": \"b\"}\n    )\n    assert str(req.url) == \"http://example.com/path?key=value&a=b\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://example.com/path?key=value&a=b'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_not_contain_fragment1",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 490,
            "end_line_number": 492,
            "source_code": "def test_path_not_contain_fragment1(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path#fragment\")\n    assert req.url.path == \"/path\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.url.path == '/path'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_path_not_contain_fragment2",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 495,
            "end_line_number": 497,
            "source_code": "def test_path_not_contain_fragment2(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path?key=value#fragment\")\n    assert str(req.url) == \"http://example.com/path?key=value\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://example.com/path?key=value'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_cookies",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 500,
            "end_line_number": 504,
            "source_code": "def test_cookies(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://test.com/path\", cookies={\"cookie1\": \"val1\"})\n\n    assert \"COOKIE\" in req.headers\n    assert \"cookie1=val1\" == req.headers[\"COOKIE\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'COOKIE' in req.headers",
                "assert 'cookie1=val1' == req.headers['COOKIE']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of web application behavior without needing to make actual network requests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_cookies_is_quoted_with_special_characters",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 507,
            "end_line_number": 511,
            "source_code": "def test_cookies_is_quoted_with_special_characters(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://test.com/path\", cookies={\"cookie1\": \"val/one\"})\n\n    assert \"COOKIE\" in req.headers\n    assert 'cookie1=\"val/one\"' == req.headers[\"COOKIE\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'COOKIE' in req.headers",
                "assert 'cookie1=\"val/one\"' == req.headers['COOKIE']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_cookies_merge_with_headers",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 514,
            "end_line_number": 522,
            "source_code": "def test_cookies_merge_with_headers(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"http://test.com/path\",\n        headers={\"cookie\": \"cookie1=val1\"},\n        cookies={\"cookie2\": \"val2\"},\n    )\n\n    assert \"cookie1=val1; cookie2=val2\" == req.headers[\"COOKIE\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'cookie1=val1; cookie2=val2' == req.headers['COOKIE']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_query_multivalued_param",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 525,
            "end_line_number": 531,
            "source_code": "def test_query_multivalued_param(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(\n            meth, \"http://python.org\", params=((\"test\", \"foo\"), (\"test\", \"baz\"))\n        )\n\n        assert str(req.url) == \"http://python.org/?test=foo&test=baz\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://python.org/?test=foo&test=baz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket communication. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to perform actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_query_str_param",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 534,
            "end_line_number": 537,
            "source_code": "def test_query_str_param(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(meth, \"http://python.org\", params=\"test=foo\")\n        assert str(req.url) == \"http://python.org/?test=foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://python.org/?test=foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_query_bytes_param_raises",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 540,
            "end_line_number": 543,
            "source_code": "def test_query_bytes_param_raises(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        with pytest.raises(TypeError):\n            make_request(meth, \"http://python.org\", params=b\"test=foo\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to generate and return a mock request object, which can be used in tests to simulate client-server interactions."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_query_str_param_is_not_encoded",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 546,
            "end_line_number": 549,
            "source_code": "def test_query_str_param_is_not_encoded(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(meth, \"http://python.org\", params=\"test=f+oo\")\n        assert str(req.url) == \"http://python.org/?test=f+oo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://python.org/?test=f+oo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_params_update_path_and_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 552,
            "end_line_number": 556,
            "source_code": "def test_params_update_path_and_url(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", params=((\"test\", \"foo\"), (\"test\", \"baz\"))\n    )\n    assert str(req.url) == \"http://python.org/?test=foo&test=baz\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req.url) == 'http://python.org/?test=foo&test=baz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. The outer function returns this `maker` function, allowing it to be used in tests to generate requests easily."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_params_empty_path_and_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 559,
            "end_line_number": 563,
            "source_code": "def test_params_empty_path_and_url(make_request: _RequestMaker) -> None:\n    req_empty = make_request(\"get\", \"http://python.org\", params={})\n    assert str(req_empty.url) == \"http://python.org\"\n    req_none = make_request(\"get\", \"http://python.org\")\n    assert str(req_none.url) == \"http://python.org\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req_empty.url) == 'http://python.org'",
                "assert str(req_none.url) == 'http://python.org'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters to create and return a mock request object, which can be used in tests to simulate client-server interactions. The outer function returns this inner `maker` function, allowing it to be used as a fixture in test cases."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_params_empty_path_and_url",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 559,
            "end_line_number": 563,
            "source_code": "def test_params_empty_path_and_url(make_request: _RequestMaker) -> None:\n    req_empty = make_request(\"get\", \"http://python.org\", params={})\n    assert str(req_empty.url) == \"http://python.org\"\n    req_none = make_request(\"get\", \"http://python.org\")\n    assert str(req_none.url) == \"http://python.org\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert str(req_empty.url) == 'http://python.org'",
                "assert str(req_none.url) == 'http://python.org'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_gen_netloc_all",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 566,
            "end_line_number": 576,
            "source_code": "def test_gen_netloc_all(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"https://aiohttp:pwpwpw@\"\n        + \"12345678901234567890123456789\"\n        + \"012345678901234567890:8080\",\n    )\n    assert (\n        req.headers[\"HOST\"]\n        == \"12345678901234567890123456789\" + \"012345678901234567890:8080\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '12345678901234567890123456789' + '012345678901234567890:8080'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_gen_netloc_no_port",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 579,
            "end_line_number": 588,
            "source_code": "def test_gen_netloc_no_port(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"https://aiohttp:pwpwpw@\"\n        + \"12345678901234567890123456789\"\n        + \"012345678901234567890/\",\n    )\n    assert (\n        req.headers[\"HOST\"] == \"12345678901234567890123456789\" + \"012345678901234567890\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers['HOST'] == '12345678901234567890123456789' + '012345678901234567890'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, and headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. The outer function returns this inner `maker` function, allowing it to be used in tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_terminate_with_closed_loop",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1307,
            "end_line_number": 1340,
            "source_code": "def test_terminate_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, conn: mock.Mock\n) -> None:\n    req = resp = writer = None\n\n    async def go() -> None:\n        nonlocal req, resp, writer\n        req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n\n        async def _mock_write_bytes(*args: object, **kwargs: object) -> None:\n            # Ensure the task is scheduled\n            await asyncio.sleep(0)\n\n        with mock.patch.object(req, \"write_bytes\", _mock_write_bytes):\n            resp = await req.send(conn)\n\n        assert req._writer is not None\n        writer = WriterMock()\n        writer.done = mock.Mock(return_value=False)\n        req._writer = writer\n        resp._writer = writer\n\n        await asyncio.sleep(0.05)\n\n    loop.run_until_complete(go())\n\n    loop.close()\n    assert req is not None\n    req.terminate()\n    assert req._writer is None\n    assert writer is not None\n    assert not writer.cancel.called\n    assert resp is not None\n    resp.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "conn"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req is not None",
                "assert req._writer is None",
                "assert writer is not None",
                "assert not writer.cancel.called",
                "assert resp is not None",
                "assert req._writer is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(return_value=False)"
            ],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly shut down an event loop or a related resource, ensuring that all associated tasks and connections are properly terminated.\n\n**How It Works**:\nThe method currently has an empty implementation (`pass`), indicating that it does not perform any actions when called. However, in the context of an event loop, a typical implementation would involve stopping the loop, canceling any running tasks, and releasing resources. In the provided code snippets, similar `close` methods are seen that handle resource cleanup, such as notifying callbacks, releasing protocols, and canceling resolvers. This suggests that when implemented, `loop.close` would follow a similar pattern to ensure a graceful shutdown of the event loop and its associated components."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_terminate_with_closed_loop",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1307,
            "end_line_number": 1340,
            "source_code": "def test_terminate_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, conn: mock.Mock\n) -> None:\n    req = resp = writer = None\n\n    async def go() -> None:\n        nonlocal req, resp, writer\n        req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n\n        async def _mock_write_bytes(*args: object, **kwargs: object) -> None:\n            # Ensure the task is scheduled\n            await asyncio.sleep(0)\n\n        with mock.patch.object(req, \"write_bytes\", _mock_write_bytes):\n            resp = await req.send(conn)\n\n        assert req._writer is not None\n        writer = WriterMock()\n        writer.done = mock.Mock(return_value=False)\n        req._writer = writer\n        resp._writer = writer\n\n        await asyncio.sleep(0.05)\n\n    loop.run_until_complete(go())\n\n    loop.close()\n    assert req is not None\n    req.terminate()\n    assert req._writer is None\n    assert writer is not None\n    assert not writer.cancel.called\n    assert resp is not None\n    resp.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "conn"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req is not None",
                "assert req._writer is None",
                "assert writer is not None",
                "assert not writer.cancel.called",
                "assert resp is not None",
                "assert req._writer is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(return_value=False)"
            ],
            "methods_under_test": [
                {
                    "name": "resp.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to release resources and perform cleanup operations associated with an object, ensuring that any ongoing processes or connections are properly terminated.\n\n**How It Works**:\nWhen the `close` method is called, it first invokes the `_notify_release` method, which executes any registered callbacks and clears the callback list. Then, if a protocol connection exists, it calls the `_release` method on the connector to release the protocol and mark it for closure. Finally, it sets the protocol attribute to `None`, indicating that the object is no longer connected. This method is crucial for managing resource lifecycles, especially in asynchronous programming contexts where connections and resources need to be explicitly managed to prevent leaks or dangling references."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_terminate_with_closed_loop",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1307,
            "end_line_number": 1340,
            "source_code": "def test_terminate_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, conn: mock.Mock\n) -> None:\n    req = resp = writer = None\n\n    async def go() -> None:\n        nonlocal req, resp, writer\n        req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n\n        async def _mock_write_bytes(*args: object, **kwargs: object) -> None:\n            # Ensure the task is scheduled\n            await asyncio.sleep(0)\n\n        with mock.patch.object(req, \"write_bytes\", _mock_write_bytes):\n            resp = await req.send(conn)\n\n        assert req._writer is not None\n        writer = WriterMock()\n        writer.done = mock.Mock(return_value=False)\n        req._writer = writer\n        resp._writer = writer\n\n        await asyncio.sleep(0.05)\n\n    loop.run_until_complete(go())\n\n    loop.close()\n    assert req is not None\n    req.terminate()\n    assert req._writer is None\n    assert writer is not None\n    assert not writer.cancel.called\n    assert resp is not None\n    resp.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "conn"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req is not None",
                "assert req._writer is None",
                "assert writer is not None",
                "assert not writer.cancel.called",
                "assert resp is not None",
                "assert req._writer is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(return_value=False)"
            ],
            "methods_under_test": [
                {
                    "name": "go",
                    "body": "def go() -> List[web.AbstractRoute]:\n    route1 = router.add_route('GET', '/plain', make_handler())\n    route2 = router.add_route('GET', '/variable/{name}', make_handler())\n    resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n    return [route1, route2] + list(resource)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `go` method is designed to set up routing for a web application by adding specific HTTP routes and static file serving capabilities to the router. It returns a list of routes that have been defined.\n\n**How It Works**:\nThe method first adds two GET routes to the router: one for a plain path (`/plain`) and another for a dynamic path (`/variable/{name}`), both linked to a handler created by `make_handler()`. It then adds a static file serving route that serves files from a directory specified by the path of the `aiohttp` module. Finally, it returns a list containing the two defined routes along with any routes associated with the static resource. This setup allows the web application to handle both dynamic and static content efficiently."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basicauth_from_netrc_present",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1468,
            "end_line_number": 1474,
            "source_code": "def test_basicauth_from_netrc_present(\n    make_request: _RequestMaker,\n    expected_auth: helpers.BasicAuth,\n) -> None:\n    \"\"\"Test appropriate Authorization header is sent when netrc is not empty.\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=True)\n    assert req.headers[hdrs.AUTHORIZATION] == expected_auth.encode()",
            "docstring": "Test appropriate Authorization header is sent when netrc is not empty.",
            "decorators": [
                "pytest.mark.parametrize(('netrc_contents', 'expected_auth'), [('machine example.com login username password pass\\n', helpers.BasicAuth('username', 'pass'))], indirect=('netrc_contents',))",
                "pytest.mark.usefixtures('netrc_contents')"
            ],
            "arguments": [
                "make_request",
                "expected_auth"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert req.headers[hdrs.AUTHORIZATION] == expected_auth.encode()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with predefined headers, particularly for WebSocket connections.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket upgrade request. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the specified parameters, the application instance, and the request handler protocol. This allows for consistent and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basicauth_from_netrc_present_untrusted_env",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1483,
            "end_line_number": 1488,
            "source_code": "def test_basicauth_from_netrc_present_untrusted_env(\n    make_request: _RequestMaker,\n) -> None:\n    \"\"\"Test no authorization header is sent via netrc if trust_env is False\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=False)\n    assert hdrs.AUTHORIZATION not in req.headers",
            "docstring": "Test no authorization header is sent via netrc if trust_env is False",
            "decorators": [
                "pytest.mark.parametrize('netrc_contents', ('machine example.com login username password pass\\n',), indirect=('netrc_contents',))",
                "pytest.mark.usefixtures('netrc_contents')"
            ],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert hdrs.AUTHORIZATION not in req.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a boolean indicating whether to include WebSocket protocols. If no headers are provided, it initializes a default set of headers suitable for WebSocket connections. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` with the provided parameters and returns the resulting mock request. This allows for flexible and controlled testing of web application behavior without needing to perform actual network operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_basicauth_from_empty_netrc",
            "module": "test_client_request",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
            "line_number": 1497,
            "end_line_number": 1502,
            "source_code": "def test_basicauth_from_empty_netrc(\n    make_request: _RequestMaker,\n) -> None:\n    \"\"\"Test that no Authorization header is sent when netrc is empty\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=True)\n    assert hdrs.AUTHORIZATION not in req.headers",
            "docstring": "Test that no Authorization header is sent when netrc is empty",
            "decorators": [
                "pytest.mark.parametrize('netrc_contents', ('',), indirect=('netrc_contents',))",
                "pytest.mark.usefixtures('netrc_contents')"
            ],
            "arguments": [
                "make_request"
            ],
            "imports": [
                "asyncio",
                "hashlib",
                "io",
                "pathlib",
                "sys",
                "zlib",
                "http.cookies.BaseCookie",
                "http.cookies.Morsel",
                "http.cookies.SimpleCookie",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Dict",
                "typing.Iterable",
                "typing.Iterator",
                "typing.List",
                "typing.Protocol",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "multidict.istr",
                "yarl.URL",
                "aiohttp",
                "aiohttp.BaseConnector",
                "aiohttp.hdrs",
                "aiohttp.helpers",
                "aiohttp.payload",
                "aiohttp.abc.AbstractStreamWriter",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.client_exceptions.ClientConnectionError",
                "aiohttp.client_reqrep.ClientRequest",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.Fingerprint",
                "aiohttp.client_reqrep._gen_default_accept_encoding",
                "aiohttp.connector.Connection",
                "aiohttp.http.HttpVersion10",
                "aiohttp.http.HttpVersion11",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.LooseCookies"
            ],
            "fixtures": [],
            "assertions": [
                "assert hdrs.AUTHORIZATION not in req.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_request",
                    "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_request` method is a pytest fixture designed to create a mock HTTP request for testing purposes in a web application. It simplifies the process of generating requests with specific HTTP methods, paths, headers, and optional WebSocket protocols.\n\n**How It Works**:\nThe method defines an inner function `maker` that takes parameters for the HTTP method, request path, optional headers, and a flag for WebSocket protocols. If no headers are provided, it initializes them with default values suitable for a WebSocket connection. If the `protocols` flag is set to `True`, it adds a `SEC-WEBSOCKET-PROTOCOL` header. Finally, it calls `make_mocked_request` to create and return a mock request object using the provided parameters, the application instance, and the request handler protocol. This allows for flexible and controlled testing of WebSocket interactions in the application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_ctor",
            "module": "test_client_connection",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
            "line_number": 33,
            "end_line_number": 41,
            "source_code": "def test_ctor(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    assert conn.protocol is protocol\n    conn.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "connector",
                "key",
                "protocol",
                "loop"
            ],
            "imports": [
                "asyncio",
                "gc",
                "typing.Any",
                "unittest.mock",
                "pytest",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection"
            ],
            "fixtures": [],
            "assertions": [
                "assert conn.protocol is protocol"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to properly close a connection associated with a connector, ensuring that resources are released and any necessary cleanup is performed.\n\n**How It Works**:  \nThe method is defined but currently does not contain any implementation (`pass` statement). It is typically called in asynchronous contexts, such as within the `__aexit__` method of an asynchronous context manager, to ensure that connections are closed when exiting the context. The method is expected to handle the cleanup of resources, potentially setting flags or invoking other cleanup methods to manage the state of the connection and prevent resource leaks. Additionally, if the connection is not closed properly, a warning is issued in the destructor (`__del__`), indicating that the connector was not closed, which helps in debugging resource management issues."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_callbacks_on_close",
            "module": "test_client_connection",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
            "line_number": 44,
            "end_line_number": 59,
            "source_code": "def test_callbacks_on_close(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    notified = False\n\n    def cb() -> None:\n        nonlocal notified\n        notified = True\n\n    conn.add_callback(cb)\n    conn.close()\n    assert notified",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "connector",
                "key",
                "protocol",
                "loop"
            ],
            "imports": [
                "asyncio",
                "gc",
                "typing.Any",
                "unittest.mock",
                "pytest",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection"
            ],
            "fixtures": [],
            "assertions": [
                "assert notified"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to close a connection associated with a connector. It ensures that resources are properly released and that any ongoing operations related to the connection are terminated.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass` statement). In the context of the surrounding code, it is called during the cleanup process, particularly in the `__aexit__` asynchronous context manager method, which ensures that the connection is closed when exiting a `with` statement. Additionally, if the connection is not closed properly, a warning is issued in the destructor (`__del__`), indicating that there are unclosed connectors. The method is expected to handle any necessary cleanup tasks, such as notifying other components of the closure and releasing resources."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_callbacks_exception",
            "module": "test_client_connection",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
            "line_number": 80,
            "end_line_number": 99,
            "source_code": "def test_callbacks_exception(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    notified = False\n\n    def cb1() -> None:\n        raise Exception\n\n    def cb2() -> None:\n        nonlocal notified\n        notified = True\n\n    conn.add_callback(cb1)\n    conn.add_callback(cb2)\n    conn.close()\n    assert notified",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "connector",
                "key",
                "protocol",
                "loop"
            ],
            "imports": [
                "asyncio",
                "gc",
                "typing.Any",
                "unittest.mock",
                "pytest",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection"
            ],
            "fixtures": [],
            "assertions": [
                "assert notified"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to gracefully close a connection associated with a connector, ensuring that all resources are properly released and that any pending operations are completed.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass`), indicating that it is a placeholder for future functionality. In the context of the surrounding code, it is called in the `__aexit__` method of an asynchronous context manager, which ensures that when the context is exited, the connection is closed. Additionally, the method is likely intended to handle cleanup tasks, such as notifying any event loops or handling warnings if the connection is not closed properly. The presence of cleanup logic in the destructor (`__del__`) and the handling of connection states (like `_closed` and `_closing`) suggests that `close` will eventually manage these states to prevent resource leaks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close",
            "module": "test_client_connection",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
            "line_number": 126,
            "end_line_number": 137,
            "source_code": "def test_close(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    assert not conn.closed\n    conn.close()\n    assert conn._protocol is None\n    connector._release.assert_called_with(key, protocol, should_close=True)  # type: ignore[attr-defined]\n    assert conn.closed",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "connector",
                "key",
                "protocol",
                "loop"
            ],
            "imports": [
                "asyncio",
                "gc",
                "typing.Any",
                "unittest.mock",
                "pytest",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector.BaseConnector",
                "aiohttp.connector.Connection"
            ],
            "fixtures": [],
            "assertions": [
                "assert not conn.closed",
                "assert conn._protocol is None",
                "assert conn.closed"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "conn.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `conn.close` method is designed to close a connection associated with a connector. It ensures that resources are properly released and that any ongoing operations related to the connection are terminated.\n\n**How It Works**:  \nThe method is defined but currently has no implementation (`pass` statement), indicating that it is a placeholder for future functionality. In the context of the surrounding code, it is called during the cleanup process, particularly in the `__aexit__` method of an asynchronous context manager, which ensures that connections are closed when exiting the context. Additionally, the method is referenced in the destructor (`__del__`), which warns if a connector is not closed properly, highlighting the importance of resource management in asynchronous operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_http",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 109,
            "end_line_number": 122,
            "source_code": "def test_run_app_http(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's response to requests and ensures proper handling of timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After running, it checks that the test task completed without exceptions and returns the task and the number of connections.\n\nThis method is crucial for setting up a robust web server that can handle requests asynchronously while providing mechanisms for testing and connection management."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_http",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 109,
            "end_line_number": 122,
            "source_code": "def test_run_app_http(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_close_loop",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 125,
            "end_line_number": 132,
            "source_code": "def test_run_app_close_loop(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert patched_loop.is_closed()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert patched_loop.is_closed()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After running, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully while monitoring connection states."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_close_loop",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 125,
            "end_line_number": 132,
            "source_code": "def test_run_app_close_loop(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert patched_loop.is_closed()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert patched_loop.is_closed()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_mixed_bindings",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 445,
            "end_line_number": 455,
            "source_code": "def test_run_app_mixed_bindings(\n    run_app_kwargs: Dict[str, Any],\n    expected_server_calls: List[mock._Call],\n    expected_unix_server_calls: List[mock._Call],\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), **run_app_kwargs, loop=patched_loop)\n\n    assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls  # type: ignore[attr-defined]\n    assert patched_loop.create_server.mock_calls == expected_server_calls",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('run_app_kwargs, expected_server_calls, expected_unix_server_calls', mixed_bindings_test_params, ids=mixed_bindings_test_ids)"
            ],
            "arguments": [
                "run_app_kwargs",
                "expected_server_calls",
                "expected_unix_server_calls",
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls",
                "assert patched_loop.create_server.mock_calls == expected_server_calls"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections, allowing it to count connections before they are cleared during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's response to requests and ensures proper handling of timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_mixed_bindings",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 445,
            "end_line_number": 455,
            "source_code": "def test_run_app_mixed_bindings(\n    run_app_kwargs: Dict[str, Any],\n    expected_server_calls: List[mock._Call],\n    expected_unix_server_calls: List[mock._Call],\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), **run_app_kwargs, loop=patched_loop)\n\n    assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls  # type: ignore[attr-defined]\n    assert patched_loop.create_server.mock_calls == expected_server_calls",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('run_app_kwargs, expected_server_calls, expected_unix_server_calls', mixed_bindings_test_params, ids=mixed_bindings_test_ids)"
            ],
            "arguments": [
                "run_app_kwargs",
                "expected_server_calls",
                "expected_unix_server_calls",
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls",
                "assert patched_loop.create_server.mock_calls == expected_server_calls"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_https",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 458,
            "end_line_number": 474,
            "source_code": "def test_run_app_https(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    web.run_app(\n        app, ssl_context=ssl_context, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY,\n        None,\n        8443,\n        ssl=ssl_context,\n        backlog=128,\n        reuse_address=None,\n        reuse_port=None,\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using the `aiohttp` framework, allowing it to handle incoming requests over a specified socket. It also facilitates testing the application's behavior under certain conditions, such as connection limits and request timeouts.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for the application to listen on and a timeout value for request handling.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to simulate client requests, checking for timeouts and ensuring the server responds correctly.\n5. **Request Handling**: A request handler is set up to execute a provided task asynchronously and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for developers looking to test the robustness of their web applications in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_https",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 458,
            "end_line_number": 474,
            "source_code": "def test_run_app_https(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    web.run_app(\n        app, ssl_context=ssl_context, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY,\n        None,\n        8443,\n        ssl=ssl_context,\n        backlog=128,\n        reuse_address=None,\n        reuse_port=None,\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_nondefault_host_port",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 477,
            "end_line_number": 490,
            "source_code": "def test_run_app_nondefault_host_port(\n    patched_loop: asyncio.AbstractEventLoop, unused_port_socket: socket.socket\n) -> None:\n    port = unused_port_socket.getsockname()[1]\n    host = \"127.0.0.1\"\n\n    app = web.Application()\n    web.run_app(\n        app, host=host, port=port, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, host, port, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to check the server's responsiveness and handle potential timeouts when making requests.\n5. **Request Handling**: A request handler is set up to execute a provided task asynchronously and respond with a simple message.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is crucial for developers looking to implement and test asynchronous web applications using the `aiohttp` framework, ensuring proper handling of requests and server shutdowns."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_nondefault_host_port",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 477,
            "end_line_number": 490,
            "source_code": "def test_run_app_nondefault_host_port(\n    patched_loop: asyncio.AbstractEventLoop, unused_port_socket: socket.socket\n) -> None:\n    port = unused_port_socket.getsockname()[1]\n    host = \"127.0.0.1\"\n\n    app = web.Application()\n    web.run_app(\n        app, host=host, port=port, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, host, port, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_with_sock",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 493,
            "end_line_number": 507,
            "source_code": "def test_run_app_with_sock(\n    patched_loop: asyncio.AbstractEventLoop, unused_port_socket: socket.socket\n) -> None:\n    sock = unused_port_socket\n    app = web.Application()\n    web.run_app(\n        app,\n        sock=sock,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock=sock, ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication, manage connections, and run a test task while handling shutdown procedures gracefully.\n\n**How It Works**:\n1. **Socket and Timeout**: It accepts a socket for the application to listen on and a timeout for shutdown operations.\n2. **Connection Management**: It defines a custom dictionary class (`DictRecordClear`) to track active connections and clear them while counting how many were present before shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection management.\n4. **Test Task Execution**: An asynchronous test function is defined to perform checks on the server's response, including handling timeouts and ensuring the server can be stopped.\n5. **Request Handling**: A request handler is set up to execute a user-defined task and return a response.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the provided socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdowns properly while providing a mechanism to run additional tests during operation."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_with_sock",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 493,
            "end_line_number": 507,
            "source_code": "def test_run_app_with_sock(\n    patched_loop: asyncio.AbstractEventLoop, unused_port_socket: socket.socket\n) -> None:\n    sock = unused_port_socket\n    app = web.Application()\n    web.run_app(\n        app,\n        sock=sock,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock=sock, ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_multiple_hosts",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 510,
            "end_line_number": 528,
            "source_code": "def test_run_app_multiple_hosts(patched_loop: asyncio.AbstractEventLoop) -> None:\n    hosts = (\"127.0.0.1\", \"127.0.0.2\")\n\n    app = web.Application()\n    web.run_app(app, host=hosts, print=stopper(patched_loop), loop=patched_loop)\n\n    calls = map(\n        lambda h: mock.call(\n            mock.ANY,\n            h,\n            8080,\n            ssl=None,\n            backlog=128,\n            reuse_address=None,\n            reuse_port=None,\n        ),\n        hosts,\n    )\n    patched_loop.create_server.assert_has_calls(calls)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during server shutdown.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Logic**: It includes a testing coroutine that checks the server's response to requests, ensuring that it handles timeouts correctly.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections.\n\nThis method is particularly useful for testing web applications in an asynchronous environment, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_multiple_hosts",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 510,
            "end_line_number": 528,
            "source_code": "def test_run_app_multiple_hosts(patched_loop: asyncio.AbstractEventLoop) -> None:\n    hosts = (\"127.0.0.1\", \"127.0.0.2\")\n\n    app = web.Application()\n    web.run_app(app, host=hosts, print=stopper(patched_loop), loop=patched_loop)\n\n    calls = map(\n        lambda h: mock.call(\n            mock.ANY,\n            h,\n            8080,\n            ssl=None,\n            backlog=128,\n            reuse_address=None,\n            reuse_port=None,\n        ),\n        hosts,\n    )\n    patched_loop.create_server.assert_has_calls(calls)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_custom_backlog",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 531,
            "end_line_number": 537,
            "source_code": "def test_run_app_custom_backlog(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, backlog=10, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=10, reuse_address=None, reuse_port=None\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_custom_backlog",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 531,
            "end_line_number": 537,
            "source_code": "def test_run_app_custom_backlog(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, backlog=10, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=10, reuse_address=None, reuse_port=None\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input (like pressing Ctrl+C).\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns this function `f`, allowing it to be called later to trigger the interruption of the event loop. This mechanism is particularly useful in scenarios where you want to handle graceful shutdowns of long-running asynchronous tasks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_custom_backlog_unix",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 540,
            "end_line_number": 552,
            "source_code": "def test_run_app_custom_backlog_unix(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(\n        app,\n        path=\"/tmp/tmpsock.sock\",\n        backlog=10,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, \"/tmp/tmpsock.sock\", ssl=None, backlog=10\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to verify that the server can handle requests and respond correctly, including testing for timeouts.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a user-provided task and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and sets up a cleanup context for running tests.\n7. **Running the Server**: It uses `web.run_app` to start the server with the provided socket and timeout, while also ensuring that the test task runs concurrently.\n8. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation. \n\nThis method is particularly useful for testing web applications in an asynchronous environment, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_custom_backlog_unix",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 540,
            "end_line_number": 552,
            "source_code": "def test_run_app_custom_backlog_unix(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(\n        app,\n        path=\"/tmp/tmpsock.sock\",\n        backlog=10,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, \"/tmp/tmpsock.sock\", ssl=None, backlog=10\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the `f` function, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_http_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 556,
            "end_line_number": 567,
            "source_code": "def test_run_app_http_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(app, path=unix_sockname, print=printer, loop=patched_loop)\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=None, backlog=128\n    )\n    assert f\"http://unix:{unix_sockname}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "unix_sockname"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://unix:{unix_sockname}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_http_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 556,
            "end_line_number": 567,
            "source_code": "def test_run_app_http_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(app, path=unix_sockname, print=printer, loop=patched_loop)\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=None, backlog=128\n    )\n    assert f\"http://unix:{unix_sockname}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "unix_sockname"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://unix:{unix_sockname}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_https_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 571,
            "end_line_number": 589,
            "source_code": "def test_run_app_https_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(\n        app,\n        path=unix_sockname,\n        ssl_context=ssl_context,\n        print=printer,\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=ssl_context, backlog=128\n    )\n    assert f\"https://unix:{unix_sockname}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "unix_sockname"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'https://unix:{unix_sockname}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to verify that the server can handle requests and respond correctly, including testing for timeouts.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a user-provided task and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_https_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 571,
            "end_line_number": 589,
            "source_code": "def test_run_app_https_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(\n        app,\n        path=unix_sockname,\n        ssl_context=ssl_context,\n        print=printer,\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=ssl_context, backlog=128\n    )\n    assert f\"https://unix:{unix_sockname}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "unix_sockname"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'https://unix:{unix_sockname}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the `f` function, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_abstract_linux_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 594,
            "end_line_number": 606,
            "source_code": "def test_run_app_abstract_linux_socket(patched_loop: asyncio.AbstractEventLoop) -> None:\n    sock_path = b\"\\x00\" + uuid4().hex.encode(\"ascii\")\n    app = web.Application()\n    web.run_app(\n        app,\n        path=sock_path.decode(\"ascii\", \"ignore\"),\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock_path.decode(\"ascii\"), ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires UNIX sockets')",
                "skip_if_no_abstract_paths"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After running the app, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_abstract_linux_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 594,
            "end_line_number": 606,
            "source_code": "def test_run_app_abstract_linux_socket(patched_loop: asyncio.AbstractEventLoop) -> None:\n    sock_path = b\"\\x00\" + uuid4().hex.encode(\"ascii\")\n    app = web.Application()\n    web.run_app(\n        app,\n        path=sock_path.decode(\"ascii\", \"ignore\"),\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock_path.decode(\"ascii\"), ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires UNIX sockets')",
                "skip_if_no_abstract_paths"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock_path.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `sock_path.decode` method is intended to decode a byte string into a regular string using a specified character encoding. However, the current implementation contains an assertion that always fails, indicating that the method is not yet functional.\n\n**How It Works**:\nThe method is defined to take two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. In a complete implementation, it would convert the byte representation of a socket path into a string based on the provided encoding, handling any decoding errors according to the specified error handling strategy. The assertion `assert False` effectively prevents any execution of the method, signaling that it is a placeholder or incomplete."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_abstract_linux_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 594,
            "end_line_number": 606,
            "source_code": "def test_run_app_abstract_linux_socket(patched_loop: asyncio.AbstractEventLoop) -> None:\n    sock_path = b\"\\x00\" + uuid4().hex.encode(\"ascii\")\n    app = web.Application()\n    web.run_app(\n        app,\n        path=sock_path.decode(\"ascii\", \"ignore\"),\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock_path.decode(\"ascii\"), ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires UNIX sockets')",
                "skip_if_no_abstract_paths"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock_path.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `sock_path.decode` method is intended to decode a byte string into a regular string using a specified character encoding. However, the current implementation contains an assertion that always fails, indicating that the method is not yet functional.\n\n**How It Works**:\nThe method is defined to take two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. In a complete implementation, it would convert the byte representation of a socket path into a string based on the provided encoding, handling any decoding errors according to the specified error handling strategy. The assertion `assert False` effectively prevents any execution of the method, signaling that it is a placeholder or incomplete."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_abstract_linux_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 594,
            "end_line_number": 606,
            "source_code": "def test_run_app_abstract_linux_socket(patched_loop: asyncio.AbstractEventLoop) -> None:\n    sock_path = b\"\\x00\" + uuid4().hex.encode(\"ascii\")\n    app = web.Application()\n    web.run_app(\n        app,\n        path=sock_path.decode(\"ascii\", \"ignore\"),\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock_path.decode(\"ascii\"), ssl=None, backlog=128\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires UNIX sockets')",
                "skip_if_no_abstract_paths"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down long-running asyncio tasks or servers in response to specific conditions or signals."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_inet_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 609,
            "end_line_number": 625,
            "source_code": "def test_run_app_preexisting_inet_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket()\n    with contextlib.closing(sock):\n        sock.bind((\"127.0.0.1\", 0))\n        _, port = sock.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://127.0.0.1:{port}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "mocker"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://127.0.0.1:{port}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to verify that the server can handle requests and respond correctly, including testing for timeouts.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a user-provided task and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_inet_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 609,
            "end_line_number": 625,
            "source_code": "def test_run_app_preexisting_inet_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket()\n    with contextlib.closing(sock):\n        sock.bind((\"127.0.0.1\", 0))\n        _, port = sock.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://127.0.0.1:{port}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "mocker"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://127.0.0.1:{port}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input (like pressing Ctrl+C).\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns this function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in long-running asynchronous applications to handle shutdown requests cleanly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_inet6_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 629,
            "end_line_number": 645,
            "source_code": "def test_run_app_preexisting_inet6_socket(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket(socket.AF_INET6)\n    with contextlib.closing(sock):\n        sock.bind((\"::1\", 0))\n        port = sock.getsockname()[1]\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://[::1]:{port}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not HAS_IPV6, reason='IPv6 is not available')"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://[::1]:{port}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_inet6_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 629,
            "end_line_number": 645,
            "source_code": "def test_run_app_preexisting_inet6_socket(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket(socket.AF_INET6)\n    with contextlib.closing(sock):\n        sock.bind((\"::1\", 0))\n        port = sock.getsockname()[1]\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://[::1]:{port}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(not HAS_IPV6, reason='IPv6 is not available')"
            ],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://[::1]:{port}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input (like pressing Ctrl+C).\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in long-running asynchronous applications to handle graceful shutdowns."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 649,
            "end_line_number": 666,
            "source_code": "def test_run_app_preexisting_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock_path = \"/tmp/test_preexisting_sock1\"\n    sock = socket.socket(socket.AF_UNIX)\n    with contextlib.closing(sock):\n        sock.bind(sock_path)\n        os.unlink(sock_path)\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://unix:{sock_path}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "mocker"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://unix:{sock_path}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were active before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to simulate requests to the server, checking for timeouts and ensuring the server responds correctly.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a provided task asynchronously and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed without exceptions and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_preexisting_unix_socket",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 649,
            "end_line_number": 666,
            "source_code": "def test_run_app_preexisting_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock_path = \"/tmp/test_preexisting_sock1\"\n    sock = socket.socket(socket.AF_UNIX)\n    with contextlib.closing(sock):\n        sock.bind(sock_path)\n        os.unlink(sock_path)\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://unix:{sock_path}:\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [
                "skip_if_no_unix_socks"
            ],
            "arguments": [
                "patched_loop",
                "mocker"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://unix:{sock_path}:' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_multiple_preexisting_sockets",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 669,
            "end_line_number": 692,
            "source_code": "def test_run_app_multiple_preexisting_sockets(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock1 = socket.socket()\n    sock2 = socket.socket()\n    with contextlib.closing(sock1), contextlib.closing(sock2):\n        sock1.bind((\"localhost\", 0))\n        _, port1 = sock1.getsockname()\n        sock2.bind((\"localhost\", 0))\n        _, port2 = sock2.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=(sock1, sock2), print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_has_calls(  # type: ignore[attr-defined]\n            [\n                mock.call(mock.ANY, sock=sock1, backlog=128, ssl=None),\n                mock.call(mock.ANY, sock=sock2, backlog=128, ssl=None),\n            ]\n        )\n        assert f\"http://127.0.0.1:{port1}\" in printer.call_args[0][0]\n        assert f\"http://127.0.0.1:{port2}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://127.0.0.1:{port1}' in printer.call_args[0][0]",
                "assert f'http://127.0.0.1:{port2}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using the `aiohttp` framework. It sets up a server that listens for incoming connections on a specified socket, runs a provided task, and allows for testing the server's behavior under certain conditions.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for the server to bind to and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during server shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to simulate client requests to the server, checking for timeouts and ensuring the server responds correctly.\n5. **Request Handling**: A request handler is defined that runs the provided task asynchronously and returns a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the specified socket.\n7. **Assertions**: After running the server, it checks that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for testing web applications in a controlled environment, ensuring that they handle requests and shutdowns gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_multiple_preexisting_sockets",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 669,
            "end_line_number": 692,
            "source_code": "def test_run_app_multiple_preexisting_sockets(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock1 = socket.socket()\n    sock2 = socket.socket()\n    with contextlib.closing(sock1), contextlib.closing(sock2):\n        sock1.bind((\"localhost\", 0))\n        _, port1 = sock1.getsockname()\n        sock2.bind((\"localhost\", 0))\n        _, port2 = sock2.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=(sock1, sock2), print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_has_calls(  # type: ignore[attr-defined]\n            [\n                mock.call(mock.ANY, sock=sock1, backlog=128, ssl=None),\n                mock.call(mock.ANY, sock=sock2, backlog=128, ssl=None),\n            ]\n        )\n        assert f\"http://127.0.0.1:{port1}\" in printer.call_args[0][0]\n        assert f\"http://127.0.0.1:{port2}\" in printer.call_args[0][0]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert f'http://127.0.0.1:{port1}' in printer.call_args[0][0]",
                "assert f'http://127.0.0.1:{port2}' in printer.call_args[0][0]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(wraps=stopper(patched_loop))"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input or a signal.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption of the event loop. This mechanism is particularly useful in scenarios where you want to programmatically stop long-running asynchronous tasks or servers."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_sigint",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 703,
            "end_line_number": 714,
            "source_code": "def test_sigint() -> None:\n    skip_if_on_windows()\n\n    with subprocess.Popen(\n        [sys.executable, \"-u\", \"-c\", _script_test_signal],\n        stdout=subprocess.PIPE,\n    ) as proc:\n        for line in proc.stdout:  # type: ignore[union-attr]\n            if line.startswith(b\"======== Running on\"):\n                break\n        proc.send_signal(signal.SIGINT)\n        assert proc.wait() == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert proc.wait() == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "skip_if_on_windows",
                    "body": "def skip_if_on_windows() -> None:\n    if platform.system() == 'Windows':\n        pytest.skip('the test is not valid for Windows')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `skip_if_on_windows` method is designed to conditionally skip tests when they are being run on a Windows operating system. This is useful for tests that are not applicable or may fail on Windows due to platform-specific behavior.\n\n**How It Works**:\nThe method checks the current operating system using `platform.system()`. If the result is 'Windows', it calls `pytest.skip()` with a message indicating that the test is not valid for Windows. This effectively prevents the test from running on Windows, allowing developers to avoid unnecessary failures in their test suite when executed in that environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_sigterm",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 717,
            "end_line_number": 728,
            "source_code": "def test_sigterm() -> None:\n    skip_if_on_windows()\n\n    with subprocess.Popen(\n        [sys.executable, \"-u\", \"-c\", _script_test_signal],\n        stdout=subprocess.PIPE,\n    ) as proc:\n        for line in proc.stdout:  # type: ignore[union-attr]\n            if line.startswith(b\"======== Running on\"):\n                break\n        proc.terminate()\n        assert proc.wait() == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert proc.wait() == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "skip_if_on_windows",
                    "body": "def skip_if_on_windows() -> None:\n    if platform.system() == 'Windows':\n        pytest.skip('the test is not valid for Windows')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `skip_if_on_windows` method is designed to conditionally skip tests when they are being run on a Windows operating system. This is useful for tests that are not applicable or may fail on Windows due to platform-specific behavior.\n\n**How It Works**:\nThe method checks the current operating system using `platform.system()`. If the result is 'Windows', it calls `pytest.skip()` with a message indicating that the test is not valid for Windows. This effectively prevents the test from running on Windows, allowing developers to avoid unnecessary failures in their test suite when executed in that environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_startup_cleanup_signals_even_on_failure",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 731,
            "end_line_number": 746,
            "source_code": "def test_startup_cleanup_signals_even_on_failure(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    patched_loop.create_server.side_effect = RuntimeError()  # type: ignore[attr-defined]\n\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    with pytest.raises(RuntimeError):\n        web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections, allowing it to count connections before they are cleared during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a user-defined task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_startup_cleanup_signals_even_on_failure",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 731,
            "end_line_number": 746,
            "source_code": "def test_startup_cleanup_signals_even_on_failure(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    patched_loop.create_server.side_effect = RuntimeError()  # type: ignore[attr-defined]\n\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    with pytest.raises(RuntimeError):\n        web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input (like pressing Ctrl+C).\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns this function `f`, allowing it to be called later to trigger the interruption of the event loop. This mechanism is particularly useful in scenarios where you want to handle graceful shutdowns of long-running asynchronous tasks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_coro",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 749,
            "end_line_number": 769,
            "source_code": "def test_run_app_coro(patched_loop: asyncio.AbstractEventLoop) -> None:\n    startup_handler = cleanup_handler = None\n\n    async def make_app() -> web.Application:\n        nonlocal startup_handler, cleanup_handler\n        app = web.Application()\n        startup_handler = make_mocked_coro()\n        app.on_startup.append(startup_handler)\n        cleanup_handler = make_mocked_coro()\n        app.on_cleanup.append(cleanup_handler)\n        return app\n\n    web.run_app(make_app(), print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert startup_handler is not None\n    assert cleanup_handler is not None\n    startup_handler.assert_called_once_with(mock.ANY)\n    cleanup_handler.assert_called_once_with(mock.ANY)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert startup_handler is not None",
                "assert cleanup_handler is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using the `aiohttp` framework. It sets up a server that listens for incoming connections on a specified socket, runs a given task, and allows for testing the application's behavior under certain conditions.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for the server to bind to and a timeout for shutting down the server.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking. This server will handle incoming requests.\n4. **Testing Logic**: An asynchronous test function is defined to simulate client requests to the server, checking for timeouts and ensuring the server responds correctly.\n5. **Request Handling**: A request handler is defined that runs the provided task asynchronously and returns a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for testing web applications in a controlled environment, ensuring that they handle requests and shutdown procedures correctly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_coro",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 749,
            "end_line_number": 769,
            "source_code": "def test_run_app_coro(patched_loop: asyncio.AbstractEventLoop) -> None:\n    startup_handler = cleanup_handler = None\n\n    async def make_app() -> web.Application:\n        nonlocal startup_handler, cleanup_handler\n        app = web.Application()\n        startup_handler = make_mocked_coro()\n        app.on_startup.append(startup_handler)\n        cleanup_handler = make_mocked_coro()\n        app.on_cleanup.append(cleanup_handler)\n        return app\n\n    web.run_app(make_app(), print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert startup_handler is not None\n    assert cleanup_handler is not None\n    startup_handler.assert_called_once_with(mock.ANY)\n    cleanup_handler.assert_called_once_with(mock.ANY)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert startup_handler is not None",
                "assert cleanup_handler is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the `f` function, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 772,
            "end_line_number": 794,
            "source_code": "def test_run_app_default_logger(\n    monkeypatch: pytest.MonkeyPatch, patched_loop: asyncio.AbstractEventLoop\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_any_call(logging.DEBUG)\n    mock_logger.hasHandlers.assert_called_with()\n    assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "monkeypatch",
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections and count them before clearing.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to verify that the server can handle requests and respond correctly, including handling timeouts.\n5. **Request Handling**: A request handler is set up to execute a provided task asynchronously and return a response.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 772,
            "end_line_number": 794,
            "source_code": "def test_run_app_default_logger(\n    monkeypatch: pytest.MonkeyPatch, patched_loop: asyncio.AbstractEventLoop\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_any_call(logging.DEBUG)\n    mock_logger.hasHandlers.assert_called_with()\n    assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "monkeypatch",
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_requires_debug",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 797,
            "end_line_number": 819,
            "source_code": "def test_run_app_default_logger_setup_requires_debug(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=False,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a user-defined task and returns a response.\n5. **Testing Logic**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the provided socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully while monitoring connection states."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_requires_debug",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 797,
            "end_line_number": 819,
            "source_code": "def test_run_app_default_logger_setup_requires_debug(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=False,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns this inner function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_requires_default_logger",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 822,
            "end_line_number": 844,
            "source_code": "def test_run_app_default_logger_setup_requires_default_logger(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": None,\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_requires_default_logger",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 822,
            "end_line_number": 844,
            "source_code": "def test_run_app_default_logger_setup_requires_default_logger(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": None,\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for gracefully stopping an asynchronous event loop, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the shutdown process of an application that relies on asynchronous operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_only_if_unconfigured",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 847,
            "end_line_number": 869,
            "source_code": "def test_run_app_default_logger_setup_only_if_unconfigured(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": True,\n        \"level\": None,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_called_with()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a user-defined task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is started using the provided socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully while monitoring connection states."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_default_logger_setup_only_if_unconfigured",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 847,
            "end_line_number": 869,
            "source_code": "def test_run_app_default_logger_setup_only_if_unconfigured(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": True,\n        \"level\": None,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_called_with()\n    mock_logger.addHandler.assert_not_called()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, particularly in scenarios where you want to interrupt long-running tasks.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interruption. This mechanism is particularly useful in managing the lifecycle of asynchronous tasks and handling shutdown procedures in an event-driven application."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_all_pending_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 872,
            "end_line_number": 887,
            "source_code": "def test_run_app_cancels_all_pending_tasks(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    task = None\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(asyncio.sleep(1000))\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.cancelled()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.cancelled()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections, allowing it to count connections before they are cleared during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a user-defined task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_all_pending_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 872,
            "end_line_number": 887,
            "source_code": "def test_run_app_cancels_all_pending_tasks(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    task = None\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(asyncio.sleep(1000))\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.cancelled()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.cancelled()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_done_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 890,
            "end_line_number": 906,
            "source_code": "def test_run_app_cancels_done_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    async def coro() -> int:\n        return 123\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(coro())\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were active before clearing.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to check the server's responsiveness and handle potential timeouts when making requests.\n5. **Request Handling**: A request handler is defined to execute a provided task asynchronously and respond with a simple message.\n6. **Application Setup**: The method creates a web application, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_done_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 890,
            "end_line_number": 906,
            "source_code": "def test_run_app_cancels_done_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    async def coro() -> int:\n        return 123\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(coro())\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "task.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `done` method is designed to indicate the completion status of a task. It returns a boolean value, specifically `True`, suggesting that the task has been successfully completed.\n\n**How It Works**:  \nThe method is defined within a class (likely a task or job management class) and simply returns `True` when called. This implies that the task is considered done without any additional logic or checks. In the context of asynchronous programming, this method could be used to quickly verify if a task has finished executing, although it does not provide information about the task's success or failure."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_done_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 890,
            "end_line_number": 906,
            "source_code": "def test_run_app_cancels_done_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    async def coro() -> int:\n        return 123\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(coro())\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the `f` function, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_failed_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 909,
            "end_line_number": 940,
            "source_code": "def test_run_app_cancels_failed_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    exc = RuntimeError(\"FAIL\")\n\n    async def fail() -> None:\n        try:\n            await asyncio.sleep(1000)\n        except asyncio.CancelledError:\n            raise exc\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(fail())\n        await asyncio.sleep(0.01)\n\n    app.on_startup.append(on_startup)\n\n    exc_handler = mock.Mock()\n    patched_loop.set_exception_handler(exc_handler)\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()\n\n    msg = {\n        \"message\": \"unhandled exception during asyncio.run() shutdown\",\n        \"exception\": exc,\n        \"task\": task,\n    }\n    exc_handler.assert_called_with(patched_loop, msg)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication, manage connections, and run a test task while handling shutdown procedures gracefully.\n\n**How It Works**:\n1. **Socket and Timeout**: It accepts a socket for the application to bind to and a timeout for shutdown operations.\n2. **Connection Management**: It defines a custom dictionary class (`DictRecordClear`) to track active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection management.\n4. **Test Task Execution**: An asynchronous test function is defined to perform checks on the server's responsiveness, including handling timeouts and making requests to the server.\n5. **Request Handling**: A request handler is defined to execute a user-provided task and return a response.\n6. **Application Setup**: The method sets up the web application, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdowns properly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_failed_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 909,
            "end_line_number": 940,
            "source_code": "def test_run_app_cancels_failed_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    exc = RuntimeError(\"FAIL\")\n\n    async def fail() -> None:\n        try:\n            await asyncio.sleep(1000)\n        except asyncio.CancelledError:\n            raise exc\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(fail())\n        await asyncio.sleep(0.01)\n\n    app.on_startup.append(on_startup)\n\n    exc_handler = mock.Mock()\n    patched_loop.set_exception_handler(exc_handler)\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()\n\n    msg = {\n        \"message\": \"unhandled exception during asyncio.run() shutdown\",\n        \"exception\": exc,\n        \"task\": task,\n    }\n    exc_handler.assert_called_with(patched_loop, msg)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "task.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate the completion status of a task, returning a boolean value that signifies whether the task has finished executing.\n\n**How It Works**:\nThe method is defined within a class (presumably a task-related class) and simply returns `True`, indicating that the task is considered done. This method can be useful in scenarios where you need to check if a task has completed its execution, although in its current form, it does not account for any actual task state or conditions. It serves as a placeholder or a default implementation that can be overridden in subclasses to provide more specific completion logic."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_cancels_failed_tasks",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 909,
            "end_line_number": 940,
            "source_code": "def test_run_app_cancels_failed_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    exc = RuntimeError(\"FAIL\")\n\n    async def fail() -> None:\n        try:\n            await asyncio.sleep(1000)\n        except asyncio.CancelledError:\n            raise exc\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(fail())\n        await asyncio.sleep(0.01)\n\n    app.on_startup.append(on_startup)\n\n    exc_handler = mock.Mock()\n    patched_loop.set_exception_handler(exc_handler)\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()\n\n    msg = {\n        \"message\": \"unhandled exception during asyncio.run() shutdown\",\n        \"exception\": exc,\n        \"task\": task,\n    }\n    exc_handler.assert_called_with(patched_loop, msg)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert task is not None",
                "assert task.done()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_keepalive_timeout",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 943,
            "end_line_number": 964,
            "source_code": "def test_run_app_keepalive_timeout(\n    patched_loop: asyncio.AbstractEventLoop,\n    mocker: MockerFixture,\n    monkeypatch: pytest.MonkeyPatch,\n) -> None:\n    new_timeout = 1234\n    base_runner_init_orig = BaseRunner.__init__\n\n    def base_runner_init_spy(\n        self: BaseRunner[web.Request], *args: Any, **kwargs: Any\n    ) -> None:\n        assert kwargs[\"keepalive_timeout\"] == new_timeout\n        base_runner_init_orig(self, *args, **kwargs)\n\n    app = web.Application()\n    monkeypatch.setattr(BaseRunner, \"__init__\", base_runner_init_spy)\n    web.run_app(\n        app,\n        keepalive_timeout=new_timeout,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "mocker",
                "monkeypatch"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert kwargs['keepalive_timeout'] == new_timeout"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections.\n\nThis method is crucial for developers looking to deploy and test asynchronous web applications efficiently while ensuring proper resource management."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_keepalive_timeout",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 943,
            "end_line_number": 964,
            "source_code": "def test_run_app_keepalive_timeout(\n    patched_loop: asyncio.AbstractEventLoop,\n    mocker: MockerFixture,\n    monkeypatch: pytest.MonkeyPatch,\n) -> None:\n    new_timeout = 1234\n    base_runner_init_orig = BaseRunner.__init__\n\n    def base_runner_init_spy(\n        self: BaseRunner[web.Request], *args: Any, **kwargs: Any\n    ) -> None:\n        assert kwargs[\"keepalive_timeout\"] == new_timeout\n        base_runner_init_orig(self, *args, **kwargs)\n\n    app = web.Application()\n    monkeypatch.setattr(BaseRunner, \"__init__\", base_runner_init_spy)\n    web.run_app(\n        app,\n        keepalive_timeout=new_timeout,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop",
                "mocker",
                "monkeypatch"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert kwargs['keepalive_timeout'] == new_timeout"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for programmatically stopping an asyncio event loop, simulating a user interrupt.\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns the function `f`, allowing it to be called later to trigger the interrupt. This mechanism can be used to gracefully shut down an asyncio application by simulating a keyboard interrupt."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_context_vars",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 967,
            "end_line_number": 996,
            "source_code": "def test_run_app_context_vars(patched_loop: asyncio.AbstractEventLoop) -> None:\n    from contextvars import ContextVar\n\n    count = 0\n    VAR = ContextVar(\"VAR\", default=\"default\")\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal count\n        assert \"init\" == VAR.get()\n        VAR.set(\"on_startup\")\n        count += 1\n\n    async def on_cleanup(app: web.Application) -> None:\n        nonlocal count\n        assert \"on_startup\" == VAR.get()\n        count += 1\n\n    async def init() -> web.Application:\n        nonlocal count\n        assert \"default\" == VAR.get()\n        VAR.set(\"init\")\n        app = web.Application()\n\n        app.on_startup.append(on_startup)\n        app.on_cleanup.append(on_cleanup)\n        count += 1\n        return app\n\n    web.run_app(init(), print=stopper(patched_loop), loop=patched_loop)\n    assert count == 3",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert count == 3",
                "assert 'init' == VAR.get()",
                "assert 'on_startup' == VAR.get()",
                "assert 'default' == VAR.get()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to keep track of active connections, allowing it to count connections before they are cleared during shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's lifecycle. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_context_vars",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 967,
            "end_line_number": 996,
            "source_code": "def test_run_app_context_vars(patched_loop: asyncio.AbstractEventLoop) -> None:\n    from contextvars import ContextVar\n\n    count = 0\n    VAR = ContextVar(\"VAR\", default=\"default\")\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal count\n        assert \"init\" == VAR.get()\n        VAR.set(\"on_startup\")\n        count += 1\n\n    async def on_cleanup(app: web.Application) -> None:\n        nonlocal count\n        assert \"on_startup\" == VAR.get()\n        count += 1\n\n    async def init() -> web.Application:\n        nonlocal count\n        assert \"default\" == VAR.get()\n        VAR.set(\"init\")\n        app = web.Application()\n\n        app.on_startup.append(on_startup)\n        app.on_cleanup.append(on_cleanup)\n        count += 1\n        return app\n\n    web.run_app(init(), print=stopper(patched_loop), loop=patched_loop)\n    assert count == 3",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert count == 3",
                "assert 'init' == VAR.get()",
                "assert 'on_startup' == VAR.get()",
                "assert 'default' == VAR.get()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "stopper",
                    "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `stopper` method is designed to create a callable function that, when invoked, raises a `KeyboardInterrupt` exception. This is useful for stopping an asynchronous event loop gracefully, typically in response to user input (like pressing Ctrl+C).\n\n**How It Works**:\nThe `stopper` method takes an `asyncio.AbstractEventLoop` as an argument and defines an inner function `raiser` that raises a `KeyboardInterrupt`. Another inner function `f` is defined, which schedules the `raiser` function to be called soon on the provided event loop using `loop.call_soon(raiser)`. The `stopper` method then returns this function `f`, allowing it to be called later to trigger the interruption of the event loop. This mechanism is particularly useful in scenarios where you want to handle graceful shutdowns of long-running asynchronous tasks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_run_app_raises_exception",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 999,
            "end_line_number": 1013,
            "source_code": "def test_run_app_raises_exception(patched_loop: asyncio.AbstractEventLoop) -> None:\n    async def context(app: web.Application) -> AsyncIterator[None]:\n        raise RuntimeError(\"foo\")\n        yield  # type: ignore[unreachable]  # pragma: no cover\n\n    app = web.Application()\n    app.cleanup_ctx.append(context)\n\n    with mock.patch.object(\n        patched_loop, \"call_exception_handler\", autospec=True, spec_set=True\n    ) as m:\n        with pytest.raises(RuntimeError, match=\"foo\"):\n            web.run_app(app, loop=patched_loop)\n\n    assert not m.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "patched_loop"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert not m.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and count them before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Logic**: It includes a testing coroutine that checks the server's response to requests and ensures proper handling of timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_wait_for_handler",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1095,
            "end_line_number": 1109,
            "source_code": "def test_shutdown_wait_for_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert not t.cancelled()",
                "assert connection_count == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Port Setup**: The method takes a socket, a timeout value, a task to run, and an optional extra test function. It retrieves the port from the provided socket.\n\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track active connections. This class overrides the `clear` method to update the `num_connections` variable, which counts how many connections are active before they are cleared.\n\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to use the custom connection tracking. \n\n4. **Testing Logic**: An asynchronous `test` function is defined to perform health checks on the server by making requests to it. It includes error handling for timeouts and attempts to stop the server gracefully.\n\n5. **Request Handling**: The main request handler (`handler`) starts the specified task and returns a response once the task is complete.\n\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler and a stop route, and runs the application using the provided socket.\n\n7. **Assertions and Return**: After the application runs, it asserts that the test task completed successfully and returns the task and the number of connections that were active during the server's operation. \n\nThis method is crucial for testing the behavior of the web application under various conditions, ensuring that it can handle requests and shutdown properly."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_wait_for_handler",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1095,
            "end_line_number": 1109,
            "source_code": "def test_shutdown_wait_for_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert not t.cancelled()",
                "assert connection_count == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (presumably related to asynchronous operations or task management). When called, it simply returns the boolean value `True`, which can be used by other parts of the code to check the completion status of the task. This method is likely intended to be overridden or extended in subclasses to provide more specific completion logic."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_handler",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1111,
            "end_line_number": 1125,
            "source_code": "def test_shutdown_timeout_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is False",
                "assert t.done()",
                "assert t.cancelled()",
                "assert connection_count == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Port Setup**: The method takes a socket, a timeout value, a task to run, and an optional extra test function. It retrieves the port from the provided socket.\n\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections. This helps in identifying potential memory leaks during shutdown.\n\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to use the custom connection tracking.\n\n4. **Testing Logic**: An asynchronous `test` function is defined to perform health checks on the server by making requests to it. It ensures that the server responds correctly and handles timeouts.\n\n5. **Request Handling**: The main request handler (`handler`) starts the specified task and returns a response. The task runs asynchronously, allowing the server to handle multiple requests concurrently.\n\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and sets up a cleanup context for running tests.\n\n7. **Running the Application**: Finally, it runs the application using `web.run_app`, passing the socket and timeout. After the application stops, it checks that the test task completed successfully and returns the task and the number of connections that were active before shutdown. \n\nThis method is crucial for testing and running asynchronous web applications in a controlled manner, ensuring proper resource management and error handling."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_handler",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1111,
            "end_line_number": 1125,
            "source_code": "def test_shutdown_timeout_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is False",
                "assert t.done()",
                "assert t.cancelled()",
                "assert connection_count == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain operation or task has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class and simply returns a boolean value of `True`. This implies that any instance of the class can call this method to check the completion status, which in this case is always affirmative. This could be useful in scenarios where the method is expected to provide a completion status, even if the actual logic for determining completion is not implemented or is trivial."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_not_reached",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1127,
            "end_line_number": 1146,
            "source_code": "def test_shutdown_timeout_not_reached(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n\n        t, connection_count = self.run_app(sock, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert time.time() - start_time < 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It establishes a server that listens for incoming requests, executes a specified task, and manages connections while allowing for testing and graceful shutdown.\n\n**How It Works**:\n1. **Connection Management**: The method defines a custom dictionary class (`DictRecordClear`) to track active connections. It overrides the `clear` method to update the count of current connections before clearing them, which helps in identifying potential memory leaks.\n\n2. **Server Setup**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection management. The main application is instantiated, and routes are defined for handling requests and stopping the server.\n\n3. **Testing Logic**: An asynchronous `test` function is defined to simulate client requests to the server. It checks for timeouts and ensures that the server responds correctly. If an `extra_test` function is provided, it is executed after the main test.\n\n4. **Running the Application**: The application is run using `web.run_app`, which starts the server and listens for incoming connections on the provided socket. The method waits for the test task to complete and checks for any exceptions.\n\n5. **Return Values**: Finally, the method returns a tuple containing the task associated with the main operation and the number of connections that were active before shutdown, allowing for further analysis or testing."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_not_reached",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1127,
            "end_line_number": 1146,
            "source_code": "def test_shutdown_timeout_not_reached(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n\n        t, connection_count = self.run_app(sock, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert time.time() - start_time < 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True`. This implies that any instance of the class will report that it has finished its operation when `done()` is called. This could be useful in scenarios where the completion status of tasks needs to be checked, such as in asynchronous programming or task management systems."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_new_conn_rejected",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1148,
            "end_line_number": 1174,
            "source_code": "def test_shutdown_new_conn_rejected(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://127.0.0.1:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(sock, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert finished is False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for network communication and a timeout value for shutting down the server.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during server shutdown.\n3. **Server Setup**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task when a request is received at the root endpoint (`/`).\n5. **Testing Logic**: It includes a testing coroutine that attempts to make requests to the server, checking for timeouts and ensuring the server responds correctly.\n6. **Application Execution**: The web application is run using `web.run_app`, which starts the server and listens for incoming requests on the specified socket.\n7. **Assertions and Return**: After the server has run, it asserts that the test task completed successfully and returns the task and the number of connections that were active before shutdown. \n\nThis method is crucial for testing and running asynchronous web applications, ensuring they handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_new_conn_rejected",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1148,
            "end_line_number": 1174,
            "source_code": "def test_shutdown_new_conn_rejected(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://127.0.0.1:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(sock, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert finished is False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True`. This implies that any instance of the class can call this method to check the completion status, which in this case is always affirmative. This could be useful in scenarios where the completion state is predetermined or does not require further checks."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_pending_handler_responds",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1176,
            "end_line_number": 1221,
            "source_code": "def test_shutdown_pending_handler_responds(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                async with sess.get(f\"http://127.0.0.1:{port}/\") as resp:\n                    assert await resp.text() == \"FOO\"\n\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(1)\n                # Handler is in-progress while we trigger server shutdown.\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                assert finished is False\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            nonlocal finished\n            await asyncio.sleep(3)\n            finished = True\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=5)\n        assert t is not None\n        assert t.exception() is None\n        assert finished is True",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.exception() is None",
                "assert finished is True",
                "assert finished is False",
                "assert await resp.text() == 'FOO'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to verify that the server can handle requests and respond correctly, including testing for timeouts.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a provided task asynchronously and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_idle_keepalive",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1223,
            "end_line_number": 1255,
            "source_code": "def test_shutdown_close_idle_keepalive(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        t = None\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                # Hold on to keep-alive connection.\n                await asyncio.sleep(5)\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        # If connection closed, then test() will be cancelled in cleanup_ctx.\n        # If not, then shutdown_timeout will allow it to sleep until complete.\n        assert t is not None\n        assert t.cancelled()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.cancelled()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using the `aiohttp` framework. It sets up a server that listens for incoming connections on a specified socket, runs a given task, and allows for testing the server's behavior under certain conditions.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for the server to bind to and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during server shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking. The server is set up to handle incoming requests and to respond to a stop request.\n4. **Testing Logic**: An asynchronous test function is defined to simulate client requests to the server, checking for timeouts and ensuring the server responds correctly.\n5. **Running the Application**: The application is instantiated, routes are defined, and the server is run using `web.run_app`, which starts listening for requests.\n6. **Assertions**: After the server runs, it checks that the test task completed successfully and that the number of connections is recorded accurately.\n\nThis method is particularly useful for testing the behavior of web applications in a controlled environment, ensuring that they handle requests and shutdown processes as expected."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections and count them before clearing on shutdown.\n3. **Server Initialization**: A subclass of `web.Server` is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `ws.prepare` method is designed to take a bytes input and return it unchanged. This method serves as a placeholder for potential preprocessing or validation of the data before it is used elsewhere in the application.\n\n**How It Works**:\nThe method accepts a single parameter, `data`, which is expected to be of type `bytes`. It simply returns this data without any modifications. This straightforward implementation suggests that the method may be intended for future enhancements, such as adding logging, validation, or transformation of the input data."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.close` method is designed to close an active WebSocket connection, ensuring that all associated resources are properly released and that the connection is terminated gracefully.\n\n**How It Works**:  \nThe method is defined as an asynchronous function (`async def close(self) -> None:`) but currently contains no implementation (`pass`). In the context of the WebSocket handling code, it is invoked when a close message is received or when the connection is being closed. The method is expected to handle the cleanup of any ongoing operations, such as closing open transports and connections, and ensuring that the WebSocket is marked as closed. It is also designed to be idempotent, meaning that calling it multiple times will not have additional effects, which is useful for preventing errors in scenarios where the close operation might be triggered more than once."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_handler_cancellation_suppressed",
            "module": "test_run_app",
            "class_name": "TestShutdown",
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1311,
            "end_line_number": 1362,
            "source_code": "def test_shutdown_handler_cancellation_suppressed(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        actions = []\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                t = ClientTimeout(total=0.4)\n                with pytest.raises(asyncio.TimeoutError):\n                    async with sess.get(f\"http://127.0.0.1:{port}/\", timeout=t) as resp:\n                        assert await resp.text() == \"FOO\"\n                actions.append(\"CANCELLED\")\n\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(0.5)\n                # Handler is in-progress while we trigger server shutdown.\n                actions.append(\"PRESTOP\")\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                actions.append(\"STOPPING\")\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            try:\n                await asyncio.sleep(5)\n            except asyncio.CancelledError:\n                actions.append(\"SUPPRESSED\")\n                await asyncio.sleep(2)\n                actions.append(\"DONE\")\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=2, handler_cancellation=True)\n        assert t is not None\n        assert t.exception() is None\n        assert actions == [\"CANCELLED\", \"SUPPRESSED\", \"PRESTOP\", \"STOPPING\", \"DONE\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.exception() is None",
                "assert actions == ['CANCELLED', 'SUPPRESSED', 'PRESTOP', 'STOPPING', 'DONE']",
                "assert await resp.text() == 'FOO'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track active connections and clear them while counting how many were present before clearing.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function is defined to check the server's responsiveness and handle potential timeouts when making requests.\n5. **Request Handling**: A request handler is defined to execute a provided task asynchronously and return a response.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_wait_for_handler",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1095,
            "end_line_number": 1109,
            "source_code": "def test_shutdown_wait_for_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert not t.cancelled()",
                "assert connection_count == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for network communication and a timeout value for shutting down the server.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during shutdown.\n3. **Server Setup**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task when a request is received at the root endpoint (`/`).\n5. **Testing Logic**: It includes a testing coroutine that attempts to connect to the server and checks for timeouts, ensuring the server behaves as expected under load.\n6. **Application Lifecycle**: The application is run using `web.run_app`, which starts the server and listens for incoming requests. It also handles cleanup and shutdown processes.\n7. **Return Values**: Finally, the method returns the task associated with the provided task and the number of connections that were active before the server was shut down."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_wait_for_handler",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1095,
            "end_line_number": 1109,
            "source_code": "def test_shutdown_wait_for_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert not t.cancelled()",
                "assert connection_count == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True`. This implies that any instance of the class will report that it has finished its operation when this method is called. This could be useful in scenarios where the completion status of an operation needs to be checked, such as in asynchronous programming or task management."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_handler",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1111,
            "end_line_number": 1125,
            "source_code": "def test_shutdown_timeout_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is False",
                "assert t.done()",
                "assert t.cancelled()",
                "assert connection_count == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for network communication and a timeout value for shutting down the server.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during shutdown.\n3. **Server Setup**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task when a request is received at the root endpoint (`/`).\n5. **Testing Logic**: It includes a testing coroutine that attempts to make requests to the server, checking for timeouts and ensuring the server responds correctly.\n6. **Application Lifecycle**: The application is run using `web.run_app`, which starts the server and listens for incoming requests. The method also handles a shutdown route (`/stop`) to gracefully stop the server.\n7. **Return Values**: Finally, it returns the task associated with the executed request and the number of connections that were active before the server was cleared."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_handler",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1111,
            "end_line_number": 1125,
            "source_code": "def test_shutdown_timeout_handler(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(sock, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is False",
                "assert t.done()",
                "assert t.cancelled()",
                "assert connection_count == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:  \nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True` when called. This implies that the method is likely used in contexts where the completion status of an operation is checked, possibly in asynchronous programming or task management scenarios. The simplicity of the method suggests it may serve as a placeholder or a default implementation in a larger framework where more complex logic could be added later."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_not_reached",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1127,
            "end_line_number": 1146,
            "source_code": "def test_shutdown_timeout_not_reached(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n\n        t, connection_count = self.run_app(sock, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert time.time() - start_time < 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Port Setup**: The method takes a socket, a timeout value, a task to run, and an optional extra test function. It retrieves the port from the provided socket.\n\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track active connections and clear them while counting how many were present before clearing.\n\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to use the custom connection tracking.\n\n4. **Testing Logic**: An asynchronous `test` function is defined to perform health checks on the server, ensuring it responds correctly to requests and handles timeouts.\n\n5. **Request Handling**: The main request handler (`handler`) runs the provided task asynchronously and returns a response.\n\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler and a stop route, and runs the application using the provided socket.\n\n7. **Assertions and Return**: After the application runs, it asserts that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is crucial for testing and running web applications in an asynchronous environment, ensuring proper handling of requests and graceful shutdowns."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_timeout_not_reached",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1127,
            "end_line_number": 1146,
            "source_code": "def test_shutdown_timeout_not_reached(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n\n        t, connection_count = self.run_app(sock, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert time.time() - start_time < 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True`. This implies that any instance of the class can call this method to check the completion status, which in this case is always affirmative. This could be useful in scenarios where the completion state is predetermined or does not require dynamic evaluation."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_new_conn_rejected",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1148,
            "end_line_number": 1174,
            "source_code": "def test_shutdown_new_conn_rejected(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://127.0.0.1:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(sock, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert finished is False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to set up and run an asynchronous web application using the `aiohttp` framework. It manages the lifecycle of the application, including handling incoming requests, running a specified task, and performing cleanup operations upon shutdown.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for network communication and a timeout value for shutting down the server.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to track the number of active connections, which helps in identifying potential memory leaks during shutdown.\n3. **Server Setup**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task when a request is received at the root endpoint (`/`).\n5. **Testing Logic**: It includes a testing coroutine that attempts to make requests to the server, checking for timeouts and ensuring the server responds correctly.\n6. **Application Lifecycle**: The application is run using `web.run_app`, which starts the server and listens for incoming requests. The method also handles a shutdown route (`/stop`) to gracefully stop the server.\n7. **Return Values**: Finally, it returns the task associated with the executed request and the number of connections that were active before the server was cleared."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_new_conn_rejected",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1148,
            "end_line_number": 1174,
            "source_code": "def test_shutdown_new_conn_rejected(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://127.0.0.1:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(sock, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert finished is True",
                "assert t.done()",
                "assert connection_count == 0",
                "assert finished is False"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.done",
                    "body": "def done(self) -> bool:\n    return True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `done` method is designed to indicate whether a certain task or operation has been completed. In this implementation, it always returns `True`, suggesting that the task is considered complete.\n\n**How It Works**:\nThe method is defined within a class (not shown in the provided snippets) and simply returns a boolean value of `True`. This implies that any instance of the class will report that it has finished its operation when `done()` is called. This could be useful in scenarios where the completion status of tasks needs to be checked, although the current implementation does not reflect any actual state or condition."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_pending_handler_responds",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1176,
            "end_line_number": 1221,
            "source_code": "def test_shutdown_pending_handler_responds(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        finished = False\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                async with sess.get(f\"http://127.0.0.1:{port}/\") as resp:\n                    assert await resp.text() == \"FOO\"\n\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(1)\n                # Handler is in-progress while we trigger server shutdown.\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                assert finished is False\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            nonlocal finished\n            await asyncio.sleep(3)\n            finished = True\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=5)\n        assert t is not None\n        assert t.exception() is None\n        assert finished is True",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.exception() is None",
                "assert finished is True",
                "assert finished is False",
                "assert await resp.text() == 'FOO'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's response to requests and ensures that the server can handle timeouts correctly.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the server, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_idle_keepalive",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1223,
            "end_line_number": 1255,
            "source_code": "def test_shutdown_close_idle_keepalive(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        t = None\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                # Hold on to keep-alive connection.\n                await asyncio.sleep(5)\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        # If connection closed, then test() will be cancelled in cleanup_ctx.\n        # If not, then shutdown_timeout will allow it to sleep until complete.\n        assert t is not None\n        assert t.cancelled()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.cancelled()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully while monitoring connection states."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous handler for incoming requests, which executes a provided task and returns a response.\n5. **Testing Mechanism**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The web application is created, routes are defined, and the server is run using the specified socket.\n7. **Assertions**: After the server runs, it checks that the test task completed successfully and returns the task and the number of connections that were active during the server's operation.\n\nThis method is particularly useful for testing web applications in an asynchronous environment, ensuring that they can handle requests and shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.prepare",
                    "body": "def prepare(data: bytes) -> bytes:\n    return data",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `ws.prepare` method is designed to take a bytes input and return it unchanged. This method serves as a placeholder for potential preprocessing or validation of the data before it is used elsewhere in the application.\n\n**How It Works**:\nThe method accepts a single parameter, `data`, which is expected to be of type `bytes`. It simply returns this data without any modifications. This straightforward implementation suggests that the method may be intended for future enhancements, such as adding logging, validation, or transformation of the input data."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_close_websockets",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1257,
            "end_line_number": 1309,
            "source_code": "def test_shutdown_close_websockets(self, unused_port_socket: socket.socket) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://127.0.0.1:{port}/ws\") as ws:\n                    async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert time.time() - start < 5",
                "assert client_finished",
                "assert server_finished"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "ws.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `ws.close` method is designed to close an active WebSocket connection. It ensures that all resources associated with the WebSocket are properly released and that the connection is terminated gracefully.\n\n**How It Works**:  \nThe method is defined as an asynchronous function (`async def close(self) -> None:`) but currently has no implementation (`pass`). In the context of the WebSocket handling code, it is invoked when a close message is received or when the connection is being closed. The method is expected to handle the closure of all associated transports and connections, ensuring that any ongoing operations are completed or canceled. It also manages cleanup tasks and logs any errors encountered during the closure process. The method is idempotent, meaning that calling it multiple times will not have additional effects, making it safe to use in various scenarios."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_shutdown_handler_cancellation_suppressed",
            "module": "test_run_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
            "line_number": 1311,
            "end_line_number": 1362,
            "source_code": "def test_shutdown_handler_cancellation_suppressed(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        actions = []\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                t = ClientTimeout(total=0.4)\n                with pytest.raises(asyncio.TimeoutError):\n                    async with sess.get(f\"http://127.0.0.1:{port}/\", timeout=t) as resp:\n                        assert await resp.text() == \"FOO\"\n                actions.append(\"CANCELLED\")\n\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(0.5)\n                # Handler is in-progress while we trigger server shutdown.\n                actions.append(\"PRESTOP\")\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                actions.append(\"STOPPING\")\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            try:\n                await asyncio.sleep(5)\n            except asyncio.CancelledError:\n                actions.append(\"SUPPRESSED\")\n                await asyncio.sleep(2)\n                actions.append(\"DONE\")\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=2, handler_cancellation=True)\n        assert t is not None\n        assert t.exception() is None\n        assert actions == [\"CANCELLED\", \"SUPPRESSED\", \"PRESTOP\", \"STOPPING\", \"DONE\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "unused_port_socket"
            ],
            "imports": [
                "asyncio",
                "contextlib",
                "logging",
                "os",
                "platform",
                "signal",
                "socket",
                "ssl",
                "subprocess",
                "sys",
                "time",
                "typing.Any",
                "typing.AsyncIterator",
                "typing.Awaitable",
                "typing.Callable",
                "typing.Coroutine",
                "typing.Dict",
                "typing.Iterator",
                "typing.List",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Set",
                "typing.Tuple",
                "unittest.mock",
                "uuid.uuid4",
                "pytest",
                "pytest_mock.MockerFixture",
                "aiohttp.ClientConnectorError",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.WSCloseCode",
                "aiohttp.web",
                "aiohttp.log.access_logger",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.web_protocol.RequestHandler",
                "aiohttp.web_runner.BaseRunner",
                "contextvars.ContextVar"
            ],
            "fixtures": [],
            "assertions": [
                "assert t is not None",
                "assert t.exception() is None",
                "assert actions == ['CANCELLED', 'SUPPRESSED', 'PRESTOP', 'STOPPING', 'DONE']",
                "assert await resp.text() == 'FOO'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "web.run_app",
                    "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and testing.\n\n**How It Works**:\n1. **Socket and Timeout**: The method accepts a socket for binding and a timeout for shutdown operations.\n2. **Connection Tracking**: It defines a custom dictionary class (`DictRecordClear`) to keep track of active connections and clear them while counting how many were active before clearing.\n3. **Server Initialization**: A subclass of `web.Server` (`ServerWithRecordClear`) is created to utilize the custom connection tracking.\n4. **Testing Logic**: An asynchronous test function (`test`) is defined to verify that the server can handle requests and respond correctly, including testing for timeouts.\n5. **Request Handling**: A request handler (`handler`) is defined to execute a provided task asynchronously when a request is received.\n6. **Application Setup**: The method creates a `web.Application`, adds the request handler, and sets up a cleanup context for running tests.\n7. **Running the Server**: It uses `web.run_app` to start the server with the specified socket and timeout, while also ensuring that the test task is executed and monitored.\n8. **Return Values**: Finally, it returns the task associated with the provided operation and the number of connections that were active before shutdown. \n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and manage connections effectively."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_header_field_size_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 718,
            "end_line_number": 733,
            "source_code": "def test_max_header_field_size_under_limit(parser: HttpRequestParser) -> None:\n    name = b\"t\" * 8190\n    text = b\"GET /test HTTP/1.1\\r\\n\" + name + b\":data\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({name.decode(): \"data\"})\n    assert msg.raw_headers == ((name, b\"data\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/test\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.method == 'GET'",
                "assert msg.path == '/test'",
                "assert msg.version == (1, 1)",
                "assert msg.headers == CIMultiDict({name.decode(): 'data'})",
                "assert msg.raw_headers == ((name, b'data'),)",
                "assert not msg.should_close",
                "assert msg.compression is None",
                "assert not msg.upgrade",
                "assert not msg.chunked",
                "assert msg.url == URL('/test')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "name.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method in the `BasicAuth` class is designed to create a `BasicAuth` object from an HTTP Authorization header that contains base64-encoded credentials. It extracts and decodes the username and password from the provided header.\n\n**How It Works**:\n1. The method first splits the `auth_header` string into the authentication type and the encoded credentials. It checks if the type is \"basic\"; if not, it raises a `ValueError`.\n2. It then decodes the base64-encoded credentials using the specified encoding (default is \"latin1\"). If the decoding fails, it raises a `ValueError`.\n3. The decoded string is split into the username and password using a colon (`:`) as the delimiter. If this fails, it raises a `ValueError`.\n4. Finally, it returns a new instance of the `BasicAuth` class with the extracted username, password, and encoding."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_header_value_size_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 746,
            "end_line_number": 761,
            "source_code": "def test_max_header_value_size_under_limit(parser: HttpRequestParser) -> None:\n    value = b\"A\" * 8190\n    text = b\"GET /test HTTP/1.1\\r\\ndata:\" + value + b\"\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({\"data\": value.decode()})\n    assert msg.raw_headers == ((b\"data\", value),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/test\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.method == 'GET'",
                "assert msg.path == '/test'",
                "assert msg.version == (1, 1)",
                "assert msg.headers == CIMultiDict({'data': value.decode()})",
                "assert msg.raw_headers == ((b'data', value),)",
                "assert not msg.should_close",
                "assert msg.compression is None",
                "assert not msg.upgrade",
                "assert not msg.chunked",
                "assert msg.url == URL('/test')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "value.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method is designed to convert a byte sequence into a string using a specified character encoding. It allows for handling different encoding types based on the headers provided in an HTTP context.\n\n**How It Works**:\nThe method takes two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. It asserts that the method is not implemented (as indicated by `assert False`). In a complete implementation, the method would typically decode the byte data according to the specified encoding and handle any errors based on the `errors` parameter. The relevant code snippets show how decoding is performed based on content transfer and content encoding headers, using helper methods to manage different encoding types like base64 and gzip."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_max_header_value_size_continuation_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 776,
            "end_line_number": 792,
            "source_code": "def test_max_header_value_size_continuation_under_limit(\n    response: HttpResponseParser,\n) -> None:\n    value = b\"A\" * 8185\n    text = b\"HTTP/1.1 200 Ok\\r\\ndata: test\\r\\n \" + value + b\"\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = response.feed_data(text)\n    msg = messages[0][0]\n    assert msg.code == 200\n    assert msg.reason == \"Ok\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({\"data\": \"test \" + value.decode()})\n    assert msg.raw_headers == ((b\"data\", b\"test \" + value),)\n    assert msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "response"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.code == 200",
                "assert msg.reason == 'Ok'",
                "assert msg.version == (1, 1)",
                "assert msg.headers == CIMultiDict({'data': 'test ' + value.decode()})",
                "assert msg.raw_headers == ((b'data', b'test ' + value),)",
                "assert msg.should_close",
                "assert msg.compression is None",
                "assert not msg.upgrade",
                "assert not msg.chunked"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "value.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method is designed to convert a byte string into a regular string using a specified character encoding. It allows for handling different encoding schemes, ensuring that the data is interpreted correctly based on the provided encoding type.\n\n**How It Works**:\nThe method takes two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. The method is expected to decode the byte data into a string according to the specified encoding. However, the current implementation contains an assertion that always fails (`assert False`), indicating that the method is not yet implemented. In a complete implementation, it would typically use the `bytes.decode()` method to perform the actual decoding, handling any errors based on the specified error handling strategy."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_http_request_max_status_line_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 1023,
            "end_line_number": 1039,
            "source_code": "def test_http_request_max_status_line_under_limit(parser: HttpRequestParser) -> None:\n    path = b\"t\" * (8190 - 5)\n    messages, upgraded, tail = parser.feed_data(\n        b\"GET /path\" + path + b\" HTTP/1.1\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\" + path.decode()\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict()\n    assert msg.raw_headers == ()\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\" + path.decode())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.method == 'GET'",
                "assert msg.path == '/path' + path.decode()",
                "assert msg.version == (1, 1)",
                "assert msg.headers == CIMultiDict()",
                "assert msg.raw_headers == ()",
                "assert not msg.should_close",
                "assert msg.compression is None",
                "assert not msg.upgrade",
                "assert not msg.chunked",
                "assert msg.url == URL('/path' + path.decode())"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "path.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `path.decode` method is intended to decode a byte string into a regular string using a specified character encoding. This is useful for converting encoded file paths or data into a human-readable format.\n\n**How It Works**:\nThe method takes two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. The method is expected to assert that it is not implemented (as indicated by `assert False`), suggesting that it is a placeholder or a stub for future implementation. When fully implemented, it would use the specified encoding to decode the byte string representation of a path, handling any decoding errors according to the specified error handling strategy."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_http_request_max_status_line_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 1023,
            "end_line_number": 1039,
            "source_code": "def test_http_request_max_status_line_under_limit(parser: HttpRequestParser) -> None:\n    path = b\"t\" * (8190 - 5)\n    messages, upgraded, tail = parser.feed_data(\n        b\"GET /path\" + path + b\" HTTP/1.1\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\" + path.decode()\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict()\n    assert msg.raw_headers == ()\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\" + path.decode())",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "parser"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.method == 'GET'",
                "assert msg.path == '/path' + path.decode()",
                "assert msg.version == (1, 1)",
                "assert msg.headers == CIMultiDict()",
                "assert msg.raw_headers == ()",
                "assert not msg.should_close",
                "assert msg.compression is None",
                "assert not msg.upgrade",
                "assert not msg.chunked",
                "assert msg.url == URL('/path' + path.decode())"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "path.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `path.decode` method is intended to decode a byte string into a regular string using a specified character encoding. This is useful for converting encoded file paths or data into a human-readable format.\n\n**How It Works**:\nThe method takes two optional parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. The method body currently contains an assertion that always fails (`assert False`), indicating that the method is not yet implemented. When fully implemented, it would likely use the specified encoding to decode the byte string representation of a path, handling errors according to the specified error handling strategy."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_http_response_parser_status_line_under_limit",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 1110,
            "end_line_number": 1120,
            "source_code": "def test_http_response_parser_status_line_under_limit(\n    response: HttpResponseParser,\n) -> None:\n    reason = b\"O\" * 8190\n    messages, upgraded, tail = response.feed_data(\n        b\"HTTP/1.1 200 \" + reason + b\"\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == reason.decode()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "response"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert msg.version == (1, 1)",
                "assert msg.code == 200",
                "assert msg.reason == reason.decode()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reason.decode",
                    "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `decode` method is intended to convert a byte string into a regular string using a specified character encoding. It allows for error handling during the decoding process.\n\n**How It Works**:\nThe method takes two parameters: `encoding`, which defaults to 'utf-8', and `errors`, which defaults to 'strict'. The method body currently contains an assertion that always fails (`assert False`), indicating that the method is not yet implemented. In a complete implementation, the method would use the provided `encoding` to decode byte data into a string, handling any errors according to the specified `errors` parameter (e.g., ignoring errors or replacing invalid characters)."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_parse_no_length_or_te_on_post",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 1341,
            "end_line_number": 1350,
            "source_code": "def test_parse_no_length_or_te_on_post(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    request_cls: Type[HttpRequestParser],\n) -> None:\n    parser = request_cls(protocol, loop, limit=2**16)\n    text = b\"POST /test HTTP/1.1\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    assert payload.is_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "protocol",
                "request_cls"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert payload.is_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "request_cls",
                    "body": "@pytest.fixture(params=REQUEST_PARSERS, ids=_gen_ids(REQUEST_PARSERS))\ndef request_cls(request: pytest.FixtureRequest) -> Type[HttpRequestParser]:\n    return request.param",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `request_cls` method is a pytest fixture that provides a parameterized class type for HTTP request parsing. It allows tests to utilize different request parser implementations defined in the `REQUEST_PARSERS` collection.\n\n**How It Works**:\nThe method is decorated with `@pytest.fixture`, which makes it a fixture that can be used in test functions. It takes a `request` argument of type `pytest.FixtureRequest`, which provides access to the current test context. The `params` argument specifies that the fixture should iterate over `REQUEST_PARSERS`, and the `ids` argument generates human-readable names for each parameter using the `_gen_ids` function. When a test function requests this fixture, it returns the current parameter (i.e., the request parser class) for that test run, enabling dynamic testing of various parser implementations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_parse_payload_response_without_body",
            "module": "test_http_parser",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
            "line_number": 1353,
            "end_line_number": 1362,
            "source_code": "def test_parse_payload_response_without_body(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    response_cls: Type[HttpResponseParser],\n) -> None:\n    parser = response_cls(protocol, loop, 2**16, response_with_body=False)\n    text = b\"HTTP/1.1 200 Ok\\r\\ncontent-length: 10\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    assert payload.is_eof()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "protocol",
                "response_cls"
            ],
            "imports": [
                "asyncio",
                "re",
                "typing.Any",
                "typing.Dict",
                "typing.Iterable",
                "typing.List",
                "typing.Type",
                "unittest.mock",
                "urllib.parse.quote",
                "pytest",
                "multidict.CIMultiDict",
                "yarl.URL",
                "aiohttp",
                "aiohttp.http_exceptions",
                "aiohttp.streams",
                "aiohttp.base_protocol.BaseProtocol",
                "aiohttp.helpers.NO_EXTENSIONS",
                "aiohttp.http_parser.DeflateBuffer",
                "aiohttp.http_parser.HttpParser",
                "aiohttp.http_parser.HttpPayloadParser",
                "aiohttp.http_parser.HttpRequestParser",
                "aiohttp.http_parser.HttpRequestParserPy",
                "aiohttp.http_parser.HttpResponseParser",
                "aiohttp.http_parser.HttpResponseParserPy",
                "aiohttp.http_writer.HttpVersion",
                "aiohttp.http_parser.HttpRequestParserC",
                "aiohttp.http_parser.HttpResponseParserC",
                "brotlicffi",
                "brotli"
            ],
            "fixtures": [],
            "assertions": [
                "assert payload.is_eof()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "response_cls",
                    "body": "@pytest.fixture(params=RESPONSE_PARSERS, ids=_gen_ids(RESPONSE_PARSERS))\ndef response_cls(request: pytest.FixtureRequest) -> Type[HttpResponseParser]:\n    return request.param",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `response_cls` method is a pytest fixture that provides a class type for HTTP response parsing. It allows tests to utilize different response parser implementations defined in the `RESPONSE_PARSERS` list.\n\n**How It Works**:  \nThe method is decorated with `@pytest.fixture`, which makes it a fixture that can be used in tests. It takes a `request` parameter of type `pytest.FixtureRequest`, which is used to access the current test context. The `params` argument specifies that the fixture should iterate over `RESPONSE_PARSERS`, providing each parser class as a parameter to the test that uses this fixture. The `ids` argument generates human-readable names for each parameter using the `_gen_ids` function. When a test requests this fixture, it returns the current parser class from `request.param`, allowing the test to instantiate and use the appropriate response parser."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_app_call",
            "module": "test_web_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
            "line_number": 18,
            "end_line_number": 20,
            "source_code": "def test_app_call() -> None:\n    app = web.Application()\n    assert app is app()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Iterator",
                "typing.NoReturn",
                "typing.Type",
                "unittest.mock",
                "pytest",
                "aiohttp.log",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.Handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert app is app()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app",
                    "body": "@pytest.fixture\ndef app(loop: asyncio.AbstractEventLoop) -> web.Application:\n    ret: web.Application = mock.create_autospec(web.Application, spec_set=True)\n    ret.on_response_prepare = aiosignal.Signal(ret)\n    ret.on_response_prepare.freeze()\n    return ret",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `app` method is a pytest fixture that creates and returns a mock instance of a `web.Application`. This mock application is used in tests to simulate the behavior of an actual web application without needing to run a real server.\n\n**How It Works**:  \nThe method uses `mock.create_autospec` to create a mock object that adheres to the `web.Application` interface, ensuring that any calls made to it will be checked against the actual methods and properties of a `web.Application`. It also sets up a signal `on_response_prepare` using `aiosignal.Signal`, which allows for asynchronous response preparation handling. The signal is then frozen to prevent further modifications. This fixture can be injected into test functions, allowing them to interact with a controlled mock application environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_app_run_middlewares",
            "module": "test_web_app",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
            "line_number": 186,
            "end_line_number": 206,
            "source_code": "def test_app_run_middlewares() -> None:\n    root = web.Application()\n    sub = web.Application()\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is False\n\n    async def middleware(request: web.Request, handler: Handler) -> web.StreamResponse:\n        return await handler(request)  # pragma: no cover\n\n    root = web.Application(middlewares=[middleware])\n    sub = web.Application()\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is True\n\n    root = web.Application()\n    sub = web.Application(middlewares=[middleware])\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is True",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "typing.AsyncIterator",
                "typing.Callable",
                "typing.Iterator",
                "typing.NoReturn",
                "typing.Type",
                "unittest.mock",
                "pytest",
                "aiohttp.log",
                "aiohttp.web",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.typedefs.Handler"
            ],
            "fixtures": [],
            "assertions": [
                "assert root._run_middlewares is False",
                "assert root._run_middlewares is True",
                "assert root._run_middlewares is True"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "handler",
                    "body": "def handler(request: web.Request) -> NoReturn:\n    assert False",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `handler` method is designed to serve as an asynchronous request handler for web requests. However, its implementation currently contains an assertion that always fails, indicating that it is not intended to be used in its current form.\n\n**How It Works**:\nThe method takes a single parameter, `request`, which is an instance of `web.Request`. The assertion `assert False` will always raise an `AssertionError` when the method is called, effectively making it a placeholder or a stub. This suggests that the method is meant to be replaced with a proper implementation that handles requests appropriately, returning a valid response instead of failing. The tests provided in the repository indicate that this method is expected to be used as an `expect_handler` in routing, where it should ideally validate or process incoming requests before they reach the main handler."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 88,
            "end_line_number": 105,
            "source_code": "def test_close(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response._closed = False\n    response._connection = mock.Mock()\n    response.close()\n    assert response.connection is None\n    response.close()\n    response.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.connection is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "response.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to properly terminate a response object, ensuring that any associated resources are released and that the connection is closed if it is still open.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if the response has already been released. If not, it notifies any pending content that needs to be processed. It then marks the response as closed and performs cleanup operations, which include closing the underlying connection if it exists. This method is crucial for managing resources effectively, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 88,
            "end_line_number": 105,
            "source_code": "def test_close(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response._closed = False\n    response._connection = mock.Mock()\n    response.close()\n    assert response.connection is None\n    response.close()\n    response.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.connection is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "response.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to properly terminate a response object, ensuring that any associated resources are released and the connection is closed if it is still open.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if the response has already been released. If not, it notifies any pending content that needs to be processed. It then marks the response as closed and performs cleanup operations, which include closing the underlying connection if it exists. This method is crucial for managing resources effectively, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_close",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 88,
            "end_line_number": 105,
            "source_code": "def test_close(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response._closed = False\n    response._connection = mock.Mock()\n    response.close()\n    assert response.connection is None\n    response.close()\n    response.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.connection is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "response.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to properly terminate a response object, ensuring that any associated resources are released and that the connection is closed if it is still open.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if the response has already been released. If not, it notifies any pending content that needs to be processed. It then marks the response as closed and performs cleanup operations, which include closing the underlying connection if it exists. This method is crucial for managing resources effectively, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_wait_for_100_1",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 108,
            "end_line_number": 123,
            "source_code": "def test_wait_for_100_1(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://python.org\"),\n        continue100=loop.create_future(),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    assert response._continue is not None\n    response.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert response._continue is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "response.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to properly terminate a response object, ensuring that any associated resources are released and that the connection is closed if it is still open.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if the response has already been released. If not, it notifies any pending content that needs to be processed. It then marks the response as closed and performs cleanup operations, which include closing the underlying connection if it exists. This method is crucial for managing resources effectively, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_wait_for_100_2",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 126,
            "end_line_number": 141,
            "source_code": "def test_wait_for_100_2(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://python.org\"),\n        request_info=mock.Mock(),\n        continue100=None,\n        writer=WriterMock(),\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    assert response._continue is None\n    response.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop",
                "session"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert response._continue is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "response.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to properly terminate a response object, ensuring that any associated resources are released and that the connection is closed if it is still open.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if the response has already been released. If not, it notifies any pending content that needs to be processed. It then marks the response as closed and performs cleanup operations, which include closing the underlying connection if it exists. This method is crucial for managing resources effectively, especially in asynchronous environments where connections may remain open longer than necessary."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_response_not_closed_after_get_ok",
            "module": "test_client_response",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
            "line_number": 1362,
            "end_line_number": 1380,
            "source_code": "def test_response_not_closed_after_get_ok(mocker: MockerFixture) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://del-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 400\n    response.reason = \"Bad Request\"\n    response._closed = False\n    spy = mocker.spy(response, \"raise_for_status\")\n    assert not response.ok\n    assert not response.closed\n    assert spy.call_count == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "mocker"
            ],
            "imports": [
                "asyncio",
                "gc",
                "sys",
                "json.JSONDecodeError",
                "unittest.mock",
                "pytest",
                "multidict.CIMultiDict",
                "multidict.CIMultiDictProxy",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientSession",
                "aiohttp.http",
                "aiohttp.client_reqrep.ClientResponse",
                "aiohttp.client_reqrep.RequestInfo",
                "aiohttp.connector.Connection",
                "aiohttp.helpers.TimerNoop",
                "aiohttp.test_utils.make_mocked_coro"
            ],
            "fixtures": [],
            "assertions": [
                "assert not response.ok",
                "assert not response.closed",
                "assert spy.call_count == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "mocker.spy",
                    "body": "def spy() -> None:\n    nonlocal called\n    called = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `mocker.spy` method is used to create a spy on a specific method of an object, allowing developers to track whether that method has been called during the execution of tests.\n\n**How It Works**:  \nWhen `mocker.spy` is invoked, it wraps the specified method (in this case, `session.connector.close`) and monitors its calls. The internal `spy` function sets a `called` flag to `True` whenever the spied method is invoked. This allows assertions in tests to check if the method was called, enabling developers to verify the behavior of their code in a controlled testing environment."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_access_logger_atoms",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 88,
            "end_line_number": 115,
            "source_code": "def test_access_logger_atoms(\n    monkeypatch: pytest.MonkeyPatch,\n    log_format: str,\n    expected: str,\n    extra: Dict[str, object],\n) -> None:\n    class PatchedDatetime(datetime.datetime):\n        @classmethod\n        def now(cls, tz: Optional[datetime.tzinfo] = None) -> Self:\n            return cls(1843, 1, 1, 0, 30, tzinfo=tz)\n\n    monkeypatch.setattr(\"datetime.datetime\", PatchedDatetime)\n    monkeypatch.setattr(\"time.timezone\", -28800)\n    monkeypatch.setattr(\"os.getpid\", lambda: 42)\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(\n        headers={\"H1\": \"a\", \"H2\": \"b\"},\n        method=\"GET\",\n        path_qs=\"/path\",\n        version=aiohttp.HttpVersion(1, 1),\n        remote=\"127.0.0.2\",\n    )\n    response = mock.Mock(headers={}, body_length=42, status=200)\n    access_logger.log(request, response, 3.1415926)\n    assert not mock_logger.exception.called, mock_logger.exception.call_args\n\n    mock_logger.info.assert_called_with(expected, extra=extra)",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(IS_PYPY, reason=\"\\n    Because of patching :py:class:`datetime.datetime`, under PyPy it\\n    fails in :py:func:`isinstance` call in\\n    :py:meth:`datetime.datetime.__sub__` (called from\\n    :py:meth:`aiohttp.AccessLogger._format_t`):\\n\\n    *** TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types\\n\\n    (Pdb) from datetime import datetime\\n    (Pdb) isinstance(now, datetime)\\n    *** TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types\\n    (Pdb) datetime.__class__\\n    <class 'unittest.mock.MagicMock'>\\n    (Pdb) isinstance(now, datetime.__class__)\\n    False\\n\\n    Ref: https://bitbucket.org/pypy/pypy/issues/1187/call-to-isinstance-in-__sub__-self-other\\n    Ref: https://github.com/celery/celery/issues/811\\n    Ref: https://stackoverflow.com/a/46102240/595220\\n    \")",
                "pytest.mark.parametrize('log_format,expected,extra', [('%t', '[01/Jan/1843:00:29:56 +0800]', {'request_start_time': '[01/Jan/1843:00:29:56 +0800]'}), ('%a %t %P %r %s %b %T %Tf %D \"%{H1}i\" \"%{H2}i\"', '127.0.0.2 [01/Jan/1843:00:29:56 +0800] <42> GET /path HTTP/1.1 200 42 3 3.141593 3141593 \"a\" \"b\"', {'first_request_line': 'GET /path HTTP/1.1', 'process_id': '<42>', 'remote_address': '127.0.0.2', 'request_start_time': '[01/Jan/1843:00:29:56 +0800]', 'request_time': '3', 'request_time_frac': '3.141593', 'request_time_micro': '3141593', 'response_size': 42, 'response_status': 200, 'request_header': {'H1': 'a', 'H2': 'b'}})])"
            ],
            "arguments": [
                "monkeypatch",
                "log_format",
                "expected",
                "extra"
            ],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [
                "assert not mock_logger.exception.called, mock_logger.exception.call_args"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock(headers={'H1': 'a', 'H2': 'b'}, method='GET', path_qs='/path', version=aiohttp.HttpVersion(1, 1), remote='127.0.0.2')",
                "mock.Mock(headers={}, body_length=42, status=200)"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests and responses. It captures relevant details such as the request's remote IP address, the time taken to process the request, and the response status, formatted according to a specified log format.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. The `request` parameter is an instance of `web.BaseRequest`, representing the incoming web request. The `response` parameter is an instance of `web.StreamResponse`, representing the outgoing response. The `time` parameter is a float indicating the time taken to process the request. The method is expected to format this information according to the defined log format and pass it to the logger for recording. However, the actual implementation of logging is not provided in the method body, indicating that it serves as a placeholder for subclasses to implement specific logging behavior."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_access_logger_dicts",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 118,
            "end_line_number": 134,
            "source_code": "def test_access_logger_dicts() -> None:\n    log_format = \"%{User-Agent}i %{Content-Length}o %{None}i\"\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(\n        headers={\"User-Agent\": \"Mock/1.0\"}, version=(1, 1), remote=\"127.0.0.2\"\n    )\n    response = mock.Mock(headers={\"Content-Length\": 123})\n    access_logger.log(request, response, 0.0)\n    assert not mock_logger.error.called\n    expected = \"Mock/1.0 123 -\"\n    extra = {\n        \"request_header\": {\"User-Agent\": \"Mock/1.0\", \"None\": \"-\"},\n        \"response_header\": {\"Content-Length\": 123},\n    }\n\n    mock_logger.info.assert_called_with(expected, extra=extra)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [
                "assert not mock_logger.error.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock(headers={'User-Agent': 'Mock/1.0'}, version=(1, 1), remote='127.0.0.2')",
                "mock.Mock(headers={'Content-Length': 123})"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests and responses. It captures relevant details such as the request's remote IP address, the time taken to process the request, and the response status, formatted according to a specified log format.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record the access details. The method utilizes a predefined log format that can include various placeholders (like `%a` for the remote IP address and `%s` for the response status) to dynamically insert the corresponding values from the request and response objects. The actual implementation of the logging functionality is not shown in the provided snippet, but it typically involves formatting the log message based on the specified format and sending it to the logger instance initialized in the `AccessLogger`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_access_logger_unix_socket",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 137,
            "end_line_number": 146,
            "source_code": "def test_access_logger_unix_socket() -> None:\n    log_format = \"|%a|\"\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(headers={\"User-Agent\": \"Mock/1.0\"}, version=(1, 1), remote=\"\")\n    response = mock.Mock()\n    access_logger.log(request, response, 0.0)\n    assert not mock_logger.error.called\n    expected = \"||\"\n    mock_logger.info.assert_called_with(expected, extra={\"remote_address\": \"\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [
                "assert not mock_logger.error.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock(headers={'User-Agent': 'Mock/1.0'}, version=(1, 1), remote='')",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests, capturing details such as the request's remote IP address, response status, and the time taken to process the request.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record relevant information based on a specified log format. The log format can include various placeholders (like `%a` for IP address and `%s` for response status) that are mapped to specific attributes of the request and response objects. The method does not return any value (`None`), as its primary function is to perform logging operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_logger_no_message",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 149,
            "end_line_number": 158,
            "source_code": "def test_logger_no_message() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%r %{content-type}i\")\n    extra_dict = {\n        \"first_request_line\": \"GET / HTTP/1.1\",\n        \"request_header\": {\"content-type\": \"-\"},\n    }\n\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n    mock_logger.info.assert_called_with(\"GET / HTTP/1.1 -\", extra=extra_dict)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests and responses. It captures relevant details such as the request's remote IP address, the time taken to process the request, and the response status, formatted according to a specified log format.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record the access details. The method utilizes a predefined log format, which can include various placeholders (like `%a` for the remote IP address and `%s` for the response status) that are mapped to specific attributes of the request and response objects. The actual logging implementation is not shown in the method body, but it is expected to format the log message based on the provided log format and then send it to the logger instance initialized in the `AccessLogger`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_logger_internal_error",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 161,
            "end_line_number": 165,
            "source_code": "def test_logger_internal_error() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%D\")\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), \"invalid\")  # type: ignore[arg-type]\n    mock_logger.exception.assert_called_with(\"Error in logging\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests, capturing details such as the request's remote IP address, response status, and the time taken to process the request.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record relevant information based on a specified log format. The log format can include various placeholders (like `%a` for the remote IP address and `%s` for the response status) that are mapped to specific attributes of the request and response objects. The method does not return any value (`None`), as its primary function is to perform logging operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_logger_no_transport",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 168,
            "end_line_number": 172,
            "source_code": "def test_logger_no_transport() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%a\")\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n    mock_logger.info.assert_called_with(\"-\", extra={\"remote_address\": \"-\"})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests and responses. It captures relevant details such as the request's remote IP address, the time taken to process the request, and the response status, formatted according to a specified log format.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record the access details. The method utilizes a predefined log format that can include various placeholders (like `%a` for IP address and `%s` for response status) to dynamically insert the corresponding values from the request and response objects. The actual logging implementation is not shown in the method body, but it is expected to format the log message based on the provided format and log it using the associated logger instance."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_logger_abc",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 175,
            "end_line_number": 199,
            "source_code": "def test_logger_abc() -> None:\n    class Logger(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            1 / 0\n\n    mock_logger = mock.Mock()\n    access_logger: AbstractAccessLogger = Logger(mock_logger, \"\")\n\n    with pytest.raises(ZeroDivisionError):\n        access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n\n    class Logger2(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            self.logger.info(\n                self.log_format.format(request=request, response=response, time=time)\n            )\n\n    mock_logger = mock.Mock()\n    access_logger = Logger2(mock_logger, \"{request} {response} {time}\")\n    access_logger.log(\"request\", \"response\", 1)  # type: ignore[arg-type]\n    mock_logger.info.assert_called_with(\"request response 1\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests and responses. It captures relevant details such as the request's remote IP address, the response status, and the time taken to process the request, formatted according to a specified log format.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record the access details. The method utilizes a predefined log format, which can include various placeholders (like `%a` for the remote IP and `%s` for the response status) that are mapped to specific attributes of the request and response objects. The actual logging implementation is not shown in the method body, but it is expected to format the log message based on the provided log format and then send it to the logger instance initialized in the `AccessLogger`."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_logger_abc",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 175,
            "end_line_number": 199,
            "source_code": "def test_logger_abc() -> None:\n    class Logger(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            1 / 0\n\n    mock_logger = mock.Mock()\n    access_logger: AbstractAccessLogger = Logger(mock_logger, \"\")\n\n    with pytest.raises(ZeroDivisionError):\n        access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n\n    class Logger2(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            self.logger.info(\n                self.log_format.format(request=request, response=response, time=time)\n            )\n\n    mock_logger = mock.Mock()\n    access_logger = Logger2(mock_logger, \"{request} {response} {time}\")\n    access_logger.log(\"request\", \"response\", 1)  # type: ignore[arg-type]\n    mock_logger.info.assert_called_with(\"request response 1\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests, capturing details such as the request's remote IP address, response status, and the time taken to process the request.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record relevant information based on a specified log format. The log format can include various placeholders (like `%a` for IP address and `%s` for response status) that are mapped to specific attributes of the request and response objects. The method does not return any value (`None`), and it is typically invoked within the context of handling web requests to ensure that access logs are generated consistently."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_access_logger_feeds_logger",
            "module": "test_web_log",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
            "line_number": 278,
            "end_line_number": 286,
            "source_code": "def test_access_logger_feeds_logger(caplog: pytest.LogCaptureFixture) -> None:\n    \"\"\"Test that the logger still works.\"\"\"\n    mock_logger = logging.getLogger(\"test.aiohttp.log\")\n    mock_logger.setLevel(logging.INFO)\n    access_logger = AccessLogger(mock_logger, \"%b\")\n    access_logger.log(\n        mock.Mock(name=\"mock_request\"), mock.Mock(name=\"mock_response\"), 42\n    )\n    assert \"mock_response\" in caplog.text",
            "docstring": "Test that the logger still works.",
            "decorators": [],
            "arguments": [
                "caplog"
            ],
            "imports": [
                "datetime",
                "logging",
                "platform",
                "sys",
                "contextvars.ContextVar",
                "typing.Dict",
                "typing.NoReturn",
                "typing.Optional",
                "unittest.mock",
                "pytest",
                "aiohttp",
                "aiohttp.web",
                "aiohttp.abc.AbstractAccessLogger",
                "aiohttp.abc.AbstractAsyncAccessLogger",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpRawServer",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_request",
                "aiohttp.typedefs.Handler",
                "aiohttp.web_log.AccessLogger",
                "aiohttp.web_response.Response",
                "typing.Self",
                "typing.Any"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'mock_response' in caplog.text"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock(name='mock_request')",
                "mock.Mock(name='mock_response')"
            ],
            "methods_under_test": [
                {
                    "name": "access_logger.log",
                    "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `log` method in the `AccessLogger` class is designed to log access information for web requests, capturing details such as the request's remote IP address, response status, and the time taken to process the request.\n\n**How It Works**:  \nThe method takes three parameters: `request`, `response`, and `time`. It is intended to be called after a web request has been processed, allowing the logger to record relevant information based on a specified log format. The log format can include various placeholders (like `%a` for the remote IP address and `%s` for the response status) that are mapped to specific attributes of the request and response objects. The method does not return any value (`None`), and it is typically invoked within the context of handling web requests to ensure that access logs are generated consistently."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connection_del_loop_closed",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 180,
            "end_line_number": 195,
            "source_code": "def test_connection_del_loop_closed(loop: asyncio.AbstractEventLoop) -> None:\n    connector = mock.Mock()\n    key = mock.Mock()\n    protocol = mock.Mock()\n    loop.set_debug(True)\n    conn = Connection(connector, key, protocol, loop=loop)\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not connector._release.called\n    assert not exc_handler.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "loop"
            ],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert not connector._release.called",
                "assert not exc_handler.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()",
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly shut down an event loop or a related resource, ensuring that all associated tasks and connections are properly terminated.\n\n**How It Works**:\nThe method currently has an empty implementation (`pass`), indicating that it does not perform any actions when called. However, in the context of an event loop, a typical implementation would involve stopping the loop, canceling any running tasks, and releasing resources. In the provided code snippets, similar `close` methods are seen that handle resource cleanup, such as notifying callbacks, releasing protocols, and canceling resolvers. This suggests that when implemented, `loop.close` would follow a similar pattern to ensure a graceful shutdown of the event loop and its associated components."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_del_with_closed_loop",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 254,
            "end_line_number": 275,
            "source_code": "def test_del_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, key: ConnectionKey\n) -> None:\n    async def make_conn() -> aiohttp.BaseConnector:\n        return aiohttp.BaseConnector()\n\n    conn = loop.run_until_complete(make_conn())\n    transp = create_mocked_conn(loop)\n    conn._conns[key] = deque([(transp, 123)])\n\n    conns_impl = conn._conns\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not conns_impl\n    assert not transp.close.called\n    assert exc_handler.called",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.implementation.name != 'cpython', reason='CPython GC is required for the test')"
            ],
            "arguments": [
                "loop",
                "key"
            ],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert not conns_impl",
                "assert not transp.close.called",
                "assert exc_handler.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "create_mocked_conn",
                    "body": "@pytest.fixture\ndef create_mocked_conn(loop: asyncio.AbstractEventLoop) -> Iterator[Callable[[], ResponseHandler]]:\n\n    def _proto_factory() -> Any:\n        proto = mock.create_autospec(ResponseHandler, instance=True)\n        proto.closed = loop.create_future()\n        proto.closed.set_result(None)\n        return proto\n    yield _proto_factory",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `create_mocked_conn` method is designed to create a mocked instance of a `ResponseHandler` for use in testing asynchronous code. It provides a controlled environment to simulate the behavior of a connection without needing a real network connection.\n\n**How It Works**:  \nThe method is defined as a pytest fixture, which means it can be used in tests to provide a setup for the test functions. Inside the fixture, a private function `_proto_factory` is defined, which creates a mock object of `ResponseHandler` using `mock.create_autospec`. This mock object has a `closed` attribute that is set to a future object, which is resolved immediately. The fixture yields this factory function, allowing test functions to call it and obtain a new mocked connection instance whenever needed. This setup helps in isolating tests and ensuring they do not depend on actual implementations or external systems."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_del_with_closed_loop",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 254,
            "end_line_number": 275,
            "source_code": "def test_del_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, key: ConnectionKey\n) -> None:\n    async def make_conn() -> aiohttp.BaseConnector:\n        return aiohttp.BaseConnector()\n\n    conn = loop.run_until_complete(make_conn())\n    transp = create_mocked_conn(loop)\n    conn._conns[key] = deque([(transp, 123)])\n\n    conns_impl = conn._conns\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not conns_impl\n    assert not transp.close.called\n    assert exc_handler.called",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.implementation.name != 'cpython', reason='CPython GC is required for the test')"
            ],
            "arguments": [
                "loop",
                "key"
            ],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert not conns_impl",
                "assert not transp.close.called",
                "assert exc_handler.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mock.Mock()"
            ],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly shut down an event loop or a related resource, ensuring that any ongoing operations are properly terminated and resources are released.\n\n**How It Works**:\nThe method currently has an empty implementation (`pass`), indicating that it does not perform any actions when called. However, in the context of an event loop, a typical implementation would involve stopping the loop, canceling any pending tasks, and releasing associated resources. In the provided code snippets, similar `close` methods are seen that handle cleanup tasks, such as notifying callbacks, releasing protocols, and canceling resolvers, which are essential for preventing resource leaks and ensuring a graceful shutdown of asynchronous operations."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_clear",
            "module": "test_connector",
            "class_name": "TestDNSCacheTable",
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 3536,
            "end_line_number": 3540,
            "source_code": "def test_clear(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.clear()\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "dns_cache_table"
            ],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "dns_cache_table.clear",
                    "body": "def clear(self) -> None:\n    nonlocal num_connections\n    num_connections = len(self)\n    super().clear()",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `clear` method in the `dns_cache_table` class is designed to remove all entries from the DNS cache, effectively resetting the cache to an empty state.\n\n**How It Works**:  \nWhen `clear` is called, it first updates the `num_connections` variable to reflect the current number of connections in the cache (using `len(self)`). Then, it invokes the `clear` method of its superclass (presumably a dictionary or similar structure) to remove all cached DNS entries. This ensures that the DNS cache is completely emptied, allowing for fresh DNS resolutions without any stale data."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connector_multiple_event_loop",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 3715,
            "end_line_number": 3744,
            "source_code": "def test_connector_multiple_event_loop() -> None:\n    \"\"\"Test the connector with multiple event loops.\"\"\"\n\n    async def async_connect() -> Literal[True]:\n        conn = aiohttp.TCPConnector()\n        loop = asyncio.get_running_loop()\n        req = ClientRequest(\"GET\", URL(\"https://127.0.0.1\"), loop=loop)\n        with suppress(aiohttp.ClientConnectorError):\n            with mock.patch.object(\n                conn._loop,\n                \"create_connection\",\n                autospec=True,\n                spec_set=True,\n                side_effect=ssl.CertificateError,\n            ):\n                await conn.connect(req, [], ClientTimeout())\n        return True\n\n    def test_connect() -> Literal[True]:\n        loop = asyncio.new_event_loop()\n        try:\n            return loop.run_until_complete(async_connect())\n        finally:\n            loop.close()\n\n    with futures.ThreadPoolExecutor() as executor:\n        res_list = [executor.submit(test_connect) for _ in range(2)]\n        raw_response_list = [res.result() for res in futures.as_completed(res_list)]\n\n    assert raw_response_list == [True, True]",
            "docstring": "Test the connector with multiple event loops.",
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [
                "assert raw_response_list == [True, True]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate an event loop or a connection, ensuring that all resources are released and any pending callbacks are executed.\n\n**How It Works**:\nThe method currently has a placeholder implementation (`pass`), indicating that it does not perform any actions yet. In the context of an event loop, a typical implementation would involve stopping the loop, releasing any resources, and notifying any registered callbacks that the loop is closing. This is crucial for preventing resource leaks and ensuring that all asynchronous tasks are properly concluded before the loop is shut down. In related code snippets, similar `close` methods handle cleanup tasks, such as canceling resolvers or notifying callbacks, which illustrates the common pattern of resource management in asynchronous programming."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_clear",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 3536,
            "end_line_number": 3540,
            "source_code": "def test_clear(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.clear()\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "dns_cache_table"
            ],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "dns_cache_table.clear",
                    "body": "def clear(self) -> None:\n    nonlocal num_connections\n    num_connections = len(self)\n    super().clear()",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `clear` method in the `dns_cache_table` class is designed to remove all entries from the DNS cache, effectively resetting the cache to an empty state.\n\n**How It Works**:  \nWhen `clear` is called, it first updates the `num_connections` variable to reflect the current number of entries in the cache before clearing it. It then invokes the `clear` method of its superclass (presumably a dictionary or similar structure) to remove all cached DNS entries. This ensures that the cache is emptied while also keeping track of how many entries were present before the operation."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_connect",
            "module": "test_connector",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
            "line_number": 3733,
            "end_line_number": 3738,
            "source_code": "def test_connect() -> Literal[True]:\n        loop = asyncio.new_event_loop()\n        try:\n            return loop.run_until_complete(async_connect())\n        finally:\n            loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "gc",
                "hashlib",
                "platform",
                "socket",
                "ssl",
                "sys",
                "uuid",
                "collections.defaultdict",
                "collections.deque",
                "concurrent.futures",
                "contextlib.closing",
                "contextlib.suppress",
                "typing.Awaitable",
                "typing.Callable",
                "typing.DefaultDict",
                "typing.Deque",
                "typing.Iterator",
                "typing.List",
                "typing.Literal",
                "typing.NoReturn",
                "typing.Optional",
                "typing.Sequence",
                "typing.Tuple",
                "unittest.mock",
                "pytest",
                "aiohappyeyeballs.AddrInfoType",
                "pytest_mock.MockerFixture",
                "yarl.URL",
                "aiohttp",
                "aiohttp.ClientRequest",
                "aiohttp.ClientSession",
                "aiohttp.ClientTimeout",
                "aiohttp.connector",
                "aiohttp.web",
                "aiohttp.abc.ResolveResult",
                "aiohttp.client_proto.ResponseHandler",
                "aiohttp.client_reqrep.ConnectionKey",
                "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
                "aiohttp.connector._SSL_CONTEXT_VERIFIED",
                "aiohttp.connector.Connection",
                "aiohttp.connector.TCPConnector",
                "aiohttp.connector._DNSCacheTable",
                "aiohttp.pytest_plugin.AiohttpClient",
                "aiohttp.pytest_plugin.AiohttpServer",
                "aiohttp.test_utils.make_mocked_coro",
                "aiohttp.test_utils.unused_port",
                "aiohttp.tracing.Trace"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self) -> None:\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly shut down an event loop or a related resource, ensuring that all associated tasks and connections are properly terminated.\n\n**How It Works**:\nThe method currently has an empty implementation (`pass`), indicating that it does not perform any actions when called. However, in the context of an event loop, a typical implementation would involve stopping the loop, canceling any running tasks, and releasing resources. In the provided code snippets, similar `close` methods are seen that handle resource cleanup, such as notifying callbacks, releasing protocols, and canceling resolvers. This suggests that when implemented, `loop.close` would follow a similar pattern to ensure a graceful shutdown of the event loop and its associated components."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_client",
            "module": "test_autobahn",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
            "line_number": 50,
            "end_line_number": 86,
            "source_code": "def test_client(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting autobahn-testsuite server\")\n        autobahn_container = docker.run(\n            detach=True,\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            publish=[(9001, 9001)],\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/client\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n        )\n        print(\"Running aiohttp test client\")\n        client = subprocess.Popen(\n            [\"wait-for-it\", \"-s\", \"localhost:9001\", \"--\"]\n            + [sys.executable]\n            + [\"tests/autobahn/client/client.py\"]\n        )\n        client.wait()\n    finally:\n        print(\"Stopping client and server\")\n        client.terminate()\n        client.wait()\n        # https://github.com/gabrieldemarmiesse/python-on-whales/pull/580\n        autobahn_container.stop()  # type: ignore[union-attr]\n\n    failed_messages = get_failed_tests(f\"{report_dir}/clients\", \"aiohttp\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
                "pytest.mark.xfail"
            ],
            "arguments": [
                "report_dir",
                "request"
            ],
            "imports": [
                "json",
                "subprocess",
                "sys",
                "pathlib.Path",
                "typing.Any",
                "typing.Dict",
                "typing.Generator",
                "typing.List",
                "pytest",
                "pytest.TempPathFactory",
                "python_on_whales.DockerException",
                "python_on_whales.docker"
            ],
            "fixtures": [],
            "assertions": [
                "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_failed_tests",
                    "body": "def get_failed_tests(report_path: str, name: str) -> List[Dict[str, Any]]:\n    path = Path(report_path)\n    result_summary = json.loads((path / 'index.json').read_text())[name]\n    failed_messages = []\n    PASS = {'OK', 'INFORMATIONAL'}\n    entry_fields = {'case', 'description', 'expectation', 'expected', 'received'}\n    for results in result_summary.values():\n        if results['behavior'] in PASS and results['behaviorClose'] in PASS:\n            continue\n        report = json.loads((path / results['reportfile']).read_text())\n        failed_messages.append({field: report[field] for field in entry_fields})\n    return failed_messages",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_failed_tests` method retrieves a list of failed test cases from a specified report directory, extracting relevant details from JSON files.\n\n**How It Works**:  \n1. It takes two parameters: `report_path` (the directory containing the test reports) and `name` (the specific test suite name).\n2. It constructs a `Path` object for the report directory and reads the `index.json` file to get a summary of test results for the specified suite.\n3. It initializes an empty list, `failed_messages`, to store details of failed tests.\n4. It defines a set `PASS` containing statuses that indicate a test passed.\n5. It iterates through the results in the summary:\n   - If both `behavior` and `behaviorClose` of a result are in the `PASS` set, it skips to the next result.\n   - Otherwise, it reads the corresponding report file and extracts specific fields (`case`, `description`, `expectation`, `expected`, `received`) into a dictionary.\n6. Finally, it returns the list of dictionaries containing details of all failed tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_client",
            "module": "test_autobahn",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
            "line_number": 50,
            "end_line_number": 86,
            "source_code": "def test_client(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting autobahn-testsuite server\")\n        autobahn_container = docker.run(\n            detach=True,\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            publish=[(9001, 9001)],\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/client\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n        )\n        print(\"Running aiohttp test client\")\n        client = subprocess.Popen(\n            [\"wait-for-it\", \"-s\", \"localhost:9001\", \"--\"]\n            + [sys.executable]\n            + [\"tests/autobahn/client/client.py\"]\n        )\n        client.wait()\n    finally:\n        print(\"Stopping client and server\")\n        client.terminate()\n        client.wait()\n        # https://github.com/gabrieldemarmiesse/python-on-whales/pull/580\n        autobahn_container.stop()  # type: ignore[union-attr]\n\n    failed_messages = get_failed_tests(f\"{report_dir}/clients\", \"aiohttp\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
                "pytest.mark.xfail"
            ],
            "arguments": [
                "report_dir",
                "request"
            ],
            "imports": [
                "json",
                "subprocess",
                "sys",
                "pathlib.Path",
                "typing.Any",
                "typing.Dict",
                "typing.Generator",
                "typing.List",
                "pytest",
                "pytest.TempPathFactory",
                "python_on_whales.DockerException",
                "python_on_whales.docker"
            ],
            "fixtures": [],
            "assertions": [
                "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "docker.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `docker.run` method is designed to execute a Docker container with specified configurations, such as image name, container name, volume mappings, network settings, and command to run inside the container. It facilitates the setup of a testing environment for running the Autobahn test suite against a WebSocket server.\n\n**How It Works**:  \nThe method constructs a `ClientResponse` object that simulates an HTTP response. It initializes this response with parameters like the HTTP method, URL, and other mock objects to simulate the request context. The connection object (`conn`) is assigned to the response, allowing it to interact with the specified connection. The method is typically called within a testing context, where it sets up the Docker container and runs the specified command, ensuring that the test server is ready for interaction. After the tests are executed, it cleans up by terminating the server process."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_server",
            "module": "test_autobahn",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
            "line_number": 91,
            "end_line_number": 132,
            "source_code": "def test_server(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting aiohttp test server\")\n        server = subprocess.Popen(\n            [sys.executable] + [\"tests/autobahn/server/server.py\"]\n        )\n        print(\"Starting autobahn-testsuite client\")\n        docker.run(\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/server\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n            networks=[\"host\"],\n            command=[\n                \"wait-for-it\",\n                \"-s\",\n                \"localhost:9001\",\n                \"--\",\n                \"wstest\",\n                \"--mode\",\n                \"fuzzingclient\",\n                \"--spec\",\n                \"/config/fuzzingclient.json\",\n            ],\n        )\n    finally:\n        print(\"Stopping client and server\")\n        server.terminate()\n        server.wait()\n\n    failed_messages = get_failed_tests(f\"{report_dir}/servers\", \"AutobahnServer\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
                "pytest.mark.xfail"
            ],
            "arguments": [
                "report_dir",
                "request"
            ],
            "imports": [
                "json",
                "subprocess",
                "sys",
                "pathlib.Path",
                "typing.Any",
                "typing.Dict",
                "typing.Generator",
                "typing.List",
                "pytest",
                "pytest.TempPathFactory",
                "python_on_whales.DockerException",
                "python_on_whales.docker"
            ],
            "fixtures": [],
            "assertions": [
                "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_failed_tests",
                    "body": "def get_failed_tests(report_path: str, name: str) -> List[Dict[str, Any]]:\n    path = Path(report_path)\n    result_summary = json.loads((path / 'index.json').read_text())[name]\n    failed_messages = []\n    PASS = {'OK', 'INFORMATIONAL'}\n    entry_fields = {'case', 'description', 'expectation', 'expected', 'received'}\n    for results in result_summary.values():\n        if results['behavior'] in PASS and results['behaviorClose'] in PASS:\n            continue\n        report = json.loads((path / results['reportfile']).read_text())\n        failed_messages.append({field: report[field] for field in entry_fields})\n    return failed_messages",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_failed_tests` method retrieves a list of failed test cases from a specified report directory, extracting relevant details from JSON files.\n\n**How It Works**:  \n1. It takes two parameters: `report_path` (the directory containing the test reports) and `name` (the specific test suite name).\n2. It constructs a `Path` object for the report directory and reads the `index.json` file to get a summary of test results for the specified suite.\n3. It initializes an empty list, `failed_messages`, to store details of failed tests.\n4. It defines a set `PASS` containing statuses that indicate a test passed.\n5. It iterates through the results in the summary:\n   - If both `behavior` and `behaviorClose` of a result are in the `PASS` set, it skips to the next result.\n   - Otherwise, it reads the corresponding report file and extracts specific fields (`case`, `description`, `expectation`, `expected`, `received`) into a dictionary.\n6. Finally, it returns the list of dictionaries containing details of all failed tests."
                }
            ]
        },
        {
            "repo_name": "aiohttp",
            "name": "test_server",
            "module": "test_autobahn",
            "class_name": null,
            "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
            "line_number": 91,
            "end_line_number": 132,
            "source_code": "def test_server(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting aiohttp test server\")\n        server = subprocess.Popen(\n            [sys.executable] + [\"tests/autobahn/server/server.py\"]\n        )\n        print(\"Starting autobahn-testsuite client\")\n        docker.run(\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/server\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n            networks=[\"host\"],\n            command=[\n                \"wait-for-it\",\n                \"-s\",\n                \"localhost:9001\",\n                \"--\",\n                \"wstest\",\n                \"--mode\",\n                \"fuzzingclient\",\n                \"--spec\",\n                \"/config/fuzzingclient.json\",\n            ],\n        )\n    finally:\n        print(\"Stopping client and server\")\n        server.terminate()\n        server.wait()\n\n    failed_messages = get_failed_tests(f\"{report_dir}/servers\", \"AutobahnServer\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
                "pytest.mark.xfail"
            ],
            "arguments": [
                "report_dir",
                "request"
            ],
            "imports": [
                "json",
                "subprocess",
                "sys",
                "pathlib.Path",
                "typing.Any",
                "typing.Dict",
                "typing.Generator",
                "typing.List",
                "pytest",
                "pytest.TempPathFactory",
                "python_on_whales.DockerException",
                "python_on_whales.docker"
            ],
            "fixtures": [],
            "assertions": [
                "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "docker.run",
                    "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `docker.run` method is designed to execute a Docker container with specified configurations, such as image name, container name, volume mappings, network settings, and command to run. It facilitates the setup of a testing environment for running the Autobahn test suite against a WebSocket server.\n\n**How It Works**:  \nThe method constructs a `ClientResponse` object that simulates an HTTP response. It initializes this response with parameters like the HTTP method, URL, and various mock objects to simulate the request environment. The connection object (`conn`) is assigned to the response, allowing it to interact with the specified Docker container. The method is typically called within a test function that sets up a subprocess for the server and runs the Docker container with the provided configurations, ensuring that the test environment is correctly established before executing the tests."
                }
            ]
        }
    ]
}