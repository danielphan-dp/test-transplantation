{
    "tests": [
        {
            "repo_name": "uvicorn",
            "name": "test_run_invalid_app_config_combination",
            "module": "test_main",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_main.py",
            "line_number": 75,
            "end_line_number": 83,
            "source_code": "def test_run_invalid_app_config_combination(caplog: pytest.LogCaptureFixture) -> None:\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, reload=True)\n    assert exit_exception.value.code == 1\n    assert caplog.records[-1].name == \"uvicorn.error\"\n    assert caplog.records[-1].levelno == WARNING\n    assert caplog.records[-1].message == (\n        \"You must pass the application as an import string to enable \" \"'reload' or 'workers'.\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "caplog"
            ],
            "imports": [
                "inspect",
                "socket",
                "logging.WARNING",
                "httpx",
                "pytest",
                "tests.utils.run_server",
                "uvicorn.Server",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.Config",
                "uvicorn.main.run"
            ],
            "fixtures": [],
            "assertions": [
                "assert exit_exception.value.code == 1",
                "assert caplog.records[-1].name == 'uvicorn.error'",
                "assert caplog.records[-1].levelno == WARNING",
                "assert caplog.records[-1].message == \"You must pass the application as an import string to enable 'reload' or 'workers'.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run",
                    "body": "def run(sockets):\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run` method is designed to start a server using the provided sockets, which can be either UNIX domain sockets, file descriptors, or standard host/port pairs. It handles the initialization of the server based on the configuration and manages the logging of the server's startup status.\n\n**How It Works**:\nThe method first checks the configuration for existing sockets or file descriptors. If a file descriptor is provided, it creates a socket from it. If a UNIX domain socket path is specified, it creates a UNIX socket and sets its permissions. If neither is available, it defaults to creating a standard TCP socket using the specified host and port. After successfully creating the server, it logs the startup message unless sockets are provided (indicating multiple workers). Finally, it sets a flag to indicate that the server has started."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_run_startup_failure",
            "module": "test_main",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_main.py",
            "line_number": 86,
            "end_line_number": 95,
            "source_code": "def test_run_startup_failure(caplog: pytest.LogCaptureFixture) -> None:\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"lifespan\"\n        message = await receive()\n        if message[\"type\"] == \"lifespan.startup\":\n            raise RuntimeError(\"Startup failed\")\n\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, lifespan=\"on\")\n    assert exit_exception.value.code == 3",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "caplog"
            ],
            "imports": [
                "inspect",
                "socket",
                "logging.WARNING",
                "httpx",
                "pytest",
                "tests.utils.run_server",
                "uvicorn.Server",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.Config",
                "uvicorn.main.run"
            ],
            "fixtures": [],
            "assertions": [
                "assert exit_exception.value.code == 3",
                "assert scope['type'] == 'lifespan'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run",
                    "body": "def run(sockets):\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run` method is designed to start a server using the provided sockets, which can be either UNIX domain sockets, file descriptors, or standard host/port pairs. It handles the initialization of the server and manages the logging of its startup status.\n\n**How It Works**:\nThe method accepts a list of sockets as an argument. It first checks the configuration to determine how to create the server:\n- If a file descriptor (`fd`) is provided, it creates a socket from that descriptor.\n- If a UNIX domain socket (`uds`) is specified, it creates a server using that socket.\n- If neither is provided, it defaults to creating a server using a host and port.\n\nAfter successfully creating the server, it logs a message indicating that the server has started, unless sockets are provided (indicating multiple workers are running). The method also sets a flag (`self.started`) to indicate that the server has been successfully started."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_get_subprocess",
            "module": "test_subprocess",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
            "line_number": 19,
            "end_line_number": 28,
            "source_code": "def test_get_subprocess() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    process = get_subprocess(config, server_run, [fdsock])\n    assert isinstance(process, SpawnProcess)\n\n    fdsock.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "__future__.annotations",
                "socket",
                "unittest.mock.patch",
                "uvicorn._subprocess.SpawnProcess",
                "uvicorn._subprocess.get_subprocess",
                "uvicorn._subprocess.subprocess_started",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.Config"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(process, SpawnProcess)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fdsock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket or connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively marking the socket as closed. This prevents any subsequent operations on the socket, helping to manage resources and avoid potential errors from attempting to use a closed connection."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_subprocess_started",
            "module": "test_subprocess",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
            "line_number": 31,
            "end_line_number": 43,
            "source_code": "def test_subprocess_started() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    with patch(\"tests.test_subprocess.server_run\") as mock_run:\n        with patch.object(config, \"configure_logging\") as mock_config_logging:\n            subprocess_started(config, server_run, [fdsock], None)\n            mock_run.assert_called_once()\n            mock_config_logging.assert_called_once()\n\n    fdsock.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "__future__.annotations",
                "socket",
                "unittest.mock.patch",
                "uvicorn._subprocess.SpawnProcess",
                "uvicorn._subprocess.get_subprocess",
                "uvicorn._subprocess.subprocess_started",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.Config"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fdsock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent operations on the socket, helping to manage resources effectively and avoid potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_non_existant_reload_dir_is_not_set",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 96,
            "end_line_number": 104,
            "source_code": "def test_non_existant_reload_dir_is_not_set(reload_directory_structure: Path, caplog: pytest.LogCaptureFixture) -> None:\n    with as_cwd(reload_directory_structure), caplog.at_level(logging.WARNING):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=[\"reload\"])\n        assert config.reload_dirs == [reload_directory_structure]\n        assert (\n            caplog.records[-1].message\n            == \"Provided reload directories ['reload'] did not contain valid \"\n            + \"directories, watching current working directory.\"\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure",
                "caplog"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert config.reload_dirs == [reload_directory_structure]",
                "assert caplog.records[-1].message == \"Provided reload directories ['reload'] did not contain valid \" + 'directories, watching current working directory.'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_subdir_removal",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 107,
            "end_line_number": 114,
            "source_code": "def test_reload_subdir_removal(reload_directory_structure: Path) -> None:\n    app_dir = reload_directory_structure / \"app\"\n\n    reload_dirs = [str(reload_directory_structure), \"app\", str(app_dir)]\n\n    with as_cwd(reload_directory_structure):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=reload_dirs)\n        assert config.reload_dirs == [reload_directory_structure]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert config.reload_dirs == [reload_directory_structure]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_included_dir_is_added_to_reload_dirs",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 117,
            "end_line_number": 131,
            "source_code": "def test_reload_included_dir_is_added_to_reload_dirs(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    ext_dir = reload_directory_structure / \"ext\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n            reload_includes=[\"*.js\", str(ext_dir)],\n        )\n        assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])\n        assert frozenset(config.reload_includes) == frozenset([\"*.js\", str(ext_dir)])",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])",
                "assert frozenset(config.reload_includes) == frozenset(['*.js', str(ext_dir)])"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working directory is always reset, maintaining a clean environment."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_dir_subdirectories_are_removed",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 134,
            "end_line_number": 153,
            "source_code": "def test_reload_dir_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n    ext_dir = reload_directory_structure / \"ext\"\n    ext_sub_dir = ext_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[\n                str(app_dir),\n                str(app_sub_dir),\n                str(ext_sub_dir),\n                str(ext_dir),\n            ],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_excluded_subdirectories_are_removed",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 156,
            "end_line_number": 170,
            "source_code": "def test_reload_excluded_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_excludes=[str(app_dir), str(app_sub_dir)],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])\n        assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])\n        assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])",
                "assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])",
                "assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first stores the current working directory in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to `path`.\n4. After the block is executed, the `finally` clause is triggered, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that no matter how the block exits (normally or via an exception), the original directory is always restored."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_includes_exclude_dir_patterns_are_matched",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 173,
            "end_line_number": 193,
            "source_code": "def test_reload_includes_exclude_dir_patterns_are_matched(\n    reload_directory_structure: Path, caplog: pytest.LogCaptureFixture\n) -> None:\n    with caplog.at_level(logging.INFO):\n        first_app_dir = reload_directory_structure / \"app_first\" / \"src\"\n        second_app_dir = reload_directory_structure / \"app_second\" / \"src\"\n\n        with as_cwd(reload_directory_structure):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*/src\"],\n                reload_excludes=[\"app\", \"*third*\"],\n            )\n            assert len(caplog.records) == 1\n            assert (\n                caplog.records[-1].message == \"Will watch for changes in these directories: \"\n                f\"{sorted([str(first_app_dir), str(second_app_dir)])}\"\n            )\n            assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])\n            assert config.reload_includes == [\"*/src\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "reload_directory_structure",
                "caplog"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(caplog.records) == 1",
                "assert caplog.records[-1].message == f'Will watch for changes in these directories: {sorted([str(first_app_dir), str(second_app_dir)])}'",
                "assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])",
                "assert config.reload_includes == ['*/src']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_socket_bind",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 262,
            "end_line_number": 267,
            "source_code": "def test_socket_bind() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    sock.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_bind_unix_socket_works_with_reload_or_workers",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 491,
            "end_line_number": 500,
            "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
                "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
            ],
            "arguments": [
                "tmp_path",
                "reload",
                "workers",
                "short_socket_name"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)",
                "assert sock.family == socket.AF_UNIX",
                "assert sock.getsockname() == short_socket_name"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_bind_unix_socket_works_with_reload_or_workers",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 491,
            "end_line_number": 500,
            "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
                "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
            ],
            "arguments": [
                "tmp_path",
                "reload",
                "workers",
                "short_socket_name"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)",
                "assert sock.family == socket.AF_UNIX",
                "assert sock.getsockname() == short_socket_name"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.getsockname",
                    "body": "def getsockname(self):\n    return self.sockname",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `getsockname` method retrieves the local socket address (name) associated with the socket object. This address typically includes the IP address and port number for network sockets or the file path for Unix domain sockets.\n\n**How It Works**:  \nThe method simply returns the value of the `sockname` attribute from the socket instance. This attribute is set when the socket is created and bound to a specific address using the `bind` method. In the context of the provided code, it is used to log the socket's address when the server is running, allowing developers to know where the server is listening for incoming connections."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_bind_fd_works_with_reload_or_workers",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 512,
            "end_line_number": 522,
            "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
                "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
            ],
            "arguments": [
                "reload",
                "workers"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)",
                "assert sock.family == socket.AF_UNIX",
                "assert sock.getsockname() == ''"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_bind_fd_works_with_reload_or_workers",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 512,
            "end_line_number": 522,
            "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
                "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
            ],
            "arguments": [
                "reload",
                "workers"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)",
                "assert sock.family == socket.AF_UNIX",
                "assert sock.getsockname() == ''"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fdsock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent operations on the socket, helping to manage resources effectively and avoid potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_bind_fd_works_with_reload_or_workers",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_config.py",
            "line_number": 512,
            "end_line_number": 522,
            "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
                "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
            ],
            "arguments": [
                "reload",
                "workers"
            ],
            "imports": [
                "__future__.annotations",
                "configparser",
                "io",
                "json",
                "logging",
                "os",
                "socket",
                "sys",
                "typing",
                "pathlib.Path",
                "typing.Any",
                "typing.Literal",
                "unittest.mock.MagicMock",
                "pytest",
                "yaml",
                "pytest_mock.MockerFixture",
                "tests.utils.as_cwd",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Environ",
                "uvicorn._types.Scope",
                "uvicorn._types.StartResponse",
                "uvicorn.config.Config",
                "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
                "uvicorn.middleware.wsgi.WSGIMiddleware",
                "uvicorn.protocols.http.h11_impl.H11Protocol"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(sock, socket.socket)",
                "assert sock.family == socket.AF_UNIX",
                "assert sock.getsockname() == ''"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.getsockname",
                    "body": "def getsockname(self):\n    return self.sockname",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `getsockname` method retrieves the local socket address (name) associated with the socket object. This address typically includes the IP address and port number for network sockets or the file path for Unix domain sockets.\n\n**How It Works**:  \nThe method simply returns the value of the `sockname` attribute from the socket instance. This attribute is set when the socket is created and bound to a specific address using methods like `bind()`. In the context of the provided code, `getsockname` is used to obtain the socket's address for logging or further processing, particularly when the socket is created from a file descriptor or bound to a specific address."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 10,
            "end_line_number": 40,
            "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 10,
            "end_line_number": 40,
            "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `startup` method is designed to handle the startup phase of an application within the lifespan management context. It logs the startup process, manages asynchronous tasks, and signals when the application is ready or if it has failed to start.\n\n**How It Works**:\n1. The method begins by logging an informational message indicating that the application is waiting for startup.\n2. It retrieves the current event loop and creates a task for the main lifespan process.\n3. A startup event is created and placed in a receive queue, which is used to communicate between different parts of the application.\n4. The method then waits for the `startup_event` to be set, indicating that the startup process is complete.\n5. After waiting, it checks for any errors that occurred during startup. If any issues are detected, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 10,
            "end_line_number": 40,
            "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no error is detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be signaled, which indicates that the shutdown process can continue. After the shutdown event is processed, it checks for any shutdown failures or errors that may have occurred during the shutdown process, logging appropriate messages and setting a flag to indicate whether the application should exit. If everything completes successfully, it logs that the application shutdown is complete."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_off",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 43,
            "end_line_number": 56,
            "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It asserts that the object is not already closed before changing its state.\n\n**How It Works**:\nThe method first checks if the `closed` attribute is `False` using an assertion. If the assertion passes, it sets the `closed` attribute to `True`, indicating that the object is now closed. This prevents any subsequent operations that may rely on the object being open, helping to manage resource cleanup and state transitions effectively."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_off",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 43,
            "end_line_number": 56,
            "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals the start of the application lifecycle and manages the necessary setup before the application begins processing requests.\n\n**How It Works**:  \nWhen the `startup` method is called, it logs a message indicating that the application is waiting to start. It then creates a task for the main lifespan process and puts a `lifespan.startup` event into a queue for processing. The method waits for the `startup_event` to be set, which indicates that the application has completed its startup procedures. If any errors occurred during startup or if the startup process failed, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_off",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 43,
            "end_line_number": 56,
            "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no errors are detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be set, which indicates that the shutdown process is complete. After waiting, it checks if the shutdown was successful or if any errors occurred during the process, logging appropriate messages and setting a flag to indicate whether the application should exit."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 59,
            "end_line_number": 89,
            "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It helps manage the lifecycle of the object, preventing actions that should not occur after closure.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the object is now closed. This mechanism is typically used in asynchronous programming to safely manage resources and prevent errors related to operations on closed objects."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 59,
            "end_line_number": 89,
            "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals the start of the application lifecycle and manages the necessary setup before the application begins processing requests.\n\n**How It Works**:  \nWhen invoked, the `startup` method logs a message indicating that the application is waiting to start. It creates a task for the main lifespan process and places a startup event in a queue for further processing. The method then waits for the startup event to be signaled, indicating that the application is ready to proceed. If any errors occurred during startup or if the startup process fails, it logs an error message and sets a flag to indicate that the application should exit. If successful, it logs a completion message. This method is typically called as part of the application lifecycle management in an ASGI server environment."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 59,
            "end_line_number": 89,
            "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert not shutdown_complete",
                "assert startup_complete",
                "assert shutdown_complete"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of an application, ensuring that all necessary cleanup tasks are performed before the application exits. It logs the shutdown process and manages the state of the application during this phase.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors occurred during the application's operation. If errors are present, it exits early without proceeding with the shutdown. If no errors are detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue, signaling that the shutdown process has started. The method waits for a shutdown event to be set, which indicates that the shutdown process is complete. Finally, it checks if the shutdown was successful or if any errors occurred during this phase, logging the appropriate messages and setting the `should_exit` flag if necessary."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 92,
            "end_line_number": 107,
            "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope['type'] == 'http'",
                "assert lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively closing the object. This mechanism helps prevent any operations on the object after it has been closed, which can be crucial for resource management and avoiding errors in asynchronous programming contexts."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 92,
            "end_line_number": 107,
            "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope['type'] == 'http'",
                "assert lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals the start of the application lifecycle and manages the necessary setup before the application begins processing requests.\n\n**How It Works**:  \nWhen invoked, the `startup` method logs a message indicating that the application is waiting to start. It then creates a task for the main lifespan process and places a startup event message into a queue for processing. The method waits for the startup event to be signaled, which indicates that the application is ready to handle requests. If any errors occurred during startup or if the startup process fails, it logs an error message and sets a flag to indicate that the application should exit. If successful, it logs a completion message. This method is crucial for ensuring that all necessary preparations are completed before the application begins its operation."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_auto_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 92,
            "end_line_number": 107,
            "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope['type'] == 'http'",
                "assert lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the shutdown process of an application. It ensures that the application can gracefully terminate by logging the shutdown event and managing any necessary cleanup tasks.\n\n**How It Works**:  \nWhen invoked, the `shutdown` method first checks if any errors occurred during the application's operation. If there are no errors, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be set, which indicates that the shutdown process is complete. If the shutdown fails or if there were errors during the application's lifecycle, it logs an error message and sets a flag to indicate that the application should exit. If the shutdown is successful, it logs a completion message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 110,
            "end_line_number": 126,
            "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert lifespan.error_occured",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It asserts that the object is not already closed before changing its state.\n\n**How It Works**:\nWhen the `close` method is called, it first checks if the `closed` attribute is `False` using an assertion. If the assertion passes, it sets the `closed` attribute to `True`, indicating that the object is now closed. This prevents any subsequent operations that may rely on the object being open, thereby helping to manage resource cleanup and state integrity."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 110,
            "end_line_number": 126,
            "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert lifespan.error_occured",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals that the application is starting up and manages the necessary events and state transitions.\n\n**How It Works**:  \nWhen invoked, the `startup` method logs a message indicating that the application is waiting for startup. It creates a task for the main lifespan process and places a startup event in a queue for processing. The method then waits for the startup event to be set, which indicates that the application has completed its startup procedures. If any errors occurred during startup or if the startup process fails, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_on_with_error",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 110,
            "end_line_number": 126,
            "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert lifespan.error_occured",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors have occurred during the application's operation. If there are no errors, it logs a message indicating that the shutdown process is starting. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be set, which indicates that the shutdown process has been completed. If the shutdown fails or if there were errors during the application's lifecycle, it logs an error message and sets a flag to indicate that the application should exit. If the shutdown completes successfully, it logs a confirmation message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_startup",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 131,
            "end_line_number": 157,
            "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert lifespan.startup_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_startup",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 131,
            "end_line_number": 157,
            "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert lifespan.startup_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals the start of the application lifecycle and manages the necessary setup before the application begins processing requests.\n\n**How It Works**:  \nWhen the `startup` method is called, it logs a message indicating that the application is waiting to start. It then creates a task for the main lifespan process and puts a `lifespan.startup` event into a queue for processing. The method waits for the `startup_event` to be set, which indicates that the application has completed its startup procedures. If any errors occurred during startup or if the startup process failed, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message. This method is crucial for ensuring that the application is fully prepared to handle incoming requests."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_startup",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 131,
            "end_line_number": 157,
            "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert lifespan.startup_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of an application, ensuring that all necessary cleanup tasks are performed before the application exits. It logs the shutdown process and manages the state of the application during this phase.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors occurred during the application's operation. If errors are present, it exits early without proceeding with the shutdown. If no errors are detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a queue for processing. The method waits for a signal that the shutdown process is complete. After the shutdown event is processed, it checks for any shutdown failures and logs an appropriate message, updating the application's exit state accordingly."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi3app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 160,
            "end_line_number": 180,
            "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
                "assert not lifespan.startup_failed",
                "assert not lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi3app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 160,
            "end_line_number": 180,
            "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
                "assert not lifespan.startup_failed",
                "assert not lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `startup` method is designed to handle the startup phase of an application within the lifespan management context. It logs the startup process, manages asynchronous tasks, and signals the completion of the startup phase.\n\n**How It Works**:\nWhen invoked, the `startup` method first logs a message indicating that the application is waiting for startup. It then creates an asynchronous task for the main lifespan process and puts a startup event message into a queue. The method waits for the `startup_event` to be set, which indicates that the startup process has completed. If any errors occurred during startup or if the startup failed, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi3app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 160,
            "end_line_number": 180,
            "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
                "assert not lifespan.startup_failed",
                "assert not lifespan.error_occured",
                "assert not lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no error is detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue, signaling that the shutdown process has started. The method waits for a shutdown event to be set, which indicates that the shutdown process has completed. After waiting, it checks if the shutdown was successful or if any errors occurred during the process, logging appropriate messages and setting a flag to indicate whether the application should exit."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi2app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 183,
            "end_line_number": 205,
            "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:  \nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi2app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 183,
            "end_line_number": 205,
            "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `startup` method is designed to handle the startup phase of an application within the lifespan management context. It logs the startup process, manages asynchronous tasks, and signals the completion of the startup phase.\n\n**How It Works**:\nWhen invoked, the `startup` method first logs a message indicating that the application is waiting for startup. It then creates an asynchronous task for the main lifespan process and puts a startup event message into a queue. The method waits for a signal that the startup has completed. If any errors occurred during startup or if the startup process failed, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message. This method is crucial for ensuring that the application is properly initialized before handling requests."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_scope_asgi2app",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 183,
            "end_line_number": 205,
            "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no error is detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be set, which indicates that the shutdown process is complete. After waiting, it checks if the shutdown was successful or if any errors occurred during the shutdown process, logging appropriate messages and setting a flag to indicate whether the application should exit."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_shutdown",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 210,
            "end_line_number": 241,
            "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not lifespan.startup_failed",
                "assert lifespan.shutdown_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:  \nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents the object from being closed multiple times, which could lead to inconsistent states or errors in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_shutdown",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 210,
            "end_line_number": 241,
            "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not lifespan.startup_failed",
                "assert lifespan.shutdown_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the initialization process of an application within the lifespan management of an ASGI server. It signals the start of the application lifecycle and manages the necessary setup before the application begins processing requests.\n\n**How It Works**:  \nWhen invoked, the `startup` method logs a message indicating that the application is waiting to start. It then creates a task for the main lifespan process and places a startup event message into a queue for processing. The method waits for the startup event to be signaled, which allows for asynchronous operations to complete. If any errors occurred during startup or if the application is configured to exit, it logs an error message and sets a flag to indicate that the application should exit. If the startup completes successfully, it logs a confirmation message. This method is crucial for ensuring that all necessary preparations are made before the application begins handling incoming requests."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_with_failed_shutdown",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 210,
            "end_line_number": 241,
            "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('auto', 'on'))",
                "pytest.mark.parametrize('raise_exception', (True, False))"
            ],
            "arguments": [
                "mode",
                "raise_exception",
                "caplog"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'the lifespan event failed' in error_messages.pop(0)",
                "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert not lifespan.startup_failed",
                "assert lifespan.shutdown_failed",
                "assert lifespan.error_occured is raise_exception",
                "assert lifespan.should_exit"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no error is detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be signaled, which indicates that the shutdown process can continue. After the shutdown event is processed, it checks for any shutdown failures or errors, logging appropriate messages and setting a flag to indicate whether the application should exit. If everything completes successfully, it logs that the application shutdown is complete."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_state",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 244,
            "end_line_number": 264,
            "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert lifespan.state == {'foo': 123}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "loop.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively preventing any further actions that would require the object to be open. This is a common pattern in resource management to ensure that resources are properly released and not used after they have been closed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_state",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 244,
            "end_line_number": 264,
            "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert lifespan.state == {'foo': 123}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to handle the startup phase of an application within the lifespan management of an ASGI (Asynchronous Server Gateway Interface) application. It signals that the application is starting up and manages the necessary events and state transitions.\n\n**How It Works**:  \nWhen the `startup` method is called, it logs a message indicating that the application is waiting for startup. It then creates a task for the main lifespan process and puts a startup event into a queue for processing. The method waits for the startup event to be signaled, which allows for asynchronous handling of the startup process. If any errors occurred during startup or if the startup process fails, it sets a flag to indicate that the application should exit. If successful, it logs a completion message. This method is crucial for initializing resources and preparing the application to handle incoming requests."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_lifespan_state",
            "module": "test_lifespan",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
            "line_number": 244,
            "end_line_number": 264,
            "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn"
            ],
            "fixtures": [],
            "assertions": [
                "assert message['type'] == 'lifespan.startup'",
                "assert message['type'] == 'lifespan.shutdown'",
                "assert lifespan.state == {'foo': 123}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "lifespan.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method in the `LifespanOn` class is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if an error has occurred during the application's operation. If an error is present, the method returns immediately without proceeding. If no error is detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be signaled, which indicates that the shutdown process can continue. After the shutdown event is processed, it checks for any shutdown failures or errors. If any issues are detected, it logs an error message and sets a flag to indicate that the application should exit. If the shutdown completes successfully, it logs a confirmation message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_env_variables",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
            "line_number": 155,
            "end_line_number": 161,
            "source_code": "def test_env_variables(http_protocol: str):\n    with load_env_var(\"UVICORN_HTTP\", http_protocol):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == http_protocol",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('http_protocol', ['h11', 'httptools'])"
            ],
            "arguments": [
                "http_protocol"
            ],
            "imports": [
                "contextlib",
                "importlib",
                "os",
                "platform",
                "sys",
                "pathlib.Path",
                "textwrap.dedent",
                "typing.Iterator",
                "unittest.mock",
                "pytest",
                "click.testing.CliRunner",
                "uvicorn",
                "uvicorn.config.Config",
                "uvicorn.main.main",
                "uvicorn.server.Server",
                "uvicorn.supervisors.ChangeReload",
                "uvicorn.supervisors.Multiprocess"
            ],
            "fixtures": [],
            "assertions": [
                "assert kwargs['http'] == http_protocol"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "load_env_var",
                    "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that any changes made during the block do not persist. \n\nThis method is useful for testing or temporarily altering the environment without affecting the global state."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_ignore_environment_variable_when_set_on_cli",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
            "line_number": 164,
            "end_line_number": 170,
            "source_code": "def test_ignore_environment_variable_when_set_on_cli():\n    with load_env_var(\"UVICORN_HTTP\", \"h11\"):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\", \"--http=httptools\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == \"httptools\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "contextlib",
                "importlib",
                "os",
                "platform",
                "sys",
                "pathlib.Path",
                "textwrap.dedent",
                "typing.Iterator",
                "unittest.mock",
                "pytest",
                "click.testing.CliRunner",
                "uvicorn",
                "uvicorn.config.Config",
                "uvicorn.main.main",
                "uvicorn.server.Server",
                "uvicorn.supervisors.ChangeReload",
                "uvicorn.supervisors.Multiprocess"
            ],
            "fixtures": [],
            "assertions": [
                "assert kwargs['http'] == 'httptools'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "load_env_var",
                    "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that the temporary change does not affect subsequent code. \n\nThis method is useful for testing or scenarios where you need to modify environment variables without permanently altering the system's environment."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_set_app_via_environment_variable",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
            "line_number": 195,
            "end_line_number": 203,
            "source_code": "def test_set_app_via_environment_variable():\n    app_path = \"tests.test_cli:App\"\n    with load_env_var(\"UVICORN_APP\", app_path):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            result = runner.invoke(cli)\n            args, _ = mock_run.call_args\n            assert result.exit_code == 0\n            assert args == (app_path,)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "contextlib",
                "importlib",
                "os",
                "platform",
                "sys",
                "pathlib.Path",
                "textwrap.dedent",
                "typing.Iterator",
                "unittest.mock",
                "pytest",
                "click.testing.CliRunner",
                "uvicorn",
                "uvicorn.config.Config",
                "uvicorn.main.main",
                "uvicorn.server.Server",
                "uvicorn.supervisors.ChangeReload",
                "uvicorn.supervisors.Multiprocess"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert args == (app_path,)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "load_env_var",
                    "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that the environment remains unchanged outside the context. \n\nThis method is useful for testing or temporarily modifying environment settings without affecting the global state."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes need to be detected and applied without restarting the entire application.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent regardless of what happens within the context."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or shut down.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or shut down.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string 'shutdown' to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be performed. In the context of the provided code snippets, it is part of a larger reloader class that manages application restarts and shutdowns based on specific conditions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes need to be detected and applied without restarting the entire application.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown process is executed as expected during the reloader's lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates the files that have changed according to the reloader's logic. If no changes are detected, it returns `None`."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string \"shutdown\" to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method is typically called when the application is being terminated, allowing for any necessary cleanup or logging to occur. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and can be verified through assertions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on the rest of the program."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or stop.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be executed. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that the application can exit cleanly."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function with the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple marker to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown sequence is executed as expected."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method is typically called when the application is being terminated, allowing for any necessary cleanup or logging to occur. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and can be verified through assertions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on other parts of the code."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader detects these changes correctly.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function with the provided files, simulating a quick modification to those files.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected after the files were modified. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method is typically called when the application needs to gracefully terminate, allowing for any necessary cleanup or state management before the application exits. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and can be verified through assertions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function with the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle. It then touches each file to simulate a change.\n4. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files triggered a reload, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected after the files were touched. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method is typically called when the application is being terminated, allowing for any necessary cleanup or logging to occur. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and can be verified through assertions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of lifecycle events (like startup, restart, and shutdown) that have occurred during the reloader's operation. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has been requested. This can be useful for testing and debugging purposes, as seen in the provided test cases where the order of calls is asserted."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.should_restart",
                    "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `should_restart` method determines whether the application should restart based on the number of times it has been called. It is part of a reloader class that manages application restarts during development.\n\n**How It Works**:\nThe method uses a nonlocal variable `step` to track the number of calls. On the first call, it returns `None`, indicating no restart is needed. On the second call, it returns a list containing the path to a file (`foobar.py`), suggesting that this file has changed and a restart is warranted. On any subsequent calls, it raises a `StopIteration` exception, signaling that no further checks for restarts should be made. This mechanism allows the reloader to control the restart process based on file changes detected during development."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects from changing directories."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": "TestBaseReload",
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or stop.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be executed. In the context of the provided tests, it ensures that the shutdown process is correctly logged and that the application state is updated accordingly."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_watch_one_dir_cwd",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 336,
            "end_line_number": 349,
            "source_code": "def test_should_watch_one_dir_cwd(mocker, reload_directory_structure):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir), str(app_first_dir)],\n        )\n        WatchFilesReload(config, target=run, sockets=[])\n        mock_watch.assert_called_once()\n        assert mock_watch.call_args[0] == (Path.cwd(),)",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')"
            ],
            "arguments": [
                "mocker",
                "reload_directory_structure"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert mock_watch.call_args[0] == (Path.cwd(),)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [
                "mocker.patch('uvicorn.supervisors.watchfilesreload.watch')"
            ],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_display_path_relative",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 371,
            "end_line_number": 375,
            "source_code": "def test_display_path_relative(tmp_path):\n    with as_cwd(tmp_path):\n        p = tmp_path / \"app\" / \"foobar.py\"\n        # accept windows paths as wells as posix\n        assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on other parts of the code."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_base_reloader_run",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 383,
            "end_line_number": 411,
            "source_code": "def test_base_reloader_run(tmp_path):\n    calls = []\n    step = 0\n\n    class CustomReload(BaseReload):\n        def startup(self):\n            calls.append(\"startup\")\n\n        def restart(self):\n            calls.append(\"restart\")\n\n        def shutdown(self):\n            calls.append(\"shutdown\")\n\n        def should_restart(self):\n            nonlocal step\n            step += 1\n            if step == 1:\n                return None\n            elif step == 2:\n                return [tmp_path / \"foobar.py\"]\n            else:\n                raise StopIteration()\n\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = CustomReload(config, target=run, sockets=[])\n    reloader.run()\n\n    assert calls == [\"startup\", \"restart\", \"shutdown\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert calls == ['startup', 'restart', 'shutdown']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.run",
                    "body": "def run(sockets):\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `reloader.run` method is designed to manage the execution of a server with the capability to reload its configuration or restart based on file changes, particularly in a Unix-like environment.\n\n**How It Works**:  \nThe method takes a list of socket objects as an argument, which are used for binding the server. It is typically invoked when the server is set to reload its configuration or when multiple worker processes are required. The method itself is currently a placeholder (`pass`), indicating that its implementation is yet to be defined. In the context of the surrounding code, it is likely intended to handle the logic for monitoring file changes and restarting the server as needed, ensuring that the application can adapt to changes without manual intervention."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_base_reloader_closes_sockets_on_shutdown",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 430,
            "end_line_number": 437,
            "source_code": "def test_base_reloader_closes_sockets_on_shutdown():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[sock])\n    reloader.startup()\n    assert sock.fileno() != -1\n    reloader.shutdown()\n    assert sock.fileno() == -1",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert sock.fileno() != -1",
                "assert sock.fileno() == -1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.startup",
                    "body": "def startup(self):\n    calls.append('startup')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `startup` method is designed to be called when the reloader is initialized or started. Its primary function is to log or register that the startup process has begun, which can be useful for tracking the reloader's lifecycle during development.\n\n**How It Works**:  \nWhen the `startup` method is invoked, it appends the string `'startup'` to a list called `calls`. This list is used to keep track of the sequence of events that occur during the reloader's operation. In the context of the provided tests, this method is called to ensure that the reloader's startup phase is executed, and its effect can be verified by checking the contents of the `calls` list."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_base_reloader_closes_sockets_on_shutdown",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 430,
            "end_line_number": 437,
            "source_code": "def test_base_reloader_closes_sockets_on_shutdown():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[sock])\n    reloader.startup()\n    assert sock.fileno() != -1\n    reloader.shutdown()\n    assert sock.fileno() == -1",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert sock.fileno() != -1",
                "assert sock.fileno() == -1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:\nWhen the `shutdown` method is invoked, it appends the string \"shutdown\" to a list called `calls`. This serves as a simple logging mechanism to track the sequence of operations performed by the reloader. In the context of the provided tests, this method is called during the shutdown phase of the reloader's lifecycle, ensuring that the shutdown event is recorded and can be asserted in tests to verify the correct behavior of the reloader."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects from changing directories."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reloader_should_initialize",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 77,
            "end_line_number": 87,
            "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
            "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list called `calls`. This list is used to track the sequence of operations performed by the reloader. The method is typically called when the application needs to gracefully terminate, allowing for any necessary cleanup or resource deallocation to occur. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and can be verified through assertions."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_python_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 90,
            "end_line_number": 100,
            "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert changes == [file]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown process is executed as expected during the reloader's lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader, specifically checking if changes to specified files trigger a reload. It interacts with the reloader to restart it and simulates file changes to verify that the reloader detects these changes correctly.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the `reloader` is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function with the provided files, simulating a quick modification.\n3. If the reloader is not of that type, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected by the reloader after the simulated modifications. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_python_file_in_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 103,
            "end_line_number": 112,
            "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes need to be detected and applied without restarting the entire application.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, restoring the original working directory with `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes need to be detected and applied without restarting the entire application.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 115,
            "end_line_number": 129,
            "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, sub_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string \"shutdown\" to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple marker to indicate that the shutdown has occurred. In the context of the tests, it helps verify that the shutdown process is executed as expected during the reloader's lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_reload_when_pattern_matched_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
            ],
            "arguments": [
                "self",
                "result",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes need to be detected and applied without restarting the entire application.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 150,
            "end_line_number": 168,
            "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, python_file)",
                "assert self._reload_tester(touch_soon, reloader, css_file)",
                "assert not self._reload_tester(touch_soon, reloader, js_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader detects these changes correctly.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate any detected changes in the files.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on the rest of the program."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for restarting an application when code changes are detected. This method records a shutdown event and is part of the lifecycle management of the reloader.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`. This list is used to track the sequence of lifecycle events (like startup, restart, and shutdown) that have occurred during the reloader's operation. The method does not perform any additional actions, such as closing sockets or terminating processes, but it serves as a simple logging mechanism to indicate that a shutdown has been initiated."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_dot_file_is_changed",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 171,
            "end_line_number": 180,
            "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert not self._reload_tester(touch_soon, reloader, file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_reload_when_directories_have_same_prefix",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 183,
            "end_line_number": 200,
            "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown process is executed as expected during the reloader's lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files were changed, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown process is executed as expected during the reloader's lifecycle."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_not_reload_when_only_subdirectory_is_watched",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 210,
            "end_line_number": 225,
            "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects from changing directories."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether the reloader detected any changes after the files were touched. If no changes are detected, it returns `None`."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list to track the shutdown event.\n\n**How It Works**:\nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to record the sequence of events that occur during the reloader's lifecycle, allowing developers to verify that the shutdown process was executed as expected. The method is typically called when the application is terminating, ensuring that any necessary cleanup or state tracking can be performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_override_defaults",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 234,
            "end_line_number": 253,
            "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
                "assert not self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the environment remains consistent after the context manager is used."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files triggered a reload, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a modification.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_explicit_paths",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 262,
            "end_line_number": 279,
            "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
                "assert self._reload_tester(touch_soon, reloader, python_file)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:\nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a marker for when the shutdown process is triggered. In the context of the tests, it helps verify that the shutdown sequence is executed as expected."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()` and stores it in `prev_cwd`.\n2. It then changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on the rest of the program."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or stop.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be performed. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that resources are released appropriately."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_watchfiles_no_changes",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 283,
            "end_line_number": 308,
            "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
                "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
            ],
            "arguments": [
                "self"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(reloader, WatchFilesReload)",
                "assert reloader.should_restart() is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.should_restart",
                    "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `should_restart` method determines whether the application should restart based on the number of times it has been called. It is part of a reloader mechanism that monitors changes and decides when to reload the application.\n\n**How It Works**:  \nThe method uses a nonlocal variable `step` to track its invocation count. On the first call (`step == 1`), it returns `None`, indicating no restart is needed. On the second call (`step == 2`), it returns a list containing the path to a file (`foobar.py`), suggesting that this file change should trigger a restart. On any subsequent calls, it raises a `StopIteration` exception, signaling that no further checks are necessary. This method is typically used in a reloader context to manage application lifecycle events based on file changes."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "as_cwd",
                    "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `as_cwd` method is a context manager that temporarily changes the current working directory to a specified path and ensures that the original working directory is restored when the context is exited.\n\n**How It Works**:  \n1. It first captures the current working directory using `Path.cwd()`.\n2. It changes the working directory to the specified `path` using `os.chdir(path)`.\n3. The `yield` statement allows the code block within the `with` statement to execute while the working directory is set to the new path.\n4. Upon exiting the context (either normally or due to an exception), the `finally` block is executed, which restores the original working directory by calling `os.chdir(prev_cwd)`. This ensures that the working environment remains consistent and avoids side effects on the rest of the program."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._setup_reloader",
                    "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no changes were detected, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self._reload_tester",
                    "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_should_detect_new_reload_dirs",
            "module": "test_reload",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
            "line_number": 311,
            "end_line_number": 332,
            "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
            ],
            "arguments": [
                "self",
                "touch_soon",
                "caplog",
                "tmp_path"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "platform",
                "signal",
                "socket",
                "sys",
                "pathlib.Path",
                "time.sleep",
                "pytest",
                "tests.utils.as_cwd",
                "uvicorn.config.Config",
                "uvicorn.supervisors.basereload.BaseReload",
                "uvicorn.supervisors.basereload._display_path",
                "uvicorn.supervisors.statreload.StatReload",
                "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
                "uvicorn.supervisors.watchgodreload.WatchGodReload",
                "watchfiles.watch"
            ],
            "fixtures": [],
            "assertions": [
                "assert self._reload_tester(touch_soon, reloader, app_file)",
                "assert self._reload_tester(touch_soon, reloader, app_first_file)",
                "assert caplog.records[-2].levelno == logging.INFO",
                "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "reloader.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or shut down.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for cleanup operations such as closing sockets and stopping background tasks. In the context of the provided tests, it ensures that the shutdown process is correctly recorded and that any necessary cleanup actions are performed."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_fragmentation",
            "module": "test_http",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
            "line_number": 902,
            "end_line_number": 944,
            "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
            "docstring": null,
            "decorators": [
                "skip_if_no_httptools"
            ],
            "arguments": [
                "unused_tcp_port"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "socket",
                "threading",
                "time",
                "typing.TYPE_CHECKING",
                "typing.Any",
                "pytest",
                "tests.response.Response",
                "uvicorn.Server",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.WS_PROTOCOLS",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn",
                "uvicorn.main.ServerState",
                "uvicorn.protocols.http.h11_impl.H11Protocol",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "sys",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
                "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
                "typing.TypeAlias",
                "typing_extensions.TypeAlias"
            ],
            "fixtures": [],
            "assertions": [
                "assert bad_response != response[:len(bad_response)]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "t.start",
                    "body": "def start(*paths: Path):\n    thread = Thread(target=sleep_touch, args=paths)\n    thread.start()\n    threads.append(thread)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `start` method is designed to initiate a new thread that executes the `sleep_touch` function, which touches (updates the timestamp of) the specified file paths after a brief sleep period.\n\n**How It Works**:  \nThe method accepts a variable number of `Path` arguments. It creates a new `Thread` object targeting the `sleep_touch` function, passing the provided paths as arguments. The thread is then started, allowing it to run concurrently with the main program. Each thread is stored in a list called `threads` for later management, such as joining (waiting for the thread to finish) after the main execution. This approach enables asynchronous file operations without blocking the main thread."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_fragmentation",
            "module": "test_http",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
            "line_number": 902,
            "end_line_number": 944,
            "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
            "docstring": null,
            "decorators": [
                "skip_if_no_httptools"
            ],
            "arguments": [
                "unused_tcp_port"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "socket",
                "threading",
                "time",
                "typing.TYPE_CHECKING",
                "typing.Any",
                "pytest",
                "tests.response.Response",
                "uvicorn.Server",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.WS_PROTOCOLS",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn",
                "uvicorn.main.ServerState",
                "uvicorn.protocols.http.h11_impl.H11Protocol",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "sys",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
                "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
                "typing.TypeAlias",
                "typing_extensions.TypeAlias"
            ],
            "fixtures": [],
            "assertions": [
                "assert bad_response != response[:len(bad_response)]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "send_fragmented_req",
                    "body": "def send_fragmented_req(path: str):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('127.0.0.1', unused_tcp_port))\n    d = f'GET {path} HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n'.encode()\n    split = len(path) // 2\n    sock.sendall(d[:split])\n    time.sleep(0.01)\n    sock.sendall(d[split:])\n    resp = receive_all(sock)\n    try:\n        sock.shutdown(socket.SHUT_RDWR)\n    except Exception:\n        pass\n    sock.close()\n    return resp",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `send_fragmented_req` method is designed to send an HTTP GET request to a specified path in a fragmented manner over a TCP socket connection. It simulates network conditions where data is sent in parts, which can be useful for testing how a server handles fragmented requests.\n\n**How It Works**:\n1. A TCP socket is created and connected to a local server at `127.0.0.1` on a specified unused port.\n2. The HTTP GET request is constructed and encoded into bytes. The request is split into two halves based on the length of the path.\n3. The first half of the request is sent immediately, followed by a brief pause (0.01 seconds) before sending the second half. This simulates fragmentation.\n4. The method then waits for the server's response by calling `receive_all`, which collects all incoming data until the connection is closed.\n5. After receiving the response, the socket is shut down and closed, and the response data is returned. This method handles potential exceptions during shutdown gracefully."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_fragmentation",
            "module": "test_http",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
            "line_number": 902,
            "end_line_number": 944,
            "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
            "docstring": null,
            "decorators": [
                "skip_if_no_httptools"
            ],
            "arguments": [
                "unused_tcp_port"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "socket",
                "threading",
                "time",
                "typing.TYPE_CHECKING",
                "typing.Any",
                "pytest",
                "tests.response.Response",
                "uvicorn.Server",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.WS_PROTOCOLS",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn",
                "uvicorn.main.ServerState",
                "uvicorn.protocols.http.h11_impl.H11Protocol",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "sys",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
                "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
                "typing.TypeAlias",
                "typing_extensions.TypeAlias"
            ],
            "fixtures": [],
            "assertions": [
                "assert bad_response != response[:len(bad_response)]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "receive_all",
                    "body": "def receive_all(sock: socket.socket):\n    chunks: list[bytes] = []\n    while True:\n        chunk = sock.recv(1024)\n        if not chunk:\n            break\n        chunks.append(chunk)\n    return b''.join(chunks)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `receive_all` method is designed to read all incoming data from a socket until the connection is closed, aggregating the received data into a single bytes object. This is particularly useful for handling fragmented data transmissions in network communication.\n\n**How It Works**:\nThe method initializes an empty list called `chunks` to store the data received in segments. It enters an infinite loop where it repeatedly calls `sock.recv(1024)` to read up to 1024 bytes from the socket. If `recv` returns an empty bytes object (indicating that the connection has been closed), the loop breaks. Each non-empty chunk is appended to the `chunks` list. Finally, the method concatenates all the chunks into a single bytes object using `b''.join(chunks)` and returns it. This ensures that all parts of the message are collected and returned as one complete message."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_fragmentation",
            "module": "test_http",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
            "line_number": 902,
            "end_line_number": 944,
            "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
            "docstring": null,
            "decorators": [
                "skip_if_no_httptools"
            ],
            "arguments": [
                "unused_tcp_port"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "socket",
                "threading",
                "time",
                "typing.TYPE_CHECKING",
                "typing.Any",
                "pytest",
                "tests.response.Response",
                "uvicorn.Server",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.WS_PROTOCOLS",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn",
                "uvicorn.main.ServerState",
                "uvicorn.protocols.http.h11_impl.H11Protocol",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "sys",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
                "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
                "typing.TypeAlias",
                "typing_extensions.TypeAlias"
            ],
            "fixtures": [],
            "assertions": [
                "assert bad_response != response[:len(bad_response)]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.close",
                    "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
                }
            ]
        },
        {
            "repo_name": "uvicorn",
            "name": "test_fragmentation",
            "module": "test_http",
            "class_name": null,
            "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
            "line_number": 902,
            "end_line_number": 944,
            "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
            "docstring": null,
            "decorators": [
                "skip_if_no_httptools"
            ],
            "arguments": [
                "unused_tcp_port"
            ],
            "imports": [
                "__future__.annotations",
                "logging",
                "socket",
                "threading",
                "time",
                "typing.TYPE_CHECKING",
                "typing.Any",
                "pytest",
                "tests.response.Response",
                "uvicorn.Server",
                "uvicorn._types.ASGIApplication",
                "uvicorn._types.ASGIReceiveCallable",
                "uvicorn._types.ASGISendCallable",
                "uvicorn._types.Scope",
                "uvicorn.config.WS_PROTOCOLS",
                "uvicorn.config.Config",
                "uvicorn.lifespan.off.LifespanOff",
                "uvicorn.lifespan.on.LifespanOn",
                "uvicorn.main.ServerState",
                "uvicorn.protocols.http.h11_impl.H11Protocol",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "sys",
                "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
                "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
                "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
                "typing.TypeAlias",
                "typing_extensions.TypeAlias"
            ],
            "fixtures": [],
            "assertions": [
                "assert bad_response != response[:len(bad_response)]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "sock.shutdown",
                    "body": "def shutdown(self):\n    calls.append('shutdown')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to gracefully terminate a server process and close all associated sockets. It ensures that no new connections are accepted and that existing connections are properly shut down.\n\n**How It Works**:  \nWhen invoked, the method first logs a shutdown message. It then iterates over all server instances to close them, followed by closing any provided sockets. After that, it requests a shutdown on all active connections by calling their respective `shutdown` methods. Finally, it pauses for a brief moment (0.1 seconds) to allow for any cleanup processes to complete before fully exiting. This method is crucial for ensuring that resources are released properly and that the server can shut down without leaving hanging connections."
                }
            ]
        }
    ]
}