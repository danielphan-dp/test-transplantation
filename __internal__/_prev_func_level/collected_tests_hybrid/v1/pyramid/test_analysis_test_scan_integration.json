{
  "test_name": "test_scan_integration",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/tests/test_config/test_init.py",
  "static_methods": [
    {
      "name": "self._makeOne",
      "source_code": "    def _makeOne(self, name=None):\n        if name is None:\n            name = self.DEFAULT_NAME\n        return self._getTargetClass()(name)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/tests/test_interface.py",
      "line_number": 120
    },
    {
      "name": "config.scan",
      "source_code": "    def scan(self, pattern):\n        \"\"\"\n        Scan the text for the given pattern and update pos/match\n        and related fields. The return value is a boolean that\n        indicates if the pattern matched. The matched value is\n        stored on the instance as ``match``, the last value is\n        stored as ``last``. ``start_pos`` is the position of the\n        pointer before the pattern was matched, ``pos`` is the\n        end position.\n        \"\"\"\n        if self.eos:\n            raise EndOfText()\n        if pattern not in self._re_cache:\n            self._re_cache[pattern] = re.compile(pattern, self.flags)\n        self.last = self.match\n        m = self._re_cache[pattern].match(self.data, self.pos)\n        if m is None:\n            return False\n        self.start_pos = m.start()\n        self.pos = m.end()\n        self.match = m.group()\n        return True",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/pip/_vendor/pygments/scanner.py",
      "line_number": 72
    },
    {
      "name": "DummyContext",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "DummyRequest",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "alsoProvides",
      "source_code": "    def alsoProvides(object, *interfaces):  # pylint:disable=redefined-builtin\n        \"\"\"\n        Declare additional interfaces directly for an object.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/interfaces.py",
      "line_number": 730
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertRaises",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "render_view_to_response",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line_number": 28
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "self._makeOne",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/tests/test_interface.py",
      "line": 120,
      "caller": "test_scan_integration",
      "source_code": "    def _makeOne(self, name=None):\n        if name is None:\n            name = self.DEFAULT_NAME\n        return self._getTargetClass()(name)\n\n"
    },
    {
      "function": "config.scan",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/pip/_vendor/pygments/scanner.py",
      "line": 72,
      "caller": "test_scan_integration",
      "source_code": "    def scan(self, pattern):\n        \"\"\"\n        Scan the text for the given pattern and update pos/match\n        and related fields. The return value is a boolean that\n        indicates if the pattern matched. The matched value is\n        stored on the instance as ``match``, the last value is\n        stored as ``last``. ``start_pos`` is the position of the\n        pointer before the pattern was matched, ``pos`` is the\n        end position.\n        \"\"\"\n        if self.eos:\n            raise EndOfText()\n        if pattern not in self._re_cache:\n            self._re_cache[pattern] = re.compile(pattern, self.flags)\n        self.last = self.match\n        m = self._re_cache[pattern].match(self.data, self.pos)\n        if m is None:\n            return False\n        self.start_pos = m.start()\n        self.pos = m.end()\n        self.match = m.group()\n        return True\n\n"
    },
    {
      "function": "DummyContext",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "DummyRequest",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "alsoProvides",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/interfaces.py",
      "line": 730,
      "caller": "test_scan_integration",
      "source_code": "    def alsoProvides(object, *interfaces):  # pylint:disable=redefined-builtin\n        \"\"\"\n        Declare additional interfaces directly for an object.\n\n        For example::\n\n          alsoProvides(ob, I1)\n\n        is equivalent to::\n\n          directlyProvides(ob, directlyProvidedBy(ob), I1)\n\n        .. seealso:: `zope.interface.alsoProvides`\n        \"\"\"\n\n"
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "self.assertRaises",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    },
    {
      "function": "render_view_to_response",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/src/pyramid/view.py",
      "line": 28,
      "caller": "test_scan_integration",
      "source_code": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    # We explicitly pass in the interfaces provided by the request as\n    # request_iface to _call_view; we don't want _call_view to use\n    # request.request_iface, because render_view_to_response and friends are\n    # pretty much limited to finding views that are not views associated with\n    # routes, and the only thing request.request_iface is used for is to find\n    # route-based views.  The render_view_to_response API is (and always has\n    # been) a stepchild API reserved for use of those who actually use\n    # traversal.  Doing this fixes an infinite recursion bug introduced in\n    # Pyramid 1.6a1, and causes the render_view* APIs to behave as they did in\n    # 1.5 and previous. We should probably provide some sort of different API\n    # that would allow people to find views for routes.  See\n    # https://github.com/Pylons/pyramid/issues/1643 for more info.\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None\n\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_scan_integration",
      "source_code": ""
    }
  ],
  "assertions": [],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_scan_integration(self):\n        from zope.interface import alsoProvides\n\n        from pyramid.view import render_view_to_response\n        from tests.test_config.pkgs import scannable as package\n\n        config = self._makeOne(autocommit=True)\n        config.scan(package)\n\n        ctx = DummyContext()\n        req = DummyRequest()\n        alsoProvides(req, IRequest)\n        req.registry = config.registry\n\n        req.method = 'GET'\n        result = render_view_to_response(ctx, req, '')\n        self.assertEqual(result, 'grokked')\n\n        req.method = 'POST'\n        result = render_view_to_response(ctx, req, '')\n        self.assertEqual(result, 'grokked_post')\n\n        result = render_view_to_response(ctx, req, 'grokked_class')\n        self.assertEqual(result, 'grokked_class')\n\n        result = render_view_to_response(ctx, req, 'grokked_instance')\n        self.assertEqual(result, 'grokked_instance')\n\n        result = render_view_to_response(ctx, req, 'oldstyle_grokked_class')\n        self.assertEqual(result, 'oldstyle_grokked_class')\n\n        req.method = 'GET'\n        result = render_view_to_response(ctx, req, 'another')\n        self.assertEqual(result, 'another_grokked')\n\n        req.method = 'POST'\n        result = render_view_to_response(ctx, req, 'another')\n        self.assertEqual(result, 'another_grokked_post')\n\n        result = render_view_to_response(ctx, req, 'another_grokked_class')\n        self.assertEqual(result, 'another_grokked_class')\n\n        result = render_view_to_response(ctx, req, 'another_grokked_instance')\n        self.assertEqual(result, 'another_grokked_instance')\n\n        result = render_view_to_response(\n            ctx, req, 'another_oldstyle_grokked_class'\n        )\n        self.assertEqual(result, 'another_oldstyle_grokked_class')\n\n        result = render_view_to_response(ctx, req, 'stacked1')\n        self.assertEqual(result, 'stacked')\n\n        result = render_view_to_response(ctx, req, 'stacked2')\n        self.assertEqual(result, 'stacked')\n\n        result = render_view_to_response(ctx, req, 'another_stacked1')\n        self.assertEqual(result, 'another_stacked')\n\n        result = render_view_to_response(ctx, req, 'another_stacked2')\n        self.assertEqual(result, 'another_stacked')\n\n        result = render_view_to_response(ctx, req, 'stacked_class1')\n        self.assertEqual(result, 'stacked_class')\n\n        result = render_view_to_response(ctx, req, 'stacked_class2')\n        self.assertEqual(result, 'stacked_class')\n\n        result = render_view_to_response(ctx, req, 'another_stacked_class1')\n        self.assertEqual(result, 'another_stacked_class')\n\n        result = render_view_to_response(ctx, req, 'another_stacked_class2')\n        self.assertEqual(result, 'another_stacked_class')\n\n        # NB: on Jython, a class without an __init__ apparently accepts\n        # any number of arguments without raising a TypeError, so the next\n        # assertion may fail there.  We don't support Jython at the moment,\n        # this is just a note to a future self.\n\n        self.assertRaises(\n            TypeError, render_view_to_response, ctx, req, 'basemethod'\n        )\n\n        result = render_view_to_response(ctx, req, 'method1')\n        self.assertEqual(result, 'method1')\n\n        result = render_view_to_response(ctx, req, 'method2')\n        self.assertEqual(result, 'method2')\n\n        result = render_view_to_response(ctx, req, 'stacked_method1')\n        self.assertEqual(result, 'stacked_method')\n\n        result = render_view_to_response(ctx, req, 'stacked_method2')\n        self.assertEqual(result, 'stacked_method')\n\n        result = render_view_to_response(ctx, req, 'subpackage_init')\n        self.assertEqual(result, 'subpackage_init')\n\n        result = render_view_to_response(ctx, req, 'subpackage_notinit')\n        self.assertEqual(result, 'subpackage_notinit')\n\n        result = render_view_to_response(ctx, req, 'subsubpackage_init')\n        self.assertEqual(result, 'subsubpackage_init')\n\n        result = render_view_to_response(ctx, req, 'pod_notinit')\n        self.assertEqual(result, None)"
}