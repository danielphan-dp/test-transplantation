{
  "test_name": "test_contextual_exception_context",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/tests/test_exceptions.py",
  "static_methods": [
    {
      "name": "Sanic",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.test_client.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.test_client.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "BeautifulSoup",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "dl_to_dict",
      "source_code": "def dl_to_dict(soup, dl_id):\n    keys, values = [], []\n    for dl in soup.find_all(\"dl\", {\"id\": dl_id}):\n        for dt in dl.find_all(\"dt\"):\n            keys.append(dt.text.split(\":\", 1)[0])\n        for dd in dl.find_all(\"dd\"):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/tests/test_exceptions.py",
      "line_number": 28
    },
    {
      "name": "app.test_client.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "list",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "TeapotError",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "app.post",
      "source_code": "    def post(self) -> None:\n        return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line_number": 144
    },
    {
      "name": "map",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "lines.index",
      "source_code": "    def index(self, sub):\n        return self.lower().index(sub.lower())",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_vendor/importlib_metadata/_text.py",
      "line_number": 94
    },
    {
      "name": "fail",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line_number": 429
    },
    {
      "name": "fail",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line_number": 429
    },
    {
      "name": "fail",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line_number": 429
    },
    {
      "name": "soup.find",
      "source_code": "    def find(self, requirement, meta_extras=None, prereleases=False):\n        \"\"\"\n        Find a distribution and all distributions it depends on.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/distlib/locators.py",
      "line_number": 1192
    },
    {
      "name": "response.body.split",
      "source_code": "    def split(\n        self,\n        *layouts: Union[\"Layout\", RenderableType],\n        splitter: Union[Splitter, str] = \"column\",\n    ) -> None:\n        \"\"\"Split the layout in to multiple sub-layouts.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/rich/layout.py",
      "line_number": 262
    },
    {
      "name": "x.decode",
      "source_code": "    def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode ANSI codes in an iterable of lines.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/rich/ansi.py",
      "line_number": 122
    }
  ],
  "dynamic_methods": [
    {
      "function": "Sanic",
      "filename": "",
      "line": 0,
      "caller": "test_contextual_exception_context",
      "source_code": ""
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.test_client.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.test_client.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "BeautifulSoup",
      "filename": "",
      "line": 0,
      "caller": "test_contextual_exception_context",
      "source_code": ""
    },
    {
      "function": "dl_to_dict",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/tests/test_exceptions.py",
      "line": 28,
      "caller": "test_contextual_exception_context",
      "source_code": "def dl_to_dict(soup, dl_id):\n    keys, values = [], []\n    for dl in soup.find_all(\"dl\", {\"id\": dl_id}):\n        for dt in dl.find_all(\"dt\"):\n            keys.append(dt.text.split(\":\", 1)[0])\n        for dd in dl.find_all(\"dd\"):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))\n\n\n"
    },
    {
      "function": "app.test_client.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "list",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_contextual_exception_context",
      "source_code": ""
    },
    {
      "function": "TeapotError",
      "filename": "",
      "line": 0,
      "caller": "test_contextual_exception_context",
      "source_code": ""
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "app.post",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/packaging/version.py",
      "line": 144,
      "caller": "test_contextual_exception_context",
      "source_code": "    @property\n    def post(self) -> None:\n        return None\n\n"
    },
    {
      "function": "map",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_contextual_exception_context",
      "source_code": ""
    },
    {
      "function": "lines.index",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_vendor/importlib_metadata/_text.py",
      "line": 94,
      "caller": "test_contextual_exception_context",
      "source_code": "    def index(self, sub):\n        return self.lower().index(sub.lower())\n\n"
    },
    {
      "function": "fail",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line": 429,
      "caller": "test_contextual_exception_context",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.\n\n        .. _Fail the WebSocket connection:\n            https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.7\n\n        Parameters:\n            code: close code\n            reason: close reason\n\n        Raises:\n            ProtocolError: If the code isn't valid.\n        \"\"\"\n        # 7.1.7. Fail the WebSocket Connection\n\n        # Send a close frame when the state is OPEN (a close frame was already\n        # sent if it's CLOSING), except when failing the connection because\n        # of an error reading from or writing to the network.\n        if self.state is OPEN:\n            if code != CloseCode.ABNORMAL_CLOSURE:\n                close = Close(code, reason)\n                data = close.serialize()\n                self.send_frame(Frame(OP_CLOSE, data))\n                self.close_sent = close\n                # If recv_messages() raised an exception upon receiving a close\n                # frame but before echoing it, then close_rcvd is not None even\n                # though the state is OPEN. This happens when the connection is\n                # closed while receiving a fragmented message.\n                if self.close_rcvd is not None:\n                    self.close_rcvd_then_sent = True\n                self.state = CLOSING\n\n        # When failing the connection, a server closes the TCP connection\n        # without waiting for the client to complete the handshake, while a\n        # client waits for the server to close the TCP connection, possibly\n        # after sending a close frame that the client will ignore.\n        if self.side is SERVER and not self.eof_sent:\n            self.send_eof()\n\n        # 7.1.7. Fail the WebSocket Connection \"An endpoint MUST NOT continue\n        # to attempt to process data(including a responding Close frame) from\n        # the remote endpoint after being instructed to _Fail the WebSocket\n        # Connection_.\"\n        self.parser = self.discard()\n        next(self.parser)  # start coroutine\n\n"
    },
    {
      "function": "fail",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line": 429,
      "caller": "test_contextual_exception_context",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.\n\n        .. _Fail the WebSocket connection:\n            https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.7\n\n        Parameters:\n            code: close code\n            reason: close reason\n\n        Raises:\n            ProtocolError: If the code isn't valid.\n        \"\"\"\n        # 7.1.7. Fail the WebSocket Connection\n\n        # Send a close frame when the state is OPEN (a close frame was already\n        # sent if it's CLOSING), except when failing the connection because\n        # of an error reading from or writing to the network.\n        if self.state is OPEN:\n            if code != CloseCode.ABNORMAL_CLOSURE:\n                close = Close(code, reason)\n                data = close.serialize()\n                self.send_frame(Frame(OP_CLOSE, data))\n                self.close_sent = close\n                # If recv_messages() raised an exception upon receiving a close\n                # frame but before echoing it, then close_rcvd is not None even\n                # though the state is OPEN. This happens when the connection is\n                # closed while receiving a fragmented message.\n                if self.close_rcvd is not None:\n                    self.close_rcvd_then_sent = True\n                self.state = CLOSING\n\n        # When failing the connection, a server closes the TCP connection\n        # without waiting for the client to complete the handshake, while a\n        # client waits for the server to close the TCP connection, possibly\n        # after sending a close frame that the client will ignore.\n        if self.side is SERVER and not self.eof_sent:\n            self.send_eof()\n\n        # 7.1.7. Fail the WebSocket Connection \"An endpoint MUST NOT continue\n        # to attempt to process data(including a responding Close frame) from\n        # the remote endpoint after being instructed to _Fail the WebSocket\n        # Connection_.\"\n        self.parser = self.discard()\n        next(self.parser)  # start coroutine\n\n"
    },
    {
      "function": "fail",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/websockets/protocol.py",
      "line": 429,
      "caller": "test_contextual_exception_context",
      "source_code": "    def fail(self, code: int, reason: str = \"\") -> None:\n        \"\"\"\n        `Fail the WebSocket connection`_.\n\n        .. _Fail the WebSocket connection:\n            https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.7\n\n        Parameters:\n            code: close code\n            reason: close reason\n\n        Raises:\n            ProtocolError: If the code isn't valid.\n        \"\"\"\n        # 7.1.7. Fail the WebSocket Connection\n\n        # Send a close frame when the state is OPEN (a close frame was already\n        # sent if it's CLOSING), except when failing the connection because\n        # of an error reading from or writing to the network.\n        if self.state is OPEN:\n            if code != CloseCode.ABNORMAL_CLOSURE:\n                close = Close(code, reason)\n                data = close.serialize()\n                self.send_frame(Frame(OP_CLOSE, data))\n                self.close_sent = close\n                # If recv_messages() raised an exception upon receiving a close\n                # frame but before echoing it, then close_rcvd is not None even\n                # though the state is OPEN. This happens when the connection is\n                # closed while receiving a fragmented message.\n                if self.close_rcvd is not None:\n                    self.close_rcvd_then_sent = True\n                self.state = CLOSING\n\n        # When failing the connection, a server closes the TCP connection\n        # without waiting for the client to complete the handshake, while a\n        # client waits for the server to close the TCP connection, possibly\n        # after sending a close frame that the client will ignore.\n        if self.side is SERVER and not self.eof_sent:\n            self.send_eof()\n\n        # 7.1.7. Fail the WebSocket Connection \"An endpoint MUST NOT continue\n        # to attempt to process data(including a responding Close frame) from\n        # the remote endpoint after being instructed to _Fail the WebSocket\n        # Connection_.\"\n        self.parser = self.discard()\n        next(self.parser)  # start coroutine\n\n"
    },
    {
      "function": "soup.find",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/distlib/locators.py",
      "line": 1192,
      "caller": "test_contextual_exception_context",
      "source_code": "    def find(self, requirement, meta_extras=None, prereleases=False):\n        \"\"\"\n        Find a distribution and all distributions it depends on.\n\n        :param requirement: The requirement specifying the distribution to\n                            find, or a Distribution instance.\n        :param meta_extras: A list of meta extras such as :test:, :build: and\n                            so on.\n        :param prereleases: If ``True``, allow pre-release versions to be\n                            returned - otherwise, don't return prereleases\n                            unless they're all that's available.\n\n        Return a set of :class:`Distribution` instances and a set of\n        problems.\n\n        The distributions returned should be such that they have the\n        :attr:`required` attribute set to ``True`` if they were\n        from the ``requirement`` passed to ``find()``, and they have the\n        :attr:`build_time_dependency` attribute set to ``True`` unless they\n        are post-installation dependencies of the ``requirement``.\n\n        The problems should be a tuple consisting of the string\n        ``'unsatisfied'`` and the requirement which couldn't be satisfied\n        by any distribution known to the locator.\n        \"\"\"\n\n        self.provided = {}\n        self.dists = {}\n        self.dists_by_name = {}\n        self.reqts = {}\n\n        meta_extras = set(meta_extras or [])\n        if ':*:' in meta_extras:\n            meta_extras.remove(':*:')\n            # :meta: and :run: are implicitly included\n            meta_extras |= set([':test:', ':build:', ':dev:'])\n\n        if isinstance(requirement, Distribution):\n            dist = odist = requirement\n            logger.debug('passed %s as requirement', odist)\n        else:\n            dist = odist = self.locator.locate(requirement,\n                                               prereleases=prereleases)\n            if dist is None:\n                raise DistlibException('Unable to locate %r' % requirement)\n            logger.debug('located %s', odist)\n        dist.requested = True\n        problems = set()\n        todo = set([dist])\n        install_dists = set([odist])\n        while todo:\n            dist = todo.pop()\n            name = dist.key     # case-insensitive\n            if name not in self.dists_by_name:\n                self.add_distribution(dist)\n            else:\n                #import pdb; pdb.set_trace()\n                other = self.dists_by_name[name]\n                if other != dist:\n                    self.try_to_replace(dist, other, problems)\n\n            ireqts = dist.run_requires | dist.meta_requires\n            sreqts = dist.build_requires\n            ereqts = set()\n            if meta_extras and dist in install_dists:\n                for key in ('test', 'build', 'dev'):\n                    e = ':%s:' % key\n                    if e in meta_extras:\n                        ereqts |= getattr(dist, '%s_requires' % key)\n            all_reqts = ireqts | sreqts | ereqts\n            for r in all_reqts:\n                providers = self.find_providers(r)\n                if not providers:\n                    logger.debug('No providers found for %r', r)\n                    provider = self.locator.locate(r, prereleases=prereleases)\n                    # If no provider is found and we didn't consider\n                    # prereleases, consider them now.\n                    if provider is None and not prereleases:\n                        provider = self.locator.locate(r, prereleases=True)\n                    if provider is None:\n                        logger.debug('Cannot satisfy %r', r)\n                        problems.add(('unsatisfied', r))\n                    else:\n                        n, v = provider.key, provider.version\n                        if (n, v) not in self.dists:\n                            todo.add(provider)\n                        providers.add(provider)\n                        if r in ireqts and dist in install_dists:\n                            install_dists.add(provider)\n                            logger.debug('Adding %s to install_dists',\n                                         provider.name_and_version)\n                for p in providers:\n                    name = p.key\n                    if name not in self.dists_by_name:\n                        self.reqts.setdefault(p, set()).add(r)\n                    else:\n                        other = self.dists_by_name[name]\n                        if other != p:\n                            # see if other can be replaced by p\n                            self.try_to_replace(p, other, problems)\n\n        dists = set(self.dists.values())\n        for dist in dists:\n            dist.build_time_dependency = dist not in install_dists\n            if dist.build_time_dependency:\n                logger.debug('%s is a build-time dependency only.',\n                             dist.name_and_version)\n        logger.debug('find done for %s', odist)\n        return dists, problems\n"
    },
    {
      "function": "response.body.split",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/rich/layout.py",
      "line": 262,
      "caller": "test_contextual_exception_context",
      "source_code": "    def split(\n        self,\n        *layouts: Union[\"Layout\", RenderableType],\n        splitter: Union[Splitter, str] = \"column\",\n"
    },
    {
      "function": "x.decode",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/rich/ansi.py",
      "line": 122,
      "caller": "test_contextual_exception_context",
      "source_code": "    def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode ANSI codes in an iterable of lines.\n\n        Args:\n            lines (Iterable[str]): An iterable of lines of terminal output.\n\n        Yields:\n            Text: Marked up Text.\n        \"\"\"\n        for line in terminal_text.splitlines():\n            yield self.decode_line(line)\n\n"
    }
  ],
  "assertions": [
    "assert response.status == 418",
    "assert response.json['message'] == 'Sorry, I cannot brew coffee'",
    "assert response.json['context'] == {'foo': 'bar'}",
    "assert response.status == 418",
    "assert 'Sorry, I cannot brew coffee' in soup.find('p').text",
    "assert dl == {'foo': 'bar'}",
    "assert response.status == 418",
    "assert lines[2] == 'Sorry, I cannot brew coffee'",
    "assert lines[idx] == '    foo: \"bar\"'"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_contextual_exception_context(debug):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n        message = \"Sorry, I cannot brew coffee\"\n\n    def fail():\n        raise TeapotError(context={\"foo\": \"bar\"})\n\n    app.post(\"/coffee/json\", error_format=\"json\", name=\"json\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/html\", error_format=\"html\", name=\"html\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/text\", error_format=\"text\", name=\"text\")(\n        lambda _: fail()\n    )\n\n    _, response = app.test_client.post(\"/coffee/json\", debug=debug)\n    assert response.status == 418\n    assert response.json[\"message\"] == \"Sorry, I cannot brew coffee\"\n    assert response.json[\"context\"] == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/html\", debug=debug)\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    dl = dl_to_dict(soup, \"exception-context\")\n    assert response.status == 418\n    assert \"Sorry, I cannot brew coffee\" in soup.find(\"p\").text\n    assert dl == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/text\", debug=debug)\n    lines = list(map(lambda x: x.decode(), response.body.split(b\"\\n\")))\n    idx = lines.index(\"Context\") + 1\n    assert response.status == 418\n    assert lines[2] == \"Sorry, I cannot brew coffee\"\n    assert lines[idx] == '    foo: \"bar\"'"
}