{
  "test_name": "test_executable_data",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_build_py.py",
  "static_methods": [
    {
      "name": "Distribution",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "open.close",
      "source_code": "    def close(self):\n        pass",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/cachecontrol/cache.py",
      "line_number": 23
    },
    {
      "name": "open.close",
      "source_code": "    def close(self):\n        pass",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/cachecontrol/cache.py",
      "line_number": 23
    },
    {
      "name": "dist.parse_command_line",
      "source_code": "    def parse_command_line(self):\n        \"\"\"Parse the setup script's command line, taken from the\n        'script_args' instance attribute (which defaults to 'sys.argv[1:]'\n        -- see 'setup()' in core.py).  This list is first processed for\n        \"global options\" -- options that set attributes of the Distribution\n        instance.  Then, it is alternately scanned for Distutils commands\n        and options for that command.  Each new command terminates the\n        options for the previous command.  The allowed options for a\n        command are determined by the 'user_options' attribute of the\n        command class -- thus, we have to be able to load command classes\n        in order to parse the command line.  Any error in that 'options'\n        attribute raises DistutilsGetoptError; any error on the\n        command-line raises DistutilsArgError.  If no Distutils commands\n        were found on the command line, raises DistutilsArgError.  Return\n        true if command-line was successfully parsed and we should carry\n        on with executing commands; false if no errors but we shouldn't\n        execute commands (currently, this only happens if user asks for\n        help).\n        \"\"\"\n        #\n        # We now have enough information to show the Macintosh dialog\n        # that allows the user to interactively specify the \"command line\".\n        #\n        toplevel_options = self._get_toplevel_options()",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line_number": 428
    },
    {
      "name": "dist.run_commands",
      "source_code": "    def run_commands(self):\n        \"\"\"Run each command that was seen on the setup script command line.\n        Uses the list of commands found and cache of command objects\n        created by 'get_command_obj()'.\n        \"\"\"\n        for cmd in self.commands:\n            self.run_command(cmd)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line_number": 948
    },
    {
      "name": "dict",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "open",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "open",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "Distribution",
      "filename": "",
      "line": 0,
      "caller": "test_executable_data",
      "source_code": ""
    },
    {
      "function": "open.close",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/cachecontrol/cache.py",
      "line": 23,
      "caller": "test_executable_data",
      "source_code": "    def close(self):\n        pass\n\n\n"
    },
    {
      "function": "open.close",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/cachecontrol/cache.py",
      "line": 23,
      "caller": "test_executable_data",
      "source_code": "    def close(self):\n        pass\n\n\n"
    },
    {
      "function": "dist.parse_command_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line": 428,
      "caller": "test_executable_data",
      "source_code": "    def parse_command_line(self):\n        \"\"\"Parse the setup script's command line, taken from the\n        'script_args' instance attribute (which defaults to 'sys.argv[1:]'\n        -- see 'setup()' in core.py).  This list is first processed for\n        \"global options\" -- options that set attributes of the Distribution\n        instance.  Then, it is alternately scanned for Distutils commands\n        and options for that command.  Each new command terminates the\n        options for the previous command.  The allowed options for a\n        command are determined by the 'user_options' attribute of the\n        command class -- thus, we have to be able to load command classes\n        in order to parse the command line.  Any error in that 'options'\n        attribute raises DistutilsGetoptError; any error on the\n        command-line raises DistutilsArgError.  If no Distutils commands\n        were found on the command line, raises DistutilsArgError.  Return\n        true if command-line was successfully parsed and we should carry\n        on with executing commands; false if no errors but we shouldn't\n        execute commands (currently, this only happens if user asks for\n        help).\n        \"\"\"\n        #\n        # We now have enough information to show the Macintosh dialog\n        # that allows the user to interactively specify the \"command line\".\n        #\n        toplevel_options = self._get_toplevel_options()\n\n        # We have to parse the command line a bit at a time -- global\n        # options, then the first command, then its options, and so on --\n        # because each command will be handled by a different class, and\n        # the options that are valid for a particular class aren't known\n        # until we have loaded the command class, which doesn't happen\n        # until we know what the command is.\n\n        self.commands = []\n        parser = FancyGetopt(toplevel_options + self.display_options)\n        parser.set_negative_aliases(self.negative_opt)\n        parser.set_aliases({'licence': 'license'})\n        args = parser.getopt(args=self.script_args, object=self)\n        option_order = parser.get_option_order()\n        logging.getLogger().setLevel(logging.WARN - 10 * self.verbose)\n\n        # for display options we return immediately\n        if self.handle_display_options(option_order):\n            return\n        while args:\n            args = self._parse_command_opts(parser, args)\n            if args is None:  # user asked for help (and got it)\n                return\n\n        # Handle the cases of --help as a \"global\" option, ie.\n        # \"setup.py --help\" and \"setup.py --help command ...\".  For the\n        # former, we show global options (--verbose, --dry-run, etc.)\n        # and display-only options (--name, --version, etc.); for the\n        # latter, we omit the display-only options and show help for\n        # each command listed on the command line.\n        if self.help:\n            self._show_help(\n                parser, display_options=len(self.commands) == 0, commands=self.commands\n            )\n            return\n\n        # Oops, no commands found -- an end-user error\n        if not self.commands:\n            raise DistutilsArgError(\"no commands supplied\")\n\n        # All is well: return true\n        return True\n\n"
    },
    {
      "function": "dist.run_commands",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line": 948,
      "caller": "test_executable_data",
      "source_code": "    def run_commands(self):\n        \"\"\"Run each command that was seen on the setup script command line.\n        Uses the list of commands found and cache of command objects\n        created by 'get_command_obj()'.\n        \"\"\"\n        for cmd in self.commands:\n            self.run_command(cmd)\n\n"
    },
    {
      "function": "dict",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_executable_data",
      "source_code": ""
    },
    {
      "function": "open",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_executable_data",
      "source_code": ""
    },
    {
      "function": "open",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_executable_data",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert os.stat('build/lib/pkg/run-me').st_mode & stat.S_IEXEC, 'Script is not executable'"
  ],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_executable_data(tmpdir_cwd):\n    \"\"\"\n    Ensure executable bit is preserved in copy for\n    package data, as users rely on it for scripts.\n\n    #2041\n    \"\"\"\n    dist = Distribution(\n        dict(\n            script_name='setup.py',\n            script_args=['build_py'],\n            packages=['pkg'],\n            package_data={'pkg': ['run-me']},\n        )\n    )\n    os.makedirs('pkg')\n    open('pkg/__init__.py', 'wb').close()\n    open('pkg/run-me', 'wb').close()\n    os.chmod('pkg/run-me', 0o700)\n\n    dist.parse_command_line()\n    dist.run_commands()\n\n    assert os.stat('build/lib/pkg/run-me').st_mode & stat.S_IEXEC, (\n        \"Script is not executable\"\n    )"
}