{
  "test_name": "test_errors",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
  "static_methods": [
    {
      "name": "Connection",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "c.receive_data",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 352
    },
    {
      "name": "print",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "Connection",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "conn",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 929
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "conn",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 929
    },
    {
      "name": "conn",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 929
    },
    {
      "name": "c.send_failed",
      "source_code": "    def send_failed(self) -> None:\n        \"\"\"Notify the state machine that we failed to send the data it gave\n        us.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 551
    },
    {
      "name": "c.send_failed",
      "source_code": "    def send_failed(self) -> None:\n        \"\"\"Notify the state machine that we failed to send the data it gave\n        us.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 551
    },
    {
      "name": "c.next_event",
      "source_code": "    def next_event(self) -> Union[Event, Type[NEED_DATA], Type[PAUSED]]:\n        \"\"\"Parse the next event out of our receive buffer, update our internal\n        state, and return it.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 426
    },
    {
      "name": "c.next_event",
      "source_code": "    def next_event(self) -> Union[Event, Type[NEED_DATA], Type[PAUSED]]:\n        \"\"\"Parse the next event out of our receive buffer, update our internal\n        state, and return it.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 426
    },
    {
      "name": "receive_and_get",
      "source_code": "def receive_and_get(conn: Connection, data: bytes) -> List[Event]:\n    conn.receive_data(data)\n    return get_all_events(conn)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line_number": 35
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "Connection",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "c.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 352,
      "caller": "test_errors",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.\n\n        This does not actually do any processing on the data, just stores\n        it. To trigger processing, you have to call :meth:`next_event`.\n\n        Args:\n            data (:term:`bytes-like object`):\n                The new data that was just received.\n\n                Special case: If *data* is an empty byte-string like ``b\"\"``,\n                then this indicates that the remote side has closed the\n                connection (end of file). Normally this is convenient, because\n                standard Python APIs like :meth:`file.read` or\n                :meth:`socket.recv` use ``b\"\"`` to indicate end-of-file, while\n                other failures to read are indicated using other mechanisms\n                like raising :exc:`TimeoutError`. When using such an API you\n                can just blindly pass through whatever you get from ``read``\n                to :meth:`receive_data`, and everything will work.\n\n                But, if you have an API where reading an empty string is a\n                valid non-EOF condition, then you need to be aware of this and\n                make sure to check for such strings and avoid passing them to\n                :meth:`receive_data`.\n\n        Returns:\n            Nothing, but after calling this you should call :meth:`next_event`\n            to parse the newly received data.\n\n        Raises:\n            RuntimeError:\n                Raised if you pass an empty *data*, indicating EOF, and then\n                pass a non-empty *data*, indicating more data that somehow\n                arrived after the EOF.\n\n                (Calling ``receive_data(b\"\")`` multiple times is fine,\n                and equivalent to calling it once.)\n\n        \"\"\"\n        if data:\n            if self._receive_buffer_closed:\n                raise RuntimeError(\"received close, then received more data?\")\n            self._receive_buffer += data\n        else:\n            self._receive_buffer_closed = True\n\n"
    },
    {
      "function": "print",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "Connection",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "conn",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 929,
      "caller": "test_errors",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_errors",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "conn",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 929,
      "caller": "test_errors",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c\n\n"
    },
    {
      "function": "conn",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 929,
      "caller": "test_errors",
      "source_code": "    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c\n\n"
    },
    {
      "function": "c.send_failed",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 551,
      "caller": "test_errors",
      "source_code": "    def send_failed(self) -> None:\n        \"\"\"Notify the state machine that we failed to send the data it gave\n        us.\n\n        This causes :attr:`Connection.our_state` to immediately become\n        :data:`ERROR` -- see :ref:`error-handling` for discussion.\n\n        \"\"\"\n        self._process_error(self.our_role)\n\n"
    },
    {
      "function": "c.send_failed",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 551,
      "caller": "test_errors",
      "source_code": "    def send_failed(self) -> None:\n        \"\"\"Notify the state machine that we failed to send the data it gave\n        us.\n\n        This causes :attr:`Connection.our_state` to immediately become\n        :data:`ERROR` -- see :ref:`error-handling` for discussion.\n\n        \"\"\"\n        self._process_error(self.our_role)\n\n"
    },
    {
      "function": "c.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 426,
      "caller": "test_errors",
      "source_code": "    def next_event(self) -> Union[Event, Type[NEED_DATA], Type[PAUSED]]:\n        \"\"\"Parse the next event out of our receive buffer, update our internal\n        state, and return it.\n\n        This is a mutating operation -- think of it like calling :func:`next`\n        on an iterator.\n\n        Returns:\n            : One of three things:\n\n            1) An event object -- see :ref:`events`.\n\n            2) The special constant :data:`NEED_DATA`, which indicates that\n               you need to read more data from your socket and pass it to\n               :meth:`receive_data` before this method will be able to return\n               any more events.\n\n            3) The special constant :data:`PAUSED`, which indicates that we\n               are not in a state where we can process incoming data (usually\n               because the peer has finished their part of the current\n               request/response cycle, and you have not yet called\n               :meth:`start_next_cycle`). See :ref:`flow-control` for details.\n\n        Raises:\n            RemoteProtocolError:\n                The peer has misbehaved. You should close the connection\n                (possibly after sending some kind of 4xx response).\n\n        Once this method returns :class:`ConnectionClosed` once, then all\n        subsequent calls will also return :class:`ConnectionClosed`.\n\n        If this method raises any exception besides :exc:`RemoteProtocolError`\n        then that's a bug -- if it happens please file a bug report!\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.their_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n\n        if self.their_state is ERROR:\n            raise RemoteProtocolError(\"Can't receive data when peer state is ERROR\")\n        try:\n            event = self._extract_next_receive_event()\n            if event not in [NEED_DATA, PAUSED]:\n                self._process_event(self.their_role, cast(Event, event))\n            if event is NEED_DATA:\n                if len(self._receive_buffer) > self._max_incomplete_event_size:\n                    # 431 is \"Request header fields too large\" which is pretty\n                    # much the only situation where we can get here\n                    raise RemoteProtocolError(\n                        \"Receive buffer too long\", error_status_hint=431\n                    )\n                if self._receive_buffer_closed:\n                    # We're still trying to complete some event, but that's\n                    # never going to happen because no more data is coming\n                    raise RemoteProtocolError(\"peer unexpectedly closed connection\")\n            return event\n        except BaseException as exc:\n            self._process_error(self.their_role)\n            if isinstance(exc, LocalProtocolError):\n                exc._reraise_as_remote_protocol_error()\n            else:\n                raise\n\n"
    },
    {
      "function": "c.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 426,
      "caller": "test_errors",
      "source_code": "    def next_event(self) -> Union[Event, Type[NEED_DATA], Type[PAUSED]]:\n        \"\"\"Parse the next event out of our receive buffer, update our internal\n        state, and return it.\n\n        This is a mutating operation -- think of it like calling :func:`next`\n        on an iterator.\n\n        Returns:\n            : One of three things:\n\n            1) An event object -- see :ref:`events`.\n\n            2) The special constant :data:`NEED_DATA`, which indicates that\n               you need to read more data from your socket and pass it to\n               :meth:`receive_data` before this method will be able to return\n               any more events.\n\n            3) The special constant :data:`PAUSED`, which indicates that we\n               are not in a state where we can process incoming data (usually\n               because the peer has finished their part of the current\n               request/response cycle, and you have not yet called\n               :meth:`start_next_cycle`). See :ref:`flow-control` for details.\n\n        Raises:\n            RemoteProtocolError:\n                The peer has misbehaved. You should close the connection\n                (possibly after sending some kind of 4xx response).\n\n        Once this method returns :class:`ConnectionClosed` once, then all\n        subsequent calls will also return :class:`ConnectionClosed`.\n\n        If this method raises any exception besides :exc:`RemoteProtocolError`\n        then that's a bug -- if it happens please file a bug report!\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.their_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n\n        if self.their_state is ERROR:\n            raise RemoteProtocolError(\"Can't receive data when peer state is ERROR\")\n        try:\n            event = self._extract_next_receive_event()\n            if event not in [NEED_DATA, PAUSED]:\n                self._process_event(self.their_role, cast(Event, event))\n            if event is NEED_DATA:\n                if len(self._receive_buffer) > self._max_incomplete_event_size:\n                    # 431 is \"Request header fields too large\" which is pretty\n                    # much the only situation where we can get here\n                    raise RemoteProtocolError(\n                        \"Receive buffer too long\", error_status_hint=431\n                    )\n                if self._receive_buffer_closed:\n                    # We're still trying to complete some event, but that's\n                    # never going to happen because no more data is coming\n                    raise RemoteProtocolError(\"peer unexpectedly closed connection\")\n            return event\n        except BaseException as exc:\n            self._process_error(self.their_role)\n            if isinstance(exc, LocalProtocolError):\n                exc._reraise_as_remote_protocol_error()\n            else:\n                raise\n\n"
    },
    {
      "function": "receive_and_get",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line": 35,
      "caller": "test_errors",
      "source_code": "def receive_and_get(conn: Connection, data: bytes) -> List[Event]:\n    conn.receive_data(data)\n    return get_all_events(conn)\n\n\n"
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_errors",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_errors",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_errors",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_errors",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert c.their_state is ERROR",
    "assert c.our_state is not ERROR",
    "assert c.our_state is not ERROR",
    "assert c.our_state is ERROR",
    "assert c.their_state is not ERROR",
    "assert c.our_state is ERROR",
    "assert c.their_state is not ERROR",
    "assert c.our_state is ERROR",
    "assert c.their_state is not ERROR",
    "assert c.send(Response(status_code=400, headers=[])) == b'HTTP/1.1 400 \\r\\nConnection: close\\r\\n\\r\\n'",
    "assert c.our_state is SEND_RESPONSE"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_errors() -> None:\n    # After a receive error, you can't receive\n    for role in [CLIENT, SERVER]:\n        c = Connection(our_role=role)\n        c.receive_data(b\"gibberish\\r\\n\\r\\n\")\n        with pytest.raises(RemoteProtocolError):\n            c.next_event()\n        # Now any attempt to receive continues to raise\n        assert c.their_state is ERROR\n        assert c.our_state is not ERROR\n        print(c._cstate.states)\n        with pytest.raises(RemoteProtocolError):\n            c.next_event()\n        # But we can still yell at the client for sending us gibberish\n        if role is SERVER:\n            assert (\n                c.send(Response(status_code=400, headers=[]))  # type: ignore[arg-type]\n                == b\"HTTP/1.1 400 \\r\\nConnection: close\\r\\n\\r\\n\"\n            )\n\n    # After an error sending, you can no longer send\n    # (This is especially important for things like content-length errors,\n    # where there's complex internal state being modified)\n    def conn(role: Type[Sentinel]) -> Connection:\n        c = Connection(our_role=role)\n        if role is SERVER:\n            # Put it into the state where it *could* send a response...\n            receive_and_get(c, b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n            assert c.our_state is SEND_RESPONSE\n        return c\n\n    for role in [CLIENT, SERVER]:\n        if role is CLIENT:\n            # This HTTP/1.0 request won't be detected as bad until after we go\n            # through the state machine and hit the writing code\n            good = Request(method=\"GET\", target=\"/\", headers=[(\"Host\", \"example.com\")])\n            bad = Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[(\"Host\", \"example.com\")],\n                http_version=\"1.0\",\n            )\n        elif role is SERVER:\n            good = Response(status_code=200, headers=[])  # type: ignore[arg-type,assignment]\n            bad = Response(status_code=200, headers=[], http_version=\"1.0\")  # type: ignore[arg-type,assignment]\n        # Make sure 'good' actually is good\n        c = conn(role)\n        c.send(good)\n        assert c.our_state is not ERROR\n        # Do that again, but this time sending 'bad' first\n        c = conn(role)\n        with pytest.raises(LocalProtocolError):\n            c.send(bad)\n        assert c.our_state is ERROR\n        assert c.their_state is not ERROR\n        # Now 'good' is not so good\n        with pytest.raises(LocalProtocolError):\n            c.send(good)\n\n        # And check send_failed() too\n        c = conn(role)\n        c.send_failed()\n        assert c.our_state is ERROR\n        assert c.their_state is not ERROR\n        # This is idempotent\n        c.send_failed()\n        assert c.our_state is ERROR\n        assert c.their_state is not ERROR"
}