{
  "pairs": [
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_create_item",
        "module": "test_openapi_separate_input_output_schemas",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
        "line_number": 52,
        "end_line_number": 62,
        "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "typing.List",
          "typing.Optional",
          "fastapi.FastAPI",
          "fastapi.testclient.TestClient",
          "pydantic.BaseModel",
          "utils.PYDANTIC_V2",
          "utils.needs_pydanticv2"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == response2.status_code == 200, response.text",
          "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_app_client",
            "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient` instance, which can be used in tests to make requests and assert responses."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_mixed_formdata",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 319,
          "end_line_number": 333,
          "source_code": "def test_mixed_formdata(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-mixed-formData\",\n        data={\"formData\": \"test\"},\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"data\": {\"formData\": \"test\"},\n        \"files\": {\n            \"filename.txt\": \"file contents\",\n        },\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.json() == {'data': {'formData': 'test'}, 'files': {'filename.txt': 'file contents'}}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data (in the form of keyword arguments) and receive a response.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kwargs`), updates them with a default key-value pair (`{'name': 'post'}`), and returns a tuple containing the updated keyword arguments and a status code of `201`, indicating successful creation. This method can be used in testing scenarios to verify the behavior of API endpoints, as demonstrated in the provided code snippets where it checks for correct handling of various request payloads and response statuses."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_create_item",
        "module": "test_openapi_separate_input_output_schemas",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
        "line_number": 52,
        "end_line_number": 62,
        "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "typing.List",
          "typing.Optional",
          "fastapi.FastAPI",
          "fastapi.testclient.TestClient",
          "pydantic.BaseModel",
          "utils.PYDANTIC_V2",
          "utils.needs_pydanticv2"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == response2.status_code == 200, response.text",
          "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_app_client",
            "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_mixed_formdata",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 319,
          "end_line_number": 333,
          "source_code": "def test_mixed_formdata(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-mixed-formData\",\n        data={\"formData\": \"test\"},\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"data\": {\"formData\": \"test\"},\n        \"files\": {\n            \"filename.txt\": \"file contents\",\n        },\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.json() == {'data': {'formData': 'test'}, 'files': {'filename.txt': 'file contents'}}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data (in the form of keyword arguments) and receive a response.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kwargs`), updates them with a default key-value pair (`{'name': 'post'}`), and returns a tuple containing the updated keyword arguments and a status code of `201`, indicating successful creation. This method can be used in testing scenarios to verify the behavior of API endpoints, as demonstrated in the provided code snippets where it checks for correct handling of various request payloads and response statuses."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_items",
        "module": "test_openapi_separate_input_output_schemas",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
        "line_number": 113,
        "end_line_number": 130,
        "source_code": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/items/\")\n    response2 = client_no.get(\"/items/\")\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": {\"subname\": \"subname\", \"sub_description\": None, \"tags\": []},\n            },\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n        ]\n    )",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "typing.List",
          "typing.Optional",
          "fastapi.FastAPI",
          "fastapi.testclient.TestClient",
          "pydantic.BaseModel",
          "utils.PYDANTIC_V2",
          "utils.needs_pydanticv2"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == response2.status_code == 200, response.text",
          "assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_app_client",
            "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and validate responses."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_mixed_formdata",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 319,
          "end_line_number": 333,
          "source_code": "def test_mixed_formdata(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-mixed-formData\",\n        data={\"formData\": \"test\"},\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"data\": {\"formData\": \"test\"},\n        \"files\": {\n            \"filename.txt\": \"file contents\",\n        },\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.json() == {'data': {'formData': 'test'}, 'files': {'filename.txt': 'file contents'}}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data (in the form of keyword arguments) and receive a response.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kwargs`), updates them with a default key-value pair (`{'name': 'post'}`), and returns a tuple containing the updated keyword arguments and a status code of `201`, indicating successful creation. This method can be used in testing scenarios to verify the behavior of API endpoints, as demonstrated in the provided code snippets where it checks for correct handling of various request payloads and response statuses."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_openapi_schema",
        "module": "test_openapi_separate_input_output_schemas",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
        "line_number": 134,
        "end_line_number": 348,
        "source_code": "def test_openapi_schema():\n    client = get_app_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"items\": {\n                                            \"$ref\": \"#/components/schemas/Item-Output\"\n                                        },\n                                        \"type\": \"array\",\n                                        \"title\": \"Response Read Items Items  Get\",\n                                    }\n                                }\n                            },\n                        }\n                    },\n                },\n                \"post\": {\n                    \"summary\": \"Create Item\",\n                    \"operationId\": \"create_item_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item-Input\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"402\": {\n                            \"description\": \"Payment Required\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                },\n            },\n            \"/items-list/\": {\n                \"post\": {\n                    \"summary\": \"Create Item List\",\n                    \"operationId\": \"create_item_list_items_list__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Item-Input\"\n                                    },\n                                    \"type\": \"array\",\n                                    \"title\": \"Item\",\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"Item-Input\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Input\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"title\": \"Item\",\n                },\n                \"Item-Output\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Output\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\", \"description\", \"sub\"],\n                    \"title\": \"Item\",\n                },\n                \"SubItem-Input\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\"],\n                    \"title\": \"SubItem\",\n                },\n                \"SubItem-Output\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\", \"sub_description\", \"tags\"],\n                    \"title\": \"SubItem\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
        "docstring": null,
        "decorators": [
          "needs_pydanticv2"
        ],
        "arguments": [],
        "imports": [
          "typing.List",
          "typing.Optional",
          "fastapi.FastAPI",
          "fastapi.testclient.TestClient",
          "pydantic.BaseModel",
          "utils.PYDANTIC_V2",
          "utils.needs_pydanticv2"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Output'}, 'type': 'array', 'title': 'Response Read Items Items  Get'}}}}}}, 'post': {'summary': 'Create Item', 'operationId': 'create_item_items__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Input'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '402': {'description': 'Payment Required', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/items-list/': {'post': {'summary': 'Create Item List', 'operationId': 'create_item_list_items_list__post', 'requestBody': {'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Input'}, 'type': 'array', 'title': 'Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'Item-Input': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Input'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name'], 'title': 'Item'}, 'Item-Output': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Output'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name', 'description', 'sub'], 'title': 'Item'}, 'SubItem-Input': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname'], 'title': 'SubItem'}, 'SubItem-Output': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname', 'sub_description', 'tags'], 'title': 'SubItem'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_app_client",
            "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_mixed_formdata",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 319,
          "end_line_number": 333,
          "source_code": "def test_mixed_formdata(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-mixed-formData\",\n        data={\"formData\": \"test\"},\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"data\": {\"formData\": \"test\"},\n        \"files\": {\n            \"filename.txt\": \"file contents\",\n        },\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.json() == {'data': {'formData': 'test'}, 'files': {'filename.txt': 'file contents'}}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data (in the form of keyword arguments) and receive a response.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kwargs`), updates them with a default key-value pair (`{'name': 'post'}`), and returns a tuple containing the updated keyword arguments and a status code of `201`, indicating successful creation. This method can be used in testing scenarios to verify the behavior of API endpoints, as demonstrated in the provided code snippets where it checks for correct handling of various request payloads and response statuses."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_app",
        "module": "test_main_b_an_py39",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py39.py",
        "line_number": 5,
        "end_line_number": 13,
        "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py39 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
        "docstring": null,
        "decorators": [
          "needs_py39"
        ],
        "arguments": [],
        "imports": [
          "utils.needs_py39",
          "docs_src.app_testing.app_b_an_py39.test_main"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "test_main.test_create_item",
            "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
            "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_app",
        "module": "test_main_b_an_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py310.py",
        "line_number": 5,
        "end_line_number": 13,
        "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py310 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [],
        "imports": [
          "utils.needs_py310",
          "docs_src.app_testing.app_b_an_py310.test_main"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "test_main.test_create_item",
            "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
            "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_override_settings",
        "module": "test_app02",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_settings/test_app02.py",
        "line_number": 17,
        "end_line_number": 20,
        "source_code": "def test_override_settings():\n    from docs_src.settings.app02 import test_main\n\n    test_main.test_app()",
        "docstring": null,
        "decorators": [
          "needs_pydanticv2"
        ],
        "arguments": [],
        "imports": [
          "pytest.MonkeyPatch",
          "utils.needs_pydanticv2",
          "docs_src.settings.app02.main",
          "docs_src.settings.app02.test_main"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "test_main.test_app",
            "body": "def test_app():\n    with client:\n        response = client.get('/')\n    assert response.json() == {'msg': 'Hello World'}\n    assert response.headers['content-type'] == json_type",
            "method_explanation": "**Main Purpose of the Method**:\nThe `test_app` method is designed to verify the functionality of the root endpoint (`/`) of a FastAPI application. It checks that the response is as expected, specifically that it returns a JSON object with a message and the correct content type.\n\n**How It Works**:\n1. The method uses a context manager (`with client:`) to ensure that the test client is properly set up for making requests to the FastAPI application.\n2. It sends a GET request to the root endpoint (`/`) using `client.get('/')`.\n3. The response is then validated with two assertions:\n   - It checks that the JSON response matches the expected dictionary `{'msg': 'Hello World'}`.\n   - It verifies that the `content-type` header of the response matches a predefined variable `json_type`, ensuring the response is in the correct format."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_parameters_snake_case",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 575,
          "end_line_number": 634,
          "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "snake_case_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200",
            "assert resp.status_code == 200, resp.text",
            "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
            "assert resp.status_code == 400",
            "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}",
            "assert resp.status_code == 200",
            "assert resp.json() == {'truthiness': False, 'order_by': None}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles different scenarios and returns appropriate status codes and messages."
            }
          ]
        },
        {
          "repo_name": "connexion",
          "name": "test_formdata_file_upload",
          "module": "test_parameters",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
          "line_number": 272,
          "end_line_number": 291,
          "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
          "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
          "decorators": [],
          "arguments": [
            "simple_app"
          ],
          "imports": [
            "json",
            "io.BytesIO",
            "typing.List",
            "pytest"
          ],
          "fixtures": [],
          "assertions": [
            "assert resp.status_code == 400",
            "assert resp.status_code == 200",
            "assert resp.json() == {'filename.txt': 'file contents'}"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app_client.post",
              "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app_client.post` method is designed to simulate an HTTP POST request, allowing developers to send data to a specified endpoint and receive a response. It is commonly used in testing scenarios to verify the behavior of API endpoints.\n\n**How It Works**:\nThe method accepts keyword arguments (`**kwargs`), which can include parameters such as the request path and the data to be sent (e.g., JSON payload). It updates the `kwargs` dictionary to include a default key-value pair (`'name': 'post'`) and then returns the updated `kwargs` along with a status code of `201`, indicating successful creation. In the context of the provided code snippets, this method is used to test the API's response to various inputs, including valid and invalid JSON data, ensuring that the API correctly handles requests and returns appropriate status codes and error messages."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token",
        "module": "test_tutorial005_an_py39",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
        "line_number": 62,
        "end_line_number": 73,
        "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
        "docstring": null,
        "decorators": [
          "needs_py39"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py39",
          "docs_src.security.tutorial005_an_py39.app",
          "docs_src.security.tutorial005_an_py39.fake_users_db",
          "docs_src.security.tutorial005_an_py39.verify_password",
          "docs_src.security.tutorial005_an_py39.get_password_hash",
          "docs_src.security.tutorial005_an_py39.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token_inactive_user",
        "module": "test_tutorial005_an_py39",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
        "line_number": 167,
        "end_line_number": 175,
        "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
        "docstring": null,
        "decorators": [
          "needs_py39"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py39",
          "docs_src.security.tutorial005_an_py39.app",
          "docs_src.security.tutorial005_an_py39.fake_users_db",
          "docs_src.security.tutorial005_an_py39.verify_password",
          "docs_src.security.tutorial005_an_py39.get_password_hash",
          "docs_src.security.tutorial005_an_py39.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 400, response.text",
          "assert response.json() == {'detail': 'Inactive user'}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_items",
        "module": "test_tutorial005_an_py39",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
        "line_number": 179,
        "end_line_number": 185,
        "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
        "docstring": null,
        "decorators": [
          "needs_py39"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py39",
          "docs_src.security.tutorial005_an_py39.app",
          "docs_src.security.tutorial005_an_py39.fake_users_db",
          "docs_src.security.tutorial005_an_py39.verify_password",
          "docs_src.security.tutorial005_an_py39.get_password_hash",
          "docs_src.security.tutorial005_an_py39.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_system_status",
        "module": "test_tutorial005_py39",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
        "line_number": 189,
        "end_line_number": 195,
        "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
        "docstring": null,
        "decorators": [
          "needs_py39"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py39",
          "docs_src.security.tutorial005_py39.app",
          "docs_src.security.tutorial005_py39.fake_users_db",
          "docs_src.security.tutorial005_py39.verify_password",
          "docs_src.security.tutorial005_py39.get_password_hash",
          "docs_src.security.tutorial005_py39.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'status': 'ok'}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token_no_scope",
        "module": "test_tutorial005_an",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
        "line_number": 121,
        "end_line_number": 128,
        "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "docs_src.security.tutorial005_an.app",
          "docs_src.security.tutorial005_an.create_access_token",
          "docs_src.security.tutorial005_an.fake_users_db",
          "docs_src.security.tutorial005_an.get_password_hash",
          "docs_src.security.tutorial005_an.verify_password"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 401, response.text",
          "assert response.json() == {'detail': 'Not enough permissions'}",
          "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. Upon receiving a response, it parses the JSON content to extract the `access_token`, which it returns. If the request is successful, this token can be used in the `Authorization` header for accessing protected routes."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_items",
        "module": "test_tutorial005_an",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
        "line_number": 154,
        "end_line_number": 160,
        "source_code": "def test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "docs_src.security.tutorial005_an.app",
          "docs_src.security.tutorial005_an.create_access_token",
          "docs_src.security.tutorial005_an.fake_users_db",
          "docs_src.security.tutorial005_an.get_password_hash",
          "docs_src.security.tutorial005_an.verify_password"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_system_status",
        "module": "test_tutorial005_an",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
        "line_number": 163,
        "end_line_number": 169,
        "source_code": "def test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "docs_src.security.tutorial005_an.app",
          "docs_src.security.tutorial005_an.create_access_token",
          "docs_src.security.tutorial005_an.fake_users_db",
          "docs_src.security.tutorial005_an.get_password_hash",
          "docs_src.security.tutorial005_an.verify_password"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'status': 'ok'}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token",
        "module": "test_tutorial005_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
        "line_number": 62,
        "end_line_number": 73,
        "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_py310.app",
          "docs_src.security.tutorial005_py310.fake_users_db",
          "docs_src.security.tutorial005_py310.verify_password",
          "docs_src.security.tutorial005_py310.get_password_hash",
          "docs_src.security.tutorial005_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are incorrect or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token_no_scope",
        "module": "test_tutorial005_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
        "line_number": 143,
        "end_line_number": 150,
        "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_py310.app",
          "docs_src.security.tutorial005_py310.fake_users_db",
          "docs_src.security.tutorial005_py310.verify_password",
          "docs_src.security.tutorial005_py310.get_password_hash",
          "docs_src.security.tutorial005_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 401, response.text",
          "assert response.json() == {'detail': 'Not enough permissions'}",
          "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_system_status",
        "module": "test_tutorial005_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
        "line_number": 189,
        "end_line_number": 195,
        "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_py310.app",
          "docs_src.security.tutorial005_py310.fake_users_db",
          "docs_src.security.tutorial005_py310.verify_password",
          "docs_src.security.tutorial005_py310.get_password_hash",
          "docs_src.security.tutorial005_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'status': 'ok'}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token",
        "module": "test_tutorial005_an_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
        "line_number": 62,
        "end_line_number": 73,
        "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_an_py310.app",
          "docs_src.security.tutorial005_an_py310.fake_users_db",
          "docs_src.security.tutorial005_an_py310.verify_password",
          "docs_src.security.tutorial005_an_py310.get_password_hash",
          "docs_src.security.tutorial005_an_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_items",
        "module": "test_tutorial005_an_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
        "line_number": 179,
        "end_line_number": 185,
        "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_an_py310.app",
          "docs_src.security.tutorial005_an_py310.fake_users_db",
          "docs_src.security.tutorial005_an_py310.verify_password",
          "docs_src.security.tutorial005_an_py310.get_password_hash",
          "docs_src.security.tutorial005_an_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_read_system_status",
        "module": "test_tutorial005_an_py310",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
        "line_number": 189,
        "end_line_number": 195,
        "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
        "docstring": null,
        "decorators": [
          "needs_py310"
        ],
        "arguments": [
          "client"
        ],
        "imports": [
          "pytest",
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "utils.needs_py310",
          "docs_src.security.tutorial005_an_py310.app",
          "docs_src.security.tutorial005_an_py310.fake_users_db",
          "docs_src.security.tutorial005_an_py310.verify_password",
          "docs_src.security.tutorial005_an_py310.get_password_hash",
          "docs_src.security.tutorial005_an_py310.create_access_token"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 200, response.text",
          "assert response.json() == {'status': 'ok'}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "fastapi",
        "name": "test_token_no_scope",
        "module": "test_tutorial005",
        "class_name": null,
        "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
        "line_number": 121,
        "end_line_number": 128,
        "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "dirty_equals.IsDict",
          "dirty_equals.IsOneOf",
          "fastapi.testclient.TestClient",
          "docs_src.security.tutorial005.app",
          "docs_src.security.tutorial005.create_access_token",
          "docs_src.security.tutorial005.fake_users_db",
          "docs_src.security.tutorial005.get_password_hash",
          "docs_src.security.tutorial005.verify_password"
        ],
        "fixtures": [],
        "assertions": [
          "assert response.status_code == 401, response.text",
          "assert response.json() == {'detail': 'Not enough permissions'}",
          "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "get_access_token",
            "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "connexion",
          "name": "test_verify_basic_missing_auth_header",
          "module": "test_security",
          "class_name": null,
          "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
          "line_number": 174,
          "end_line_number": 185,
          "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "json",
            "unittest.mock.MagicMock",
            "unittest.mock.patch",
            "pytest",
            "requests",
            "connexion.exceptions.BadRequestProblem",
            "connexion.exceptions.ConnexionException",
            "connexion.exceptions.OAuthProblem",
            "connexion.exceptions.OAuthResponseProblem",
            "connexion.exceptions.OAuthScopeProblem",
            "connexion.lifecycle.ConnexionRequest",
            "connexion.security.NO_VALUE",
            "connexion.security.ApiKeySecurityHandler",
            "connexion.security.BasicSecurityHandler",
            "connexion.security.OAuthSecurityHandler",
            "connexion.security.SecurityHandlerFactory"
          ],
          "fixtures": [],
          "assertions": [
            "assert wrapped_func(request) is NO_VALUE"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "security_handler._get_verify_func",
              "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_get_verify_func` method is designed to create a verification function that checks the authorization credentials provided in an HTTP request. It specifically handles a custom authentication scheme called \"my_basic\" and validates the credentials against a user-defined function.\n\n**How It Works**:\n1. The method takes a `basic_info_func` as an argument, which is a function that checks the basic authentication information.\n2. It wraps this function in another function (`wrapper`) that processes incoming requests.\n3. Inside the `wrapper`, it retrieves the `Authorization` header from the request and checks if the authentication type is \"my_basic\".\n4. If the type is correct, it decodes the base64-encoded credentials, extracting the username and password.\n5. If decoding fails or the credentials are invalid, it raises an `OAuthProblem`.\n6. Finally, it calls the `check_basic_info_func` with the request, username, and password to perform the actual validation and returns the result."
            }
          ]
        }
      ]
    }
  ]
}