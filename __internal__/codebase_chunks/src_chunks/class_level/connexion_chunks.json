{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/connexion/examples/helloworld_async/hello.py",
      "content": "from pathlib import Path\n\nimport connexion"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/connexion/examples/helloworld_async/hello.py",
      "content": "async def test():\n    pass"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/connexion/examples/helloworld_async/hello.py",
      "content": "async def post_greeting(name: str):\n    await test()\n    return f\"Hello {name}\", 201"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/connexion/examples/helloworld_async/hello.py",
      "content": "app = connexion.AsyncApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\", arguments={\"title\": \"Hello World Example\"})\napp.add_api(\"swagger.yaml\", arguments={\"title\": \"Hello World Example\"})"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/connexion/examples/helloworld_async/hello.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/orm.py",
      "content": "from sqlalchemy import Column, DateTime, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\nBase = declarative_base()"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/orm.py",
      "content": "class Pet(Base):\n    __tablename__ = \"pets\"\n    id = Column(String(20), primary_key=True)\n    name = Column(String(100))\n    animal_type = Column(String(20))\n    created = Column(DateTime())\n\n    def update(self, id=None, name=None, animal_type=None, tags=None, created=None):\n        if name is not None:\n            self.name = name\n        if animal_type is not None:\n            self.animal_type = animal_type\n        if created is not None:\n            self.created = created\n\n    def dump(self):\n        return {k: v for k, v in vars(self).items() if not k.startswith(\"_\")}"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/orm.py",
      "content": "def init_db():\n    \"\"\"\n    Initialize the database and return a sessionmaker object.\n    `check_same_thread` and `StaticPool` are helpful for unit testing of\n    in-memory sqlite databases; they should not be used in production.\n    https://stackoverflow.com/questions/6519546/scoped-sessionsessionmaker-or-plain-sessionmaker-in-sqlalchemy\n    \"\"\"\n    engine = create_engine(\n        url=\"sqlite:///:memory:\",\n        connect_args={\"check_same_thread\": False},\n        poolclass=StaticPool,\n    )\n    Base.metadata.create_all(bind=engine)\n    return sessionmaker(autocommit=False, autoflush=False, bind=engine)"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "import logging\nfrom datetime import datetime, timezone\n\nimport connexion\nimport orm\nfrom connexion import NoContent"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "def get_pets(limit, animal_type=None):\n    with db_session_factory() as db_session:\n        q = db_session.query(orm.Pet)\n        if animal_type:\n            q = q.filter(orm.Pet.animal_type == animal_type)\n        return [p.dump() for p in q][:limit]"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "def get_pet(pet_id):\n    with db_session_factory() as db_session:\n        pet = db_session.query(orm.Pet).filter(orm.Pet.id == pet_id).one_or_none()\n        return pet.dump() if pet is not None else (\"Not found\", 404)"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "def put_pet(pet_id, pet):\n    with db_session_factory() as db_session:\n        p = db_session.query(orm.Pet).filter(orm.Pet.id == pet_id).one_or_none()\n        pet[\"id\"] = pet_id\n        if p is not None:\n            logging.info(\"Updating pet %s..\", pet_id)\n            p.update(**pet)\n        else:\n            logging.info(\"Creating pet %s..\", pet_id)\n            pet[\"created\"] = datetime.now(timezone.utc)\n            db_session.add(orm.Pet(**pet))\n        db_session.commit()\n        return NoContent, (200 if p is not None else 201)"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "def delete_pet(pet_id):\n    with db_session_factory() as db_session:\n        pet = db_session.query(orm.Pet).filter(orm.Pet.id == pet_id).one_or_none()\n        if pet is not None:\n            logging.info(\"Deleting pet %s..\", pet_id)\n            db_session.delete(pet)\n            db_session.commit()\n            return NoContent, 204\n        else:\n            return NoContent, 404"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "logging.basicConfig(level=logging.INFO)\ndb_session_factory = orm.init_db()\npets = {\n    1: {\"name\": \"Aldo\", \"animal_type\": \"cat\"},\n    2: {\"name\": \"Bailey\", \"animal_type\": \"dog\"},\n    3: {\"name\": \"Hugo\", \"animal_type\": \"cat\"},\n}\nfor id_, pet in pets.items():\n    put_pet(id_, pet)"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")\napp.add_api(\"swagger.yaml\")"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/connexion/examples/sqlalchemy/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(port=8080, reload=False)"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/app.py",
      "content": "import logging\nfrom pathlib import Path\n\nimport connexion\nfrom connexion.resolver import MethodViewResolver\n\nlogging.basicConfig(level=logging.INFO)\n\nzoo = {\n    1: {\n        \"id\": 1,\n        \"name\": \"giraffe\",\n        \"tags\": [\"africa\", \"yellow\", \"hoofs\", \"herbivore\", \"long neck\"],\n    },\n    2: {\n        \"id\": 2,\n        \"name\": \"lion\",\n        \"tags\": [\"africa\", \"yellow\", \"paws\", \"carnivore\", \"mane\"],\n    },\n}"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec/\")\n\noptions = {\"swagger_ui\": True}\napp.add_api(\n    \"openapi.yaml\",\n    options=options,\n    arguments={\"title\": \"MethodViewResolver Example\"},\n    resolver=MethodViewResolver(\n        \"api\",\n        class_arguments={\"PetsView\": {\"kwargs\": {\"pets\": zoo}}},\n    ),\n    strict_validation=True,\n    validate_responses=True,\n)"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/api/__init__.py",
      "content": "from .petsview import PetsView as PetsView"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/api/petsview.py",
      "content": "import datetime\n\nfrom connexion import NoContent\nfrom flask.views import MethodView"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/api/petsview.py",
      "content": "def example_decorator(f):\n    \"\"\"\n    the returned view from <class>.as_view can be decorated\n    the decorator is initialized exactly once per class\n    \"\"\"\n\n    def decorator(*args, **kwargs):\n        return f(*args, **kwargs)\n\n    return decorator"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/connexion/examples/methodresolver/api/petsview.py",
      "content": "class PetsView(MethodView):\n    \"\"\"Create Pets service\"\"\"\n\n    decorators = [example_decorator]\n    pets = {}\n\n    def __init__(self, pets=None):\n        # the args and kwargs can be provided\n        # via the MethodViewResolver's class_params dict\n        if pets is not None:\n            self.pets = pets\n\n    def post(self, body: dict):\n        name = body.get(\"name\")\n        tag = body.get(\"tag\")\n        count = len(self.pets)\n        pet = {}\n        pet[\"id\"] = count + 1\n        pet[\"tag\"] = tag\n        pet[\"name\"] = name\n        pet[\"last_updated\"] = datetime.datetime.now()\n        self.pets[pet[\"id\"]] = pet\n        return pet, 201\n\n    def put(self, petId, body: dict):\n        name = body[\"name\"]\n        tag = body.get(\"tag\")\n        pet = self.pets.get(petId, {\"id\": petId})\n        pet[\"name\"] = name\n        pet[\"tag\"] = tag\n        pet[\"last_updated\"] = datetime.datetime.now()\n        self.pets[petId] = pet\n        return self.pets[petId], 201\n\n    def delete(self, petId):\n        id_ = int(petId)\n        if self.pets.get(id_) is None:\n            return NoContent, 404\n        del self.pets[id_]\n        return NoContent, 204\n\n    def get(self, petId=None, limit=100):\n        if petId is None:\n            # NOTE: we need to wrap it with list for Python 3 as\n            # dict_values is not JSON serializable\n            return list(self.pets.values())[0:limit]\n        if self.pets.get(petId) is None:\n            return NoContent, 404\n        return self.pets[petId]"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/connexion/examples/oauth2/app.py",
      "content": "\"\"\"\nBasic example of a resource server\n\"\"\""
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/connexion/examples/oauth2/app.py",
      "content": "from pathlib import Path\n\nimport connexion"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/connexion/examples/oauth2/app.py",
      "content": "def get_secret(user) -> str:\n    return f\"You are: {user}\""
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/connexion/examples/oauth2/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")\napp.add_api(\"swagger.yaml\")"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/connexion/examples/oauth2/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/connexion/examples/oauth2/mock_tokeninfo.py",
      "content": "\"\"\"\nMock OAuth2 token info\n\"\"\""
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/connexion/examples/oauth2/mock_tokeninfo.py",
      "content": "import connexion\nimport uvicorn\nfrom connexion import request"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/connexion/examples/oauth2/mock_tokeninfo.py",
      "content": "# our hardcoded mock \"Bearer\" access tokens\nTOKENS = {\"123\": \"jdoe\", \"456\": \"rms\"}"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/connexion/examples/oauth2/mock_tokeninfo.py",
      "content": "def get_tokeninfo() -> dict:\n    try:\n        _, access_token = request.headers[\"Authorization\"].split()\n    except Exception:\n        access_token = \"\"\n\n    sub = TOKENS.get(access_token)\n\n    if not sub:\n        return \"No such token\", 401\n\n    return {\"sub\": sub, \"scope\": [\"uid\"]}"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/connexion/examples/oauth2/mock_tokeninfo.py",
      "content": "if __name__ == \"__main__\":\n    app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\n    app.add_api(\"mock_tokeninfo.yaml\")\n    uvicorn.run(app, port=7979)"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "\"\"\"\nBasic example of a resource server\n\"\"\""
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "import time\nfrom pathlib import Path\n\nimport connexion\nfrom jose import JWTError, jwt\nfrom werkzeug.exceptions import Unauthorized"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "def generate_token(user_id):\n    timestamp = _current_timestamp()\n    payload = {\n        \"iss\": JWT_ISSUER,\n        \"iat\": int(timestamp),\n        \"exp\": int(timestamp + JWT_LIFETIME_SECONDS),\n        \"sub\": str(user_id),\n    }\n\n    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)"
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "def decode_token(token):\n    try:\n        return jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\n    except JWTError as e:\n        raise Unauthorized from e"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "def get_secret(user, token_info) -> str:\n    return \"\"\"\n    You are user_id {user} and the secret is 'wbevuec'.\n    Decoded token claims: {token_info}.\n    \"\"\".format(\n        user=user, token_info=token_info\n    )"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "def _current_timestamp() -> int:\n    return int(time.time())"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "JWT_ISSUER = \"com.zalando.connexion\"\nJWT_SECRET = \"change_this\"\nJWT_LIFETIME_SECONDS = 600\nJWT_ALGORITHM = \"HS256\""
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/connexion/examples/jwt/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "from pathlib import Path"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "import connexion"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "pets = {\n    1: {\"name\": \"Aldo\", \"registered\": \"2022-11-28T00:00:00Z\"},\n    2: {\"name\": \"Bailey\", \"registered\": \"2023-11-28T11:11:11Z\"},\n    3: {\"name\": \"Hugo\", \"registered\": \"2024-11-28T22:22:22Z\"},\n}"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "def get(petId):\n    id_ = int(petId)\n    if pets.get(id_) is None:\n        return connexion.NoContent, 404\n    return pets[id_]"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "def show():\n    # NOTE: we need to wrap it with list for Python 3 as dict_values is not JSON serializable\n    return list(pets.values())"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec/\")\napp.add_api(\"openapi.yaml\", arguments={\"title\": \"Pet Store Rel Ref Example\"})\napp.add_api(\"swagger.yaml\", arguments={\"title\": \"Pet Store Rel Ref Example\"})"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/connexion/examples/splitspecs/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/resty.py",
      "content": "import logging\nfrom pathlib import Path\n\nimport connexion\nfrom connexion.resolver import RestyResolver\n\nlogging.basicConfig(level=logging.INFO)"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/resty.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\n    \"openapi.yaml\",\n    arguments={\"title\": \"RestyResolver Example\"},\n    resolver=RestyResolver(\"api\"),\n)\napp.add_api(\n    \"swagger.yaml\",\n    arguments={\"title\": \"RestyResolver Example\"},\n    resolver=RestyResolver(\"api\"),\n)"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/resty.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/__init__.py",
      "content": "import api.pets  # noqa"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "import datetime"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "pets = {}"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "def post(body):\n    name = body.get(\"name\")\n    tag = body.get(\"tag\")\n    count = len(pets)\n    pet = {}\n    pet[\"id\"] = count + 1\n    pet[\"tag\"] = tag\n    pet[\"name\"] = name\n    pet[\"last_updated\"] = datetime.datetime.now()\n    pets[pet[\"id\"]] = pet\n    return pet, 201"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "def put(body):\n    id_ = body[\"id\"]\n    name = body[\"name\"]\n    tag = body.get(\"tag\")\n    id_ = int(id_)\n    pet = pets.get(id_, {\"id\": id_})\n    pet[\"name\"] = name\n    pet[\"tag\"] = tag\n    pet[\"last_updated\"] = datetime.datetime.now()\n    pets[id_] = pet\n    return pets[id_]"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "def delete(id_):\n    id_ = int(id_)\n    if pets.get(id_) is None:\n        return NoContent, 404\n    del pets[id_]\n    return NoContent, 204"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "def get(petId):\n    id_ = int(petId)\n    if pets.get(id_) is None:\n        return NoContent, 404\n    return pets[id_]"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/connexion/examples/restyresolver/api/pets.py",
      "content": "def search(limit=100):\n    # NOTE: we need to wrap it with list for Python 3 as dict_values is not JSON serializable\n    return list(pets.values())[0:limit]"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "\"\"\"\nexample of connexion running behind a path-altering reverse-proxy\n\nNOTE this demo is not secure by default!!\nYou'll want to make sure these headers are coming from your proxy, and not\ndirectly from users on the web!\n\n\"\"\""
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "import logging\nfrom pathlib import Path\n\nimport connexion\nimport uvicorn\nfrom starlette.types import Receive, Scope, Send"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "class ReverseProxied:\n    \"\"\"Wrap the application in this middleware and configure the\n    reverse proxy to add these headers, to let you quietly bind\n    this to a URL other than / and to an HTTP scheme that is\n    different than what is used locally.\n\n    In nginx:\n\n    location /proxied {\n        proxy_pass http://192.168.0.1:5001;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_set_header X-Forwarded-Path /proxied;\n    }\n\n    :param app: the WSGI application\n    :param root_path: override the default script name (path)\n    :param scheme: override the default scheme\n    :param server: override the default server\n    \"\"\"\n\n    def __init__(self, app, root_path=None, scheme=None, server=None):\n        self.app = app\n        self.root_path = root_path\n        self.scheme = scheme\n        self.server = server\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        logging.warning(\n            \"this demo is not secure by default!! \"\n            \"You'll want to make sure these headers are coming from your proxy, \"\n            \"and not directly from users on the web!\"\n        )\n        root_path = scope.get(\"root_path\") or self.root_path\n        for header, value in scope.get(\"headers\", []):\n            if header == b\"x-forwarded-path\":\n                root_path = value.decode()\n                break\n        if root_path:\n            root_path = \"/\" + root_path.strip(\"/\")\n            scope[\"root_path\"] = root_path\n            scope[\"path\"] = root_path + scope.get(\"path\", \"\")\n            scope[\"raw_path\"] = root_path.encode() + scope.get(\"raw_path\", \"\")\n\n        scope[\"scheme\"] = scope.get(\"scheme\") or self.scheme\n        scope[\"server\"] = scope.get(\"server\") or (self.server, None)\n\n        return await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "def hello():\n    return \"hello\""
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "def create_app():\n    app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\n    app.add_api(\"openapi.yaml\")\n    app.add_api(\"swagger.yaml\")\n    app.middleware = ReverseProxied(app.middleware, root_path=\"/reverse_proxied/\")\n    return app"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/connexion/examples/reverseproxy/app.py",
      "content": "if __name__ == \"__main__\":\n    uvicorn.run(\n        f\"{Path(__file__).stem}:create_app\", factory=True, port=8080, proxy_headers=True\n    )"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "\"\"\"\nBasic example of a resource server\n\"\"\""
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "from pathlib import Path\n\nimport connexion"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "PASSWD = {\"admin\": \"secret\", \"foo\": \"bar\"}"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "def basic_auth(username, password):\n    if PASSWD.get(username) == password:\n        return {\"sub\": username}\n    # optional: raise exception for custom error response\n    return None"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "def get_secret(user) -> str:\n    return f\"You are {user} and the secret is 'wbevuec'\""
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")\napp.add_api(\"swagger.yaml\")"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/connexion/examples/basicauth/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/connexion/examples/enforcedefaults/app.py",
      "content": "from pathlib import Path\n\nimport connexion\nfrom connexion.validators import DefaultsJSONRequestBodyValidator"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/connexion/examples/enforcedefaults/app.py",
      "content": "def echo(data):\n    return data"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/connexion/examples/enforcedefaults/app.py",
      "content": "validator_map = {\"body\": {\"application/json\": DefaultsJSONRequestBodyValidator}}"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/connexion/examples/enforcedefaults/app.py",
      "content": "app = connexion.AsyncApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\", validator_map=validator_map)\napp.add_api(\"swagger.yaml\", validator_map=validator_map)"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/connexion/examples/enforcedefaults/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "\"\"\"\nBasic example of a resource server\n\"\"\""
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "from pathlib import Path\n\nimport connexion\nfrom connexion.exceptions import OAuthProblem"
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "TOKEN_DB = {\"asdf1234567890\": {\"uid\": 100}}"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "def apikey_auth(token, required_scopes):\n    info = TOKEN_DB.get(token, None)\n\n    if not info:\n        raise OAuthProblem(\"Invalid token\")\n\n    return info"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "def get_secret(user) -> str:\n    return f\"You are {user} and the secret is 'wbevuec'\""
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")\napp.add_api(\"swagger.yaml\")"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/connexion/examples/apikey/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "\"\"\"\nBasic example of a resource server\n\"\"\""
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "from pathlib import Path\n\nimport connexion"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "# our hardcoded mock \"Bearer\" access tokens\nTOKENS = {\"123\": \"jdoe\", \"456\": \"rms\"}"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "def get_secret(user) -> str:\n    return f\"You are: {user}\""
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "def token_info(token) -> dict:\n    sub = TOKENS.get(token)\n    if not sub:\n        return None\n    return {\"sub\": sub, \"scope\": [\"uid\"]}"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec\")\napp.add_api(\"openapi.yaml\")\napp.add_api(\"swagger.yaml\")"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/connexion/examples/oauth2_local_tokeninfo/app.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_starlette.py",
      "content": "import typing as t\nfrom pathlib import Path\n\nimport connexion\nfrom connexion.decorators import StarletteDecorator\nfrom connexion.resolver import RelativeResolver\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_starlette.py",
      "content": "@StarletteDecorator()\ndef post_greeting(name: str, number: t.Optional[int] = None) -> str:\n    return f\"Hello {name}, your number is {number}!\""
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_starlette.py",
      "content": "app = Starlette(\n    debug=True,\n    routes=[\n        Route(\"/openapi/greeting/{name}\", post_greeting, methods=[\"POST\"]),\n        Route(\"/swagger/greeting/{name}\", post_greeting, methods=[\"POST\"]),\n    ],\n)"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_starlette.py",
      "content": "app = connexion.ConnexionMiddleware(\n    app,\n    specification_dir=\"spec/\",\n    resolver=RelativeResolver(\"hello_starlette\"),\n)\napp.add_api(\"openapi.yaml\", arguments={\"title\": \"Hello World Example\"})\napp.add_api(\"swagger.yaml\", arguments={\"title\": \"Hello World Example\"})"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_starlette.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_quart.py",
      "content": "import typing as t\nfrom pathlib import Path\n\nimport connexion\nfrom connexion.decorators import ASGIDecorator\nfrom connexion.resolver import RelativeResolver\nfrom quart import Quart"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_quart.py",
      "content": "app = Quart(__name__)"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_quart.py",
      "content": "@app.route(\"/openapi/greeting/<name>\", methods=[\"POST\"])\n@app.route(\"/swagger/greeting/<name>\", methods=[\"POST\"])\n@ASGIDecorator()\ndef post_greeting(name: str, number: t.Optional[int] = None) -> str:\n    return f\"Hello {name}, your number is {number}!\""
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_quart.py",
      "content": "app = connexion.ConnexionMiddleware(\n    app,\n    specification_dir=\"spec/\",\n    resolver=RelativeResolver(\"hello_quart\"),\n)\napp.add_api(\"openapi.yaml\", arguments={\"title\": \"Hello World Example\"})\napp.add_api(\"swagger.yaml\", arguments={\"title\": \"Hello World Example\"})"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/connexion/examples/frameworks/hello_quart.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/connexion/examples/helloworld/hello.py",
      "content": "from pathlib import Path"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/connexion/examples/helloworld/hello.py",
      "content": "import connexion"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/connexion/examples/helloworld/hello.py",
      "content": "def post_greeting(name: str) -> str:\n    return f\"Hello {name}\""
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/connexion/examples/helloworld/hello.py",
      "content": "app = connexion.FlaskApp(__name__, specification_dir=\"spec/\")\napp.add_api(\"openapi.yaml\", arguments={\"title\": \"Hello World Example\"})\napp.add_api(\"swagger.yaml\", arguments={\"title\": \"Hello World Example\"})"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/connexion/examples/helloworld/hello.py",
      "content": "if __name__ == \"__main__\":\n    app.run(f\"{Path(__file__).stem}:app\", port=8080)"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/connexion/connexion/__init__.py",
      "content": "from .apps import AbstractApp  # NOQA\nfrom .apps.asynchronous import AsyncApp\nfrom .datastructures import NoContent  # NOQA\nfrom .exceptions import ProblemException  # NOQA\nfrom .problem import problem  # NOQA\nfrom .resolver import Resolution, Resolver, RestyResolver  # NOQA\nfrom .utils import not_installed_error  # NOQA\n\ntry:\n    from connexion.apps.flask import FlaskApi, FlaskApp\nexcept ImportError as e:  # pragma: no cover\n    _flask_not_installed_error = not_installed_error(\n        e, msg=\"Please install connexion using the 'flask' extra\"\n    )\n    FlaskApi = _flask_not_installed_error  # type: ignore\n    FlaskApp = _flask_not_installed_error  # type: ignore\n\nfrom connexion.apps.asynchronous import AsyncApi, AsyncApp\nfrom connexion.context import request\nfrom connexion.middleware import ConnexionMiddleware"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/connexion/connexion/__init__.py",
      "content": "App = FlaskApp\nApi = FlaskApi"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "```"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "This module contains resolvers, functions that resolves the user defined view functions\nfrom the operations defined in the OpenAPI spec."
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "import inspect\nimport logging\nimport typing as t\n\nfrom inflection import camelize\n\nimport connexion.utils as utils\nfrom connexion.exceptions import ResolverError\n\nlogger = logging.getLogger(\"connexion.resolver\")"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class Resolution:\n    def __init__(self, function, operation_id):\n        \"\"\"\n        Represents the result of operation resolution\n\n        :param function: The endpoint function\n        :type function: types.FunctionType\n        \"\"\"\n        self.function = function\n        self.operation_id = operation_id"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class Resolver:\n    def __init__(self, function_resolver: t.Callable = utils.get_function_from_name):\n        \"\"\"\n        Standard resolver\n\n        :param function_resolver: Function that resolves functions using an operationId\n        \"\"\"\n        self.function_resolver = function_resolver\n\n    def resolve(self, operation):\n        \"\"\"\n        Default operation resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = self.resolve_operation_id(operation)\n        return Resolution(\n            self.resolve_function_from_operation_id(operation_id), operation_id\n        )\n\n    def resolve_operation_id(self, operation):\n        \"\"\"\n        Default operationId resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = operation.operation_id\n        router_controller = operation.router_controller\n        if router_controller is None:\n            return operation_id\n        return f\"{router_controller}.{operation_id}\"\n\n    def resolve_function_from_operation_id(self, operation_id):\n        \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n        try:\n            return self.function_resolver(operation_id)\n        except ImportError as e:\n            msg = f'Cannot resolve operationId \"{operation_id}\"! Import error was \"{str(e)}\"'\n            raise ResolverError(msg)\n        except (AttributeError, ValueError) as e:\n            raise ResolverError(str(e))"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class RelativeResolver(Resolver):\n    \"\"\"\n    Resolves endpoint functions relative to a given root path or module.\n    \"\"\"\n\n    def __init__(self, root_path, function_resolver=utils.get_function_from_name):\n        \"\"\"\n        :param root_path: The root path relative to which an operationId is resolved.\n            Can also be a module. Has the same effect as setting\n            `x-swagger-router-controller` or `x-openapi-router-controller` equal to\n            `root_path` for every operation individually.\n        :type root_path: typing.Union[str, types.ModuleType]\n        :param function_resolver: Function that resolves functions using an operationId\n        :type function_resolver: types.FunctionType\n        \"\"\"\n        super().__init__(function_resolver=function_resolver)\n        if inspect.ismodule(root_path):\n            self.root_path = root_path.__name__\n        else:\n            self.root_path = root_path\n\n    def resolve_operation_id(self, operation):\n        \"\"\"Resolves the operationId relative to the root path, unless\n        x-swagger-router-controller or x-openapi-router-controller is specified.\n\n        :param operation: The operation to resolve\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = operation.operation_id\n        router_controller = operation.router_controller\n        if router_controller is None:\n            return f\"{self.root_path}.{operation_id}\"\n        return f\"{router_controller}.{operation_id}\""
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class RestyResolver(Resolver):\n    \"\"\"\n    Resolves endpoint functions using REST semantics (unless overridden by specifying operationId)\n    \"\"\"\n\n    def __init__(\n        self, default_module_name: str, *, collection_endpoint_name: str = \"search\"\n    ):\n        \"\"\"\n        :param default_module_name: Default module name for operations\n        :param collection_endpoint_name: Name of function to resolve collection endpoints to\n        \"\"\"\n        super().__init__()\n        self.default_module_name = default_module_name\n        self.collection_endpoint_name = collection_endpoint_name\n\n    def resolve_operation_id(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics unless explicitly configured in the spec\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        if operation.operation_id:\n            return super().resolve_operation_id(operation)\n\n        return self.resolve_operation_id_using_rest_semantics(operation)\n\n    def resolve_operation_id_using_rest_semantics(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n\n        # Split the path into components delimited by '/'\n        path_components = [c for c in operation.path.split(\"/\") if len(c)]\n\n        def is_var(component):\n            \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n            return (component[0] == \"{\") and (component[-1] == \"}\")\n\n        resource_name = \".\".join([c for c in path_components if not is_var(c)]).replace(\n            \"-\", \"_\"\n        )\n\n        def get_controller_name():\n            x_router_controller = operation.router_controller\n\n            name = self.default_module_name\n\n            if x_router_controller:\n                name = x_router_controller\n\n            elif resource_name:\n                name += \".\" + resource_name\n\n            return name\n\n        def get_function_name():\n            method = operation.method\n\n            is_collection_endpoint = (\n                method.lower() == \"get\"\n                and len(resource_name)\n                and not is_var(path_components[-1])\n            )\n\n            return (\n                self.collection_endpoint_name\n                if is_collection_endpoint\n                else method.lower()\n            )\n\n        return f\"{get_controller_name()}.{get_function_name()}\""
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class MethodResolverBase(RestyResolver):\n    \"\"\"\n    Resolves endpoint functions based on Flask's MethodView semantics, e.g.\n\n    .. code-block:: yaml\n\n        paths:\n            /foo_bar:\n                get:\n                    # Implied function call: api.FooBarView().get\n\n    .. code-block:: python\n\n        class FooBarView(MethodView):\n            def get(self):\n                return ...\n            def post(self):\n                return ...\n\n    \"\"\"\n\n    _class_arguments_type = t.Dict[\n        str, t.Dict[str, t.Union[t.Iterable, t.Dict[str, t.Any]]]\n    ]\n\n    def __init__(self, *args, class_arguments: _class_arguments_type = None, **kwargs):\n        \"\"\"\n        :param args: Arguments passed to :class:`~RestyResolver`\n        :param class_arguments: Arguments to instantiate the View Class in the format below\n        :param kwargs: Keywords arguments passed to :class:`~RestyResolver`\n\n        .. code-block:: python\n\n            {\n              \"ViewName\": {\n                \"args\": (positional arguments,)\n                \"kwargs\": {\n                  \"keyword\": \"argument\"\n                }\n              }\n            }\n        \"\"\"\n        self.class_arguments = class_arguments or {}\n        super(MethodResolverBase, self).__init__(*args, **kwargs)\n        self.initialized_views: list = []\n\n    def resolve_operation_id(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics unless explicitly configured in the spec\n        Once resolved with REST semantics the view_name is capitalised and has 'View' added\n        to it so it now matches the Class names of the MethodView\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        if operation.operation_id:\n            # If operation_id is defined then use the higher level API to resolve\n            return RestyResolver.resolve_operation_id(self, operation)\n\n        # Use RestyResolver to get operation_id for us (follow their naming conventions/structure)\n        operation_id = self.resolve_operation_id_using_rest_semantics(operation)\n        module_name, view_base, meth_name = operation_id.rsplit(\".\", 2)\n        view_name = camelize(view_base) + \"View\"\n\n        return f\"{module_name}.{view_name}.{meth_name}\"\n\n    def resolve_function_from_operation_id(self, operation_id):\n        \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n\n        try:\n            module_name, view_name, meth_name = operation_id.rsplit(\".\", 2)\n            if operation_id and not view_name.endswith(\"View\"):\n                # If operation_id is not a view then assume it is a standard function\n                return self.function_resolver(operation_id)\n\n            mod = __import__(module_name, fromlist=[view_name])\n            view_cls = getattr(mod, view_name)\n            # find the view and return it\n            return self.resolve_method_from_class(view_name, meth_name, view_cls)\n\n        except ImportError as e:\n            msg = 'Cannot resolve operationId \"{}\"! Import error was \"{}\"'.format(\n                operation_id, str(e)\n            )\n            raise ResolverError(msg)\n        except (AttributeError, ValueError) as e:\n            raise ResolverError(str(e))\n\n    def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        \"\"\"\n        Returns the view function for the given view class.\n        \"\"\"\n        raise NotImplementedError()"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class MethodResolver(MethodResolverBase):\n    \"\"\"\n    A generic method resolver that instantiates a class and extracts the method\n    from it, based on the operation id.\n    \"\"\"\n\n    def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        view = None\n        for v in self.initialized_views:\n            if v.__class__ == view_cls:\n                view = v\n                break\n        if view is None:\n            # get the args and kwargs for this view\n            cls_arguments = self.class_arguments.get(view_name, {})\n            cls_args = cls_arguments.get(\"args\", ())\n            cls_kwargs = cls_arguments.get(\"kwargs\", {})\n            # instantiate the class with the args and kwargs\n            view = view_cls(*cls_args, **cls_kwargs)\n            self.initialized_views.append(view)\n        # get the method if the class\n        func = getattr(view, meth_name)\n        # Return the method function of the class\n        return func"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/connexion/connexion/resolver.py",
      "content": "class MethodViewResolver(MethodResolverBase):\n    \"\"\"\n    A specialized method resolver that works with flask's method views.\n    It resolves the method by calling as_view on the class.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        if \"collection_endpoint_name\" in kwargs:\n            del kwargs[\"collection_endpoint_name\"]\n            # Dispatch of request is done by Flask\n            logger.warning(\n                \"collection_endpoint_name is ignored by the MethodViewResolver. \"\n                \"Requests to a collection endpoint will be routed to .get()\"\n            )\n        super().__init__(*args, **kwargs)\n\n    def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        view = None\n        for v in self.initialized_views:\n            # views returned by <class>.as_view\n            # have the origin class attached as .view_class\n            if v.view_class == view_cls:\n                view = v\n                break\n        if view is None:\n            # get the args and kwargs for this view\n            cls_arguments = self.class_arguments.get(view_name, {})\n            cls_args = cls_arguments.get(\"args\", ())\n            cls_kwargs = cls_arguments.get(\"kwargs\", {})\n            # call as_view to get a view function\n            # that is decorated with the classes\n            # decorator list, if any\n            view = view_cls.as_view(view_name, *cls_args, **cls_kwargs)\n            # add the view to the list of initialized views\n            # in order to call as_view only once\n            self.initialized_views.append(view)\n        # return the class as view function\n        # for each operation so that requests\n        # are dispatched with <class>.dispatch_request,\n        # when calling the view function\n        return view\n```"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "```python"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "\"\"\"\nThis module defines interfaces for requests and responses used in Connexion for authentication,\nvalidation, serialization, etc.\n\"\"\"\nimport typing as t\nfrom collections import defaultdict\n\nfrom python_multipart.multipart import parse_options_header\nfrom starlette.datastructures import UploadFile\nfrom starlette.requests import Request as StarletteRequest\nfrom werkzeug import Request as WerkzeugRequest\n\nfrom connexion.http_facts import FORM_CONTENT_TYPES\nfrom connexion.utils import is_json_mimetype"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "class _RequestInterface:\n    @property\n    def context(self) -> t.Dict[str, t.Any]:\n        \"\"\"The connexion context of the current request cycle.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def content_type(self) -> str:\n        \"\"\"The content type included in the request headers.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def mimetype(self) -> str:\n        \"\"\"The content type included in the request headers stripped from any optional character\n        set encoding\"\"\"\n        raise NotImplementedError\n\n    @property\n    def path_params(self) -> t.Dict[str, t.Any]:\n        \"\"\"Path parameters exposed as a dictionary\"\"\"\n        raise NotImplementedError\n\n    @property\n    def query_params(self) -> t.Dict[str, t.Any]:\n        \"\"\"Query parameters exposed as a dictionary\"\"\"\n        raise NotImplementedError\n\n    def form(self) -> t.Union[t.Dict[str, t.Any], t.Awaitable[t.Dict[str, t.Any]]]:\n        \"\"\"Form data, including files.\"\"\"\n        raise NotImplementedError\n\n    def files(self) -> t.Dict[str, t.Any]:\n        \"\"\"Files included in the request.\"\"\"\n        raise NotImplementedError\n\n    def json(self) -> dict:\n        \"\"\"Json data included in the request.\"\"\"\n        raise NotImplementedError\n\n    def get_body(self) -> t.Any:\n        \"\"\"Get body based on the content type. This returns json data for json content types,\n        form data for form content types, and bytes for all others. If the bytes data is empty,\n        :code:`None` is returned instead.\"\"\"\n        raise NotImplementedError"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "class WSGIRequest(_RequestInterface):\n    def __init__(\n        self, werkzeug_request: WerkzeugRequest, uri_parser=None, view_args=None\n    ):\n        self._werkzeug_request = werkzeug_request\n        self.uri_parser = uri_parser\n        self.view_args = view_args\n\n        self._context = None\n        self._path_params = None\n        self._query_params = None\n        self._form = None\n        self._body = None\n\n    @property\n    def context(self):\n        if self._context is None:\n            scope = self.environ[\"asgi.scope\"]\n            extensions = scope.setdefault(\"extensions\", {})\n            self._context = extensions.setdefault(\"connexion_context\", {})\n        return self._context\n\n    @property\n    def content_type(self) -> str:\n        return self._werkzeug_request.content_type or \"application/octet-stream\"\n\n    @property\n    def mimetype(self) -> str:\n        return self._werkzeug_request.mimetype\n\n    @property\n    def path_params(self):\n        if self._path_params is None:\n            self._path_params = self.uri_parser.resolve_path(self.view_args)\n        return self._path_params\n\n    @property\n    def query_params(self):\n        if self._query_params is None:\n            query_params = {k: self.args.getlist(k) for k in self.args}\n            self._query_params = self.uri_parser.resolve_query(query_params)\n        return self._query_params\n\n    def form(self):\n        if self._form is None:\n            form = self._werkzeug_request.form.to_dict(flat=False)\n            self._form = self.uri_parser.resolve_form(form)\n        return self._form\n\n    def files(self):\n        return self._werkzeug_request.files.to_dict(flat=False)\n\n    def json(self):\n        return self.get_json(silent=True)\n\n    def get_body(self):\n        if self._body is None:\n            if is_json_mimetype(self.content_type):\n                self._body = self.get_json(silent=True)\n            elif self.mimetype in FORM_CONTENT_TYPES:\n                self._body = self.form()\n            else:\n                # Return explicit None instead of empty bytestring so it is handled as null downstream\n                self._body = self.get_data() or None\n        return self._body\n\n    def __getattr__(self, item):\n        return getattr(self._werkzeug_request, item)"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "class ConnexionRequest(_RequestInterface):\n    \"\"\"\n    Implementation of the Connexion :code:`_RequestInterface` representing an ASGI request.\n\n    .. attribute:: _starlette_request\n        :noindex:\n\n        This class wraps a Starlette `Request <https://www.starlette.io/requests/#request>`_,\n        and provides access to its attributes by proxy.\n\n    \"\"\"\n\n    def __init__(self, *args, uri_parser=None, **kwargs):\n        # Might be set in `from_starlette_request` class method\n        if not hasattr(self, \"_starlette_request\"):\n            self._starlette_request = StarletteRequest(*args, **kwargs)\n        self.uri_parser = uri_parser\n\n        self._context = None\n        self._mimetype = None\n        self._path_params = None\n        self._query_params = None\n        self._form = None\n        self._files = None\n\n    @classmethod\n    def from_starlette_request(\n        cls, request: StarletteRequest, uri_parser=None\n    ) -> \"ConnexionRequest\":\n        # Instantiate the class, and set the `_starlette_request` property before initializing.\n        self = cls.__new__(cls)\n        self._starlette_request = request\n        self.__init__(uri_parser=uri_parser)  # type: ignore\n        return self\n\n    @property\n    def context(self):\n        if self._context is None:\n            extensions = self.scope.setdefault(\"extensions\", {})\n            self._context = extensions.setdefault(\"connexion_context\", {})\n        return self._context\n\n    @property\n    def content_type(self):\n        return self.headers.get(\"content-type\", \"application/octet-stream\")\n\n    @property\n    def mimetype(self):\n        if not self._mimetype:\n            mimetype, _ = parse_options_header(self.content_type)\n            self._mimetype = mimetype.decode()\n        return self._mimetype\n\n    @property\n    def path_params(self) -> t.Dict[str, t.Any]:\n        if self._path_params is None:\n            self._path_params = self.uri_parser.resolve_path(\n                self._starlette_request.path_params\n            )\n        return self._path_params\n\n    @property\n    def query_params(self):\n        if self._query_params is None:\n            args = self._starlette_request.query_params\n            query_params = {k: args.getlist(k) for k in args}\n            self._query_params = self.uri_parser.resolve_query(query_params)\n        return self._query_params\n\n    async def form(self):\n        if self._form is None:\n            await self._split_form_files()\n        return self._form\n\n    async def files(self):\n        if self._files is None:\n            await self._split_form_files()\n        return self._files\n\n    async def _split_form_files(self):\n        form_data = await self._starlette_request.form()\n\n        files = defaultdict(list)\n        form = defaultdict(list)\n        for k, v in form_data.multi_items():\n            if isinstance(v, UploadFile):\n                files[k].append(v)\n            else:\n                form[k].append(v)\n\n        self._files = files\n        self._form = self.uri_parser.resolve_form(form)\n\n    async def json(self):\n        try:\n            return await self._starlette_request.json()\n        except ValueError:\n            return None\n\n    async def get_body(self):\n        if is_json_mimetype(self.content_type):\n            return await self.json()\n        elif self.mimetype in FORM_CONTENT_TYPES:\n            return await self.form()\n        else:\n            # Return explicit None instead of empty bytestring so it is handled as null downstream\n            return await self.body() or None\n\n    def __getattr__(self, item):\n        if self.__getattribute__(\"_starlette_request\"):\n            return getattr(self._starlette_request, item)"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/connexion/connexion/lifecycle.py",
      "content": "class ConnexionResponse:\n    \"\"\"Connexion interface for a response.\"\"\"\n\n    def __init__(\n        self,\n        status_code=200,\n        mimetype=None,\n        content_type=None,\n        body=None,\n        headers=None,\n        is_streamed=False,\n    ):\n        self.status_code = status_code\n        self.mimetype = mimetype\n        self.content_type = content_type\n        self.body = body\n        self.headers = headers or {}\n        if content_type:\n            self.headers.update({\"Content-Type\": content_type})\n        self.is_streamed = is_streamed\n```"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "```"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "This module centralizes all functionality related to json encoding and decoding in Connexion.\n```\n```"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "import datetime\nimport functools\nimport json\nimport typing as t\nimport uuid\nfrom decimal import Decimal\n```\n```"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "def wrap_default(default_fn: t.Callable) -> t.Callable:\n    \"\"\"The Connexion defaults for JSON encoding. Handles extra types compared to the\n    built-in :class:`json.JSONEncoder`.\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`decimal.Decimal` is serialized to a float.\n    -   :class:`uuid.UUID` is serialized to a string.\n    \"\"\"\n\n    @functools.wraps(default_fn)\n    def wrapped_default(self, o):\n        if isinstance(o, datetime.datetime):\n            if o.tzinfo:\n                # eg: '2015-09-25T23:14:42.588601+00:00'\n                return o.isoformat(\"T\")\n            else:\n                # No timezone present - assume UTC.\n                # eg: '2015-09-25T23:14:42.588601Z'\n                return o.isoformat(\"T\") + \"Z\"\n\n        if isinstance(o, datetime.date):\n            return o.isoformat()\n\n        if isinstance(o, Decimal):\n            return float(o)\n\n        if isinstance(o, uuid.UUID):\n            return str(o)\n\n        return default_fn(self, o)\n\n    return wrapped_default\n```\n```"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "class JSONEncoder(json.JSONEncoder):\n    \"\"\"The default Connexion JSON encoder. Handles extra types compared to the\n    built-in :class:`json.JSONEncoder`.\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`uuid.UUID` is serialized to a string.\n    \"\"\"\n\n    @wrap_default\n    def default(self, o):\n        return super().default(o)\n```\n```"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/connexion/connexion/jsonifier.py",
      "content": "class Jsonifier:\n    \"\"\"\n    Central point to serialize and deserialize to/from JSon in Connexion.\n    \"\"\"\n\n    def __init__(self, json_=json, **kwargs):\n        \"\"\"\n        :param json_: json library to use. Must have loads() and dumps() method  # NOQA\n        :param kwargs: default arguments to pass to json.dumps()\n        \"\"\"\n        self.json = json_\n        self.dumps_args = kwargs\n        self.dumps_args.setdefault(\"cls\", JSONEncoder)\n\n    def dumps(self, data, **kwargs):\n        \"\"\"Central point where JSON serialization happens inside\n        Connexion.\n        \"\"\"\n        for k, v in self.dumps_args.items():\n            kwargs.setdefault(k, v)\n        return self.json.dumps(data, **kwargs) + \"\\n\"\n\n    def loads(self, data):\n        \"\"\"Central point where JSON deserialization happens inside\n        Connexion.\n        \"\"\"\n        if isinstance(data, bytes):\n            data = data.decode()\n\n        try:\n            return self.json.loads(data)\n        except Exception:\n            if isinstance(data, str):\n                return data\n```"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "```python"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "This module defines Python interfaces for OpenAPI specifications.\n\"\"\"\n\nimport abc\nimport copy\nimport json\nimport os\nimport pathlib\nimport pkgutil\nimport typing as t\nfrom collections.abc import Mapping\nfrom urllib.parse import urlsplit\n\nimport jinja2\nimport jsonschema\nimport yaml\nfrom jsonschema import Draft4Validator\nfrom jsonschema.validators import extend as extend_validator\n\nfrom .exceptions import InvalidSpecification\nfrom .json_schema import NullableTypeValidator, URLHandler, resolve_refs\nfrom .operations import AbstractOperation, OpenAPIOperation, Swagger2Operation\nfrom .utils import deep_get\n\nvalidate_properties = Draft4Validator.VALIDATORS[\"properties\"]"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "def create_spec_validator(spec: dict) -> Draft4Validator:\n    \"\"\"Create a Validator to validate an OpenAPI spec against the OpenAPI schema.\n\n    :param spec: specification to validate\n    \"\"\"\n    # Create an instance validator, which validates defaults against the spec itself instead of\n    # against the OpenAPI schema.\n    InstanceValidator = extend_validator(\n        Draft4Validator, {\"type\": NullableTypeValidator}\n    )\n    instance_validator = InstanceValidator(spec)\n\n    def validate_defaults(validator, properties, instance, schema):\n        \"\"\"Validation function to validate the `properties` subschema, enforcing each default\n        value validates against the schema in which it resides.\n        \"\"\"\n        valid = True\n        for error in validate_properties(validator, properties, instance, schema):\n            valid = False\n            yield error\n\n        # Validate default only when the subschema has validated successfully\n        if not valid:\n            return\n        if isinstance(instance, dict) and \"default\" in instance:\n            for error in instance_validator.evolve(schema=instance).iter_errors(\n                instance[\"default\"]\n            ):\n                yield error\n\n    SpecValidator = extend_validator(Draft4Validator, {\"properties\": validate_defaults})\n    return SpecValidator"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "NO_SPEC_VERSION_ERR_MSG = \"\"\"Unable to get the spec version.\nYou are missing either '\"swagger\": \"2.0\"' or '\"openapi\": \"3.0.0\"'\nfrom the top level of your spec.\"\"\""
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip(\"/\")"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "class Specification(Mapping):\n\n    operation_cls: t.Type[AbstractOperation]\n\n    def __init__(self, raw_spec, *, base_uri=\"\"):\n        self._raw_spec = copy.deepcopy(raw_spec)\n        self._set_defaults(raw_spec)\n        self._validate_spec(raw_spec)\n        self._spec = resolve_refs(raw_spec, base_uri=base_uri)\n\n    @classmethod\n    @abc.abstractmethod\n    def _set_defaults(cls, spec):\n        \"\"\"set some default values in the spec\"\"\"\n\n    @classmethod\n    def _validate_spec(cls, spec):\n        \"\"\"validate spec against schema\"\"\"\n        try:\n            OpenApiValidator = create_spec_validator(spec)\n            validator = OpenApiValidator(cls.openapi_schema)\n            validator.validate(spec)\n        except jsonschema.exceptions.ValidationError as e:\n            raise InvalidSpecification.create_from(e)\n\n    def get_path_params(self, path):\n        return deep_get(self._spec, [\"paths\", path]).get(\"parameters\", [])\n\n    def get_operation(self, path, method):\n        return deep_get(self._spec, [\"paths\", path, method])\n\n    @property\n    def raw(self):\n        return self._raw_spec\n\n    @property\n    def version(self):\n        return self._get_spec_version(self._spec)\n\n    @property\n    def security(self):\n        return self._spec.get(\"security\")\n\n    @property\n    @abc.abstractmethod\n    def security_schemes(self):\n        raise NotImplementedError\n\n    def __getitem__(self, k):\n        return self._spec[k]\n\n    def __iter__(self):\n        return self._spec.__iter__()\n\n    def __len__(self):\n        return self._spec.__len__()\n\n    @staticmethod\n    def _load_spec_from_file(arguments, specification):\n        \"\"\"\n        Loads a YAML specification file, optionally rendering it with Jinja2.\n\n        :param arguments: passed to Jinja2 renderer\n        :param specification: path to specification\n        \"\"\"\n        arguments = arguments or {}\n\n        with specification.open(mode=\"rb\") as openapi_yaml:\n            contents = openapi_yaml.read()\n            try:\n                openapi_template = contents.decode()\n            except UnicodeDecodeError:\n                openapi_template = contents.decode(\"utf-8\", \"replace\")\n\n            openapi_string = jinja2.Template(openapi_template).render(**arguments)\n            return yaml.safe_load(openapi_string)\n\n    @classmethod\n    def from_file(cls, spec, *, arguments=None, base_uri=\"\"):\n        \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n        specification_path = pathlib.Path(spec)\n        spec = cls._load_spec_from_file(arguments, specification_path)\n        return cls.from_dict(spec, base_uri=base_uri)\n\n    @classmethod\n    def from_url(cls, spec, *, base_uri=\"\"):\n        \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n        spec = URLHandler()(spec)\n        return cls.from_dict(spec, base_uri=base_uri)\n\n    @staticmethod\n    def _get_spec_version(spec):\n        try:\n            version_string = spec.get(\"openapi\") or spec.get(\"swagger\")\n        except AttributeError:\n            raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n        if version_string is None:\n            raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n        try:\n            version_tuple = tuple(map(int, version_string.split(\".\")))\n        except TypeError:\n            err = (\n                \"Unable to convert version string to semantic version tuple: \"\n                \"{version_string}.\"\n            )\n            err = err.format(version_string=version_string)\n            raise InvalidSpecification(err)\n        return version_tuple\n\n    @classmethod\n    def from_dict(cls, spec, *, base_uri=\"\"):\n        \"\"\"\n        Takes in a dictionary, and returns a Specification\n        \"\"\"\n\n        def enforce_string_keys(obj):\n            # YAML supports integer keys, but JSON does not\n            if isinstance(obj, dict):\n                return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n            return obj\n\n        spec = enforce_string_keys(spec)\n        version = cls._get_spec_version(spec)\n        if version < (3, 0, 0):\n            return Swagger2Specification(spec, base_uri=base_uri)\n        return OpenAPISpecification(spec, base_uri=base_uri)\n\n    def clone(self):\n        return type(self)(copy.deepcopy(self._spec))\n\n    @classmethod\n    def load(cls, spec, *, arguments=None):\n        if isinstance(spec, str) and (\n            spec.startswith(\"http://\") or spec.startswith(\"https://\")\n        ):\n            return cls.from_url(spec)\n        if not isinstance(spec, dict):\n            base_uri = f\"{pathlib.Path(spec).parent}{os.sep}\"\n            return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n        return cls.from_dict(spec)\n\n    def with_base_path(self, base_path):\n        new_spec = self.clone()\n        new_spec.base_path = base_path\n        return new_spec\n\n    @property\n    @abc.abstractmethod\n    def base_path(self):\n        pass\n\n    @base_path.setter\n    @abc.abstractmethod\n    def base_path(self, base_path):\n        pass"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "class Swagger2Specification(Specification):\n    \"\"\"Python interface for a Swagger 2 specification.\"\"\"\n\n    yaml_name = \"swagger.yaml\"\n    operation_cls = Swagger2Operation\n\n    openapi_schema = json.loads(\n        pkgutil.get_data(\"connexion\", \"resources/schemas/v2.0/schema.json\")  # type: ignore\n    )\n\n    @classmethod\n    def _set_defaults(cls, spec):\n        spec.setdefault(\"produces\", [])\n        spec.setdefault(\"consumes\", [\"application/json\"])\n        spec.setdefault(\"definitions\", {})\n        spec.setdefault(\"parameters\", {})\n        spec.setdefault(\"responses\", {})\n\n    @property\n    def produces(self):\n        return self._spec[\"produces\"]\n\n    @property\n    def consumes(self):\n        return self._spec[\"consumes\"]\n\n    @property\n    def definitions(self):\n        return self._spec[\"definitions\"]\n\n    @property\n    def parameter_definitions(self):\n        return self._spec[\"parameters\"]\n\n    @property\n    def response_definitions(self):\n        return self._spec[\"responses\"]\n\n    @property\n    def security_schemes(self):\n        return self._spec.get(\"securityDefinitions\", {})\n\n    @property\n    def base_path(self):\n        return canonical_base_path(self._spec.get(\"basePath\", \"\"))\n\n    @base_path.setter\n    def base_path(self, base_path):\n        base_path = canonical_base_path(base_path)\n        self._raw_spec[\"basePath\"] = base_path\n        self._spec[\"basePath\"] = base_path"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/connexion/connexion/spec.py",
      "content": "class OpenAPISpecification(Specification):\n    \"\"\"Python interface for an OpenAPI 3 specification.\"\"\"\n\n    yaml_name = \"openapi.yaml\"\n    operation_cls = OpenAPIOperation\n\n    openapi_schema = json.loads(\n        pkgutil.get_data(\"connexion\", \"resources/schemas/v3.0/schema.json\")  # type: ignore\n    )\n\n    @classmethod\n    def _set_defaults(cls, spec):\n        spec.setdefault(\"components\", {})\n\n    @property\n    def security_schemes(self):\n        return self._spec[\"components\"].get(\"securitySchemes\", {})\n\n    @property\n    def components(self):\n        return self._spec[\"components\"]\n\n    @property\n    def base_path(self):\n        servers = self._spec.get(\"servers\", [])\n        try:\n            # assume we're the first server in list\n            server = copy.deepcopy(servers[0])\n            server_vars = server.pop(\"variables\", {})\n            server[\"url\"] = server[\"url\"].format(\n                **{k: v[\"default\"] for k, v in server_vars.items()}\n            )\n            base_path = urlsplit(server[\"url\"]).path\n        except IndexError:\n            base_path = \"\"\n        return canonical_base_path(base_path)\n\n    @base_path.setter\n    def base_path(self, base_path):\n        base_path = canonical_base_path(base_path)\n        user_servers = [{\"url\": base_path}]\n        self._raw_spec[\"servers\"] = user_servers\n        self._spec[\"servers\"] = user_servers\n```"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/connexion/connexion/__main__.py",
      "content": "\"\"\"\nThis module provides an entrypoint for Connexion's CLI.\n\"\"\""
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/connexion/connexion/__main__.py",
      "content": "from connexion.cli import main  # pragma: no cover"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/connexion/connexion/__main__.py",
      "content": "main()  # pragma: no cover"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/connexion/connexion/mock.py",
      "content": "This module contains a mock resolver that returns mock functions for operations it cannot resolve."
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/connexion/connexion/mock.py",
      "content": "import functools\nimport logging\n\nfrom connexion.resolver import Resolution, Resolver, ResolverError\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/connexion/connexion/mock.py",
      "content": "class MockResolver(Resolver):\n    def __init__(self, mock_all):\n        super().__init__()\n        self.mock_all = mock_all\n        self._operation_id_counter = 1\n\n    def resolve(self, operation):\n        \"\"\"\n        Mock operation resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = self.resolve_operation_id(operation)\n        if not operation_id:\n            # just generate an unique operation ID\n            operation_id = f\"mock-{self._operation_id_counter}\"\n            self._operation_id_counter += 1\n\n        mock_func = functools.partial(self.mock_operation, operation=operation)\n        if self.mock_all:\n            func = mock_func\n        else:\n            try:\n                func = self.resolve_function_from_operation_id(operation_id)\n                msg = \"... Successfully resolved operationId '{}'! Mock is *not* used for this operation.\".format(\n                    operation_id\n                )\n                logger.debug(msg)\n            except ResolverError as resolution_error:\n                logger.debug(\n                    \"... {}! Mock function is used for this operation.\".format(\n                        resolution_error.args[0].capitalize()\n                    )\n                )\n                func = mock_func\n        return Resolution(func, operation_id)\n\n    def mock_operation(self, operation, *args, **kwargs):\n        resp, code = operation.example_response()\n        if resp is not None:\n            return resp, code\n        return (\n            \"No example response defined in the API, and response \"\n            \"auto-generation disabled. To enable response auto-generation, \"\n            \"install connexion using the mock extra (connexion[mock])\",\n            501,\n        )"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "```"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "\"\"\"\nModule containing all code related to json schema validation.\n\"\"\"\n\nimport contextlib\nimport io\nimport os\nimport typing as t\nimport urllib.parse\nimport urllib.request\nfrom collections.abc import Mapping\nfrom copy import deepcopy\n\nimport requests\nimport yaml\nfrom jsonschema import Draft4Validator, RefResolver\nfrom jsonschema.exceptions import RefResolutionError, ValidationError  # noqa\nfrom jsonschema.validators import extend\n\nfrom .utils import deep_get"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "class ExtendedSafeLoader(yaml.SafeLoader):\n    \"\"\"Extends the yaml SafeLoader to coerce all keys to string so the result is valid json.\"\"\"\n\n    def __init__(self, stream):\n        self.original_construct_mapping = self.construct_mapping\n        self.construct_mapping = self.extended_construct_mapping\n        super().__init__(stream)\n\n    def extended_construct_mapping(self, node, deep=False):\n        data = self.original_construct_mapping(node, deep)\n        return {str(key): data[key] for key in data}"
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "class FileHandler:\n    \"\"\"Handler to resolve file refs.\"\"\"\n\n    def __call__(self, uri):\n        filepath = self._uri_to_path(uri)\n        with open(filepath) as fh:\n            return yaml.load(fh, ExtendedSafeLoader)\n\n    @staticmethod\n    def _uri_to_path(uri):\n        parsed = urllib.parse.urlparse(uri)\n        host = \"{0}{0}{mnt}{0}\".format(os.path.sep, mnt=parsed.netloc)\n        return os.path.abspath(\n            os.path.join(host, urllib.request.url2pathname(parsed.path))\n        )"
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "class URLHandler:\n    \"\"\"Handler to resolve url refs.\"\"\"\n\n    def __call__(self, uri):\n        response = requests.get(uri)\n        response.raise_for_status()\n\n        data = io.StringIO(response.text)\n        with contextlib.closing(data) as fh:\n            return yaml.load(fh, ExtendedSafeLoader)"
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "handlers = {\n    \"http\": URLHandler(),\n    \"https\": URLHandler(),\n    \"file\": FileHandler(),\n    \"\": FileHandler(),\n}"
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "def resolve_refs(spec, store=None, base_uri=\"\"):\n    \"\"\"\n    Resolve JSON references like {\"$ref\": <some URI>} in a spec.\n    Optionally takes a store, which is a mapping from reference URLs to a\n    dereferenced objects. Prepopulating the store can avoid network calls.\n    \"\"\"\n    spec = deepcopy(spec)\n    store = store or {}\n    resolver = RefResolver(base_uri, spec, store, handlers=handlers)\n\n    def _do_resolve(node):\n        if isinstance(node, Mapping) and \"$ref\" in node:\n            path = node[\"$ref\"][2:].split(\"/\")\n            try:\n                # resolve known references\n                retrieved = deep_get(spec, path)\n                node.update(retrieved)\n                if isinstance(retrieved, Mapping) and \"$ref\" in retrieved:\n                    node = _do_resolve(node)\n                node.pop(\"$ref\", None)\n                return node\n            except KeyError:\n                # resolve external references\n                with resolver.resolving(node[\"$ref\"]) as resolved:\n                    return _do_resolve(resolved)\n        elif isinstance(node, Mapping):\n            for k, v in node.items():\n                node[k] = _do_resolve(v)\n        elif isinstance(node, (list, tuple)):\n            for i, _ in enumerate(node):\n                node[i] = _do_resolve(node[i])\n        return node\n\n    res = _do_resolve(spec)\n    return res"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "def format_error_with_path(exception: ValidationError) -> str:\n    \"\"\"Format a `ValidationError` with path to error.\"\"\"\n    error_path = \".\".join(str(item) for item in exception.path)\n    error_path_msg = f\" - '{error_path}'\" if error_path else \"\"\n    return error_path_msg"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "def allow_nullable(validation_fn: t.Callable) -> t.Callable:\n    \"\"\"Extend an existing validation function, so it allows nullable values to be null.\"\"\"\n\n    def nullable_validation_fn(validator, to_validate, instance, schema):\n        if instance is None and (\n            schema.get(\"x-nullable\") is True or schema.get(\"nullable\")\n        ):\n            return\n\n        yield from validation_fn(validator, to_validate, instance, schema)\n\n    return nullable_validation_fn"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "def validate_writeOnly(validator, wo, instance, schema):\n    yield ValidationError(\"Property is write-only\")"
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/connexion/connexion/json_schema.py",
      "content": "NullableTypeValidator = allow_nullable(Draft4Validator.VALIDATORS[\"type\"])\nNullableEnumValidator = allow_nullable(Draft4Validator.VALIDATORS[\"enum\"])\n\nDraft4RequestValidator = extend(\n    Draft4Validator,\n    {\n        \"type\": NullableTypeValidator,\n        \"enum\": NullableEnumValidator,\n    },\n)\n\nDraft4ResponseValidator = extend(\n    Draft4Validator,\n    {\n        \"type\": NullableTypeValidator,\n        \"enum\": NullableEnumValidator,\n        \"writeOnly\": validate_writeOnly,\n        \"x-writeOnly\": validate_writeOnly,\n    },\n)\n```"
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "import types\nimport typing as t"
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "_ReturnType = t.TypeVar(\"_ReturnType\")\nMaybeAwaitable = t.Union[t.Awaitable[_ReturnType], _ReturnType]"
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "Environ = t.Mapping[str, object]"
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "_WriteCallable = t.Callable[[bytes], t.Any]\n_ExcInfo = t.Tuple[type, BaseException, types.TracebackType]"
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "_StartResponseCallable = t.Callable[\n    [\n        str,  # status\n        t.Sequence[t.Tuple[str, str]],  # response headers\n    ],\n    _WriteCallable,  # write() callable\n]\n_StartResponseCallableWithExcInfo = t.Callable[\n    [\n        str,  # status\n        t.Sequence[t.Tuple[str, str]],  # response headers\n        t.Optional[_ExcInfo],  # exc_info\n    ],\n    _WriteCallable,  # write() callable\n]\nStartResponse = t.Union[_StartResponseCallable, _StartResponseCallableWithExcInfo]\nResponseStream = t.Iterable[bytes]"
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/connexion/connexion/types.py",
      "content": "WSGIApp = t.Callable[[Environ, StartResponse], ResponseStream]"
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "\"\"\"\nThis module defines a command-line interface (CLI) that runs an OpenAPI specification to be a\nstarting point for developing your API with Connexion.\n\"\"\""
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "import argparse\nimport importlib.metadata\nimport logging\nimport os\nimport sys\nimport typing as t\n\nimport connexion\nfrom connexion.apps import AbstractApp\nfrom connexion.mock import MockResolver\nfrom connexion.options import SwaggerUIOptions"
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "logger = logging.getLogger(__name__)\n\nFLASK_APP = \"flask\"\nASYNC_APP = \"async\"\nAVAILABLE_APPS = {\n    FLASK_APP: \"connexion.apps.flask.FlaskApp\",\n    ASYNC_APP: \"connexion.apps.asynchronous.AsyncApp\",\n}"
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "def run(app: AbstractApp, args: argparse.Namespace):\n    app.run(\"connexion.cli:create_app\", port=args.port, host=args.host, factory=True)"
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "parser = argparse.ArgumentParser()\n\nparser.add_argument(\n    \"--version\",\n    action=\"version\",\n    version=f\"Connexion {importlib.metadata.version('connexion')}\",\n)\n\nsubparsers = parser.add_subparsers()\nrun_parser = subparsers.add_parser(\"run\")\nrun_parser.set_defaults(func=run)\n\nrun_parser.add_argument(\"spec_file\", help=\"Path to OpenAPI specification.\")\nrun_parser.add_argument(\n    \"base_module_path\", nargs=\"?\", help=\"Root directory of handler code.\"\n)\nrun_parser.add_argument(\n    \"-p\", \"--port\", default=5000, type=int, help=\"Port to listen on.\"\n)\nrun_parser.add_argument(\n    \"-H\", \"--host\", default=\"127.0.0.1\", type=str, help=\"Host interface to bind on.\"\n)\nrun_parser.add_argument(\n    \"--stub\",\n    action=\"store_true\",\n    help=\"Returns status code 501, and `Not Implemented Yet` payload, for the endpoints which \"\n    \"handlers are not found.\",\n)\nrun_parser.add_argument(\n    \"--mock\",\n    choices=[\"all\", \"notimplemented\"],\n    help=\"Returns example data for all endpoints or for which handlers are not found.\",\n)\nrun_parser.add_argument(\n    \"--swagger-ui-path\",\n    help=\"Personalize what URL path the API console UI will be mounted.\",\n    default=\"/ui\",\n)\nrun_parser.add_argument(\n    \"--swagger-ui-template-dir\",\n    help=\"Path to a customized API console UI dashboard.\",\n)\nrun_parser.add_argument(\n    \"--auth-all-paths\",\n    help=\"Enable authentication to paths not defined in the spec.\",\n    action=\"store_true\",\n)\nrun_parser.add_argument(\n    \"--validate-responses\",\n    help=\"Enable validation of response values from operation handlers.\",\n    action=\"store_true\",\n)\nrun_parser.add_argument(\n    \"--strict-validation\",\n    help=\"Enable strict validation of request payloads.\",\n    action=\"store_true\",\n)\nrun_parser.add_argument(\n    \"-v\",\n    \"--verbose\",\n    help=\"Show verbose information.\",\n    action=\"count\",\n    default=0,\n)\nrun_parser.add_argument(\"--base-path\", help=\"Override the basePath in the API spec.\")\nrun_parser.add_argument(\n    \"--app-framework\",\n    \"-f\",\n    choices=list(AVAILABLE_APPS),\n    default=ASYNC_APP,\n    help=\"The app framework used to run the server\",\n)"
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "def create_app(args: t.Optional[argparse.Namespace] = None) -> AbstractApp:\n    \"\"\"Runs a server compliant with a OpenAPI/Swagger Specification file.\"\"\"\n    if args is None:\n        args = parser.parse_args()\n\n    if args.verbose == 1:\n        logging_level = logging.INFO\n    elif args.verbose >= 2:\n        logging_level = logging.DEBUG\n    else:\n        logging_level = logging.WARN\n\n    logging.basicConfig(level=logging_level)\n\n    if args.spec_file.startswith(\"http\") or args.spec_file.startswith(\"https\"):\n        spec_file_full_path = args.spec_file\n    else:\n        spec_file_full_path = os.path.abspath(args.spec_file)\n        py_module_path = args.base_module_path or os.path.dirname(spec_file_full_path)\n        sys.path.insert(1, os.path.abspath(py_module_path))\n        logger.debug(f\"Added {py_module_path} to system path.\")\n\n    resolver_error = None\n    if args.stub:\n        resolver_error = 501\n\n    api_extra_args = {}\n    if args.mock:\n        resolver = MockResolver(mock_all=args.mock == \"all\")\n        api_extra_args[\"resolver\"] = resolver\n\n    app_cls = connexion.utils.get_function_from_name(AVAILABLE_APPS[args.app_framework])\n\n    swagger_ui_options = SwaggerUIOptions(\n        swagger_ui_path=args.swagger_ui_path,\n        swagger_ui_template_dir=args.swagger_ui_template_dir,\n    )\n\n    app = app_cls(\n        __name__,\n        auth_all_paths=args.auth_all_paths,\n        swagger_ui_options=swagger_ui_options,\n    )\n\n    app.add_api(\n        spec_file_full_path,\n        base_path=args.base_path,\n        resolver_error=resolver_error,\n        validate_responses=args.validate_responses,\n        strict_validation=args.strict_validation,\n        **api_extra_args,\n    )\n\n    return app"
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/connexion/connexion/cli.py",
      "content": "def main(argv: t.Optional[t.List[str]] = None) -> None:\n    if argv is None:\n        argv = sys.argv[1:]\n    if not argv:\n        argv = [\"--help\"]\n\n    args = parser.parse_args(argv)\n    app = create_app(args)\n    args.func(app, args)"
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/connexion/connexion/http_facts.py",
      "content": "\"\"\"\nThis module contains definitions of the HTTP protocol.\n\"\"\""
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/connexion/connexion/http_facts.py",
      "content": "FORM_CONTENT_TYPES = [\"application/x-www-form-urlencoded\", \"multipart/form-data\"]"
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/connexion/connexion/http_facts.py",
      "content": "METHODS = {\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"}"
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/connexion/connexion/http_facts.py",
      "content": "HTTP_STATUS_CODES = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    102: \"Processing\",\n    103: \"Early Hints\",  # see RFC 8297\n    200: \"OK\",\n    201: \"Created\",\n    202: \"Accepted\",\n    203: \"Non Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    207: \"Multi Status\",\n    208: \"Already Reported\",  # see RFC 5842\n    226: \"IM Used\",  # see RFC 3229\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    306: \"Switch Proxy\",  # unused\n    307: \"Temporary Redirect\",\n    308: \"Permanent Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",  # unused\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    405: \"Method Not Allowed\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authentication Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Large\",\n    414: \"Request URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    418: \"I'm a teapot\",  # see RFC 2324\n    421: \"Misdirected Request\",  # see RFC 7540\n    422: \"Unprocessable Entity\",\n    423: \"Locked\",\n    424: \"Failed Dependency\",\n    425: \"Too Early\",  # see RFC 8470\n    426: \"Upgrade Required\",\n    428: \"Precondition Required\",  # see RFC 6585\n    429: \"Too Many Requests\",\n    431: \"Request Header Fields Too Large\",\n    449: \"Retry With\",  # proprietary MS extension\n    451: \"Unavailable For Legal Reasons\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\",\n    506: \"Variant Also Negotiates\",  # see RFC 2295\n    507: \"Insufficient Storage\",\n    508: \"Loop Detected\",  # see RFC 5842\n    510: \"Not Extended\",\n    511: \"Network Authentication Failed\",\n}"
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "```python"
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "import asyncio\nimport base64\nimport http.cookies\nimport logging\nimport os\nimport typing as t\n\nimport httpx\n\nfrom connexion.decorators.parameter import inspect_function_arguments\nfrom connexion.exceptions import OAuthProblem, OAuthResponseProblem, OAuthScopeProblem\nfrom connexion.lifecycle import ConnexionRequest\nfrom connexion.utils import get_function_from_name\n\nlogger = logging.getLogger(__name__)\n\n\nNO_VALUE = object()\n\"\"\"Sentinel value to indicate that no security credentials were found.\"\"\""
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class AbstractSecurityHandler:\n\n    required_scopes_kw = \"required_scopes\"\n    request_kw = \"request\"\n    client = None\n    security_definition_key: str\n    \"\"\"The key which contains the value for the function name to resolve.\"\"\"\n    environ_key: str\n    \"\"\"The name of the environment variable that can be used alternatively for the function name.\"\"\"\n\n    def get_fn(self, security_scheme, required_scopes):\n        \"\"\"Returns the handler function\"\"\"\n        security_func = self._resolve_func(security_scheme)\n        if not security_func:\n            logger.warning(\"... %s missing\", self.security_definition_key)\n            return None\n\n        return self._get_verify_func(security_func)\n\n    @classmethod\n    def _get_function(\n        cls,\n        security_definition: dict,\n        security_definition_key: str,\n        environ_key: str,\n        default: t.Optional[t.Callable] = None,\n    ):\n        \"\"\"\n        Return function by getting its name from security_definition or environment variable\n\n        :param security_definition: Security Definition (scheme) from the spec.\n        :param security_definition_key: The key which contains the value for the function name to resolve.\n        :param environ_key: The name of the environment variable that can be used alternatively for the function name.\n        :param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key\n        \"\"\"\n        func_name = security_definition.get(security_definition_key) or os.environ.get(\n            environ_key\n        )\n        if func_name:\n            return get_function_from_name(func_name)\n        return default\n\n    def _generic_check(self, func, exception_msg):\n        async def wrapper(request, *args, required_scopes=None):\n            kwargs = {}\n            if self._accepts_kwarg(func, self.required_scopes_kw):\n                kwargs[self.required_scopes_kw] = required_scopes\n            if self._accepts_kwarg(func, self.request_kw):\n                kwargs[self.request_kw] = request\n            token_info = func(*args, **kwargs)\n            while asyncio.iscoroutine(token_info):\n                token_info = await token_info\n            if token_info is NO_VALUE:\n                return NO_VALUE\n            if token_info is None:\n                raise OAuthResponseProblem(detail=exception_msg)\n            return token_info\n\n        return wrapper\n\n    @staticmethod\n    def get_auth_header_value(request):\n        \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n        authorization = request.headers.get(\"Authorization\")\n        if not authorization:\n            return None, None\n\n        try:\n            auth_type, value = authorization.split(maxsplit=1)\n        except ValueError:\n            raise OAuthProblem(detail=\"Invalid authorization header\")\n        return auth_type.lower(), value\n\n    @staticmethod\n    def _accepts_kwarg(func: t.Callable, keyword: str) -> bool:\n        \"\"\"Check if the function accepts the provided keyword argument.\"\"\"\n        arguments, has_kwargs = inspect_function_arguments(func)\n        return has_kwargs or keyword in arguments\n\n    def _resolve_func(self, security_scheme):\n        \"\"\"\n        Get the user function object based on the security scheme or the environment variable.\n\n        :param security_scheme: Security Definition (scheme) from the spec.\n        \"\"\"\n        return self._get_function(\n            security_scheme, self.security_definition_key, self.environ_key\n        )\n\n    def _get_verify_func(self, function):\n        \"\"\"\n        Wraps the user security function in a function that checks the request for the correct\n        security credentials and calls the user function with the correct arguments.\n        \"\"\"\n        return self._generic_check(function, \"Provided authorization is not valid\")"
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class BasicSecurityHandler(AbstractSecurityHandler):\n    \"\"\"\n    Security Handler for\n    - `type: basic` (Swagger 2), and\n    - `type: http` and `scheme: basic` (OpenAPI 3)\n    \"\"\"\n\n    security_definition_key = \"x-basicInfoFunc\"\n    environ_key = \"BASICINFO_FUNC\"\n\n    def _get_verify_func(self, basic_info_func):\n        check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n        def wrapper(request):\n            auth_type, user_pass = self.get_auth_header_value(request)\n            if auth_type != \"basic\":\n                return NO_VALUE\n\n            try:\n                username, password = (\n                    base64.b64decode(user_pass).decode(\"latin1\").split(\":\", 1)\n                )\n            except Exception:\n                raise OAuthProblem(detail=\"Invalid authorization header\")\n\n            return check_basic_info_func(request, username, password)\n\n        return wrapper\n\n    def check_basic_auth(self, basic_info_func):\n        return self._generic_check(\n            basic_info_func, \"Provided authorization is not valid\"\n        )"
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class BearerSecurityHandler(AbstractSecurityHandler):\n    \"\"\"\n    Security Handler for HTTP Bearer authentication.\n    \"\"\"\n\n    security_definition_key = \"x-bearerInfoFunc\"\n    environ_key = \"BEARERINFO_FUNC\"\n\n    def check_bearer_token(self, token_info_func):\n        return self._generic_check(token_info_func, \"Provided token is not valid\")\n\n    def _get_verify_func(self, token_info_func):\n        \"\"\"\n        :param token_info_func: types.FunctionType\n        :rtype: types.FunctionType\n        \"\"\"\n        check_bearer_func = self.check_bearer_token(token_info_func)\n\n        def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n            return check_bearer_func(request, token)\n\n        return wrapper"
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class ApiKeySecurityHandler(AbstractSecurityHandler):\n    \"\"\"\n    Security Handler for API Keys.\n    \"\"\"\n\n    security_definition_key = \"x-apikeyInfoFunc\"\n    environ_key = \"APIKEYINFO_FUNC\"\n\n    def get_fn(self, security_scheme, required_scopes):\n        apikey_info_func = self._resolve_func(security_scheme)\n        if not apikey_info_func:\n            logger.warning(\"... %s missing\", self.security_definition_key)\n            return None\n\n        return self._get_verify_func(\n            apikey_info_func,\n            security_scheme[\"in\"],\n            security_scheme[\"name\"],\n            required_scopes,\n        )\n\n    def _get_verify_func(self, api_key_info_func, loc, name, required_scopes):\n        check_api_key_func = self.check_api_key(api_key_info_func)\n\n        def wrapper(request: ConnexionRequest):\n            if loc == \"query\":\n                api_key = request.query_params.get(name)\n            elif loc == \"header\":\n                api_key = request.headers.get(name)\n            elif loc == \"cookie\":\n                cookie_list = request.headers.get(\"Cookie\")\n                api_key = self.get_cookie_value(cookie_list, name)\n            else:\n                return NO_VALUE\n\n            if api_key is None:\n                return NO_VALUE\n\n            return check_api_key_func(request, api_key, required_scopes=required_scopes)\n\n        return wrapper\n\n    def check_api_key(self, api_key_info_func):\n        return self._generic_check(api_key_info_func, \"Provided apikey is not valid\")\n\n    @staticmethod\n    def get_cookie_value(cookies, name):\n        \"\"\"\n        Returns cookie value by its name. `None` if no such value.\n\n        :param cookies: str: cookies raw data\n        :param name: str: cookies key\n        \"\"\"\n        cookie_parser = http.cookies.SimpleCookie()\n        cookie_parser.load(str(cookies))\n        try:\n            return cookie_parser[name].value\n        except KeyError:\n            return None"
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class OAuthSecurityHandler(AbstractSecurityHandler):\n    \"\"\"\n    Security Handler for the OAuth security scheme.\n    \"\"\"\n\n    def get_fn(self, security_scheme, required_scopes):\n        token_info_func = self.get_tokeninfo_func(security_scheme)\n        scope_validate_func = self.get_scope_validate_func(security_scheme)\n        if not token_info_func:\n            logger.warning(\"... x-tokenInfoFunc missing\")\n            return None\n\n        return self._get_verify_func(\n            token_info_func, scope_validate_func, required_scopes\n        )\n\n    def get_tokeninfo_func(self, security_definition: dict) -> t.Optional[t.Callable]:\n        \"\"\"\n        Gets the function for retrieving the token info.\n        It is possible to specify a function or a URL. The function variant is\n        preferred. If it is not found, the URL variant is used with the\n        `get_token_info_remote` function.\n\n        >>> get_tokeninfo_func({'x-tokenInfoFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n        token_info_func = self._get_function(\n            security_definition, \"x-tokenInfoFunc\", \"TOKENINFO_FUNC\"\n        )\n        if token_info_func:\n            return token_info_func\n\n        token_info_url = security_definition.get(\"x-tokenInfoUrl\") or os.environ.get(\n            \"TOKENINFO_URL\"\n        )\n        if token_info_url:\n            return self.get_token_info_remote(token_info_url)\n\n        return None\n\n    @classmethod\n    def get_scope_validate_func(cls, security_definition):\n        \"\"\"\n        Gets the function for validating the token scopes.\n        If it is not found, the default `validate_scope` function is used.\n\n        >>> get_scope_validate_func({'x-scopeValidateFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n        return cls._get_function(\n            security_definition,\n            \"x-scopeValidateFunc\",\n            \"SCOPEVALIDATE_FUNC\",\n            cls.validate_scope,\n        )\n\n    @staticmethod\n    def validate_scope(required_scopes, token_scopes):\n        \"\"\"\n        :param required_scopes: Scopes required to access operation\n        :param token_scopes: Scopes granted by authorization server\n        :rtype: bool\n        \"\"\"\n        required_scopes = set(required_scopes)\n        if isinstance(token_scopes, list):\n            token_scopes = set(token_scopes)\n        else:\n            token_scopes = set(token_scopes.split())\n        logger.debug(\"... Scopes required: %s\", required_scopes)\n        logger.debug(\"... Token scopes: %s\", token_scopes)\n        if not required_scopes <= token_scopes:\n            logger.info(\n                \"... Token scopes (%s) do not match the scopes necessary to call endpoint (%s).\"\n                \" Aborting with 403.\",\n                token_scopes,\n                required_scopes,\n            )\n            return False\n        return True\n\n    def get_token_info_remote(self, token_info_url: str) -> t.Callable:\n        \"\"\"\n        Return a function which will call `token_info_url` to retrieve token info.\n\n        Returned function must accept oauth token in parameter.\n        It must return a token_info dict in case of success, None otherwise.\n\n        :param token_info_url: URL to get information about the token\n        \"\"\"\n\n        async def wrapper(token):\n            if self.client is None:\n                self.client = httpx.AsyncClient()\n            headers = {\"Authorization\": f\"Bearer {token}\"}\n            token_request = await self.client.get(\n                token_info_url, headers=headers, timeout=5\n            )\n            if token_request.status_code != 200:\n                return\n            return token_request.json()\n\n        return wrapper\n\n    def _get_verify_func(self, token_info_func, scope_validate_func, required_scopes):\n        check_oauth_func = self.check_oauth_func(token_info_func, scope_validate_func)\n\n        def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n\n            return check_oauth_func(request, token, required_scopes=required_scopes)\n\n        return wrapper\n\n    def check_oauth_func(self, token_info_func, scope_validate_func):\n        get_token_info = self._generic_check(\n            token_info_func, \"Provided token is not valid\"\n        )\n\n        async def wrapper(request, token, required_scopes):\n            token_info = await get_token_info(\n                request, token, required_scopes=required_scopes\n            )\n\n            # Fallback to 'scopes' for backward compatibility\n            token_scopes = token_info.get(\"scope\", token_info.get(\"scopes\", \"\"))\n\n            validation = scope_validate_func(required_scopes, token_scopes)\n            while asyncio.iscoroutine(validation):\n                validation = await validation\n            if not validation:\n                raise OAuthScopeProblem(\n                    required_scopes=required_scopes,\n                    token_scopes=token_scopes,\n                )\n\n            return token_info\n\n        return wrapper"
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "SECURITY_HANDLERS = {\n    # Swagger 2: `type: basic`\n    # OpenAPI 3: `type: http` and `scheme: basic`\n    \"basic\": BasicSecurityHandler,\n    # Swagger 2 and OpenAPI 3\n    \"apiKey\": ApiKeySecurityHandler,\n    \"oauth2\": OAuthSecurityHandler,\n    # OpenAPI 3: http schemes\n    \"bearer\": BearerSecurityHandler,\n}"
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/connexion/connexion/security.py",
      "content": "class SecurityHandlerFactory:\n    \"\"\"\n    A factory class for parsing security schemes and returning the appropriate\n    security handler.\n\n    By default, it will use the built-in security handlers specified in the\n    SECURITY_HANDLERS dict, but you can also pass in your own security handlers\n    to override the built-in ones.\n    \"\"\"\n\n    def __init__(\n        self,\n        security_handlers: t.Optional[dict] = None,\n    ) -> None:\n        self.security_handlers = SECURITY_HANDLERS.copy()\n        if security_handlers is not None:\n            self.security_handlers.update(security_handlers)\n\n    def parse_security_scheme(\n        self,\n        security_scheme: dict,\n        required_scopes: t.List[str],\n    ) -> t.Optional[t.Callable]:\n        \"\"\"Parses the security scheme and returns the function for verifying it.\n\n        :param security_scheme: The security scheme from the spec.\n        :param required_scopes: List of scopes for this security scheme.\n        \"\"\"\n        security_type = security_scheme[\"type\"]\n        if security_type in (\"basic\", \"oauth2\"):\n            security_handler = self.security_handlers[security_type]\n            return security_handler().get_fn(security_scheme, required_scopes)\n\n        # OpenAPI 3.0.0\n        elif security_type == \"http\":\n            scheme = security_scheme[\"scheme\"].lower()\n            if scheme in self.security_handlers:\n                security_handler = self.security_handlers[scheme]\n                return security_handler().get_fn(security_scheme, required_scopes)\n            else:\n                logger.warning(\"... Unsupported http authorization scheme %s\", scheme)\n                return None\n\n        elif security_type == \"apiKey\":\n            scheme = security_scheme.get(\"x-authentication-scheme\", \"\").lower()\n            if scheme == \"bearer\":\n                return BearerSecurityHandler().get_fn(security_scheme, required_scopes)\n            else:\n                security_handler = self.security_handlers[\"apiKey\"]\n                return security_handler().get_fn(security_scheme, required_scopes)\n\n        # Custom security handler\n        elif (scheme := security_scheme[\"scheme\"].lower()) in self.security_handlers:\n            security_handler = self.security_handlers[scheme]\n            return security_handler().get_fn(security_scheme, required_scopes)\n\n        else:\n            logger.warning(\n                \"... Unsupported security scheme type %s\",\n                security_type,\n            )\n            return None\n\n    @staticmethod\n    async def security_passthrough(request):\n        \"\"\"Used when no security is required for the operation.\n\n        Equivalent OpenAPI snippet:\n\n        .. code-block:: yaml\n\n            /helloworld\n              get:\n                security: []   # No security\n                ...\n        \"\"\"\n        return request\n\n    @staticmethod\n    def verify_none(request):\n        \"\"\"Used for optional security.\n\n        Equivalent OpenAPI snippet:\n\n        .. code-block:: yaml\n\n            security:\n              - {}  # <--\n              - myapikey: []\n        \"\"\"\n        return {}\n\n    def verify_multiple_schemes(self, schemes):\n        \"\"\"\n        Verifies multiple authentication schemes in AND fashion.\n        If any scheme fails, the entire authentication fails.\n\n        :param schemes: mapping scheme_name to auth function\n        :type schemes: dict\n        :rtype: types.FunctionType\n        \"\"\"\n\n        async def wrapper(request):\n            token_info = {}\n            for scheme_name, func in schemes.items():\n                result = func(request)\n                while asyncio.iscoroutine(result):\n                    result = await result\n                if result is NO_VALUE:\n                    return NO_VALUE\n                token_info[scheme_name] = result\n\n            return token_info\n\n        return wrapper\n\n    @classmethod\n    def verify_security(cls, auth_funcs):\n        async def verify_fn(request):\n            token_info = NO_VALUE\n            errors = []\n            for func in auth_funcs:\n                try:\n                    token_info = func(request)\n                    while asyncio.iscoroutine(token_info):\n                        token_info = await token_info\n                    if token_info is not NO_VALUE:\n                        break\n                except Exception as err:\n                    errors.append(err)\n\n            else:\n                if errors != []:\n                    cls._raise_most_specific(errors)\n                else:\n                    logger.info(\"... No auth provided. Aborting with 401.\")\n                    raise OAuthProblem(detail=\"No authorization token provided\")\n\n            request.context.update(\n                {\n                    # Fallback to 'uid' for backward compatibility\n                    \"user\": token_info.get(\"sub\", token_info.get(\"uid\")),\n                    \"token_info\": token_info,\n                }\n            )\n\n        return verify_fn\n\n    @staticmethod\n    def _raise_most_specific(exceptions: t.List[Exception]) -> None:\n        \"\"\"Raises the most specific error from a list of exceptions by status code.\n\n        The status codes are expected to be either in the `code`\n        or in the `status` attribute of the exceptions.\n\n        The order is as follows:\n            - 403: valid credentials but not enough privileges\n            - 401: no or invalid credentials\n            - for other status codes, the smallest one is selected\n\n        :param errors: List of exceptions.\n        :type errors: t.List[Exception]\n        \"\"\"\n        if not exceptions:\n            return\n        # We only use status code attributes from exceptions\n        # We use 600 as default because 599 is highest valid status code\n        status_to_exc = {\n            getattr(exc, \"status_code\", getattr(exc, \"status\", 600)): exc\n            for exc in exceptions\n        }\n        if 403 in status_to_exc:\n            raise status_to_exc[403]\n        elif 401 in status_to_exc:\n            raise status_to_exc[401]\n        else:\n            lowest_status_code = min(status_to_exc)\n            raise status_to_exc[lowest_status_code]\n```"
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/connexion/connexion/testing.py",
      "content": "import contextvars\nimport typing as t\nfrom unittest.mock import MagicMock\n\nfrom starlette.types import Receive, Scope\n\nfrom connexion.context import _context, _operation, _receive, _scope\nfrom connexion.operations import AbstractOperation"
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/connexion/connexion/testing.py",
      "content": "class TestContext:\n    __test__ = False  # Pytest\n\n    def __init__(\n        self,\n        *,\n        context: t.Optional[dict] = None,\n        operation: t.Optional[AbstractOperation] = None,\n        receive: t.Optional[Receive] = None,\n        scope: t.Optional[Scope] = None,\n    ) -> None:\n        self.context = context if context is not None else self.build_context()\n        self.operation = operation if operation is not None else self.build_operation()\n        self.receive = receive if receive is not None else self.build_receive()\n        self.scope = scope if scope is not None else self.build_scope()\n\n        self.tokens: t.Dict[str, contextvars.Token] = {}\n\n    def __enter__(self) -> None:\n        self.tokens[\"context\"] = _context.set(self.context)\n        self.tokens[\"operation\"] = _operation.set(self.operation)\n        self.tokens[\"receive\"] = _receive.set(self.receive)\n        self.tokens[\"scope\"] = _scope.set(self.scope)\n        return\n\n    def __exit__(self, type, value, traceback):\n        _context.reset(self.tokens[\"context\"])\n        _operation.reset(self.tokens[\"operation\"])\n        _receive.reset(self.tokens[\"receive\"])\n        _scope.reset(self.tokens[\"scope\"])\n        return False\n\n    @staticmethod\n    def build_context() -> dict:\n        return {}\n\n    @staticmethod\n    def build_operation() -> AbstractOperation:\n        return MagicMock(name=\"operation\")\n\n    @staticmethod\n    def build_receive() -> Receive:\n        async def receive() -> t.MutableMapping[str, t.Any]:\n            return {\n                \"type\": \"http.request\",\n                \"body\": b\"\",\n            }\n\n        return receive\n\n    @staticmethod\n    def build_scope(**kwargs) -> Scope:\n        scope = {\n            \"type\": \"http\",\n            \"query_string\": b\"\",\n            \"headers\": [(b\"Content-Type\", b\"application/octet-stream\")],\n        }\n\n        for key, value in kwargs.items():\n            scope[key] = value\n\n        return scope"
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/connexion/connexion/problem.py",
      "content": "\"\"\"\nThis module contains a Python interface for Problem Details for HTTP APIs\n<https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>, which is a standardized format\nto communicate distinct \"problem types\" to non-human consumers.\n\"\"\""
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/connexion/connexion/problem.py",
      "content": "import json"
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/connexion/connexion/problem.py",
      "content": "def problem(status, title, detail, type=None, instance=None, headers=None, ext=None):\n    \"\"\"\n    Returns a `Problem Details <https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>`_ error response.\n\n\n    :param status: The HTTP status code generated by the origin server for this occurrence of the problem.\n    :type status: int\n    :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to\n                  occurrence of the problem, except for purposes of localisation.\n    :type title: str\n    :param detail: An human readable explanation specific to this occurrence of the problem.\n    :type detail: str\n    :param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide human-readable\n                 documentation for the problem type (e.g., using HTML).  When this member is not present its value is\n                 assumed to be \"about:blank\".\n    :type: type: str\n    :param instance: An absolute URI that identifies the specific occurrence of the problem.  It may or may not yield\n                     further information if dereferenced.\n    :type instance: str\n    :param headers: HTTP headers to include in the response\n    :type headers: dict | None\n    :param ext: Extension members to include in the body\n    :type ext: dict | None\n    :return: error response\n    :rtype: ConnexionResponse\n    \"\"\"\n    from .lifecycle import ConnexionResponse  # prevent circular import\n\n    if not type:\n        type = \"about:blank\"\n\n    problem_response = {\n        \"type\": type,\n        \"title\": title,\n        \"detail\": detail,\n        \"status\": status,\n    }\n    if instance:\n        problem_response[\"instance\"] = instance\n    if ext:\n        problem_response.update(ext)\n\n    mimetype = content_type = \"application/problem+json\"\n\n    return ConnexionResponse(\n        status,\n        mimetype,\n        content_type,\n        body=json.dumps(problem_response),\n        headers=headers,\n    )"
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/connexion/connexion/options.py",
      "content": "\"\"\"\nThis module defines a Connexion specific options class to pass to the Connexion App or API.\n\"\"\"\nimport dataclasses\nimport logging\nimport typing as t\n\ntry:\n    from swagger_ui_bundle import swagger_ui_path as default_template_dir\nexcept ImportError:\n    default_template_dir = None\n\nNO_UI_MSG = \"\"\"The swagger_ui directory could not be found.\n    Please install connexion with extra install: pip install connexion[swagger-ui]\n    or provide the path to your local installation by passing swagger_path=<your path>\n\"\"\"\n\nlogger = logging.getLogger(\"connexion.options\")"
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/connexion/connexion/options.py",
      "content": "@dataclasses.dataclass\nclass SwaggerUIOptions:\n    \"\"\"Options to configure the Swagger UI.\n\n    :param serve_spec: Whether to serve the Swagger / OpenAPI Specification\n    :param spec_path: Where to serve the Swagger / OpenAPI Specification\n\n    :param swagger_ui: Whether to serve the Swagger UI\n    :param swagger_ui_path: Where to serve the Swagger UI\n    :param swagger_ui_config: Options to configure the Swagger UI. See\n          https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration\n          for an overview of the available options.\n    :param swagger_ui_template_dir: Directory with static files to use to serve Swagger UI\n    :param swagger_ui_template_arguments: Arguments passed to the Swagger UI template. Useful\n        when providing your own template dir with additional template arguments.\n    \"\"\"\n\n    serve_spec: bool = True\n    spec_path: t.Optional[str] = None\n\n    swagger_ui: bool = True\n    swagger_ui_config: dict = dataclasses.field(default_factory=dict)\n    swagger_ui_path: str = \"/ui\"\n    swagger_ui_template_dir: t.Optional[str] = None\n    swagger_ui_template_arguments: dict = dataclasses.field(default_factory=dict)"
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/connexion/connexion/options.py",
      "content": "class SwaggerUIConfig:\n    \"\"\"Class holding swagger UI specific options.\"\"\"\n\n    def __init__(\n        self,\n        options: t.Optional[SwaggerUIOptions] = None,\n        oas_version: t.Tuple[int, ...] = (2,),\n    ):\n        if oas_version >= (3, 0, 0):\n            self.spec_path = \"/openapi.json\"\n        else:\n            self.spec_path = \"/swagger.json\"\n\n        if options is not None and not isinstance(options, SwaggerUIOptions):\n            raise ValueError(\n                f\"`swaggger_ui_options` should be of type `SwaggerUIOptions`, \"\n                f\"but received {type(options)} instead.\"\n            )\n\n        self._options = options or SwaggerUIOptions()\n\n    @property\n    def openapi_spec_available(self) -> bool:\n        \"\"\"Whether to make the OpenAPI Specification available.\"\"\"\n        return self._options.serve_spec\n\n    @property\n    def openapi_spec_path(self) -> str:\n        \"\"\"Path to host the Swagger UI.\"\"\"\n        return self._options.spec_path or self.spec_path\n\n    @property\n    def swagger_ui_available(self) -> bool:\n        \"\"\"Whether to make the Swagger UI available.\"\"\"\n        if self._options.swagger_ui and self.swagger_ui_template_dir is None:\n            logger.warning(NO_UI_MSG)\n            return False\n        return self._options.swagger_ui\n\n    @property\n    def swagger_ui_path(self) -> str:\n        \"\"\"Path to mount the Swagger UI and make it accessible via a browser.\"\"\"\n        return self._options.swagger_ui_path\n\n    @property\n    def swagger_ui_template_dir(self) -> str:\n        \"\"\"Directory with static files to use to serve Swagger UI.\"\"\"\n        return self._options.swagger_ui_template_dir or default_template_dir\n\n    @property\n    def swagger_ui_config(self) -> dict:\n        \"\"\"Options to configure the Swagger UI.\"\"\"\n        return self._options.swagger_ui_config\n\n    @property\n    def swagger_ui_template_arguments(self) -> dict:\n        \"\"\"Arguments passed to the Swagger UI template.\"\"\"\n        return self._options.swagger_ui_template_arguments"
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/connexion/connexion/datastructures.py",
      "content": "from fnmatch import fnmatch"
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/connexion/connexion/datastructures.py",
      "content": "NoContent = object()"
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/connexion/connexion/datastructures.py",
      "content": "class MediaTypeDict(dict):\n    \"\"\"\n    A dictionary where keys can be either media types or media type ranges. When fetching a\n    value from the dictionary, the provided key is checked against the ranges. The most specific\n    key is chosen as prescribed by the OpenAPI spec, with `type/*` being preferred above\n    `*/subtype`.\n    \"\"\"\n\n    def __getitem__(self, item):\n        # Sort keys in order of specificity\n        for key in sorted(self, key=lambda k: (\"*\" not in k, k), reverse=True):\n            if fnmatch(item, key):\n                return super().__getitem__(key)\n        raise super().__getitem__(item)\n\n    def get(self, item, default=None):\n        try:\n            return self[item]\n        except KeyError:\n            return default\n\n    def __contains__(self, item):\n        try:\n            self[item]\n        except KeyError:\n            return False\n        else:\n            return True"
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/connexion/connexion/handlers.py",
      "content": "\"\"\"\nThis module defines error handlers, operations that produce proper response problems.\n\"\"\""
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/connexion/connexion/handlers.py",
      "content": "import logging\n\nfrom .exceptions import ResolverProblem\n\nlogger = logging.getLogger(\"connexion.handlers\")\n\nRESOLVER_ERROR_ENDPOINT_RANDOM_DIGITS = 6"
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/connexion/connexion/handlers.py",
      "content": "class ResolverErrorHandler:\n    \"\"\"\n    Handler for responding to ResolverError.\n    \"\"\"\n\n    def __init__(self, status_code, exception):\n        self.status_code = status_code\n        self.exception = exception\n\n    @property\n    def function(self):\n        return self.handle\n\n    def handle(self, *args, **kwargs):\n        raise ResolverProblem(\n            detail=self.exception.args[0],\n            status=self.status_code,\n        )\n\n    @property\n    def operation_id(self):\n        return \"noop\"\n\n    @property\n    def randomize_endpoint(self):\n        return RESOLVER_ERROR_ENDPOINT_RANDOM_DIGITS\n\n    def get_path_parameter_types(self):\n        return {}\n\n    @property\n    def uri_parser_class(self):\n        return \"dummy\"\n\n    @property\n    def api(self):\n        return \"dummy\"\n\n    def get_mimetype(self):\n        return \"dummy\"\n\n    async def __call__(self, *args, **kwargs):\n        raise ResolverProblem(\n            detail=self.exception.args[0],\n            status=self.status_code,\n        )"
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "from contextvars import ContextVar\n\nfrom starlette.types import Receive, Scope\nfrom werkzeug.local import LocalProxy\n\nfrom connexion.lifecycle import ConnexionRequest\nfrom connexion.operations import AbstractOperation\n\nUNBOUND_MESSAGE = (\n    \"Working outside of operation context. Make sure your app is wrapped in a \"\n    \"ContextMiddleware and you're processing a request while accessing the context.\"\n)"
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "_context: ContextVar[dict] = ContextVar(\"CONTEXT\")\ncontext = LocalProxy(_context, unbound_message=UNBOUND_MESSAGE)"
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "_operation: ContextVar[AbstractOperation] = ContextVar(\"OPERATION\")\noperation = LocalProxy(_operation, unbound_message=UNBOUND_MESSAGE)"
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "_receive: ContextVar[Receive] = ContextVar(\"RECEIVE\")\nreceive = LocalProxy(_receive, unbound_message=UNBOUND_MESSAGE)"
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "_scope: ContextVar[Scope] = ContextVar(\"SCOPE\")\nscope = LocalProxy(_scope, unbound_message=UNBOUND_MESSAGE)"
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/connexion/connexion/context.py",
      "content": "request = LocalProxy(\n    lambda: ConnexionRequest(scope, receive), unbound_message=UNBOUND_MESSAGE\n)"
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "\"\"\"\nThis module defines Exception classes used by Connexion to generate a proper response.\n\"\"\""
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "import typing as t\n\nfrom jsonschema.exceptions import ValidationError\nfrom starlette.exceptions import HTTPException\n\nfrom .problem import problem"
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ConnexionException(Exception):\n    \"\"\"Base class for any exception thrown by the Connexion framework.\"\"\""
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ResolverError(LookupError, ConnexionException):\n    \"\"\"Error raised at startup when the resolver cannot find a view function for an endpoint in\n    your specification, and no ``resolver_error`` is configured.\"\"\""
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class InvalidSpecification(ValidationError, ConnexionException):\n    \"\"\"Error raised at startup when the provided specification cannot be validated.\"\"\""
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class MissingMiddleware(ConnexionException):\n    \"\"\"Error raised when you're leveraging behavior that depends on a specific middleware,\n    and that middleware is not part of your middleware stack.\"\"\""
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ProblemException(HTTPException, ConnexionException):\n    \"\"\"\n    This exception holds arguments that are going to be passed to the\n    `connexion.problem` function to generate a proper response.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        status=500,\n        title=None,\n        detail=None,\n        type=None,\n        instance=None,\n        headers=None,\n        ext=None,\n    ):\n        self.status = self.status_code = status\n        self.title = title\n        self.detail = detail\n        self.type = type\n        self.instance = instance\n        self.headers = headers\n        self.ext = ext\n\n    def to_problem(self):\n        return problem(\n            status=self.status,\n            title=self.title,\n            detail=self.detail,\n            type=self.type,\n            instance=self.instance,\n            headers=self.headers,\n            ext=self.ext,\n        )"
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ClientProblem(ProblemException):\n    \"\"\"Base exception for any 4XX error. Returns 400 by default, however\n    :class:`BadRequestProblem` should be preferred for 400 errors.\"\"\"\n\n    def __init__(\n        self,\n        status: int = 400,\n        title: t.Optional[str] = None,\n        *,\n        detail: t.Optional[str] = None,\n    ):\n        super().__init__(status=status, title=title, detail=detail)"
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class BadRequestProblem(ClientProblem):\n    \"\"\"Problem class for 400 Bad Request errors.\"\"\"\n\n    def __init__(self, detail=None):\n        super().__init__(status=400, title=\"Bad Request\", detail=detail)"
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ExtraParameterProblem(BadRequestProblem):\n    \"\"\"Problem class for 400 Bad Request errors raised when extra query or form parameters are\n    detected and ``strict_validation`` is enabled.\"\"\"\n\n    def __init__(self, *, param_type: str, extra_params: t.Iterable[str]):\n        detail = f\"Extra {param_type} parameter(s) {','.join(extra_params)} not in spec\"\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class TypeValidationError(BadRequestProblem):\n    \"\"\"Problem class for 400 Bad Request errors raised when path, query or form parameters with\n    an incorrect type are detected.\"\"\"\n\n    def __init__(self, schema_type: str, parameter_type: str, parameter_name: str):\n        detail = f\"Wrong type, expected '{schema_type}' for {parameter_type} parameter '{parameter_name}'\"\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class Unauthorized(ClientProblem):\n    \"\"\"Problem class for 401 Unauthorized errors.\"\"\"\n\n    description = (\n        \"The server could not verify that you are authorized to access\"\n        \" the URL requested. You either supplied the wrong credentials\"\n        \" (e.g. a bad password), or your browser doesn't understand\"\n        \" how to supply the credentials required.\"\n    )\n\n    def __init__(self, detail: str = description):\n        super().__init__(401, title=\"Unauthorized\", detail=detail)"
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class OAuthProblem(Unauthorized):\n    \"\"\"Problem class for 401 Unauthorized errors raised when there is an issue with the received\n    OAuth headers.\"\"\"\n\n    pass"
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class OAuthResponseProblem(OAuthProblem):\n    \"\"\"Problem class for 401 Unauthorized errors raised when improper OAuth credentials are\n    retrieved from your OAuth server.\"\"\"\n\n    pass"
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class Forbidden(HTTPException):\n    \"\"\"Problem class for 403 Unauthorized errors.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = (\n                \"You don't have the permission to access the requested\"\n                \" resource. It is either read-protected or not readable by the\"\n                \" server.\"\n            )\n        super().__init__(403, detail=detail)"
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class OAuthScopeProblem(Forbidden):\n    \"\"\"Problem class for 403 Unauthorized errors raised because of OAuth scope validation errors.\"\"\"\n\n    def __init__(self, token_scopes: list, required_scopes: list) -> None:\n        self.required_scopes = required_scopes\n        self.token_scopes = token_scopes\n        detail = (\n            f\"Provided token does not have the required scopes. \"\n            f\"Provided: {token_scopes}; Required: {required_scopes}\"\n        )\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class UnsupportedMediaTypeProblem(ClientProblem):\n    \"\"\"Problem class for 415 Unsupported Media Type errors which are raised when Connexion\n    receives a request with an unsupported media type header.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        super().__init__(status=415, title=\"Unsupported Media Type\", detail=detail)"
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ServerError(ProblemException):\n    \"\"\"Base exception for any 5XX error. Returns 500 by default, however\n    :class:`InternalServerError` should be preferred for 500 errors.\"\"\"\n\n    def __init__(\n        self,\n        status: int = 500,\n        title: t.Optional[str] = None,\n        *,\n        detail: t.Optional[str] = None,\n    ):\n        if title is None:\n            title = \"Internal Server Error\"\n\n        super().__init__(status=status, title=title, detail=detail)"
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class InternalServerError(ServerError):\n    \"\"\"Problem class for 500 Internal Server errors.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = (\n                \"The server encountered an internal error and was unable to complete your \"\n                \"request. Either the server is overloaded or there is an error in the application.\"\n            )\n        super().__init__(status=500, title=\"Internal Server Error\", detail=detail)"
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class NonConformingResponse(InternalServerError):\n    \"\"\"Problem class for 500 Internal Server errors raised because of a returned response not\n    matching the specification if response validation is enabled.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class NonConformingResponseBody(NonConformingResponse):\n    \"\"\"Problem class for 500 Internal Server errors raised because of a returned response body not\n    matching the specification if response validation is enabled.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = \"Response body does not conform to specification\"\n\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class NonConformingResponseHeaders(NonConformingResponse):\n    \"\"\"Problem class for 500 Internal Server errors raised because of a returned response headers\n    not matching the specification if response validation is enabled.\"\"\"\n\n    def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = \"Response headers do not conform to specification\"\n\n        super().__init__(detail=detail)"
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/connexion/connexion/exceptions.py",
      "content": "class ResolverProblem(ServerError):\n    \"\"\"Problem class for 501 Not Implemented errors raised when the resolver cannot find a view\n    function to handle the incoming request.\"\"\"\n\n    def __init__(self, status: int = 501, *, detail: t.Optional[str] = None):\n        super().__init__(status=status, title=\"Not Implemented\", detail=detail)"
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "```"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "This module defines URIParsers which parse query and path parameters according to OpenAPI\nserialization rules."
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "import abc\nimport json\nimport logging\nimport re\n\nfrom connexion.exceptions import TypeValidationError\nfrom connexion.utils import all_json, coerce_type, deep_merge\n\nlogger = logging.getLogger(\"connexion.decorators.uri_parsing\")\n\nQUERY_STRING_DELIMITERS = {\n    \"spaceDelimited\": \" \",\n    \"pipeDelimited\": \"|\",\n    \"simple\": \",\",\n    \"form\": \",\",\n}"
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "class AbstractURIParser(metaclass=abc.ABCMeta):\n    parsable_parameters = [\"query\", \"path\"]\n\n    def __init__(self, param_defns, body_defn):\n        \"\"\"\n        a URI parser is initialized with parameter definitions.\n        When called with a request object, it handles array types in the URI\n        both in the path and query according to the spec.\n        Some examples include:\n        - https://mysite.fake/in/path/1,2,3/            # path parameters\n        - https://mysite.fake/?in_query=a,b,c           # simple query params\n        - https://mysite.fake/?in_query=a|b|c           # various separators\n        - https://mysite.fake/?in_query=a&in_query=b,c  # complex query params\n        \"\"\"\n        self._param_defns = {\n            p[\"name\"]: p for p in param_defns if p[\"in\"] in self.parsable_parameters\n        }\n        self._body_schema = body_defn.get(\"schema\", {})\n        self._body_encoding = body_defn.get(\"encoding\", {})\n\n    @property\n    @abc.abstractmethod\n    def param_defns(self):\n        \"\"\"\n        returns the parameter definitions by name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def param_schemas(self):\n        \"\"\"\n        returns the parameter schemas by name\n        \"\"\"\n\n    def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        return \"<{classname}>\".format(\n            classname=self.__class__.__name__\n        )  # pragma: no cover\n\n    @abc.abstractmethod\n    def resolve_form(self, form_data):\n        \"\"\"Resolve cases where form parameters are provided multiple times.\"\"\"\n\n    @abc.abstractmethod\n    def resolve_query(self, query_data):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\"\"\"\n\n    @abc.abstractmethod\n    def resolve_path(self, path):\n        \"\"\"Resolve cases where path parameters include lists\"\"\"\n\n    @abc.abstractmethod\n    def _resolve_param_duplicates(self, values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` could be \"4,5,6\", or \"1,2,3\" or \"1,2,3,4,5,6\" depending on the\n        implementation.\n        \"\"\"\n\n    @abc.abstractmethod\n    def _split(self, value, param_defn, _in):\n        \"\"\"\n        takes a string, a parameter definition, and a parameter type\n        and returns an array that has been constructed according to\n        the parameter definition.\n        \"\"\"\n\n    def resolve_params(self, params, _in):\n        \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n        resolved_param = {}\n        for k, values in params.items():\n            param_defn = self.param_defns.get(k)\n            param_schema = self.param_schemas.get(k)\n\n            if not (param_defn or param_schema):\n                # rely on validation\n                resolved_param[k] = values\n                continue\n\n            if _in == \"path\":\n                # multiple values in a path is impossible\n                values = [values]\n\n            if param_schema and param_schema[\"type\"] == \"array\":\n                # resolve variable re-assignment, handle explode\n                values = self._resolve_param_duplicates(values, param_defn, _in)\n                # handle array styles\n                resolved_param[k] = self._split(values, param_defn, _in)\n            else:\n                resolved_param[k] = values[-1]\n\n            try:\n                resolved_param[k] = coerce_type(\n                    param_defn, resolved_param[k], \"parameter\", k\n                )\n            except TypeValidationError:\n                pass\n\n        return resolved_param"
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "class OpenAPIURIParser(AbstractURIParser):\n    style_defaults = {\n        \"path\": \"simple\",\n        \"header\": \"simple\",\n        \"query\": \"form\",\n        \"cookie\": \"form\",\n        \"form\": \"form\",\n    }\n\n    @property\n    def param_defns(self):\n        return self._param_defns\n\n    @property\n    def form_defns(self):\n        return {k: v for k, v in self._body_schema.get(\"properties\", {}).items()}\n\n    @property\n    def param_schemas(self):\n        return {k: v.get(\"schema\", {}) for k, v in self.param_defns.items()}\n\n    def resolve_form(self, form_data):\n        if self._body_schema is None or self._body_schema.get(\"type\") != \"object\":\n            return form_data\n        for k in form_data:\n            encoding = self._body_encoding.get(k, {\"style\": \"form\"})\n            defn = self.form_defns.get(k, {})\n            # TODO support more form encoding styles\n            form_data[k] = self._resolve_param_duplicates(\n                form_data[k], encoding, \"form\"\n            )\n            if \"contentType\" in encoding and all_json([encoding.get(\"contentType\")]):\n                form_data[k] = json.loads(form_data[k])\n            elif defn and defn[\"type\"] == \"array\":\n                form_data[k] = self._split(form_data[k], encoding, \"form\")\n            form_data[k] = coerce_type(defn, form_data[k], \"requestBody\", k)\n        return form_data\n\n    def _make_deep_object(self, k, v):\n        \"\"\"consumes keys, value pairs like (a[foo][bar], \"baz\")\n        returns (a, {\"foo\": {\"bar\": \"baz\"}}}, is_deep_object)\n        \"\"\"\n        root_key = None\n        if k in self.param_schemas.keys():\n            return k, v, False\n        else:\n            for key in self.param_schemas.keys():\n                if k.startswith(key) and \"[\" in k:\n                    root_key = key.replace(k, \"\")\n\n        if not root_key:\n            root_key = k.split(\"[\", 1)[0]\n            if k == root_key:\n                return k, v, False\n\n        if not self._is_deep_object_style_param(root_key):\n            return k, v, False\n\n        key_path = re.findall(r\"\\[([^\\[\\]]*)\\]\", k)\n        root = prev = node = {}\n        for k in key_path:\n            node[k] = {}\n            prev = node\n            node = node[k]\n        prev[k] = v[0]\n        return root_key, [root], True\n\n    def _is_deep_object_style_param(self, param_name):\n        default_style = self.style_defaults[\"query\"]\n        style = self.param_defns.get(param_name, {}).get(\"style\", default_style)\n        return style == \"deepObject\"\n\n    def _preprocess_deep_objects(self, query_data):\n        \"\"\"deep objects provide a way of rendering nested objects using query\n        parameters.\n        \"\"\"\n        deep = [self._make_deep_object(k, v) for k, v in query_data.items()]\n        root_keys = [k for k, v, is_deep_object in deep]\n        ret = dict.fromkeys(root_keys, [{}])\n        for k, v, is_deep_object in deep:\n            if is_deep_object:\n                ret[k] = [deep_merge(v[0], ret[k][0])]\n            else:\n                ret[k] = v\n        return ret\n\n    def resolve_query(self, query_data):\n        query_data = self._preprocess_deep_objects(query_data)\n        return self.resolve_params(query_data, \"query\")\n\n    def resolve_path(self, path_data):\n        return self.resolve_params(path_data, \"path\")\n\n    @staticmethod\n    def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"4,5,6\".\n        However, if 'explode' is 'True' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        default_style = OpenAPIURIParser.style_defaults[_in]\n        style = param_defn.get(\"style\", default_style)\n        delimiter = QUERY_STRING_DELIMITERS.get(style, \",\")\n        is_form = style == \"form\"\n        explode = param_defn.get(\"explode\", is_form)\n        if explode:\n            return delimiter.join(values)\n\n        # default to last defined value\n        return values[-1]\n\n    @staticmethod\n    def _split(value, param_defn, _in):\n        default_style = OpenAPIURIParser.style_defaults[_in]\n        style = param_defn.get(\"style\", default_style)\n        delimiter = QUERY_STRING_DELIMITERS.get(style, \",\")\n        return value.split(delimiter)"
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "class Swagger2URIParser(AbstractURIParser):\n    \"\"\"\n    Adheres to the Swagger2 spec,\n    Assumes that the last defined query parameter should be used.\n    \"\"\"\n\n    parsable_parameters = [\"query\", \"path\", \"formData\"]\n\n    @property\n    def param_defns(self):\n        return self._param_defns\n\n    @property\n    def param_schemas(self):\n        return self._param_defns  # swagger2 conflates defn and schema\n\n    def resolve_form(self, form_data):\n        return self.resolve_params(form_data, \"form\")\n\n    def resolve_query(self, query_data):\n        return self.resolve_params(query_data, \"query\")\n\n    def resolve_path(self, path_data):\n        return self.resolve_params(path_data, \"path\")\n\n    @staticmethod\n    def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"4,5,6\".\n        However, if 'collectionFormat' is 'multi' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"multi\":\n            return \",\".join(values)\n        # default to last defined value\n        return values[-1]\n\n    @staticmethod\n    def _split(value, param_defn, _in):\n        if param_defn.get(\"collectionFormat\") == \"pipes\":\n            return value.split(\"|\")\n        return value.split(\",\")"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "class FirstValueURIParser(Swagger2URIParser):\n    \"\"\"\n    Adheres to the Swagger2 spec\n    Assumes that the first defined query parameter should be used\n    \"\"\"\n\n    @staticmethod\n    def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"1,2,3\".\n        However, if 'collectionFormat' is 'multi' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"multi\":\n            return \",\".join(values)\n        # default to first defined value\n        return values[0]"
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/connexion/connexion/uri_parsing.py",
      "content": "class AlwaysMultiURIParser(Swagger2URIParser):\n    \"\"\"\n    Does not adhere to the Swagger2 spec, but is backwards compatible with\n    connexion behavior in version 1.4.2\n    \"\"\"\n\n    @staticmethod\n    def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to join all provided parameters together.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"pipes\":\n            return \"|\".join(values)\n        return \",\".join(values)\n```"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "```python"
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "This module provides general utility functions used within Connexion.\n###"
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "import asyncio\nimport functools\nimport importlib\nimport inspect\nimport os\nimport pkgutil\nimport sys\nimport typing as t\n\nimport yaml\nfrom starlette.routing import compile_path\n\nfrom connexion.exceptions import TypeValidationError\n###"
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def boolean(s):\n    \"\"\"\n    Convert JSON/Swagger boolean value to Python, raise ValueError otherwise\n\n    >>> boolean('true')\n    True\n\n    >>> boolean('false')\n    False\n    \"\"\"\n    if isinstance(s, bool):\n        return s\n    elif not hasattr(s, \"lower\"):\n        raise ValueError(\"Invalid boolean value\")\n    elif s.lower() == \"true\":\n        return True\n    elif s.lower() == \"false\":\n        return False\n    else:\n        raise ValueError(\"Invalid boolean value\")\n###"
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "TYPE_MAP: t.Dict[str, t.Any] = {\n    \"integer\": int,\n    \"number\": float,\n    \"string\": str,\n    \"boolean\": boolean,\n    \"array\": list,\n    \"object\": dict,\n    \"file\": lambda x: x,  # Don't cast files\n}  # map of swagger types to python types\n###"
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    # In OpenAPI, files are represented with string type and binary format\n    if type_ == \"string\" and format_ == \"binary\":\n        type_ = \"file\"\n\n    type_func = TYPE_MAP[type_]\n    return type_func(value)\n###"
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def deep_merge(a, b):\n    \"\"\"merges b into a\n    in case of conflict the value from b is used\n    \"\"\"\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                deep_merge(a[key], b[key])\n            elif a[key] == b[key]:\n                pass\n            else:\n                # b overwrites a\n                a[key] = b[key]\n        else:\n            a[key] = b[key]\n    return a\n###"
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def deep_getattr(obj, attr):\n    \"\"\"\n    Recurses through an attribute chain to get the ultimate value.\n    \"\"\"\n\n    attrs = attr.split(\".\")\n\n    return functools.reduce(getattr, attrs, obj)\n###"
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])\n###"
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def get_function_from_name(function_name):\n    \"\"\"\n    Tries to get function by fully qualified name (e.g. \"mymodule.myobj.myfunc\")\n\n    :type function_name: str\n    \"\"\"\n    if function_name is None:\n        raise ValueError(\"Empty function name\")\n\n    if \".\" in function_name:\n        module_name, attr_path = function_name.rsplit(\".\", 1)\n    else:\n        module_name = \"\"\n        attr_path = function_name\n\n    module = None\n    last_import_error = None\n\n    while not module:\n        try:\n            module = importlib.import_module(module_name)\n        except ImportError as import_error:\n            last_import_error = import_error\n            if \".\" in module_name:\n                module_name, attr_path1 = module_name.rsplit(\".\", 1)\n                attr_path = f\"{attr_path1}.{attr_path}\"\n            else:\n                raise\n    try:\n        function = deep_getattr(module, attr_path)\n    except AttributeError:\n        if last_import_error:\n            raise last_import_error\n        else:\n            raise\n    return function\n###"
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def is_json_mimetype(mimetype):\n    \"\"\"\n    :type mimetype: str\n    :rtype: bool\n    \"\"\"\n    if mimetype is None:\n        return False\n\n    maintype, subtype = mimetype.split(\"/\")  # type: str, str\n    if \";\" in subtype:\n        subtype, parameter = subtype.split(\";\", maxsplit=1)\n    return maintype == \"application\" and (\n        subtype == \"json\" or subtype.endswith(\"+json\")\n    )\n###"
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def all_json(mimetypes):\n    \"\"\"\n    Returns True if all mimetypes are serialized with json\n\n    :type mimetypes: list\n    :rtype: bool\n\n    >>> all_json(['application/json'])\n    True\n    >>> all_json(['application/x.custom+json'])\n    True\n    >>> all_json([])\n    True\n    >>> all_json(['application/xml'])\n    False\n    >>> all_json(['text/json'])\n    False\n    >>> all_json(['application/json', 'other/type'])\n    False\n    >>> all_json(['application/json', 'application/x.custom+json'])\n    True\n    \"\"\"\n    return all(is_json_mimetype(mimetype) for mimetype in mimetypes)\n###"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def is_nullable(param_def):\n    return param_def.get(\"schema\", param_def).get(\"nullable\", False) or param_def.get(\n        \"x-nullable\", False\n    )  # swagger2\n###"
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def is_null(value):\n    if hasattr(value, \"strip\") and value.strip() in [\"null\", \"None\"]:\n        return True\n\n    if value is None:\n        return True\n\n    return False\n###"
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def has_coroutine(function, api=None):\n    \"\"\"\n    Checks if function is a coroutine.\n    If ``function`` is a decorator (has a ``__wrapped__`` attribute)\n    this function will also look at the wrapped function.\n    \"\"\"\n\n    def iscorofunc(func):\n        iscorofunc = asyncio.iscoroutinefunction(func)\n        while not iscorofunc and hasattr(func, \"__wrapped__\"):\n            func = func.__wrapped__\n            iscorofunc = asyncio.iscoroutinefunction(func)\n        return iscorofunc\n\n    if api is None:\n        return iscorofunc(function)\n\n    else:\n        return any(iscorofunc(func) for func in (function, api.get_response))\n###"
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def yamldumper(openapi):\n    \"\"\"\n    Returns a nicely-formatted yaml spec.\n    :param openapi: a spec dictionary.\n    :return: a nicely-formatted, serialized yaml spec.\n    \"\"\"\n\n    def should_use_block(value):\n        char_list = (\n            \"\\u000a\"  # line feed\n            \"\\u000d\"  # carriage return\n            \"\\u001c\"  # file separator\n            \"\\u001d\"  # group separator\n            \"\\u001e\"  # record separator\n            \"\\u0085\"  # next line\n            \"\\u2028\"  # line separator\n            \"\\u2029\"  # paragraph separator\n        )\n        for c in char_list:\n            if c in value:\n                return True\n        return False\n\n    def my_represent_scalar(self, tag, value, style=None):\n        if should_use_block(value):\n            style = \"|\"\n        else:\n            style = self.default_style\n\n        node = yaml.representer.ScalarNode(tag, value, style=style)\n        if self.alias_key is not None:\n            self.represented_objects[self.alias_key] = node\n        return node\n\n    class NoAnchorDumper(yaml.dumper.SafeDumper):\n        \"\"\"A yaml Dumper that does not replace duplicate entries\n        with yaml anchors.\n        \"\"\"\n\n        def ignore_aliases(self, *args):\n            return True\n\n    # Dump long lines as \"|\".\n    yaml.representer.SafeRepresenter.represent_scalar = my_represent_scalar\n\n    return yaml.dump(openapi, allow_unicode=True, Dumper=NoAnchorDumper)\n###"
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def not_installed_error(exc, *, msg=None):  # pragma: no cover\n    \"\"\"Raises the ImportError when the module/object is actually called with a custom message.\"\"\"\n\n    def _delayed_error(*args, **kwargs):\n        if msg is not None:\n            raise type(exc)(msg).with_traceback(exc.__traceback__)\n        raise exc\n\n    return _delayed_error\n###"
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def extract_content_type(\n    headers: t.Union[t.List[t.Tuple[bytes, bytes]], t.Dict[str, str]]\n) -> t.Optional[str]:\n    \"\"\"Extract the mime type and encoding from the content type headers.\n\n    :param headers: Headers from ASGI scope\n\n    :return: The content type if available in headers, otherwise None\n    \"\"\"\n    content_type: t.Optional[str] = None\n\n    header_pairs_type = t.Collection[t.Tuple[t.Union[str, bytes], t.Union[str, bytes]]]\n    header_pairs: header_pairs_type = headers.items() if isinstance(headers, dict) else headers  # type: ignore\n    for key, value in header_pairs:\n        # Headers can always be decoded using latin-1:\n        # https://stackoverflow.com/a/27357138/4098821\n        if isinstance(key, bytes):\n            decoded_key: str = key.decode(\"latin-1\")\n        else:\n            decoded_key = key\n\n        if decoded_key.lower() == \"content-type\":\n            if isinstance(value, bytes):\n                content_type = value.decode(\"latin-1\")\n            else:\n                content_type = value\n            break\n\n    return content_type\n###"
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def split_content_type(\n    content_type: t.Optional[str],\n) -> t.Tuple[t.Optional[str], t.Optional[str]]:\n    \"\"\"Split the content type in mime_type and encoding. Other parameters are ignored.\"\"\"\n    mime_type, encoding = None, None\n\n    if content_type is None:\n        return mime_type, encoding\n\n    # Check for parameters\n    if \";\" in content_type:\n        mime_type, parameters = content_type.split(\";\", maxsplit=1)\n\n        # Find parameter describing the charset\n        prefix = \"charset=\"\n        for parameter in parameters.split(\";\"):\n            if parameter.startswith(prefix):\n                encoding = parameter[len(prefix) :]\n    else:\n        mime_type = content_type\n    return mime_type, encoding\n###"
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def coerce_type(param, value, parameter_type, parameter_name=None):\n    # TODO: clean up\n    TYPE_MAP = {\"integer\": int, \"number\": float, \"boolean\": boolean, \"object\": dict}\n\n    def make_type(value, type_literal):\n        type_func = TYPE_MAP.get(type_literal)\n        return type_func(value)\n\n    param_schema = param.get(\"schema\", param)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n\n    param_type = param_schema.get(\"type\")\n    parameter_name = parameter_name if parameter_name else param.get(\"name\")\n    if param_type == \"array\":\n        converted_params = []\n        if parameter_type == \"header\":\n            value = value.split(\",\")\n        for v in value:\n            try:\n                converted = make_type(v, param_schema[\"items\"][\"type\"])\n            except (ValueError, TypeError):\n                converted = v\n            converted_params.append(converted)\n        return converted_params\n    elif param_type == \"object\":\n        if param_schema.get(\"properties\"):\n\n            def cast_leaves(d, schema):\n                if type(d) is not dict:\n                    try:\n                        return make_type(d, schema[\"type\"])\n                    except (ValueError, TypeError):\n                        return d\n                for k, v in d.items():\n                    if k in schema[\"properties\"]:\n                        d[k] = cast_leaves(v, schema[\"properties\"][k])\n                return d\n\n            return cast_leaves(value, param_schema)\n        return value\n    else:\n        try:\n            return make_type(value, param_type)\n        except ValueError:\n            raise TypeValidationError(param_type, parameter_type, parameter_name)\n        except TypeError:\n            return value\n###"
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def get_root_path(import_name: str) -> str:\n    \"\"\"Copied from Flask:\n    https://github.com/pallets/flask/blob/836866dc19218832cf02f8b04911060ac92bfc0b/src/flask/helpers.py#L595\n\n    Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # type: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n###"
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [\n        name\n        for name, p in parameters.items()\n        if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    has_kwargs = any(p.kind == p.VAR_KEYWORD for p in parameters.values())\n    return list(bound_arguments), has_kwargs\n###"
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "T = t.TypeVar(\"T\")\n###"
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "@t.overload\ndef sort_routes(routes: t.List[str], *, key: None = None) -> t.List[str]:\n    ...\n\n\n@t.overload\ndef sort_routes(routes: t.List[T], *, key: t.Callable[[T], str]) -> t.List[T]:\n    ...\n###"
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def sort_routes(routes, *, key=None):\n    \"\"\"Sorts a list of routes from most specific to least specific.\n\n    See Starlette routing documentation and implementation as this function\n    is aimed to sort according to that logic.\n    - https://www.starlette.io/routing/#route-priority\n\n    The only difference is that a `path` component is appended to each route\n    such that `/` is less specific than `/basepath` while they are technically\n    not comparable.\n    This is because it is also done by the `Mount` class internally:\n    https://github.com/encode/starlette/blob/1c1043ca0ab7126419948b27f9d0a78270fd74e6/starlette/routing.py#L388\n\n    For example, from most to least specific:\n    - /users/me\n    - /users/{username}/projects/{project}\n    - /users/{username}\n\n    :param routes: List of routes to sort\n    :param key: Function to extract the path from a route if it is not a string\n\n    :return: List of routes sorted from most specific to least specific\n    \"\"\"\n\n    class SortableRoute:\n        def __init__(self, path: str) -> None:\n            self.path = path.rstrip(\"/\")\n            if not self.path.endswith(\"/{path:path}\"):\n                self.path += \"/{path:path}\"\n            self.path_regex, _, _ = compile_path(self.path)\n\n        def __lt__(self, other: \"SortableRoute\") -> bool:\n            return bool(other.path_regex.match(self.path))\n\n    return sorted(routes, key=lambda r: SortableRoute(key(r) if key else r))\n###"
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def sort_apis_by_basepath(apis: t.List[\"API\"]) -> t.List[\"API\"]:\n    \"\"\"Sorts a list of APIs by basepath.\n\n    :param apis: List of APIs to sort\n\n    :return: List of APIs sorted by basepath\n    \"\"\"\n    return sort_routes(apis, key=lambda api: api.base_path or \"/\")\n###"
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/connexion/connexion/utils.py",
      "content": "def build_example_from_schema(schema):\n    if \"example\" in schema:\n        return schema[\"example\"]\n\n    if \"properties\" in schema:\n        # Recurse if schema is an object\n        return {\n            key: build_example_from_schema(value)\n            for (key, value) in schema[\"properties\"].items()\n        }\n\n    if \"items\" in schema:\n        # Recurse if schema is an array\n        min_item_count = schema.get(\"minItems\", 0)\n        max_item_count = schema.get(\"maxItems\")\n\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n\n        return [build_example_from_schema(schema[\"items\"]) for n in range(item_count)]\n\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n\n    faker = JSF(schema)\n    return faker.generate()\n```"
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/connexion/connexion/decorators/__init__.py",
      "content": "\"\"\"\nThis module defines decorators which Connexion uses to wrap user provided view functions.\n\"\"\""
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/connexion/connexion/decorators/__init__.py",
      "content": "from .main import (  # noqa\n    ASGIDecorator,\n    FlaskDecorator,\n    StarletteDecorator,\n    WSGIDecorator,\n)"
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "import abc\nimport asyncio\nimport functools\nimport json\nimport typing as t\n\nfrom asgiref.sync import async_to_sync\nfrom starlette.concurrency import run_in_threadpool\n\nfrom connexion.context import operation, receive, scope\nfrom connexion.decorators.parameter import (\n    AsyncParameterDecorator,\n    BaseParameterDecorator,\n    SyncParameterDecorator,\n)\nfrom connexion.decorators.response import (\n    AsyncResponseDecorator,\n    BaseResponseDecorator,\n    NoResponseDecorator,\n    SyncResponseDecorator,\n)\nfrom connexion.frameworks.abstract import Framework\nfrom connexion.frameworks.starlette import Starlette as StarletteFramework\nfrom connexion.uri_parsing import AbstractURIParser\nfrom connexion.utils import not_installed_error\n\ntry:\n    from connexion.frameworks.flask import Flask as FlaskFramework\nexcept ImportError as e:\n    _flask_not_installed_error = not_installed_error(\n        e, msg=\"Please install connexion using the 'flask' extra\"\n    )\n    FlaskFramework = _flask_not_installed_error  # type: ignore"
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "class BaseDecorator:\n    \"\"\"Base class for connexion decorators.\"\"\"\n\n    framework: t.Type[Framework]\n\n    def __init__(\n        self,\n        *,\n        pythonic_params: bool = False,\n        uri_parser_class: AbstractURIParser = None,\n        jsonifier=json,\n    ) -> None:\n        self.pythonic_params = pythonic_params\n        self.uri_parser_class = uri_parser_class\n        self.jsonifier = jsonifier\n\n        self.arguments, self.has_kwargs = None, None\n\n    @property\n    @abc.abstractmethod\n    def _parameter_decorator_cls(self) -> t.Type[BaseParameterDecorator]:\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        \"\"\"Decorator to translate between sync and async functions.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def uri_parser(self):\n        uri_parser_class = self.uri_parser_class or operation.uri_parser_class\n        return uri_parser_class(operation.parameters, operation.body_definition())\n\n    def decorate(self, function: t.Callable) -> t.Callable:\n        \"\"\"Decorate a function with decorators based on the operation.\"\"\"\n        function = self._sync_async_decorator(function)\n\n        parameter_decorator = self._parameter_decorator_cls(\n            framework=self.framework,\n            pythonic_params=self.pythonic_params,\n        )\n        function = parameter_decorator(function)\n\n        response_decorator = self._response_decorator_cls(\n            framework=self.framework,\n            jsonifier=self.jsonifier,\n        )\n        function = response_decorator(function)\n\n        return function\n\n    @abc.abstractmethod\n    def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError"
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "class WSGIDecorator(BaseDecorator):\n    \"\"\"Decorator for usage with WSGI apps. The parameter decorator works with a Flask request,\n    and provides Flask datastructures to the view function. This works for any WSGI app, since\n    we get the request via the connexion context provided by WSGI middleware.\n\n    This decorator does not parse responses, but passes them directly to the WSGI App.\"\"\"\n\n    framework = FlaskFramework\n\n    @property\n    def _parameter_decorator_cls(self) -> t.Type[SyncParameterDecorator]:\n        return SyncParameterDecorator\n\n    @property\n    def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        return NoResponseDecorator\n\n    @property\n    def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            def wrapper(*args, **kwargs) -> t.Callable:\n                if asyncio.iscoroutinefunction(function):\n                    return async_to_sync(function)(*args, **kwargs)\n                else:\n                    return function(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            request = self.framework.get_request(uri_parser=self.uri_parser)\n            decorated_function = self.decorate(function)\n            return decorated_function(request)\n\n        return wrapper"
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "class FlaskDecorator(WSGIDecorator):\n    \"\"\"Decorator for usage with Connexion or Flask apps. The parameter decorator works with a\n    Flask request, and provides Flask datastructures to the view function.\n\n    The response decorator returns Flask responses.\"\"\"\n\n    @property\n    def _response_decorator_cls(self) -> t.Type[SyncResponseDecorator]:\n        return SyncResponseDecorator"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "class ASGIDecorator(BaseDecorator):\n    \"\"\"Decorator for usage with ASGI apps. The parameter decorator works with a Starlette request,\n    and provides Starlette datastructures to the view function. This works for any ASGI app, since\n    we get the request via the connexion context provided by ASGI middleware.\n\n    This decorator does not parse responses, but passes them directly to the ASGI App.\"\"\"\n\n    framework = StarletteFramework\n\n    @property\n    def _parameter_decorator_cls(self) -> t.Type[AsyncParameterDecorator]:\n        return AsyncParameterDecorator\n\n    @property\n    def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        return NoResponseDecorator\n\n    @property\n    def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            async def wrapper(*args, **kwargs):\n                if asyncio.iscoroutinefunction(function):\n                    return await function(*args, **kwargs)\n                else:\n                    return await run_in_threadpool(function, *args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        async def wrapper(*args, **kwargs):\n            request = self.framework.get_request(\n                uri_parser=self.uri_parser, scope=scope, receive=receive\n            )\n            decorated_function = self.decorate(function)\n            return await decorated_function(request)\n\n        return wrapper"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/connexion/connexion/decorators/main.py",
      "content": "class StarletteDecorator(ASGIDecorator):\n    \"\"\"Decorator for usage with Connexion or Starlette apps. The parameter decorator works with a\n    Starlette request, and provides Starlette datastructures to the view function.\n\n    The response decorator returns Starlette responses.\"\"\"\n\n    @property\n    def _response_decorator_cls(self) -> t.Type[AsyncResponseDecorator]:\n        return AsyncResponseDecorator"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/connexion/connexion/decorators/response.py",
      "content": "import abc\nimport collections.abc\nimport functools\nimport logging\nimport types\nimport typing as t\nfrom enum import Enum\n\nfrom connexion import utils\nfrom connexion.context import operation\nfrom connexion.datastructures import NoContent\nfrom connexion.exceptions import NonConformingResponseHeaders\nfrom connexion.frameworks.abstract import Framework\nfrom connexion.lifecycle import ConnexionResponse\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/connexion/connexion/decorators/response.py",
      "content": "class BaseResponseDecorator:\n    def __init__(self, *, framework: t.Type[Framework], jsonifier):\n        self.framework = framework\n        self.jsonifier = jsonifier\n\n    @abc.abstractmethod\n    def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError\n\n    def build_framework_response(self, handler_response):\n        data, status_code, headers = self._unpack_handler_response(handler_response)\n        content_type = self._infer_content_type(data, headers)\n        if not self.framework.is_framework_response(data):\n            data = self._serialize_data(data, content_type=content_type)\n            status_code = status_code or self._infer_status_code(data)\n            headers = self._update_headers(headers, content_type=content_type)\n        return self.framework.build_response(\n            data, content_type=content_type, status_code=status_code, headers=headers\n        )\n\n    @staticmethod\n    def _infer_content_type(data: t.Any, headers: dict) -> t.Optional[str]:\n        \"\"\"Infer the response content type from the returned data, headers and operation spec.\n\n        :param data: Response data\n        :param headers: Headers returned by the handler.\n\n        :return: Inferred content type\n\n        :raises: NonConformingResponseHeaders if content type cannot be deducted.\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n\n        # TODO: don't default\n        produces = list(set(operation.produces))\n        if data is not None and not produces:\n            produces = [\"application/json\"]\n\n        if content_type:\n            if content_type not in produces:\n                raise NonConformingResponseHeaders(\n                    f\"Returned content type ({content_type}) is not defined in operation spec \"\n                    f\"({operation.produces}).\"\n                )\n        else:\n            if not produces:\n                # Produces can be empty/ for empty responses\n                pass\n            elif len(produces) == 1:\n                content_type = produces[0]\n            else:\n                if isinstance(data, str):\n                    for produced_content_type in produces:\n                        if \"text/plain\" in produced_content_type:\n                            content_type = produced_content_type\n                elif isinstance(data, bytes) or isinstance(\n                    data, (types.GeneratorType, collections.abc.Iterator)\n                ):\n                    for produced_content_type in produces:\n                        if \"application/octet-stream\" in produced_content_type:\n                            content_type = produced_content_type\n\n                if content_type is None:\n                    raise NonConformingResponseHeaders(\n                        \"Multiple response content types are defined in the operation spec, but \"\n                        \"the handler response did not specify which one to return.\"\n                    )\n\n        return content_type\n\n    def _serialize_data(self, data: t.Any, *, content_type: str) -> t.Any:\n        \"\"\"Serialize the data based on the content type.\"\"\"\n        if data is None or data is NoContent:\n            return None\n        # TODO: encode responses\n        mime_type, _ = utils.split_content_type(content_type)\n        if utils.is_json_mimetype(mime_type):\n            return self.jsonifier.dumps(data)\n        return data\n\n    @staticmethod\n    def _infer_status_code(data: t.Any) -> int:\n        \"\"\"Infer the status code from the returned data.\"\"\"\n        if data is None:\n            return 204\n        return 200\n\n    @staticmethod\n    def _update_headers(\n        headers: t.Dict[str, str], *, content_type: str\n    ) -> t.Dict[str, str]:\n        # Check if Content-Type is in headers, taking into account case-insensitivity\n        for key, value in headers.items():\n            if key.lower() == \"content-type\":\n                return headers\n\n        if content_type:\n            headers[\"Content-Type\"] = content_type\n        return headers\n\n    @staticmethod\n    def _unpack_handler_response(\n        handler_response: t.Union[str, bytes, dict, list, tuple]\n    ) -> t.Tuple[t.Union[str, bytes, dict, list, None], t.Optional[int], dict]:\n        \"\"\"Unpack the handler response into data, status_code and headers.\n\n        :param handler_response: The response returned from the handler function if it was not a\n            response class.\n\n        :return: A tuple of data, status_code and headers\n        \"\"\"\n        data, status_code, headers = None, None, {}\n\n        if not isinstance(handler_response, tuple):\n            data = handler_response\n\n        elif len(handler_response) == 1:\n            (data,) = handler_response\n\n        elif len(handler_response) == 2:\n            data, status_code_or_headers = handler_response\n            if isinstance(status_code_or_headers, int):\n                # Extra int call because of int subclasses such as http.HTTPStatus (IntEnum)\n                status_code = int(status_code_or_headers)\n            elif isinstance(status_code_or_headers, Enum) and isinstance(\n                status_code_or_headers.value, int\n            ):\n                status_code = status_code_or_headers.value\n            else:\n                headers = status_code_or_headers\n\n        elif len(handler_response) == 3:\n            data, status_code, headers = handler_response\n\n        else:\n            raise TypeError(\n                \"The view function did not return a valid response tuple.\"\n                \" The tuple must have the form (body), (body, status, headers),\"\n                \" (body, status), or (body, headers).\"\n            )\n\n        return data, status_code, headers"
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/connexion/connexion/decorators/response.py",
      "content": "class SyncResponseDecorator(BaseResponseDecorator):\n    def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"\n            This method converts a handler response to a framework response.\n            The handler response can be a ConnexionResponse, a framework response, a tuple or an\n            object.\n            \"\"\"\n            handler_response = function(*args, **kwargs)\n            if self.framework.is_framework_response(handler_response):\n                return handler_response\n            elif isinstance(handler_response, ConnexionResponse):\n                return self.framework.connexion_to_framework_response(handler_response)\n            else:\n                return self.build_framework_response(handler_response)\n\n        return wrapper"
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/connexion/connexion/decorators/response.py",
      "content": "class AsyncResponseDecorator(BaseResponseDecorator):\n    def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        async def wrapper(*args, **kwargs):\n            \"\"\"\n            This method converts a handler response to a framework response.\n            The handler response can be a ConnexionResponse, a framework response, a tuple or an\n            object.\n            \"\"\"\n            handler_response = await function(*args, **kwargs)\n            if self.framework.is_framework_response(handler_response):\n                return handler_response\n            elif isinstance(handler_response, ConnexionResponse):\n                return self.framework.connexion_to_framework_response(handler_response)\n            else:\n                return self.build_framework_response(handler_response)\n\n        return wrapper"
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/connexion/connexion/decorators/response.py",
      "content": "class NoResponseDecorator(BaseResponseDecorator):\n    \"\"\"Dummy decorator to skip response serialization.\"\"\"\n\n    def __call__(self, function: t.Callable) -> t.Callable:\n        return lambda request: function(request)"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "```"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "\"\"\"\nThis module defines a decorator to convert request parameters to arguments for the view function.\n\"\"\"\nimport abc\nimport asyncio\nimport builtins\nimport functools\nimport keyword\nimport logging\nimport re\nimport typing as t\nfrom copy import copy, deepcopy\n\nimport inflection\n\nfrom connexion.context import context, operation\nfrom connexion.frameworks.abstract import Framework\nfrom connexion.http_facts import FORM_CONTENT_TYPES\nfrom connexion.lifecycle import ConnexionRequest, WSGIRequest\nfrom connexion.operations import AbstractOperation, Swagger2Operation\nfrom connexion.utils import (\n    deep_merge,\n    inspect_function_arguments,\n    is_null,\n    is_nullable,\n    make_type,\n)\n\nlogger = logging.getLogger(__name__)\n\nCONTEXT_NAME = \"context_\""
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "class BaseParameterDecorator:\n    def __init__(\n        self,\n        *,\n        framework: t.Type[Framework],\n        pythonic_params: bool = False,\n    ) -> None:\n        self.framework = framework\n        self.sanitize_fn = pythonic if pythonic_params else sanitized\n\n    def _maybe_get_body(\n        self,\n        request: t.Union[WSGIRequest, ConnexionRequest],\n        *,\n        arguments: t.List[str],\n        has_kwargs: bool,\n    ) -> t.Any:\n        body_name = self.sanitize_fn(operation.body_name(request.content_type))\n        # Pass form contents separately for Swagger2 for backward compatibility with\n        # Connexion 2 Checking for body_name is not enough\n        if (body_name in arguments or has_kwargs) or (\n            request.mimetype in FORM_CONTENT_TYPES\n            and isinstance(operation, Swagger2Operation)\n        ):\n            return request.get_body()\n        else:\n            return None\n\n    @abc.abstractmethod\n    def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError"
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "class SyncParameterDecorator(BaseParameterDecorator):\n    def __call__(self, function: t.Callable) -> t.Callable:\n        unwrapped_function = unwrap_decorators(function)\n        arguments, has_kwargs = inspect_function_arguments(unwrapped_function)\n\n        @functools.wraps(function)\n        def wrapper(request: WSGIRequest) -> t.Any:\n            request_body = self._maybe_get_body(\n                request, arguments=arguments, has_kwargs=has_kwargs\n            )\n\n            kwargs = prep_kwargs(\n                request,\n                request_body=request_body,\n                files=request.files(),\n                arguments=arguments,\n                has_kwargs=has_kwargs,\n                sanitize=self.sanitize_fn,\n            )\n\n            return function(**kwargs)\n\n        return wrapper"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "class AsyncParameterDecorator(BaseParameterDecorator):\n    def __call__(self, function: t.Callable) -> t.Callable:\n        unwrapped_function = unwrap_decorators(function)\n        arguments, has_kwargs = inspect_function_arguments(unwrapped_function)\n\n        @functools.wraps(function)\n        async def wrapper(request: ConnexionRequest) -> t.Any:\n            request_body = self._maybe_get_body(\n                request, arguments=arguments, has_kwargs=has_kwargs\n            )\n\n            while asyncio.iscoroutine(request_body):\n                request_body = await request_body\n\n            kwargs = prep_kwargs(\n                request,\n                request_body=request_body,\n                files=await request.files(),\n                arguments=arguments,\n                has_kwargs=has_kwargs,\n                sanitize=self.sanitize_fn,\n            )\n\n            return await function(**kwargs)\n\n        return wrapper"
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def prep_kwargs(\n    request: t.Union[WSGIRequest, ConnexionRequest],\n    *,\n    request_body: t.Any,\n    files: t.Dict[str, t.Any],\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    kwargs = get_arguments(\n        operation,\n        path_params=request.path_params,\n        query_params=request.query_params,\n        body=request_body,\n        files=files,\n        arguments=arguments,\n        has_kwargs=has_kwargs,\n        sanitize=sanitize,\n        content_type=request.mimetype,\n    )\n\n    # optionally convert parameter variable names to un-shadowed, snake_case form\n    kwargs = {sanitize(k): v for k, v in kwargs.items()}\n\n    # add context info (e.g. from security decorator)\n    for key, value in context.items():\n        if has_kwargs or key in arguments:\n            kwargs[key] = value\n        else:\n            logger.debug(\"Context parameter '%s' not in function arguments\", key)\n    # attempt to provide the request context to the function\n    if CONTEXT_NAME in arguments:\n        kwargs[CONTEXT_NAME] = context\n\n    return kwargs"
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def unwrap_decorators(function: t.Callable) -> t.Callable:\n    \"\"\"Unwrap decorators to return the original function.\"\"\"\n    while hasattr(function, \"__wrapped__\"):\n        function = function.__wrapped__  # type: ignore\n    return function"
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def snake_and_shadow(name: str) -> str:\n    \"\"\"\n    Converts the given name into Pythonic form. Firstly it converts CamelCase names to snake_case. Secondly it looks to\n    see if the name matches a known built-in and if it does it appends an underscore to the name.\n    :param name: The parameter name\n    \"\"\"\n    snake = inflection.underscore(name)\n    if snake in builtins.__dict__ or keyword.iskeyword(snake):\n        return f\"{snake}_\"\n    return snake"
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def sanitized(name: str) -> str:\n    return name and re.sub(\n        \"^[^a-zA-Z_]+\", \"\", re.sub(\"[^0-9a-zA-Z_]\", \"\", re.sub(r\"\\[(?!])\", \"_\", name))\n    )"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def pythonic(name: str) -> str:\n    name = name and snake_and_shadow(name)\n    return sanitized(name)"
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def get_arguments(\n    operation: AbstractOperation,\n    *,\n    path_params: dict,\n    query_params: dict,\n    body: t.Any,\n    files: dict,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n    content_type: str,\n) -> t.Dict[str, t.Any]:\n    \"\"\"\n    get arguments for handler function\n    \"\"\"\n    ret = {}\n    ret.update(_get_path_arguments(path_params, operation=operation, sanitize=sanitize))\n    ret.update(\n        _get_query_arguments(\n            query_params,\n            operation=operation,\n            arguments=arguments,\n            has_kwargs=has_kwargs,\n            sanitize=sanitize,\n        )\n    )\n\n    if operation.method.upper() == \"TRACE\":\n        # TRACE requests MUST NOT include a body (RFC7231 section 4.3.8)\n        return ret\n\n    ret.update(\n        _get_body_argument(\n            body,\n            operation=operation,\n            arguments=arguments,\n            has_kwargs=has_kwargs,\n            sanitize=sanitize,\n            content_type=content_type,\n        )\n    )\n    body_schema = operation.body_schema(content_type)\n    ret.update(_get_file_arguments(files, arguments, body_schema, has_kwargs))\n    return ret"
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_path_arguments(\n    path_params: dict, *, operation: AbstractOperation, sanitize: t.Callable\n) -> dict:\n    \"\"\"\n    Extract handler function arguments from path parameters\n    \"\"\"\n    kwargs = {}\n\n    path_definitions = {\n        parameter[\"name\"]: parameter\n        for parameter in operation.parameters\n        if parameter[\"in\"] == \"path\"\n    }\n\n    for name, value in path_params.items():\n        sanitized_key = sanitize(name)\n        if name in path_definitions:\n            kwargs[sanitized_key] = _get_val_from_param(value, path_definitions[name])\n        else:  # Assume path params mechanism used for injection\n            kwargs[sanitized_key] = value\n    return kwargs"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get(\"schema\", param_definitions)\n\n    if is_nullable(param_schema) and is_null(value):\n        return None\n\n    if param_schema[\"type\"] == \"array\":\n        type_ = param_schema[\"items\"][\"type\"]\n        format_ = param_schema[\"items\"].get(\"format\")\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema[\"type\"]\n        format_ = param_schema.get(\"format\")\n        return make_type(value, type_, format_)"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_query_arguments(\n    query_params: dict,\n    *,\n    operation: AbstractOperation,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    \"\"\"\n    extract handler function arguments from the query parameters\n    \"\"\"\n    query_definitions = {\n        parameter[\"name\"]: parameter\n        for parameter in operation.parameters\n        if parameter[\"in\"] == \"query\"\n    }\n\n    default_query_params = _get_query_defaults(query_definitions)\n\n    query_arguments = deepcopy(default_query_params)\n    query_arguments = deep_merge(query_arguments, query_params)\n    return _query_args_helper(\n        query_definitions, query_arguments, arguments, has_kwargs, sanitize\n    )"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_query_defaults(query_definitions: t.Dict[str, dict]) -> t.Dict[str, t.Any]:\n    \"\"\"Get the default values for the query parameter from the parameter definition.\"\"\"\n    defaults = {}\n    for k, v in query_definitions.items():\n        try:\n            if \"default\" in v:\n                defaults[k] = v[\"default\"]\n            elif v[\"schema\"][\"type\"] == \"object\":\n                defaults[k] = _get_default_obj(v[\"schema\"])\n            else:\n                defaults[k] = v[\"schema\"][\"default\"]\n        except KeyError:\n            pass\n    return defaults"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_default_obj(schema: dict) -> dict:\n    try:\n        return deepcopy(schema[\"default\"])\n    except KeyError:\n        properties = schema.get(\"properties\", {})\n        return _build_default_obj_recursive(properties, {})"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _build_default_obj_recursive(properties: dict, default_object: dict) -> dict:\n    \"\"\"takes disparate and nested default keys, and builds up a default object\"\"\"\n    for name, property_ in properties.items():\n        if \"default\" in property_ and name not in default_object:\n            default_object[name] = copy(property_[\"default\"])\n        elif property_.get(\"type\") == \"object\" and \"properties\" in property_:\n            default_object.setdefault(name, {})\n            default_object[name] = _build_default_obj_recursive(\n                property_[\"properties\"], default_object[name]\n            )\n    return default_object"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _query_args_helper(\n    query_definitions: dict,\n    query_arguments: dict,\n    function_arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    result = {}\n    for key, value in query_arguments.items():\n        sanitized_key = sanitize(key)\n        if not has_kwargs and sanitized_key not in function_arguments:\n            logger.debug(\n                \"Query Parameter '%s' (sanitized: '%s') not in function arguments\",\n                key,\n                sanitized_key,\n            )\n        else:\n            logger.debug(\n                \"Query Parameter '%s' (sanitized: '%s') in function arguments\",\n                key,\n                sanitized_key,\n            )\n            try:\n                query_defn = query_definitions[key]\n            except KeyError:  # pragma: no cover\n                logger.error(\n                    \"Function argument '%s' (non-sanitized: %s) not defined in specification\",\n                    sanitized_key,\n                    key,\n                )\n            else:\n                logger.debug(\"%s is a %s\", key, query_defn)\n                result.update({sanitized_key: _get_val_from_param(value, query_defn)})\n    return result"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_body_argument(\n    body: t.Any,\n    *,\n    operation: AbstractOperation,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n    content_type: str,\n) -> dict:\n    if len(arguments) <= 0 and not has_kwargs:\n        return {}\n\n    if not operation.is_request_body_defined:\n        return {}\n\n    body_name = sanitize(operation.body_name(content_type))\n\n    if content_type in FORM_CONTENT_TYPES:\n        result = _get_body_argument_form(\n            body, operation=operation, content_type=content_type\n        )\n\n        # Unpack form values for Swagger for compatibility with Connexion 2 behavior\n        if content_type in FORM_CONTENT_TYPES and isinstance(\n            operation, Swagger2Operation\n        ):\n            if has_kwargs:\n                return result\n            else:\n                return {\n                    sanitize(name): value\n                    for name, value in result.items()\n                    if sanitize(name) in arguments\n                }\n    else:\n        result = _get_body_argument_json(\n            body, operation=operation, content_type=content_type\n        )\n\n    if body_name in arguments or has_kwargs:\n        return {body_name: result}\n\n    return {}"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_body_argument_json(\n    body: t.Any, *, operation: AbstractOperation, content_type: str\n) -> t.Any:\n    # if the body came in null, and the schema says it can be null, we decide\n    # to include no value for the body argument, rather than the default body\n    if is_nullable(operation.body_schema(content_type)) and is_null(body):\n        return None\n\n    if body is None:\n        default_body = operation.body_schema(content_type).get(\"default\", {})\n        return deepcopy(default_body)\n\n    return body"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_body_argument_form(\n    body: dict, *, operation: AbstractOperation, content_type: str\n) -> dict:\n    # now determine the actual value for the body (whether it came in or is default)\n    default_body = operation.body_schema(content_type).get(\"default\", {})\n    body_props = {\n        k: {\"schema\": v}\n        for k, v in operation.body_schema(content_type).get(\"properties\", {}).items()\n    }\n\n    # by OpenAPI specification `additionalProperties` defaults to `true`\n    # see: https://github.com/OAI/OpenAPI-Specification/blame/3.0.2/versions/3.0.2.md#L2305\n    additional_props = operation.body_schema().get(\"additionalProperties\", True)\n\n    body_arg = deepcopy(default_body)\n    body_arg.update(body or {})\n\n    if body_props or additional_props:\n        return _get_typed_body_values(body_arg, body_props, additional_props)\n\n    return {}"
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_typed_body_values(body_arg, body_props, additional_props):\n    \"\"\"\n    Return a copy of the provided body_arg dictionary\n    whose values will have the appropriate types\n    as defined in the provided schemas.\n\n    :type body_arg: type dict\n    :type body_props: dict\n    :type additional_props: dict|bool\n    :rtype: dict\n    \"\"\"\n    additional_props_defn = (\n        {\"schema\": additional_props} if isinstance(additional_props, dict) else None\n    )\n    res = {}\n\n    for key, value in body_arg.items():\n        try:\n            prop_defn = body_props[key]\n            res[key] = _get_val_from_param(value, prop_defn)\n        except KeyError:  # pragma: no cover\n            if not additional_props:\n                logger.error(f\"Body property '{key}' not defined in body schema\")\n                continue\n            if additional_props_defn is not None:\n                value = _get_val_from_param(value, additional_props_defn)\n            res[key] = value\n\n    return res"
    },
    {
      "chunk_id": 295,
      "source": "__internal__/data_repo/connexion/connexion/decorators/parameter.py",
      "content": "def _get_file_arguments(files, arguments, body_schema: dict, has_kwargs=False):\n    results = {}\n    for k, v in files.items():\n        if not (k in arguments or has_kwargs):\n            continue\n        if body_schema.get(\"properties\", {}).get(k, {}).get(\"type\") != \"array\":\n            v = v[0]\n        results[k] = v\n\n    return results\n```"
    },
    {
      "chunk_id": 296,
      "source": "__internal__/data_repo/connexion/connexion/middleware/__init__.py",
      "content": "from .abstract import SpecMiddleware  # NOQA\nfrom .main import ConnexionMiddleware, MiddlewarePosition  # NOQA"
    },
    {
      "chunk_id": 297,
      "source": "__internal__/data_repo/connexion/connexion/middleware/main.py",
      "content": "import copy\nimport dataclasses\nimport enum\nimport logging\nimport pathlib\nimport typing as t\nfrom dataclasses import dataclass, field\nfrom functools import partial\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion import utils\nfrom connexion.handlers import ResolverErrorHandler\nfrom connexion.jsonifier import Jsonifier\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.middleware.abstract import SpecMiddleware\nfrom connexion.middleware.context import ContextMiddleware\nfrom connexion.middleware.exceptions import ExceptionMiddleware\nfrom connexion.middleware.lifespan import Lifespan, LifespanMiddleware\nfrom connexion.middleware.request_validation import RequestValidationMiddleware\nfrom connexion.middleware.response_validation import ResponseValidationMiddleware\nfrom connexion.middleware.routing import RoutingMiddleware\nfrom connexion.middleware.security import SecurityMiddleware\nfrom connexion.middleware.server_error import ServerErrorMiddleware\nfrom connexion.middleware.swagger_ui import SwaggerUIMiddleware\nfrom connexion.options import SwaggerUIOptions\nfrom connexion.resolver import Resolver\nfrom connexion.spec import Specification\nfrom connexion.types import MaybeAwaitable\nfrom connexion.uri_parsing import AbstractURIParser\nfrom connexion.utils import inspect_function_arguments\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 298,
      "source": "__internal__/data_repo/connexion/connexion/middleware/main.py",
      "content": "@dataclass\nclass _Options:\n    \"\"\"\n    Connexion provides a lot of parameters for the user to configure the app / middleware of\n    application.\n\n    This class provides a central place to parse these parameters a mechanism to update them.\n    Application level arguments can be provided when instantiating the application / middleware,\n    after which they can be overwritten on an API level.\n\n    The defaults should only be set in this class, and set to None in the signature of user facing\n    methods. This is necessary for this class to be able to differentiate between missing and\n    falsy arguments.\n    \"\"\"\n\n    arguments: t.Optional[dict] = None\n    auth_all_paths: t.Optional[bool] = False\n    jsonifier: t.Optional[Jsonifier] = None\n    pythonic_params: t.Optional[bool] = False\n    resolver: t.Optional[t.Union[Resolver, t.Callable]] = None\n    resolver_error: t.Optional[int] = None\n    resolver_error_handler: t.Optional[t.Callable] = field(init=False)\n    strict_validation: t.Optional[bool] = False\n    swagger_ui_options: t.Optional[SwaggerUIOptions] = None\n    uri_parser_class: t.Optional[AbstractURIParser] = None\n    validate_responses: t.Optional[bool] = False\n    validator_map: t.Optional[dict] = None\n    security_map: t.Optional[dict] = None\n\n    def __post_init__(self):\n        self.resolver = (\n            Resolver(self.resolver) if callable(self.resolver) else self.resolver\n        )\n        self.resolver_error_handler = self._resolver_error_handler_factory()\n\n    def _resolver_error_handler_factory(\n        self,\n    ) -> t.Optional[t.Callable[[], ResolverErrorHandler]]:\n        \"\"\"Returns a factory to create a ResolverErrorHandler.\"\"\"\n        if self.resolver_error is not None:\n\n            def resolver_error_handler(*args, **kwargs) -> ResolverErrorHandler:\n                return ResolverErrorHandler(self.resolver_error, *args, **kwargs)\n\n            return resolver_error_handler\n        return None\n\n    def replace(self, **changes) -> \"_Options\":\n        \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n        changes = {key: value for key, value in changes.items() if value is not None}\n        return dataclasses.replace(self, **changes)"
    },
    {
      "chunk_id": 299,
      "source": "__internal__/data_repo/connexion/connexion/middleware/main.py",
      "content": "class MiddlewarePosition(enum.Enum):\n    \"\"\"Positions to insert a middleware\"\"\"\n\n    BEFORE_EXCEPTION = ExceptionMiddleware\n    \"\"\"Add before the :class:`ExceptionMiddleware`. This is useful if you want your changes to\n    affect the way exceptions are handled, such as a custom error handler.\n\n    Be mindful that security has not yet been applied at this stage.\n    Additionally, the inserted middleware is positioned before the RoutingMiddleware, so you cannot\n    leverage any routing information yet and should implement your middleware to work globally\n    instead of on an operation level.\n\n    Useful for middleware which should also be applied to error responses. Note that errors\n    raised here will not be handled by the exception handlers and will always result in an\n    internal server error response.\n\n    :meta hide-value:\n    \"\"\"\n    BEFORE_SWAGGER = SwaggerUIMiddleware\n    \"\"\"Add before the :class:`SwaggerUIMiddleware`. This is useful if you want your changes to\n    affect the Swagger UI, such as a path altering middleware that should also alter the paths\n    exposed by the Swagger UI\n\n    Be mindful that security has not yet been applied at this stage.\n\n    Since the inserted middleware is positioned before the RoutingMiddleware, you cannot leverage\n    any routing information yet and should implement your middleware to work globally instead of on\n    an operation level.\n\n    :meta hide-value:\n    \"\"\"\n    BEFORE_ROUTING = RoutingMiddleware\n    \"\"\"Add before the :class:`RoutingMiddleware`. This is useful if you want your changes to be\n    applied before hitting the router, such as for path altering or CORS middleware.\n\n    Be mindful that security has not yet been applied at this stage.\n\n    Since the inserted middleware is positioned before the RoutingMiddleware, you cannot leverage\n    any routing information yet and should implement your middleware to work globally instead of\n    on an operation level.\n\n    :meta hide-value:\n    \"\"\"\n    BEFORE_SECURITY = SecurityMiddleware\n    \"\"\"Add before the :class:`SecurityMiddleware`. Insert middleware here that needs to be able to\n    adapt incoming requests before security is applied.\n\n    Be mindful that security has not yet been applied at this stage.\n\n    Since the inserted middleware is positioned after the RoutingMiddleware, you can leverage\n    routing information and implement the middleware to work on an individual operation level.\n\n    :meta hide-value:\n    \"\"\"\n    BEFORE_VALIDATION = RequestValidationMiddleware\n    \"\"\"Add before the :class:`RequestValidationMiddleware`. Insert middleware here that needs to be\n    able to adapt incoming requests before they are validated.\n\n    Since the inserted middleware is positioned after the RoutingMiddleware, you can leverage\n    routing information and implement the middleware to work on an individual operation level.\n\n    :meta hide-value:\n    \"\"\"\n    BEFORE_CONTEXT = ContextMiddleware\n    \"\"\"Add before the :class:`ContextMiddleware`, near the end of the stack. This is the default\n    location. The inserted middleware is only followed by the ContextMiddleware, which ensures any\n    changes to the context are properly exposed to the application.\n\n    Since the inserted middleware is positioned after the RoutingMiddleware, you can leverage\n    routing information and implement the middleware to work on an individual operation level.\n\n    Since the inserted middleware is positioned after the ResponseValidationMiddleware,\n    it can intercept responses coming from the application and alter them before they are validated.\n\n    :meta hide-value:\n    \"\"\""
    },
    {
      "chunk_id": 300,
      "source": "__internal__/data_repo/connexion/connexion/middleware/main.py",
      "content": "class API:\n    def __init__(self, specification, *, base_path, **kwargs) -> None:\n        self.specification = specification\n        self.base_path = base_path\n        self.kwargs = kwargs"
    },
    {
      "chunk_id": 301,
      "source": "__internal__/data_repo/connexion/connexion/middleware/main.py",
      "content": "class ConnexionMiddleware:\n    \"\"\"The main Connexion middleware, which wraps a list of specialized middlewares around the\n    provided application.\"\"\"\n\n    default_middlewares = [\n        ServerErrorMiddleware,\n        ExceptionMiddleware,\n        SwaggerUIMiddleware,\n        RoutingMiddleware,\n        SecurityMiddleware,\n        RequestValidationMiddleware,\n        ResponseValidationMiddleware,\n        LifespanMiddleware,\n        ContextMiddleware,\n    ]\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        *,\n        import_name: t.Optional[str] = None,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[t.List[ASGIApp]] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ):\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionmMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`.\n        \"\"\"\n        import_name = import_name or str(pathlib.Path.cwd())\n        self.root_path = utils.get_root_path(import_name)\n\n        spec_dir = pathlib.Path(specification_dir)\n        self.specification_dir = (\n            spec_dir if spec_dir.is_absolute() else self.root_path / spec_dir\n        )\n\n        self.app = app\n        self.lifespan = lifespan\n        self.middlewares = (\n            middlewares\n            if middlewares is not None\n            else copy.copy(self.default_middlewares)\n        )\n        self.middleware_stack: t.Optional[t.Iterable[ASGIApp]] = None\n        self.apis: t.List[API] = []\n        self.error_handlers: t.List[tuple] = []\n\n        self.options = _Options(\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        self.extra_files: t.List[str] = []\n\n    def add_middleware(\n        self,\n        middleware_class: t.Type[ASGIApp],\n        *,\n        position: MiddlewarePosition = MiddlewarePosition.BEFORE_CONTEXT,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Add a middleware to the stack on the specified position.\n\n        :param middleware_class: Middleware class to add\n        :param position: Position to add the middleware, one of the MiddlewarePosition Enum\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\"Cannot add middleware after an application has started\")\n\n        for m, middleware in enumerate(self.middlewares):\n            if isinstance(middleware, partial):\n                middleware = middleware.func\n\n            if middleware == position.value:\n                self.middlewares.insert(\n                    m, t.cast(ASGIApp, partial(middleware_class, **options))\n                )\n                break\n        else:\n            raise ValueError(\n                f\"Could not insert middleware at position {position.name}. \"\n                f\"Please make sure you have a {position.value} in your stack.\"\n            )\n\n    def _build_middleware_stack(self) -> t.Tuple[ASGIApp, t.Iterable[ASGIApp]]:\n        \"\"\"Apply all middlewares to the provided app.\n\n        :return: Tuple of the outer middleware wrapping the application and a list of the wrapped\n            middlewares, including the wrapped application.\n        \"\"\"\n        # Include the wrapped application in the returned list.\n        app = self.app\n        apps = [app]\n        for middleware in reversed(self.middlewares):\n            arguments, _ = inspect_function_arguments(middleware)\n            if \"lifespan\" in arguments:\n                app = middleware(app, lifespan=self.lifespan)  # type: ignore\n            else:\n                app = middleware(app)  # type: ignore\n            apps.append(app)\n\n        # We sort the APIs by base path so that the most specific APIs are registered first.\n        # This is due to the way Starlette matches routes.\n        self.apis = utils.sort_apis_by_basepath(self.apis)\n        for app in apps:\n            if isinstance(app, SpecMiddleware):\n                for api in self.apis:\n                    app.add_api(\n                        api.specification,\n                        base_path=api.base_path,\n                        **api.kwargs,\n                    )\n\n            if isinstance(app, ExceptionMiddleware):\n                for error_handler in self.error_handlers:\n                    app.add_exception_handler(*error_handler)\n\n        return app, list(reversed(apps))\n\n    def add_api(\n        self,\n        specification: t.Union[pathlib.Path, str, dict],\n        *,\n        base_path: t.Optional[str] = None,\n        name: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Register een API represented by a single OpenAPI specification on this middleware.\n        Multiple APIs can be registered on a single middleware.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A dict with configuration options for the swagger ui. See\n            :class:`options.SwaggerUIOptions`.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the wrapped application.\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\"Cannot add api after an application has started\")\n\n        if isinstance(specification, str) and (\n            specification.startswith(\"http://\") or specification.startswith(\"https://\")\n        ):\n            pass\n        elif isinstance(specification, (pathlib.Path, str)):\n            specification = t.cast(pathlib.Path, self.specification_dir / specification)\n\n            # Add specification as file to watch for reloading\n            if pathlib.Path.cwd() in specification.parents:\n                self.extra_files.append(\n                    str(specification.relative_to(pathlib.Path.cwd()))\n                )\n\n        specification = Specification.load(specification, arguments=arguments)\n\n        options = self.options.replace(\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            swagger_ui_options=swagger_ui_options,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        api = API(\n            specification, base_path=base_path, name=name, **options.__dict__, **kwargs\n        )\n        self.apis.append(api)\n\n    def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\n                \"Cannot add error handler after an application has started\"\n            )\n\n        error_handler = (code_or_exception, function)\n        self.error_handlers.append(error_handler)\n\n    def run(self, import_string: t.Optional[str] = None, **kwargs):\n        \"\"\"Run the application using uvicorn.\n\n        :param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                              using reload.\n        :param kwargs: kwargs to pass to `uvicorn.run`.\n        \"\"\"\n        try:\n            import uvicorn\n        except ImportError:\n            raise RuntimeError(\n                \"uvicorn is not installed. Please install connexion using the uvicorn extra \"\n                \"(connexion[uvicorn])\"\n            )\n\n        logger.warning(\n            f\"`{self.__class__.__name__}.run` is optimized for development. \"\n            \"For production, run using a dedicated ASGI server.\"\n        )\n\n        app: t.Union[str, ConnexionMiddleware]\n        if import_string is not None:\n            app = import_string\n            kwargs.setdefault(\"reload\", True)\n            kwargs[\"reload_includes\"] = self.extra_files + kwargs.get(\n                \"reload_includes\", []\n            )\n        else:\n            app = self\n\n        uvicorn.run(app, **kwargs)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.middleware_stack is None:\n            self.app, self.middleware_stack = self._build_middleware_stack()\n        # Set so starlette router throws exceptions instead of returning error responses\n        # This instance is also passed to any lifespan handler\n        scope[\"app\"] = self\n        await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 302,
      "source": "__internal__/data_repo/connexion/connexion/middleware/response_validation.py",
      "content": "```python"
    },
    {
      "chunk_id": 303,
      "source": "__internal__/data_repo/connexion/connexion/middleware/response_validation.py",
      "content": "\"\"\"\nValidation Middleware.\n\"\"\"\nimport logging\nimport typing as t\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion import utils\nfrom connexion.datastructures import MediaTypeDict\nfrom connexion.exceptions import NonConformingResponseHeaders\nfrom connexion.middleware.abstract import RoutedAPI, RoutedMiddleware\nfrom connexion.operations import AbstractOperation\nfrom connexion.validators import VALIDATOR_MAP\n\nlogger = logging.getLogger(\"connexion.middleware.validation\")"
    },
    {
      "chunk_id": 304,
      "source": "__internal__/data_repo/connexion/connexion/middleware/response_validation.py",
      "content": "class ResponseValidationOperation:\n    def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n        validator_map: t.Optional[dict] = None,\n    ) -> None:\n        self.next_app = next_app\n        self._operation = operation\n        self._validator_map = VALIDATOR_MAP.copy()\n        self._validator_map.update(validator_map or {})\n\n    def extract_content_type(\n        self, headers: t.List[t.Tuple[bytes, bytes]]\n    ) -> t.Tuple[str, str]:\n        \"\"\"Extract the mime type and encoding from the content type headers.\n\n        :param headers: Headers from ASGI scope\n\n        :return: A tuple of mime type, encoding\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n        mime_type, encoding = utils.split_content_type(content_type)\n        if mime_type is None:\n            # Content-type header is not required. Take a best guess.\n            try:\n                mime_type = self._operation.produces[0]\n            except IndexError:\n                mime_type = \"application/octet-stream\"\n        if encoding is None:\n            encoding = \"utf-8\"\n\n        return mime_type, encoding\n\n    def validate_mime_type(self, mime_type: str) -> None:\n        \"\"\"Validate the mime type against the spec if it defines which mime types are produced.\n\n        :param mime_type: mime type from content type header\n        \"\"\"\n        if not self._operation.produces:\n            return\n\n        media_type_dict = MediaTypeDict(\n            [(p.lower(), None) for p in self._operation.produces]\n        )\n        if mime_type.lower() not in media_type_dict:\n            raise NonConformingResponseHeaders(\n                detail=f\"Invalid Response Content-type ({mime_type}), \"\n                f\"expected {self._operation.produces}\",\n            )\n\n    @staticmethod\n    def validate_required_headers(\n        headers: t.List[tuple], response_definition: dict\n    ) -> None:\n        required_header_keys = {\n            k.lower()\n            for (k, v) in response_definition.get(\"headers\", {}).items()\n            if v.get(\"required\", False)\n        }\n        header_keys = set(header[0].decode(\"latin-1\").lower() for header in headers)\n        missing_keys = required_header_keys - header_keys\n        if missing_keys:\n            pretty_list = \", \".join(missing_keys)\n            msg = (\n                \"Keys in response header don't match response specification. Difference: {}\"\n            ).format(pretty_list)\n            raise NonConformingResponseHeaders(detail=msg)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        async def wrapped_send(message: t.MutableMapping[str, t.Any]) -> None:\n            nonlocal send\n\n            if message[\"type\"] == \"http.response.start\":\n                headers = message[\"headers\"]\n\n                mime_type, encoding = self.extract_content_type(headers)\n                if message[\"status\"] < 400:\n                    self.validate_mime_type(mime_type)\n\n                status = str(message[\"status\"])\n                response_definition = self._operation.response_definition(\n                    status, mime_type\n                )\n                self.validate_required_headers(headers, response_definition)\n\n                # Validate body\n                try:\n                    body_validator = self._validator_map[\"response\"][mime_type]  # type: ignore\n                except KeyError:\n                    logger.info(\n                        f\"Skipping validation. No validator registered for content type: \"\n                        f\"{mime_type}.\"\n                    )\n                else:\n                    validator = body_validator(\n                        scope,\n                        schema=self._operation.response_schema(status, mime_type),\n                        nullable=utils.is_nullable(\n                            self._operation.response_definition(status, mime_type)\n                        ),\n                        encoding=encoding,\n                    )\n                    send = validator.wrap_send(send)\n\n            return await send(message)\n\n        await self.next_app(scope, receive, wrapped_send)"
    },
    {
      "chunk_id": 305,
      "source": "__internal__/data_repo/connexion/connexion/middleware/response_validation.py",
      "content": "class ResponseValidationAPI(RoutedAPI[ResponseValidationOperation]):\n    \"\"\"Validation API.\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        validator_map=None,\n        validate_responses=False,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.validator_map = validator_map\n        self.validate_responses = validate_responses\n        self.add_paths()\n\n    def make_operation(\n        self, operation: AbstractOperation\n    ) -> ResponseValidationOperation:\n        if self.validate_responses:\n            return ResponseValidationOperation(\n                self.next_app,\n                operation=operation,\n                validator_map=self.validator_map,\n            )\n        else:\n            return self.next_app  # type: ignore"
    },
    {
      "chunk_id": 306,
      "source": "__internal__/data_repo/connexion/connexion/middleware/response_validation.py",
      "content": "class ResponseValidationMiddleware(RoutedMiddleware[ResponseValidationAPI]):\n    \"\"\"Middleware for validating requests according to the API contract.\"\"\"\n\n    api_cls = ResponseValidationAPI\n```"
    },
    {
      "chunk_id": 307,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "\"\"\"\nValidation Middleware.\n\"\"\""
    },
    {
      "chunk_id": 308,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "import logging\nimport typing as t\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion import utils\nfrom connexion.datastructures import MediaTypeDict\nfrom connexion.exceptions import UnsupportedMediaTypeProblem\nfrom connexion.middleware.abstract import RoutedAPI, RoutedMiddleware\nfrom connexion.operations import AbstractOperation\nfrom connexion.validators import VALIDATOR_MAP"
    },
    {
      "chunk_id": 309,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "class RequestValidationOperation:\n    def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n        strict_validation: bool = False,\n        validator_map: t.Optional[dict] = None,\n    ) -> None:\n        self.next_app = next_app\n        self._operation = operation\n        self.strict_validation = strict_validation\n        self._validator_map = VALIDATOR_MAP.copy()\n        self._validator_map.update(validator_map or {})\n\n    def extract_content_type(\n        self, headers: t.List[t.Tuple[bytes, bytes]]\n    ) -> t.Tuple[str, str]:\n        \"\"\"Extract the mime type and encoding from the content type headers.\n\n        :param headers: Headers from ASGI scope\n\n        :return: A tuple of mime type, encoding\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n        mime_type, encoding = utils.split_content_type(content_type)\n        if mime_type is None:\n            # Content-type header is not required. Take a best guess.\n            try:\n                mime_type = self._operation.consumes[0]\n            except IndexError:\n                mime_type = \"application/octet-stream\"\n        if encoding is None:\n            encoding = \"utf-8\"\n\n        return mime_type, encoding\n\n    def validate_mime_type(self, mime_type: str) -> None:\n        \"\"\"Validate the mime type against the spec if it defines which mime types are accepted.\n\n        :param mime_type: mime type from content type header\n        \"\"\"\n        if not self._operation.consumes:\n            return\n\n        # Convert to MediaTypeDict to handle media-ranges\n        media_type_dict = MediaTypeDict(\n            [(c.lower(), None) for c in self._operation.consumes]\n        )\n        if mime_type.lower() not in media_type_dict:\n            raise UnsupportedMediaTypeProblem(\n                detail=f\"Invalid Content-type ({mime_type}), \"\n                f\"expected {self._operation.consumes}\"\n            )\n\n    @property\n    def security_query_params(self) -> t.List[str]:\n        \"\"\"Get the names of query parameters that are used for security.\"\"\"\n        if not hasattr(self, \"_security_query_params\"):\n            security_query_params: t.List[str] = []\n            if self._operation.security is None:\n                self._security_query_params = security_query_params\n                return self._security_query_params\n\n            for security_req in self._operation.security:\n                for scheme_name in security_req:\n                    security_scheme = self._operation.security_schemes[scheme_name]\n\n                    if (\n                        security_scheme[\"type\"] == \"apiKey\"\n                        and security_scheme[\"in\"] == \"query\"\n                    ):\n                        # Only query parameters need to be considered for strict_validation\n                        security_query_params.append(security_scheme[\"name\"])\n            self._security_query_params = security_query_params\n\n        return self._security_query_params\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        # Validate parameters & headers\n        uri_parser_class = self._operation._uri_parser_class\n        uri_parser = uri_parser_class(\n            self._operation.parameters, self._operation.body_definition()\n        )\n        parameter_validator_cls = self._validator_map[\"parameter\"]\n        parameter_validator = parameter_validator_cls(  # type: ignore\n            self._operation.parameters,\n            uri_parser=uri_parser,\n            strict_validation=self.strict_validation,\n            security_query_params=self.security_query_params,\n        )\n        parameter_validator.validate(scope)\n\n        # Extract content type\n        headers = scope[\"headers\"]\n        mime_type, encoding = self.extract_content_type(headers)\n        self.validate_mime_type(mime_type)\n\n        # Validate body\n        schema = self._operation.body_schema(mime_type)\n        if schema:\n            try:\n                body_validator = self._validator_map[\"body\"][mime_type]  # type: ignore\n            except KeyError:\n                logger.info(\n                    f\"Skipping validation. No validator registered for content type: \"\n                    f\"{mime_type}.\"\n                )\n            else:\n                validator = body_validator(\n                    schema=schema,\n                    required=self._operation.request_body.get(\"required\", False),\n                    nullable=utils.is_nullable(\n                        self._operation.body_definition(mime_type)\n                    ),\n                    encoding=encoding,\n                    strict_validation=self.strict_validation,\n                    uri_parser=self._operation.uri_parser_class(\n                        self._operation.parameters, self._operation.body_definition()\n                    ),\n                )\n                receive, scope = await validator.wrap_receive(receive, scope=scope)\n\n        await self.next_app(scope, receive, send)"
    },
    {
      "chunk_id": 310,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "class RequestValidationAPI(RoutedAPI[RequestValidationOperation]):\n    \"\"\"Validation API.\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        strict_validation=False,\n        validator_map=None,\n        uri_parser_class=None,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.validator_map = validator_map\n\n        logger.debug(\"Strict Request Validation: %s\", str(strict_validation))\n        self.strict_validation = strict_validation\n\n        self.uri_parser_class = uri_parser_class\n\n        self.add_paths()\n\n    def make_operation(\n        self, operation: AbstractOperation\n    ) -> RequestValidationOperation:\n        return RequestValidationOperation(\n            self.next_app,\n            operation=operation,\n            strict_validation=self.strict_validation,\n            validator_map=self.validator_map,\n        )"
    },
    {
      "chunk_id": 311,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "class RequestValidationMiddleware(RoutedMiddleware[RequestValidationAPI]):\n    \"\"\"Middleware for validating requests according to the API contract.\"\"\"\n\n    api_cls = RequestValidationAPI"
    },
    {
      "chunk_id": 312,
      "source": "__internal__/data_repo/connexion/connexion/middleware/request_validation.py",
      "content": "class MissingValidationOperation(Exception):\n    \"\"\"Missing validation operation\"\"\""
    },
    {
      "chunk_id": 313,
      "source": "__internal__/data_repo/connexion/connexion/middleware/swagger_ui.py",
      "content": "import json\nimport logging\nimport re\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom starlette.requests import Request as StarletteRequest\nfrom starlette.responses import RedirectResponse\nfrom starlette.responses import Response as StarletteResponse\nfrom starlette.routing import Router\nfrom starlette.staticfiles import StaticFiles\nfrom starlette.templating import Jinja2Templates\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.jsonifier import Jsonifier\nfrom connexion.middleware import SpecMiddleware\nfrom connexion.middleware.abstract import AbstractSpecAPI\nfrom connexion.options import SwaggerUIConfig, SwaggerUIOptions\nfrom connexion.spec import Specification\nfrom connexion.utils import yamldumper\n\nlogger = logging.getLogger(\"connexion.middleware.swagger_ui\")\n\n_original_scope: ContextVar[Scope] = ContextVar(\"SCOPE\")"
    },
    {
      "chunk_id": 314,
      "source": "__internal__/data_repo/connexion/connexion/middleware/swagger_ui.py",
      "content": "class SwaggerUIAPI(AbstractSpecAPI):\n    def __init__(\n        self,\n        *args,\n        default: ASGIApp,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.router = Router(default=default)\n        self.options = SwaggerUIConfig(\n            swagger_ui_options, oas_version=self.specification.version\n        )\n\n        if self.options.openapi_spec_available:\n            self.add_openapi_json()\n            self.add_openapi_yaml()\n\n        if self.options.swagger_ui_available:\n            self.add_swagger_ui()\n\n        self._templates = Jinja2Templates(\n            directory=str(self.options.swagger_ui_template_dir)\n        )\n\n    @staticmethod\n    def normalize_string(string):\n        return re.sub(r\"[^a-zA-Z0-9]\", \"_\", string.strip(\"/\"))\n\n    def _base_path_for_prefix(self, request: StarletteRequest) -> str:\n        \"\"\"\n        returns a modified basePath which includes the incoming root_path.\n        \"\"\"\n        return request.scope.get(\n            \"route_root_path\", request.scope.get(\"root_path\", \"\")\n        ).rstrip(\"/\")\n\n    def _spec_for_prefix(self, request) -> dict:\n        \"\"\"\n        returns a spec with a modified basePath / servers block\n        which corresponds to the incoming request path.\n        This is needed when behind a path-altering reverse proxy.\n        \"\"\"\n        base_path = self._base_path_for_prefix(request)\n        return self.specification.with_base_path(base_path).raw\n\n    def add_openapi_json(self):\n        \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n        logger.info(\n            \"Adding spec json: %s%s\", self.base_path, self.options.openapi_spec_path\n        )\n        self.router.add_route(\n            methods=[\"GET\"],\n            path=self.options.openapi_spec_path,\n            endpoint=self._get_openapi_json,\n        )\n\n    def add_openapi_yaml(self):\n        \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n        if not self.options.openapi_spec_path.endswith(\"json\"):\n            return\n\n        openapi_spec_path_yaml = self.options.openapi_spec_path[: -len(\"json\")] + \"yaml\"\n        logger.debug(\"Adding spec yaml: %s/%s\", self.base_path, openapi_spec_path_yaml)\n        self.router.add_route(\n            methods=[\"GET\"],\n            path=openapi_spec_path_yaml,\n            endpoint=self._get_openapi_yaml,\n        )\n\n    async def _get_openapi_json(self, request):\n        # Yaml parses datetime objects when loading the spec, so we need our custom jsonifier to dump it\n        jsonifier = Jsonifier()\n\n        return StarletteResponse(\n            content=jsonifier.dumps(self._spec_for_prefix(request)),\n            status_code=200,\n            media_type=\"application/json\",\n        )\n\n    async def _get_openapi_yaml(self, request):\n        return StarletteResponse(\n            content=yamldumper(self._spec_for_prefix(request)),\n            status_code=200,\n            media_type=\"text/yaml\",\n        )\n\n    def add_swagger_ui(self):\n        \"\"\"\n        Adds swagger ui to {base_path}/ui/\n        \"\"\"\n        console_ui_path = self.options.swagger_ui_path.strip().rstrip(\"/\")\n        logger.debug(\"Adding swagger-ui: %s%s/\", self.base_path, console_ui_path)\n\n        for path in (\n            console_ui_path + \"/\",\n            console_ui_path + \"/index.html\",\n        ):\n            self.router.add_route(\n                methods=[\"GET\"], path=path, endpoint=self._get_swagger_ui_home\n            )\n\n        if self.options.swagger_ui_config:\n            self.router.add_route(\n                methods=[\"GET\"],\n                path=console_ui_path + \"/swagger-ui-config.json\",\n                endpoint=self._get_swagger_ui_config,\n            )\n\n        async def redirect(request):\n            url = request.scope.get(\"root_path\", \"\").rstrip(\"/\")\n            url += console_ui_path\n            url += \"/\"\n            return RedirectResponse(url=url)\n\n        self.router.add_route(methods=[\"GET\"], path=console_ui_path, endpoint=redirect)\n\n        self.router.mount(\n            path=console_ui_path,\n            app=StaticFiles(directory=str(self.options.swagger_ui_template_dir)),\n            name=\"swagger_ui_static\",\n        )\n\n    async def _get_swagger_ui_home(self, req):\n        base_path = self._base_path_for_prefix(req)\n        template_variables = {\n            \"openapi_spec_url\": (base_path + self.options.openapi_spec_path),\n            **self.options.swagger_ui_template_arguments,\n        }\n        if self.options.swagger_ui_config:\n            template_variables[\"configUrl\"] = \"swagger-ui-config.json\"\n\n        return self._templates.TemplateResponse(\n            req, name=\"index.j2\", context=template_variables\n        )\n\n    async def _get_swagger_ui_config(self, request):\n        return StarletteResponse(\n            status_code=200,\n            media_type=\"application/json\",\n            content=json.dumps(self.options.swagger_ui_config),\n        )"
    },
    {
      "chunk_id": 315,
      "source": "__internal__/data_repo/connexion/connexion/middleware/swagger_ui.py",
      "content": "class SwaggerUIMiddleware(SpecMiddleware):\n    def __init__(self, app: ASGIApp) -> None:\n        \"\"\"Middleware that hosts a swagger UI.\n\n        :param app: app to wrap in middleware.\n        \"\"\"\n        self.app = app\n        self.router = Router(default=self.default_fn)\n\n    def add_api(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        **kwargs\n    ) -> None:\n        \"\"\"Add an API to the router based on a OpenAPI spec.\n\n        :param specification: OpenAPI spec.\n        :param base_path: Base path where to add this API.\n        :param arguments: Jinja arguments to replace in the spec.\n        \"\"\"\n        api = SwaggerUIAPI(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            default=self.default_fn,\n            **kwargs\n        )\n        self.router.mount(api.base_path, app=api.router)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        _original_scope.set(scope.copy())  # type: ignore\n        await self.router(scope, receive, send)\n\n    async def default_fn(self, _scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Callback to call next app as default when no matching route is found.\n\n        Unfortunately we cannot just pass the next app as default, since the router manipulates\n        the scope when descending into mounts, losing information about the base path. Therefore,\n        we use the original scope instead.\n\n        This is caused by https://github.com/encode/starlette/issues/1336.\n        \"\"\"\n        original_scope = _original_scope.get()\n        await self.app(original_scope, receive, send)"
    },
    {
      "chunk_id": 316,
      "source": "__internal__/data_repo/connexion/connexion/middleware/security.py",
      "content": "import logging\nimport typing as t\nfrom collections import defaultdict\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.exceptions import ProblemException\nfrom connexion.lifecycle import ConnexionRequest\nfrom connexion.middleware.abstract import RoutedAPI, RoutedMiddleware\nfrom connexion.operations import AbstractOperation\nfrom connexion.security import SecurityHandlerFactory\nfrom connexion.spec import Specification\n\nlogger = logging.getLogger(\"connexion.middleware.security\")"
    },
    {
      "chunk_id": 317,
      "source": "__internal__/data_repo/connexion/connexion/middleware/security.py",
      "content": "class SecurityOperation:\n    def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        security_handler_factory: SecurityHandlerFactory,\n        security: list,\n        security_schemes: dict,\n    ):\n        self.next_app = next_app\n        self.security_handler_factory = security_handler_factory\n        self.security = security\n        self.security_schemes = security_schemes\n        self.verification_fn = self._get_verification_fn()\n\n    @classmethod\n    def from_operation(\n        cls,\n        operation: t.Union[AbstractOperation, Specification],\n        *,\n        next_app: ASGIApp,\n        security_handler_factory: SecurityHandlerFactory,\n    ) -> \"SecurityOperation\":\n        \"\"\"Create a SecurityOperation from an Operation of Specification instance\n\n        :param operation: The operation can be both an Operation or Specification instance here\n            since security is defined at both levels in the OpenAPI spec. Creating a\n            SecurityOperation based on a Specification can be used to create a SecurityOperation\n            for routes not explicitly defined in the specification.\n        :param next_app: The next ASGI app to call.\n        :param security_handler_factory: The factory to be used to generate security handlers for\n            the different security schemes.\n        \"\"\"\n        return cls(\n            next_app=next_app,\n            security_handler_factory=security_handler_factory,\n            security=operation.security,\n            security_schemes=operation.security_schemes,\n        )\n\n    def _get_verification_fn(self):\n        logger.debug(\"... Security: %s\", self.security, extra=vars(self))\n        if not self.security:\n            return self.security_handler_factory.security_passthrough\n\n        auth_funcs = []\n        for security_req in self.security:\n            if not security_req:\n                auth_funcs.append(self.security_handler_factory.verify_none)\n                continue\n\n            sec_req_funcs = {}\n            oauth = False\n            for scheme_name, required_scopes in security_req.items():\n                security_scheme = self.security_schemes[scheme_name]\n\n                if security_scheme[\"type\"] == \"oauth2\":\n                    if oauth:\n                        logger.warning(\n                            \"... multiple OAuth2 security schemes in AND fashion not supported\",\n                            extra=vars(self),\n                        )\n                        break\n                    oauth = True\n\n                sec_req_func = self.security_handler_factory.parse_security_scheme(\n                    security_scheme, required_scopes\n                )\n                if sec_req_func is None:\n                    break\n\n                sec_req_funcs[scheme_name] = sec_req_func\n\n            else:\n                # No break encountered: no missing funcs\n                if len(sec_req_funcs) == 1:\n                    (func,) = sec_req_funcs.values()\n                    auth_funcs.append(func)\n                else:\n                    auth_funcs.append(\n                        self.security_handler_factory.verify_multiple_schemes(\n                            sec_req_funcs\n                        )\n                    )\n\n        return self.security_handler_factory.verify_security(auth_funcs)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if not self.security:\n            await self.next_app(scope, receive, send)\n            return\n\n        request = ConnexionRequest(scope)\n        await self.verification_fn(request)\n        await self.next_app(scope, receive, send)"
    },
    {
      "chunk_id": 318,
      "source": "__internal__/data_repo/connexion/connexion/middleware/security.py",
      "content": "class SecurityAPI(RoutedAPI[SecurityOperation]):\n    def __init__(\n        self,\n        *args,\n        auth_all_paths: bool = False,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.security_handler_factory = SecurityHandlerFactory(security_map)\n\n        if auth_all_paths:\n            self.add_auth_on_not_found()\n        else:\n            self.operations: t.MutableMapping[t.Optional[str], SecurityOperation] = {}\n\n        self.add_paths()\n\n    def add_auth_on_not_found(self) -> None:\n        \"\"\"Register a default SecurityOperation for routes that are not found.\"\"\"\n        default_operation = self.make_operation(self.specification)\n        self.operations = defaultdict(lambda: default_operation)\n\n    def make_operation(\n        self, operation: t.Union[AbstractOperation, Specification]\n    ) -> SecurityOperation:\n        \"\"\"Create a SecurityOperation from an Operation of Specification instance\n\n        :param operation: The operation can be both an Operation or Specification instance here\n            since security is defined at both levels in the OpenAPI spec. Creating a\n            SecurityOperation based on a Specification can be used to create a SecurityOperation\n            for routes not explicitly defined in the specification.\n        \"\"\"\n        return SecurityOperation.from_operation(\n            operation,\n            next_app=self.next_app,\n            security_handler_factory=self.security_handler_factory,\n        )"
    },
    {
      "chunk_id": 319,
      "source": "__internal__/data_repo/connexion/connexion/middleware/security.py",
      "content": "class SecurityMiddleware(RoutedMiddleware[SecurityAPI]):\n    \"\"\"Middleware to check if operation is accessible on scope.\"\"\"\n\n    api_cls = SecurityAPI"
    },
    {
      "chunk_id": 320,
      "source": "__internal__/data_repo/connexion/connexion/middleware/security.py",
      "content": "class MissingSecurityOperation(ProblemException):\n    pass"
    },
    {
      "chunk_id": 321,
      "source": "__internal__/data_repo/connexion/connexion/middleware/lifespan.py",
      "content": "import typing as t\n\nfrom starlette.routing import Router\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nLifespan = t.Callable[[t.Any], t.AsyncContextManager]"
    },
    {
      "chunk_id": 322,
      "source": "__internal__/data_repo/connexion/connexion/middleware/lifespan.py",
      "content": "class LifespanMiddleware:\n    \"\"\"\n    Middleware that adds support for Starlette lifespan handlers\n    (https://www.starlette.io/lifespan/).\n    \"\"\"\n\n    def __init__(self, next_app: ASGIApp, *, lifespan: t.Optional[Lifespan]) -> None:\n        self.next_app = next_app\n        self._lifespan = lifespan\n        # Leverage a Starlette Router for lifespan handling only\n        self.router = Router(lifespan=lifespan)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        # If no lifespan is registered, pass to next app so it can be handled downstream.\n        if scope[\"type\"] == \"lifespan\" and self._lifespan:\n            await self.router(scope, receive, send)\n        else:\n            await self.next_app(scope, receive, send)"
    },
    {
      "chunk_id": 323,
      "source": "__internal__/data_repo/connexion/connexion/middleware/routing.py",
      "content": "import typing as t\nfrom contextvars import ContextVar\n\nimport starlette.convertors\nfrom starlette.routing import Router\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.frameworks import starlette as starlette_utils\nfrom connexion.middleware.abstract import (\n    ROUTING_CONTEXT,\n    AbstractRoutingAPI,\n    SpecMiddleware,\n)\nfrom connexion.operations import AbstractOperation\nfrom connexion.resolver import Resolver\nfrom connexion.spec import Specification\n\n_scope: ContextVar[dict] = ContextVar(\"SCOPE\")"
    },
    {
      "chunk_id": 324,
      "source": "__internal__/data_repo/connexion/connexion/middleware/routing.py",
      "content": "class RoutingOperation:\n    def __init__(self, operation_id: t.Optional[str], next_app: ASGIApp) -> None:\n        self.operation_id = operation_id\n        self.next_app = next_app\n\n    @classmethod\n    def from_operation(cls, operation: AbstractOperation, next_app: ASGIApp):\n        return cls(operation.operation_id, next_app)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"Attach operation to scope and pass it to the next app\"\"\"\n        original_scope = _scope.get()\n        # Pass resolved path params along\n        original_scope.setdefault(\"path_params\", {}).update(\n            scope.get(\"path_params\", {})\n        )\n\n        def get_root_path(scope: Scope) -> str:\n            return scope.get(\"route_root_path\", scope.get(\"root_path\", \"\"))\n\n        api_base_path = get_root_path(scope)[len(get_root_path(original_scope)) :]\n\n        extensions = original_scope.setdefault(\"extensions\", {})\n        connexion_routing = extensions.setdefault(ROUTING_CONTEXT, {})\n        connexion_routing.update(\n            {\"api_base_path\": api_base_path, \"operation_id\": self.operation_id}\n        )\n        await self.next_app(original_scope, receive, send)"
    },
    {
      "chunk_id": 325,
      "source": "__internal__/data_repo/connexion/connexion/middleware/routing.py",
      "content": "class RoutingAPI(AbstractRoutingAPI):\n    def __init__(\n        self,\n        specification: Specification,\n        *,\n        next_app: ASGIApp,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        resolver: t.Optional[Resolver] = None,\n        resolver_error_handler: t.Optional[t.Callable] = None,\n        debug: bool = False,\n        **kwargs,\n    ) -> None:\n        \"\"\"API implementation on top of Starlette Router for Connexion middleware.\"\"\"\n        self.next_app = next_app\n        self.router = Router(default=RoutingOperation(None, next_app))\n\n        super().__init__(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            resolver=resolver,\n            resolver_error_handler=resolver_error_handler,\n            debug=debug,\n            **kwargs,\n        )\n\n    def make_operation(self, operation: AbstractOperation) -> RoutingOperation:\n        return RoutingOperation.from_operation(operation, next_app=self.next_app)\n\n    @staticmethod\n    def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        types = operation.get_path_parameter_types()\n        starlette_path = starlette_utils.starlettify_path(path, types)\n        return starlette_path, starlette_path\n\n    def _add_operation_internal(\n        self,\n        method: str,\n        path: str,\n        operation: RoutingOperation,\n        name: t.Optional[str] = None,\n    ) -> None:\n        self.router.add_route(path, operation, methods=[method])"
    },
    {
      "chunk_id": 326,
      "source": "__internal__/data_repo/connexion/connexion/middleware/routing.py",
      "content": "class RoutingMiddleware(SpecMiddleware):\n    def __init__(self, app: ASGIApp) -> None:\n        \"\"\"Middleware that resolves the Operation for an incoming request and attaches it to the\n        scope.\n\n        :param app: app to wrap in middleware.\n        \"\"\"\n        self.app = app\n        # Pass unknown routes to next app\n        self.router = Router(default=RoutingOperation(None, self.app))\n        starlette.convertors.register_url_convertor(\n            \"float\", starlette_utils.FloatConverter()\n        )\n        starlette.convertors.register_url_convertor(\n            \"int\", starlette_utils.IntegerConverter()\n        )\n\n    def add_api(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"Add an API to the router based on a OpenAPI spec.\n\n        :param specification: OpenAPI spec.\n        :param base_path: Base path where to add this API.\n        :param arguments: Jinja arguments to replace in the spec.\n        \"\"\"\n        api = RoutingAPI(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            next_app=self.app,\n            **kwargs,\n        )\n\n        # If an API with the same base_path was already registered, chain the new API as its\n        # default. This way, if no matching route is found on the first API, the request is\n        # forwarded to the new API.\n        for route in self.router.routes:\n            if (\n                isinstance(route, starlette.routing.Mount)\n                and route.path == api.base_path\n            ):\n                route.app.default = api.router\n\n        self.router.mount(api.base_path, app=api.router)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"Route request to matching operation, and attach it to the scope before calling the\n        next app.\"\"\"\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        _scope.set(scope.copy())  # type: ignore\n\n        await self.router(scope, receive, send)"
    },
    {
      "chunk_id": 327,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "import abc\nimport logging\nimport typing as t\nfrom collections import defaultdict\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.exceptions import MissingMiddleware, ResolverError\nfrom connexion.http_facts import METHODS\nfrom connexion.operations import AbstractOperation\nfrom connexion.resolver import Resolver\nfrom connexion.spec import Specification\n\nlogger = logging.getLogger(__name__)\n\nROUTING_CONTEXT = \"connexion_routing\""
    },
    {
      "chunk_id": 328,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class SpecMiddleware(abc.ABC):\n    \"\"\"Middlewares that need the specification(s) to be registered on them should inherit from this\n    base class\"\"\"\n\n    @abc.abstractmethod\n    def add_api(self, specification: Specification, **kwargs) -> t.Any:\n        \"\"\"\n        Register an API represented by a single OpenAPI specification on this middleware.\n        Multiple APIs can be registered on a single middleware.\n        \"\"\"\n\n    @abc.abstractmethod\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        pass"
    },
    {
      "chunk_id": 329,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class AbstractSpecAPI:\n    \"\"\"Base API class with only minimal behavior related to the specification.\"\"\"\n\n    def __init__(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        resolver: t.Optional[Resolver] = None,\n        uri_parser_class=None,\n        *args,\n        **kwargs,\n    ):\n        self.specification = specification\n        self.uri_parser_class = uri_parser_class\n\n        self._set_base_path(base_path)\n\n        self.resolver = resolver or Resolver()\n\n    def _set_base_path(self, base_path: t.Optional[str] = None) -> None:\n        if base_path is not None:\n            # update spec to include user-provided base_path\n            self.specification.base_path = base_path\n            self.base_path = base_path\n        else:\n            self.base_path = self.specification.base_path"
    },
    {
      "chunk_id": 330,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "OP = t.TypeVar(\"OP\")\n\"\"\"Typevar representing an operation\"\"\""
    },
    {
      "chunk_id": 331,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class AbstractRoutingAPI(AbstractSpecAPI, t.Generic[OP]):\n    \"\"\"Base API class with shared functionality related to routing.\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        pythonic_params=False,\n        resolver_error_handler: t.Optional[t.Callable] = None,\n        **kwargs,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n        self.pythonic_params = pythonic_params\n        self.resolver_error_handler = resolver_error_handler\n\n        self.add_paths()\n\n    def add_paths(self, paths: t.Optional[dict] = None) -> None:\n        \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n        paths = t.cast(dict, paths or self.specification.get(\"paths\", dict()))\n        for path, methods in paths.items():\n            logger.debug(\"Adding %s%s...\", self.base_path, path)\n\n            for method in methods:\n                if method not in METHODS:\n                    continue\n                try:\n                    self.add_operation(path, method)\n                except ResolverError as err:\n                    # If we have an error handler for resolver errors, add it as an operation.\n                    # Otherwise treat it as any other error.\n                    if self.resolver_error_handler is not None:\n                        self._add_resolver_error_handler(method, path, err)\n                    else:\n                        self._handle_add_operation_error(path, method, err)\n                except Exception as e:\n                    # All other relevant exceptions should be handled as well.\n                    self._handle_add_operation_error(path, method, e)\n\n    def add_operation(self, path: str, method: str) -> None:\n        \"\"\"\n        Adds one operation to the api.\n\n        This method uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n        \"\"\"\n        spec_operation_cls = self.specification.operation_cls\n        spec_operation = spec_operation_cls.from_spec(\n            self.specification,\n            path=path,\n            method=method,\n            resolver=self.resolver,\n            uri_parser_class=self.uri_parser_class,\n        )\n        operation = self.make_operation(spec_operation)\n        path, name = self._framework_path_and_name(spec_operation, path)\n        self._add_operation_internal(method, path, operation, name=name)\n\n    @abc.abstractmethod\n    def make_operation(self, operation: AbstractOperation) -> OP:\n        \"\"\"Build an operation to register on the API.\"\"\"\n\n    @staticmethod\n    def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        \"\"\"Prepare the framework path & name to register the operation on the API.\"\"\"\n\n    @abc.abstractmethod\n    def _add_operation_internal(\n        self, method: str, path: str, operation: OP, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Adds the operation according to the user framework in use.\n        It will be used to register the operation on the user framework router.\n        \"\"\"\n\n    def _add_resolver_error_handler(\n        self, method: str, path: str, err: ResolverError\n    ) -> None:\n        \"\"\"\n        Adds a handler for ResolverError for the given method and path.\n        \"\"\"\n        self.resolver_error_handler = t.cast(t.Callable, self.resolver_error_handler)\n        operation = self.resolver_error_handler(\n            err,\n        )\n        self._add_operation_internal(method, path, operation)\n\n    def _handle_add_operation_error(\n        self, path: str, method: str, exc: Exception\n    ) -> None:\n        url = f\"{self.base_path}{path}\"\n        error_msg = f\"Failed to add operation for {method.upper()} {url}\"\n        logger.error(error_msg)\n        raise exc from None"
    },
    {
      "chunk_id": 332,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class RoutedAPI(AbstractSpecAPI, t.Generic[OP]):\n    def __init__(\n        self,\n        specification: Specification,\n        *args,\n        next_app: ASGIApp,\n        **kwargs,\n    ) -> None:\n        super().__init__(specification, *args, **kwargs)\n        self.next_app = next_app\n        self.operations: t.MutableMapping[t.Optional[str], OP] = {}\n\n    def add_paths(self) -> None:\n        paths = self.specification.get(\"paths\", {})\n        for path, methods in paths.items():\n            for method in methods:\n                if method not in METHODS:\n                    continue\n                try:\n                    self.add_operation(path, method)\n                except ResolverError:\n                    # ResolverErrors are either raised or handled in routing middleware.\n                    pass\n\n    def add_operation(self, path: str, method: str) -> None:\n        operation_spec_cls = self.specification.operation_cls\n        operation = operation_spec_cls.from_spec(\n            self.specification,\n            path=path,\n            method=method,\n            resolver=self.resolver,\n            uri_parser_class=self.uri_parser_class,\n        )\n        routed_operation = self.make_operation(operation)\n        self.operations[operation.operation_id] = routed_operation\n\n    @abc.abstractmethod\n    def make_operation(self, operation: AbstractOperation) -> OP:\n        \"\"\"Create an operation of the `operation_cls` type.\"\"\"\n        raise NotImplementedError"
    },
    {
      "chunk_id": 333,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "API = t.TypeVar(\"API\", bound=\"RoutedAPI\")\n\"\"\"Typevar representing an API which subclasses RoutedAPI\"\"\""
    },
    {
      "chunk_id": 334,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class RoutedMiddleware(SpecMiddleware, t.Generic[API]):\n    \"\"\"Baseclass for middleware that wants to leverage the RoutingMiddleware to route requests to\n    its operations.\n\n    The RoutingMiddleware adds the operation_id to the ASGI scope. This middleware registers its\n    operations by operation_id at startup. At request time, the operation is fetched by an\n    operation_id lookup.\n    \"\"\"\n\n    api_cls: t.Type[API]\n    \"\"\"The subclass of RoutedAPI this middleware uses.\"\"\"\n\n    def __init__(self, app: ASGIApp) -> None:\n        self.app = app\n        self.apis: t.Dict[str, t.List[API]] = defaultdict(list)\n\n    def add_api(self, specification: Specification, **kwargs) -> API:\n        api = self.api_cls(specification, next_app=self.app, **kwargs)\n        self.apis[api.base_path].append(api)\n        return api\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"Fetches the operation related to the request and calls it.\"\"\"\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        try:\n            connexion_context = scope[\"extensions\"][ROUTING_CONTEXT]\n        except KeyError:\n            raise MissingMiddleware(\n                \"Could not find routing information in scope. Please make sure \"\n                \"you have a routing middleware registered upstream. \"\n            )\n        api_base_path = connexion_context.get(\"api_base_path\")\n        if api_base_path is not None and api_base_path in self.apis:\n            for api in self.apis[api_base_path]:\n                operation_id = connexion_context.get(\"operation_id\")\n                try:\n                    operation = api.operations[operation_id]\n                except KeyError:\n                    if operation_id is None:\n                        logger.debug(\"Skipping operation without id.\")\n                        await self.app(scope, receive, send)\n                        return\n                else:\n                    return await operation(scope, receive, send)\n\n            raise MissingOperation(\"Encountered unknown operation_id.\")\n\n        await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 335,
      "source": "__internal__/data_repo/connexion/connexion/middleware/abstract.py",
      "content": "class MissingOperation(Exception):\n    \"\"\"Missing operation\"\"\""
    },
    {
      "chunk_id": 336,
      "source": "__internal__/data_repo/connexion/connexion/middleware/context.py",
      "content": "\"\"\"The ContextMiddleware creates a global context based the scope. It should be last in the\nmiddleware stack, so it exposes the scope passed to the application\"\"\"\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.context import _context, _operation, _receive, _scope\nfrom connexion.middleware.abstract import RoutedAPI, RoutedMiddleware\nfrom connexion.operations import AbstractOperation"
    },
    {
      "chunk_id": 337,
      "source": "__internal__/data_repo/connexion/connexion/middleware/context.py",
      "content": "class ContextOperation:\n    def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n    ) -> None:\n        self.next_app = next_app\n        self.operation = operation\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        _context.set(scope.get(\"extensions\", {}).get(\"connexion_context\", {}))\n        _operation.set(self.operation)\n        _receive.set(receive)\n        _scope.set(scope)\n        await self.next_app(scope, receive, send)"
    },
    {
      "chunk_id": 338,
      "source": "__internal__/data_repo/connexion/connexion/middleware/context.py",
      "content": "class ContextAPI(RoutedAPI[ContextOperation]):\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.add_paths()\n\n    def make_operation(self, operation: AbstractOperation) -> ContextOperation:\n        return ContextOperation(self.next_app, operation=operation)"
    },
    {
      "chunk_id": 339,
      "source": "__internal__/data_repo/connexion/connexion/middleware/context.py",
      "content": "class ContextMiddleware(RoutedMiddleware[ContextAPI]):\n    \"\"\"Middleware to expose operation specific context to application.\"\"\"\n\n    api_cls = ContextAPI"
    },
    {
      "chunk_id": 340,
      "source": "__internal__/data_repo/connexion/connexion/middleware/server_error.py",
      "content": "import logging\nimport typing as t\n\nfrom starlette.middleware.errors import (\n    ServerErrorMiddleware as StarletteServerErrorMiddleware,\n)\nfrom starlette.types import ASGIApp\n\nfrom connexion.exceptions import InternalServerError\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.middleware.exceptions import connexion_wrapper\nfrom connexion.types import MaybeAwaitable\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 341,
      "source": "__internal__/data_repo/connexion/connexion/middleware/server_error.py",
      "content": "class ServerErrorMiddleware(StarletteServerErrorMiddleware):\n    \"\"\"Subclass of starlette ServerErrorMiddleware to change handling of Unhandled Server\n    exceptions to existing connexion behavior.\"\"\"\n\n    def __init__(\n        self,\n        next_app: ASGIApp,\n        handler: t.Optional[\n            t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]\n        ] = None,\n    ):\n        handler = connexion_wrapper(handler) if handler else None\n        super().__init__(next_app, handler=handler)\n\n    @staticmethod\n    @connexion_wrapper\n    def error_response(_request: ConnexionRequest, exc: Exception) -> ConnexionResponse:\n        \"\"\"Default handler for any unhandled Exception\"\"\"\n        logger.error(\"%r\", exc, exc_info=exc)\n        return InternalServerError().to_problem()"
    },
    {
      "chunk_id": 342,
      "source": "__internal__/data_repo/connexion/connexion/middleware/exceptions.py",
      "content": "import asyncio\nimport functools\nimport logging\nimport typing as t\n\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware.exceptions import (\n    ExceptionMiddleware as StarletteExceptionMiddleware,\n)\nfrom starlette.requests import Request as StarletteRequest\nfrom starlette.responses import Response as StarletteResponse\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion import http_facts\nfrom connexion.exceptions import InternalServerError, ProblemException, problem\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.types import MaybeAwaitable\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 343,
      "source": "__internal__/data_repo/connexion/connexion/middleware/exceptions.py",
      "content": "def connexion_wrapper(\n    handler: t.Callable[\n        [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n    ]\n) -> t.Callable[[StarletteRequest, Exception], t.Awaitable[StarletteResponse]]:\n    \"\"\"Wrapper that translates Starlette requests to Connexion requests before passing\n    them to the error handler, and translates the returned Connexion responses to\n    Starlette responses.\"\"\"\n\n    @functools.wraps(handler)\n    async def wrapper(request: StarletteRequest, exc: Exception) -> StarletteResponse:\n        request = ConnexionRequest.from_starlette_request(request)\n\n        if asyncio.iscoroutinefunction(handler):\n            response = await handler(request, exc)  # type: ignore\n        else:\n            response = await run_in_threadpool(handler, request, exc)\n\n        while asyncio.iscoroutine(response):\n            response = await response\n\n        return StarletteResponse(\n            content=response.body,\n            status_code=response.status_code,\n            media_type=response.mimetype,\n            headers=response.headers,\n        )\n\n    return wrapper"
    },
    {
      "chunk_id": 344,
      "source": "__internal__/data_repo/connexion/connexion/middleware/exceptions.py",
      "content": "class ExceptionMiddleware(StarletteExceptionMiddleware):\n    \"\"\"Subclass of starlette ExceptionMiddleware to change handling of HTTP exceptions to\n    existing connexion behavior.\"\"\"\n\n    def __init__(self, next_app: ASGIApp):\n        super().__init__(next_app)\n        self.add_exception_handler(ProblemException, self.problem_handler)  # type: ignore\n        self.add_exception_handler(Exception, self.common_error_handler)\n\n    def add_exception_handler(\n        self,\n        exc_class_or_status_code: t.Union[int, t.Type[Exception]],\n        handler: t.Callable[[ConnexionRequest, Exception], StarletteResponse],\n    ) -> None:\n        super().add_exception_handler(\n            exc_class_or_status_code, handler=connexion_wrapper(handler)\n        )\n\n    @staticmethod\n    def problem_handler(_request: ConnexionRequest, exc: ProblemException):\n        \"\"\"Default handler for Connexion ProblemExceptions\"\"\"\n\n        if 400 <= exc.status <= 499:\n            logger.warning(\"%r\", exc)\n        else:\n            logger.error(\"%r\", exc)\n\n        return exc.to_problem()\n\n    @staticmethod\n    @connexion_wrapper\n    def http_exception(\n        _request: StarletteRequest, exc: HTTPException, **kwargs\n    ) -> StarletteResponse:\n        \"\"\"Default handler for Starlette HTTPException\"\"\"\n\n        if 400 <= exc.status_code <= 499:\n            logger.warning(\"%r\", exc)\n        else:\n            logger.error(\"%r\", exc)\n\n        return problem(\n            title=http_facts.HTTP_STATUS_CODES.get(exc.status_code),\n            detail=exc.detail,\n            status=exc.status_code,\n            headers=exc.headers,\n        )\n\n    @staticmethod\n    def common_error_handler(\n        _request: StarletteRequest, exc: Exception\n    ) -> ConnexionResponse:\n        \"\"\"Default handler for any unhandled Exception\"\"\"\n        logger.error(\"%r\", exc, exc_info=exc)\n        return InternalServerError().to_problem()\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await super().__call__(scope, receive, send)"
    },
    {
      "chunk_id": 345,
      "source": "__internal__/data_repo/connexion/connexion/apps/__init__.py",
      "content": "\"\"\"\nThis module defines Connexion applications. A Connexion App wraps a specific framework application\nand exposes a standardized interface for users to create and configure their Connexion application.\n\"\"\""
    },
    {
      "chunk_id": 346,
      "source": "__internal__/data_repo/connexion/connexion/apps/__init__.py",
      "content": "from .abstract import AbstractApp  # NOQA"
    },
    {
      "chunk_id": 347,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "```python"
    },
    {
      "chunk_id": 348,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "This module defines a native connexion asynchronous application.\n###"
    },
    {
      "chunk_id": 349,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "import functools\nimport logging\nimport pathlib\nimport typing as t\n\nfrom starlette.responses import Response as StarletteResponse\nfrom starlette.routing import Router\nfrom starlette.types import Receive, Scope, Send\n\nfrom connexion.apps.abstract import AbstractApp\nfrom connexion.decorators import StarletteDecorator\nfrom connexion.jsonifier import Jsonifier\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.middleware.abstract import RoutedAPI, RoutedMiddleware\nfrom connexion.middleware.lifespan import Lifespan\nfrom connexion.operations import AbstractOperation\nfrom connexion.options import SwaggerUIOptions\nfrom connexion.resolver import Resolver\nfrom connexion.types import MaybeAwaitable\nfrom connexion.uri_parsing import AbstractURIParser\n\nlogger = logging.getLogger(__name__)\n###"
    },
    {
      "chunk_id": 350,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "class AsyncOperation:\n    def __init__(\n        self,\n        fn: t.Callable,\n        jsonifier: Jsonifier,\n        operation_id: str,\n        pythonic_params: bool,\n    ) -> None:\n        self._fn = fn\n        self.jsonifier = jsonifier\n        self.operation_id = operation_id\n        self.pythonic_params = pythonic_params\n        functools.update_wrapper(self, fn)\n\n    @classmethod\n    def from_operation(\n        cls,\n        operation: AbstractOperation,\n        *,\n        pythonic_params: bool,\n        jsonifier: Jsonifier,\n    ) -> \"AsyncOperation\":\n        return cls(\n            operation.function,\n            jsonifier=jsonifier,\n            operation_id=operation.operation_id,\n            pythonic_params=pythonic_params,\n        )\n\n    @property\n    def fn(self) -> t.Callable:\n        decorator = StarletteDecorator(\n            pythonic_params=self.pythonic_params,\n            jsonifier=self.jsonifier,\n        )\n        return decorator(self._fn)\n\n    async def __call__(\n        self, scope: Scope, receive: Receive, send: Send\n    ) -> StarletteResponse:\n        response = await self.fn()\n        return await response(scope, receive, send)\n###"
    },
    {
      "chunk_id": 351,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "class AsyncApi(RoutedAPI[AsyncOperation]):\n    def __init__(\n        self,\n        *args,\n        pythonic_params: bool,\n        jsonifier: t.Optional[Jsonifier] = None,\n        **kwargs,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n        self.pythonic_params = pythonic_params\n        self.jsonifier = jsonifier or Jsonifier()\n        self.router = Router()\n        self.add_paths()\n\n    def make_operation(self, operation: AbstractOperation) -> AsyncOperation:\n        return AsyncOperation.from_operation(\n            operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier\n        )\n###"
    },
    {
      "chunk_id": 352,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "class AsyncASGIApp(RoutedMiddleware[AsyncApi]):\n\n    api_cls = AsyncApi\n\n    def __init__(self) -> None:\n        self.apis: t.Dict[str, t.List[AsyncApi]] = {}\n        self.operations: t.Dict[str, AsyncOperation] = {}\n        self.router = Router()\n        super().__init__(self.router)\n\n    def add_api(self, *args, name: t.Optional[str] = None, **kwargs):\n        api = super().add_api(*args, **kwargs)\n\n        if name is not None:\n            self.router.mount(api.base_path, api.router, name=name)\n        else:\n            self.router.mount(api.base_path, api.router)\n        return api\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        methods: t.List[str] = None,\n        **options,\n    ):\n        self.router.add_route(rule, endpoint=view_func, name=endpoint, methods=methods)\n###"
    },
    {
      "chunk_id": 353,
      "source": "__internal__/data_repo/connexion/connexion/apps/asynchronous.py",
      "content": "class AsyncApp(AbstractApp):\n    \"\"\"Connexion Application based on ConnexionMiddleware wrapping a async Connexion application\n    based on starlette tools.\"\"\"\n\n    def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ) -> None:\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n            shutdown tasks.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self._middleware_app: AsyncASGIApp = AsyncASGIApp()\n\n        super().__init__(\n            import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        self._middleware_app.add_url_rule(\n            rule, endpoint=endpoint, view_func=view_func, **options\n        )\n\n    def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        self.middleware.add_error_handler(code_or_exception, function)\n```"
    },
    {
      "chunk_id": 354,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "```python"
    },
    {
      "chunk_id": 355,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "This module defines a FlaskApp, a Connexion application to wrap a Flask application."
    },
    {
      "chunk_id": 356,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "import functools\nimport pathlib\nimport typing as t\n\nimport flask\nimport starlette.exceptions\nimport werkzeug.exceptions\nfrom a2wsgi import WSGIMiddleware\nfrom flask import Response as FlaskResponse\nfrom starlette.types import Receive, Scope, Send\n\nfrom connexion.apps.abstract import AbstractApp\nfrom connexion.decorators import FlaskDecorator\nfrom connexion.exceptions import ResolverError\nfrom connexion.frameworks import flask as flask_utils\nfrom connexion.jsonifier import Jsonifier\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.middleware.abstract import AbstractRoutingAPI, SpecMiddleware\nfrom connexion.middleware.lifespan import Lifespan\nfrom connexion.operations import AbstractOperation\nfrom connexion.options import SwaggerUIOptions\nfrom connexion.resolver import Resolver\nfrom connexion.types import MaybeAwaitable, WSGIApp\nfrom connexion.uri_parsing import AbstractURIParser"
    },
    {
      "chunk_id": 357,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "class FlaskOperation:\n    def __init__(\n        self,\n        fn: t.Callable,\n        jsonifier: Jsonifier,\n        operation_id: str,\n        pythonic_params: bool,\n    ) -> None:\n        self._fn = fn\n        self.jsonifier = jsonifier\n        self.operation_id = operation_id\n        self.pythonic_params = pythonic_params\n        functools.update_wrapper(self, fn)\n\n    @classmethod\n    def from_operation(\n        cls,\n        operation: AbstractOperation,\n        *,\n        pythonic_params: bool,\n        jsonifier: Jsonifier,\n    ) -> \"FlaskOperation\":\n        return cls(\n            fn=operation.function,\n            jsonifier=jsonifier,\n            operation_id=operation.operation_id,\n            pythonic_params=pythonic_params,\n        )\n\n    @property\n    def fn(self) -> t.Callable:\n        decorator = FlaskDecorator(\n            pythonic_params=self.pythonic_params,\n            jsonifier=self.jsonifier,\n        )\n        return decorator(self._fn)\n\n    def __call__(self, *args, **kwargs) -> FlaskResponse:\n        return self.fn(*args, **kwargs)"
    },
    {
      "chunk_id": 358,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "class FlaskApi(AbstractRoutingAPI):\n    def __init__(\n        self, *args, jsonifier: t.Optional[Jsonifier] = None, **kwargs\n    ) -> None:\n        self.jsonifier = jsonifier or Jsonifier(flask.json, indent=2)\n        super().__init__(*args, **kwargs)\n\n    def _set_base_path(self, base_path: t.Optional[str] = None) -> None:\n        super()._set_base_path(base_path)\n        self._set_blueprint()\n\n    def _set_blueprint(self):\n        endpoint = flask_utils.flaskify_endpoint(self.base_path) or \"/\"\n        self.blueprint = flask.Blueprint(\n            endpoint,\n            __name__,\n            url_prefix=self.base_path,\n        )\n\n    def _add_resolver_error_handler(self, method: str, path: str, err: ResolverError):\n        pass\n\n    def make_operation(self, operation):\n        return FlaskOperation.from_operation(\n            operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier\n        )\n\n    @staticmethod\n    def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        flask_path = flask_utils.flaskify_path(\n            path, operation.get_path_parameter_types()\n        )\n        endpoint_name = flask_utils.flaskify_endpoint(\n            operation.operation_id, operation.randomize_endpoint\n        )\n        return flask_path, endpoint_name\n\n    def _add_operation_internal(\n        self,\n        method: str,\n        path: str,\n        operation: t.Callable,\n        name: t.Optional[str] = None,\n    ) -> None:\n        self.blueprint.add_url_rule(path, name, operation, methods=[method])\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        return self.blueprint.add_url_rule(rule, endpoint, view_func, **options)"
    },
    {
      "chunk_id": 359,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "class FlaskASGIApp(SpecMiddleware):\n    def __init__(self, import_name, server_args: dict, **kwargs):\n        self.app = flask.Flask(import_name, **server_args)\n        self.app.json = flask_utils.FlaskJSONProvider(self.app)\n        self.app.url_map.converters[\"float\"] = flask_utils.NumberConverter\n        self.app.url_map.converters[\"int\"] = flask_utils.IntegerConverter\n\n        # Propagate Errors so we can handle them in the middleware\n        self.app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n        self.app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n        self.app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n        self.asgi_app = WSGIMiddleware(self.app.wsgi_app)\n\n    def add_api(self, specification, *, name: t.Optional[str] = None, **kwargs):\n        api = FlaskApi(specification, **kwargs)\n\n        if name is not None:\n            self.app.register_blueprint(api.blueprint, name=name)\n        else:\n            self.app.register_blueprint(api.blueprint)\n\n        return api\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        return self.app.add_url_rule(rule, endpoint, view_func, **options)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        return await self.asgi_app(scope, receive, send)"
    },
    {
      "chunk_id": 360,
      "source": "__internal__/data_repo/connexion/connexion/apps/flask.py",
      "content": "class FlaskApp(AbstractApp):\n    \"\"\"Connexion Application based on ConnexionMiddleware wrapping a Flask application.\"\"\"\n\n    _middleware_app: FlaskASGIApp\n\n    def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        server_args: t.Optional[dict] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ):\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n            shutdown tasks.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param server_args: Arguments to pass to the Flask application.\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate all paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self._middleware_app = FlaskASGIApp(import_name, server_args or {})\n\n        super().__init__(\n            import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        self.app = self._middleware_app.app\n        self.app.register_error_handler(\n            werkzeug.exceptions.HTTPException, self._http_exception\n        )\n\n    def _http_exception(self, exc: werkzeug.exceptions.HTTPException):\n        \"\"\"Reraise werkzeug HTTPExceptions as starlette HTTPExceptions\"\"\"\n        raise starlette.exceptions.HTTPException(exc.code, detail=exc.description)\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        self._middleware_app.add_url_rule(\n            rule, endpoint=endpoint, view_func=view_func, **options\n        )\n\n    def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        self.middleware.add_error_handler(code_or_exception, function)\n\n    def add_wsgi_middleware(\n        self, middleware: t.Type[WSGIApp], **options: t.Any\n    ) -> None:\n        \"\"\"Wrap the underlying Flask application with a WSGI middleware. Note that it will only be\n        called at the end of the middleware stack. Middleware that needs to act sooner, needs to\n        be added as ASGI middleware instead.\n\n        Adding multiple middleware using this method wraps each middleware around the previous one.\n\n        :param middleware: Middleware class to add\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        self._middleware_app.asgi_app.app = middleware(\n            self._middleware_app.asgi_app.app, **options  # type: ignore\n        )\n```"
    },
    {
      "chunk_id": 361,
      "source": "__internal__/data_repo/connexion/connexion/apps/abstract.py",
      "content": "\"\"\"\nThis module defines an AbstractApp, which defines a standardized user interface for a Connexion\napplication.\n\"\"\"\nimport abc\nimport pathlib\nimport typing as t\n\nfrom starlette.testclient import TestClient\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom connexion.jsonifier import Jsonifier\nfrom connexion.lifecycle import ConnexionRequest, ConnexionResponse\nfrom connexion.middleware import ConnexionMiddleware, MiddlewarePosition, SpecMiddleware\nfrom connexion.middleware.lifespan import Lifespan\nfrom connexion.options import SwaggerUIOptions\nfrom connexion.resolver import Resolver\nfrom connexion.types import MaybeAwaitable\nfrom connexion.uri_parsing import AbstractURIParser"
    },
    {
      "chunk_id": 362,
      "source": "__internal__/data_repo/connexion/connexion/apps/abstract.py",
      "content": "class AbstractApp:\n    \"\"\"\n    Abstract class for a Connexion Application. A Connexion Application provides an interface for a\n    framework application wrapped by Connexion Middleware. Since its main function is to provide an\n    interface, it delegates most of the work to the middleware and framework application.\n    \"\"\"\n\n    _middleware_app: SpecMiddleware\n    \"\"\"\n    The application wrapped by the ConnexionMiddleware, which in its turn wraps the framework\n    application.\n    \"\"\"\n\n    def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ) -> None:\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self.middleware = ConnexionMiddleware(\n            self._middleware_app,\n            import_name=import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            swagger_ui_options=swagger_ui_options,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n    def add_middleware(\n        self,\n        middleware_class: t.Type[ASGIApp],\n        position: MiddlewarePosition = MiddlewarePosition.BEFORE_CONTEXT,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Add a middleware to the stack on the specified position.\n\n        :param middleware_class: Middleware class to add\n        :param position: Position to add the middleware, one of the MiddlewarePosition Enum\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        self.middleware.add_middleware(middleware_class, position=position, **options)\n\n    def add_api(\n        self,\n        specification: t.Union[pathlib.Path, str, dict],\n        *,\n        base_path: t.Optional[str] = None,\n        name: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ) -> t.Any:\n        \"\"\"\n        Register an API represented by a single OpenAPI specification on this application.\n        Multiple APIs can be registered on a single application.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n            options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the middleware application wrapping the framework.\n        \"\"\"\n        return self.middleware.add_api(\n            specification,\n            base_path=base_path,\n            name=name,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n            **kwargs,\n        )\n\n    def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\"\n\n    def route(self, rule: str, **options):\n        \"\"\"\n        A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as `add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        :param rule: the URL rule as string\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n                        object. A change to Werkzeug is handling of method options. methods is a\n                        list of methods this rule should be limited to (`GET`, `POST` etc.).\n                        By default a rule just listens for `GET` (and implicitly `HEAD`).\n        \"\"\"\n\n        def decorator(func: t.Callable) -> t.Callable:\n            self.add_url_rule(rule, view_func=func, **options)\n            return func\n\n        return decorator\n\n    @abc.abstractmethod\n    def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\"\n\n    def test_client(self, **kwargs):\n        \"\"\"Creates a test client for this application. The keywords arguments passed in are\n        passed to the ``StarletteClient``.\"\"\"\n        return TestClient(self, **kwargs)\n\n    def run(self, import_string: t.Optional[str] = None, **kwargs):\n        \"\"\"Run the application using uvicorn.\n\n        :param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                              using reload.\n        :param kwargs: kwargs to pass to `uvicorn.run`.\n        \"\"\"\n        self.middleware.run(import_string, **kwargs)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        return await self.middleware(scope, receive, send)"
    },
    {
      "chunk_id": 363,
      "source": "__internal__/data_repo/connexion/connexion/operations/__init__.py",
      "content": "\"\"\"\nThis module defines Connexion Operation classes. A Connexion Operation implements an OpenAPI\noperation, which describes a single API operation on a path. It wraps the view function linked to\nthe operation with decorators to handle security, validation, serialization etc. based on the\nOpenAPI specification, and exposes the result to be registered as a route on the application.\n\"\"\""
    },
    {
      "chunk_id": 364,
      "source": "__internal__/data_repo/connexion/connexion/operations/__init__.py",
      "content": "from .abstract import AbstractOperation  # noqa\nfrom .openapi import OpenAPIOperation  # noqa\nfrom .swagger2 import Swagger2Operation  # noqa"
    },
    {
      "chunk_id": 365,
      "source": "__internal__/data_repo/connexion/connexion/operations/abstract.py",
      "content": "```python"
    },
    {
      "chunk_id": 366,
      "source": "__internal__/data_repo/connexion/connexion/operations/abstract.py",
      "content": "\"\"\"\nThis module defines an AbstractOperation class which implements an abstract Operation interface\nand functionality shared between Swagger 2 and OpenAPI 3 specifications.\n\"\"\"\n\nimport abc\nimport logging\nimport typing as t\n\nfrom connexion.utils import all_json\n\nlogger = logging.getLogger(\"connexion.operations.abstract\")\n\nDEFAULT_MIMETYPE = \"application/json\""
    },
    {
      "chunk_id": 367,
      "source": "__internal__/data_repo/connexion/connexion/operations/abstract.py",
      "content": "class AbstractOperation(metaclass=abc.ABCMeta):\n\n    \"\"\"\n    An API routes requests to an Operation by a (path, method) pair.\n    The operation uses a resolver to resolve its handler function.\n    We use the provided spec to do a bunch of heavy lifting before\n    (and after) we call security_schemes handler.\n    The registered handler function ends up looking something like::\n\n        @secure_endpoint\n        @validate_inputs\n        @deserialize_function_inputs\n        @serialize_function_outputs\n        @validate_outputs\n        def user_provided_handler_function(important, stuff):\n            if important:\n                serious_business(stuff)\n    \"\"\"\n\n    def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        app_security=None,\n        security_schemes=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        :param method: HTTP method\n        :type method: str\n        :param path:\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        self._method = method\n        self._path = path\n        self._operation = operation\n        self._resolver = resolver\n        self._security = operation.get(\"security\", app_security)\n        self._security_schemes = security_schemes\n        self._uri_parser_class = uri_parser_class\n        self._randomize_endpoint = randomize_endpoint\n        self._operation_id = self._operation.get(\"operationId\")\n\n        self._resolution = resolver.resolve(self)\n        self._operation_id = self._resolution.operation_id\n\n        self._responses = self._operation.get(\"responses\", {})\n\n    @classmethod\n    @abc.abstractmethod\n    def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        pass\n\n    @property\n    def method(self):\n        \"\"\"\n        The HTTP method for this operation (ex. GET, POST)\n        \"\"\"\n        return self._method\n\n    @property\n    def request_body(self):\n        \"\"\"The request body for this operation\"\"\"\n\n    @property\n    def is_request_body_defined(self) -> bool:\n        \"\"\"Whether the request body is defined for this operation\"\"\"\n        return self.request_body != {}\n\n    @property\n    def path(self):\n        \"\"\"\n        The path of the operation, relative to the API base path\n        \"\"\"\n        return self._path\n\n    @property\n    def security(self):\n        return self._security\n\n    @property\n    def security_schemes(self):\n        return self._security_schemes\n\n    @property\n    def responses(self):\n        \"\"\"\n        Returns the responses for this operation\n        \"\"\"\n        return self._responses\n\n    @property\n    def operation_id(self):\n        \"\"\"\n        The operation id used to identify the operation internally to the app\n        \"\"\"\n        return self._operation_id\n\n    @property\n    def randomize_endpoint(self):\n        \"\"\"\n        number of random digits to generate and append to the operation_id.\n        \"\"\"\n        return self._randomize_endpoint\n\n    @property\n    def router_controller(self):\n        \"\"\"\n        The router controller to use (python module where handler functions live)\n        \"\"\"\n        return self._router_controller\n\n    @property\n    @abc.abstractmethod\n    def parameters(self):\n        \"\"\"\n        Returns the parameters for this operation\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def produces(self):\n        \"\"\"\n        Content-Types that the operation produces\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def consumes(self):\n        \"\"\"\n        Content-Types that the operation consumes\n        \"\"\"\n\n    @abc.abstractmethod\n    def body_name(self, content_type: str) -> str:\n        \"\"\"\n        Name of the body in the spec.\n        \"\"\"\n\n    @abc.abstractmethod\n    def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"\n\n    @abc.abstractmethod\n    def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\"\n\n    def response_definition(self, status_code=None, content_type=None):\n        \"\"\"\n        response definition for this endpoint\n        \"\"\"\n        response_definition = self.responses.get(\n            str(status_code), self.responses.get(\"default\", {})\n        )\n        return response_definition\n\n    @abc.abstractmethod\n    def response_schema(self, status_code=None, content_type=None):\n        \"\"\"\n        response schema for this endpoint\n        \"\"\"\n\n    @abc.abstractmethod\n    def example_response(self, status_code=None, content_type=None):\n        \"\"\"\n        Returns an example from the spec\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_path_parameter_types(self):\n        \"\"\"\n        Returns the types for parameters in the path\n        \"\"\"\n\n    @abc.abstractmethod\n    def with_definitions(self, schema):\n        \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\"\n\n    def get_mimetype(self):\n        \"\"\"\n        If the endpoint has no 'produces' then the default is\n        'application/json'.\n\n        :rtype str\n        \"\"\"\n        # TODO: don't default\n        if all_json(self.produces):\n            try:\n                return self.produces[0]\n            except IndexError:\n                return DEFAULT_MIMETYPE\n        elif len(self.produces) == 1:\n            return self.produces[0]\n        else:\n            return DEFAULT_MIMETYPE\n\n    @property\n    def uri_parser_class(self):\n        \"\"\"\n        The uri parser class for this operation.\n        \"\"\"\n        return self._uri_parser_class\n\n    @property\n    def function(self):\n        \"\"\"\n        Resolved function.\n\n        :rtype: types.FunctionType\n        \"\"\"\n        return self._resolution.function\n```"
    },
    {
      "chunk_id": 368,
      "source": "__internal__/data_repo/connexion/connexion/operations/openapi.py",
      "content": "```python"
    },
    {
      "chunk_id": 369,
      "source": "__internal__/data_repo/connexion/connexion/operations/openapi.py",
      "content": "\"\"\"\nThis module defines an OpenAPIOperation class, a Connexion operation specific for OpenAPI 3 specs.\n\"\"\"\n\nimport logging\nimport typing as t\nfrom http import HTTPStatus\n\nfrom connexion.datastructures import MediaTypeDict, NoContent\nfrom connexion.operations.abstract import AbstractOperation\nfrom connexion.uri_parsing import OpenAPIURIParser\nfrom connexion.utils import build_example_from_schema, deep_get\n\nlogger = logging.getLogger(\"connexion.operations.openapi3\")"
    },
    {
      "chunk_id": 370,
      "source": "__internal__/data_repo/connexion/connexion/operations/openapi.py",
      "content": "class OpenAPIOperation(AbstractOperation):\n\n    \"\"\"\n    A single API operation on a path.\n    \"\"\"\n\n    def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        path_parameters=None,\n        app_security=None,\n        security_schemes=None,\n        components=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        This class uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n\n        :param method: HTTP method\n        :type method: str\n        :param path:\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :param path_parameters: Parameters defined in the path level\n        :type path_parameters: list\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param components: `Components Object\n            <https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#componentsObject>`_\n        :type components: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        self.components = components or {}\n\n        uri_parser_class = uri_parser_class or OpenAPIURIParser\n\n        self._router_controller = operation.get(\"x-openapi-router-controller\")\n\n        super().__init__(\n            method=method,\n            path=path,\n            operation=operation,\n            resolver=resolver,\n            app_security=app_security,\n            security_schemes=security_schemes,\n            randomize_endpoint=randomize_endpoint,\n            uri_parser_class=uri_parser_class,\n        )\n\n        self._parameters = operation.get(\"parameters\", [])\n        if path_parameters:\n            self._parameters += path_parameters\n\n        self._responses = operation.get(\"responses\", {})\n\n        # TODO figure out how to support multiple mimetypes\n        # NOTE we currently just combine all of the possible mimetypes,\n        #      but we need to refactor to support mimetypes by response code\n        response_content_types = []\n        for _, defn in self._responses.items():\n            response_content_types += defn.get(\"content\", {}).keys()\n        self._produces = response_content_types\n        self._consumes = None\n\n        logger.debug(\"consumes: %s\" % self.consumes)\n        logger.debug(\"produces: %s\" % self.produces)\n\n    @classmethod\n    def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        return cls(\n            method,\n            path,\n            spec.get_operation(path, method),\n            resolver=resolver,\n            path_parameters=spec.get_path_params(path),\n            app_security=spec.security,\n            security_schemes=spec.security_schemes,\n            components=spec.components,\n            *args,\n            **kwargs,\n        )\n\n    @property\n    def request_body(self):\n        return self._operation.get(\"requestBody\", {})\n\n    @property\n    def parameters(self):\n        return self._parameters\n\n    @property\n    def consumes(self):\n        if self._consumes is None:\n            request_content = self.request_body.get(\"content\", {})\n            self._consumes = list(request_content.keys())\n        return self._consumes\n\n    @property\n    def produces(self):\n        return self._produces\n\n    def with_definitions(self, schema: dict):\n        if self.components:\n            schema.setdefault(\"schema\", {})\n            schema[\"schema\"][\"components\"] = self.components\n        return schema\n\n    def response_schema(self, status_code=None, content_type=None):\n        response_definition = self.response_definition(status_code, content_type)\n        content_definition = response_definition.get(\"content\", response_definition)\n        content_definition = content_definition.get(content_type, content_definition)\n        if \"schema\" in content_definition:\n            return self.with_definitions(content_definition).get(\"schema\", {})\n        return {}\n\n    def example_response(self, status_code=None, content_type=None):\n        \"\"\"\n        Returns example response from spec\n        \"\"\"\n        # simply use the first/lowest status code, this is probably 200 or 201\n        status_code = status_code or sorted(self._responses.keys())[0]\n\n        content_type = content_type or self.get_mimetype()\n        examples_path = [str(status_code), \"content\", content_type, \"examples\"]\n        example_path = [str(status_code), \"content\", content_type, \"example\"]\n        schema_example_path = [\n            str(status_code),\n            \"content\",\n            content_type,\n            \"schema\",\n            \"example\",\n        ]\n        schema_path = [str(status_code), \"content\", content_type, \"schema\"]\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            status_code = 200\n\n        if status_code == HTTPStatus.NO_CONTENT:\n            return NoContent, status_code\n\n        try:\n            # TODO also use example header?\n            return (\n                list(deep_get(self._responses, examples_path).values())[0][\"value\"],\n                status_code,\n            )\n        except (KeyError, IndexError):\n            pass\n        try:\n            return (deep_get(self._responses, example_path), status_code)\n        except KeyError:\n            pass\n        try:\n            return (deep_get(self._responses, schema_example_path), status_code)\n        except KeyError:\n            pass\n\n        try:\n            schema = deep_get(self._responses, schema_path)\n        except KeyError:\n            return (\"No example response or response schema defined.\", status_code)\n\n        return (build_example_from_schema(schema), status_code)\n\n    def get_path_parameter_types(self):\n        types = {}\n        path_parameters = (p for p in self.parameters if p[\"in\"] == \"path\")\n        for path_defn in path_parameters:\n            path_schema = path_defn[\"schema\"]\n            if (\n                path_schema.get(\"type\") == \"string\"\n                and path_schema.get(\"format\") == \"path\"\n            ):\n                # path is special case for type 'string'\n                path_type = \"path\"\n            else:\n                path_type = path_schema.get(\"type\")\n            types[path_defn[\"name\"]] = path_type\n        return types\n\n    def body_name(self, _content_type: str) -> str:\n        return self.request_body.get(\"x-body-name\", \"body\")\n\n    def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"\n        return self.body_definition(content_type).get(\"schema\", {})\n\n    def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body complete definition for this operation.\n\n        **There can be one \"body\" parameter at most.**\n        \"\"\"\n        if self.request_body:\n            if content_type is None:\n                # TODO: make content type required\n                content_type = self.consumes[0]\n            if len(self.consumes) > 1:\n                logger.warning(\n                    \"this operation accepts multiple content types, using %s\",\n                    content_type,\n                )\n            content_type_dict = MediaTypeDict(self.request_body.get(\"content\", {}))\n            res = content_type_dict.get(content_type, {})\n            return self.with_definitions(res)\n        return {}\n```"
    },
    {
      "chunk_id": 371,
      "source": "__internal__/data_repo/connexion/connexion/operations/swagger2.py",
      "content": "```"
    },
    {
      "chunk_id": 372,
      "source": "__internal__/data_repo/connexion/connexion/operations/swagger2.py",
      "content": "This module defines a Swagger2Operation class, a Connexion operation specific for Swagger 2 specs."
    },
    {
      "chunk_id": 373,
      "source": "__internal__/data_repo/connexion/connexion/operations/swagger2.py",
      "content": "import logging\nimport typing as t\nfrom http import HTTPStatus\n\nfrom connexion.datastructures import NoContent\nfrom connexion.exceptions import InvalidSpecification\nfrom connexion.operations.abstract import AbstractOperation\nfrom connexion.uri_parsing import Swagger2URIParser\nfrom connexion.utils import build_example_from_schema, deep_get\n\nlogger = logging.getLogger(\"connexion.operations.swagger2\")\n\n\nCOLLECTION_FORMAT_MAPPING = {\n    \"multi\": {\"style\": \"form\", \"explode\": True},\n    \"csv\": {\"style\": \"form\", \"explode\": False},\n    \"ssv\": {\"style\": \"spaceDelimited\", \"explode\": False},\n    \"pipes\": {\"style\": \"pipeDelimited\", \"explode\": False},\n}"
    },
    {
      "chunk_id": 374,
      "source": "__internal__/data_repo/connexion/connexion/operations/swagger2.py",
      "content": "class Swagger2Operation(AbstractOperation):\n\n    \"\"\"\n    Exposes a Swagger 2.0 operation under the AbstractOperation interface.\n    The primary purpose of this class is to provide the `function()` method\n    to the API. A Swagger2Operation is plugged into the API with the provided\n    (path, method) pair. It resolves the handler function for this operation\n    with the provided resolver, and wraps the handler function with multiple\n    decorators that provide security, validation, serialization,\n    and deserialization.\n    \"\"\"\n\n    def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        app_produces,\n        app_consumes,\n        path_parameters=None,\n        app_security=None,\n        security_schemes=None,\n        definitions=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        :param method: HTTP method\n        :type method: str\n        :param path: relative path to this operation\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :type resolver: resolver.Resolver\n        :param app_produces: list of content types the application can return by default\n        :type app_produces: list\n        :param app_consumes: list of content types the application consumes by default\n        :type app_consumes: list\n        :param path_parameters: Parameters defined in the path level\n        :type path_parameters: list\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param definitions: `Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#definitionsObject>`_\n        :type definitions: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        uri_parser_class = uri_parser_class or Swagger2URIParser\n\n        self._router_controller = operation.get(\"x-swagger-router-controller\")\n\n        super().__init__(\n            method=method,\n            path=path,\n            operation=operation,\n            resolver=resolver,\n            app_security=app_security,\n            security_schemes=security_schemes,\n            randomize_endpoint=randomize_endpoint,\n            uri_parser_class=uri_parser_class,\n        )\n\n        self._produces = operation.get(\"produces\", app_produces)\n        self._consumes = operation.get(\"consumes\", app_consumes)\n\n        self.definitions = definitions or {}\n\n        self._parameters = operation.get(\"parameters\", [])\n        if path_parameters:\n            self._parameters += path_parameters\n\n        self._responses = operation.get(\"responses\", {})\n\n    @classmethod\n    def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        return cls(\n            method,\n            path,\n            spec.get_operation(path, method),\n            resolver=resolver,\n            path_parameters=spec.get_path_params(path),\n            app_produces=spec.produces,\n            app_consumes=spec.consumes,\n            app_security=spec.security,\n            security_schemes=spec.security_schemes,\n            definitions=spec.definitions,\n            *args,\n            **kwargs,\n        )\n\n    @property\n    def request_body(self) -> dict:\n        if not hasattr(self, \"_request_body\"):\n            body_params = []\n            form_params = []\n            for parameter in self.parameters:\n                if parameter[\"in\"] == \"body\":\n                    body_params.append(parameter)\n                elif parameter[\"in\"] == \"formData\":\n                    form_params.append(parameter)\n\n            if len(body_params) > 1:\n                raise InvalidSpecification(\n                    f\"{self.method} {self.path}: There can be one 'body' parameter at most\"\n                )\n\n            if body_params and form_params:\n                raise InvalidSpecification(\n                    f\"{self.method} {self.path}: 'body' and 'formData' parameters are mutually exclusive\"\n                )\n\n            if body_params:\n                self._request_body = self._transform_json(body_params[0])\n            elif form_params:\n                self._request_body = self._transform_form(form_params)\n            else:\n                self._request_body = {}\n\n        return self._request_body\n\n    @property\n    def parameters(self):\n        return self._parameters\n\n    @property\n    def consumes(self):\n        return self._consumes\n\n    @property\n    def produces(self):\n        return self._produces\n\n    def get_path_parameter_types(self):\n        types = {}\n        path_parameters = (p for p in self.parameters if p[\"in\"] == \"path\")\n        for path_defn in path_parameters:\n            if path_defn.get(\"type\") == \"string\" and path_defn.get(\"format\") == \"path\":\n                # path is special case for type 'string'\n                path_type = \"path\"\n            else:\n                path_type = path_defn.get(\"type\")\n            types[path_defn[\"name\"]] = path_type\n        return types\n\n    def with_definitions(self, schema):\n        if \"schema\" in schema:\n            schema[\"schema\"][\"definitions\"] = self.definitions\n        return schema\n\n    def response_schema(self, status_code=None, content_type=None):\n        response_definition = self.response_definition(status_code, content_type)\n        return self.with_definitions(response_definition.get(\"schema\", {}))\n\n    def example_response(self, status_code=None, *args, **kwargs):\n        \"\"\"\n        Returns example response from spec\n        \"\"\"\n        # simply use the first/lowest status code, this is probably 200 or 201\n        status_code = status_code or sorted(self._responses.keys())[0]\n        examples_path = [str(status_code), \"examples\"]\n        schema_example_path = [str(status_code), \"schema\", \"example\"]\n        schema_path = [str(status_code), \"schema\"]\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            status_code = 200\n\n        if status_code == HTTPStatus.NO_CONTENT:\n            return NoContent, status_code\n\n        try:\n            return (\n                list(deep_get(self._responses, examples_path).values())[0],\n                status_code,\n            )\n        except KeyError:\n            pass\n        try:\n            return (deep_get(self._responses, schema_example_path), status_code)\n        except KeyError:\n            pass\n\n        try:\n            schema = deep_get(self._responses, schema_path)\n        except KeyError:\n            return (\"No example response or response schema defined.\", status_code)\n\n        return (build_example_from_schema(schema), status_code)\n\n    def body_name(self, content_type: t.Optional[str] = None) -> str:\n        return self.body_definition(content_type).get(\"name\", \"body\")\n\n    def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"\n        body_definition = self.body_definition(content_type)\n        return self.with_definitions(body_definition).get(\"schema\", {})\n\n    def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body complete definition for this operation.\n\n        **There can be one \"body\" parameter at most.**\n        \"\"\"\n        return self.request_body\n\n    def _transform_json(self, body_parameter: dict) -> dict:\n        \"\"\"Translate Swagger2 json parameters into OpenAPI 3 jsonschema spec.\"\"\"\n        nullable = body_parameter.get(\"x-nullable\")\n        if nullable is not None:\n            body_parameter[\"schema\"][\"nullable\"] = nullable\n        return body_parameter\n\n    def _transform_form(self, form_parameters: t.List[dict]) -> dict:\n        \"\"\"Translate Swagger2 form parameters into OpenAPI 3 jsonschema spec.\"\"\"\n        properties = {}\n        defaults = {}\n        required = []\n        encoding = {}\n\n        for param in form_parameters:\n            prop = {}\n\n            if param[\"type\"] == \"file\":\n                prop.update(\n                    {\n                        \"type\": \"string\",\n                        \"format\": \"binary\",\n                    }\n                )\n            else:\n                prop[\"type\"] = param[\"type\"]\n\n                format_ = param.get(\"format\")\n                if format_ is not None:\n                    prop[\"format\"] = format_\n\n            default = param.get(\"default\")\n            if default is not None:\n                prop[\"default\"] = default\n                defaults[param[\"name\"]] = default\n\n            nullable = param.get(\"x-nullable\")\n            if nullable is not None:\n                prop[\"nullable\"] = nullable\n\n            if param[\"type\"] == \"array\":\n                prop[\"items\"] = param.get(\"items\", {})\n\n                collection_format = param.get(\"collectionFormat\", \"csv\")\n                try:\n                    encoding[param[\"name\"]] = COLLECTION_FORMAT_MAPPING[\n                        collection_format\n                    ]\n                except KeyError:\n                    raise InvalidSpecification(\n                        f\"The collection format ({collection_format}) is not supported by \"\n                        f\"Connexion as it cannot be mapped to OpenAPI 3.\"\n                    )\n\n            properties[param[\"name\"]] = prop\n\n            if param.get(\"required\", False):\n                required.append(param[\"name\"])\n\n        definition: t.Dict[str, t.Any] = {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required,\n            }\n        }\n        if defaults:\n            definition[\"schema\"][\"default\"] = defaults\n        if encoding:\n            definition[\"encoding\"] = encoding\n\n        return definition\n```"
    },
    {
      "chunk_id": 375,
      "source": "__internal__/data_repo/connexion/connexion/validators/__init__.py",
      "content": "from connexion.datastructures import MediaTypeDict\n\nfrom .abstract import (  # NOQA\n    AbstractRequestBodyValidator,\n    AbstractResponseBodyValidator,\n)\nfrom .form_data import FormDataValidator, MultiPartFormDataValidator\nfrom .json import DefaultsJSONRequestBodyValidator  # NOQA\nfrom .json import (\n    JSONRequestBodyValidator,\n    JSONResponseBodyValidator,\n    TextResponseBodyValidator,\n)\nfrom .parameter import ParameterValidator"
    },
    {
      "chunk_id": 376,
      "source": "__internal__/data_repo/connexion/connexion/validators/__init__.py",
      "content": "VALIDATOR_MAP = {\n    \"parameter\": ParameterValidator,\n    \"body\": MediaTypeDict(\n        {\n            \"*/*json\": JSONRequestBodyValidator,\n            \"application/x-www-form-urlencoded\": FormDataValidator,\n            \"multipart/form-data\": MultiPartFormDataValidator,\n        }\n    ),\n    \"response\": MediaTypeDict(\n        {\n            \"*/*json\": JSONResponseBodyValidator,\n            \"text/plain\": TextResponseBodyValidator,\n        }\n    ),\n}"
    },
    {
      "chunk_id": 377,
      "source": "__internal__/data_repo/connexion/connexion/validators/json.py",
      "content": "import json\nimport logging\nimport typing as t\n\nimport jsonschema\nfrom jsonschema import Draft4Validator, ValidationError\nfrom starlette.types import Scope\n\nfrom connexion.exceptions import BadRequestProblem, NonConformingResponseBody\nfrom connexion.json_schema import (\n    Draft4RequestValidator,\n    Draft4ResponseValidator,\n    format_error_with_path,\n)\nfrom connexion.validators import (\n    AbstractRequestBodyValidator,\n    AbstractResponseBodyValidator,\n)\n\nlogger = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 378,
      "source": "__internal__/data_repo/connexion/connexion/validators/json.py",
      "content": "class JSONRequestBodyValidator(AbstractRequestBodyValidator):\n    \"\"\"Request body validator for json content types.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        schema: dict,\n        required=False,\n        nullable=False,\n        encoding: str,\n        strict_validation: bool,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            schema=schema,\n            required=required,\n            nullable=nullable,\n            encoding=encoding,\n            strict_validation=strict_validation,\n        )\n\n    @property\n    def _validator(self):\n        return Draft4RequestValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )\n\n    async def _parse(\n        self, stream: t.AsyncGenerator[bytes, None], scope: Scope\n    ) -> t.Any:\n        bytes_body = b\"\".join([message async for message in stream])\n        body = bytes_body.decode(self._encoding)\n\n        if not body:\n            return None\n\n        try:\n            return json.loads(body)\n        except json.decoder.JSONDecodeError as e:\n            raise BadRequestProblem(detail=str(e))\n\n    def _validate(self, body: t.Any) -> t.Optional[dict]:\n        if not self._nullable and body is None:\n            raise BadRequestProblem(\"Request body must not be empty\")\n        try:\n            return self._validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.info(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise BadRequestProblem(detail=f\"{exception.message}{error_path_msg}\")"
    },
    {
      "chunk_id": 379,
      "source": "__internal__/data_repo/connexion/connexion/validators/json.py",
      "content": "class DefaultsJSONRequestBodyValidator(JSONRequestBodyValidator):\n    \"\"\"Request body validator for json content types which fills in default values. This Validator\n    intercepts the body, makes changes to it, and replays it for the next ASGI application.\n    \"\"\"\n\n    MUTABLE_VALIDATION = True\n    \"\"\"This validator might mutate to the body.\"\"\"\n\n    @property\n    def _validator(self):\n        validator_cls = self.extend_with_set_default(Draft4RequestValidator)\n        return validator_cls(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )\n\n    # via https://python-jsonschema.readthedocs.io/\n    @staticmethod\n    def extend_with_set_default(validator_class):\n        validate_properties = validator_class.VALIDATORS[\"properties\"]\n\n        def set_defaults(validator, properties, instance, schema):\n            for property, subschema in properties.items():\n                if \"default\" in subschema:\n                    instance.setdefault(property, subschema[\"default\"])\n\n            yield from validate_properties(validator, properties, instance, schema)\n\n        return jsonschema.validators.extend(\n            validator_class, {\"properties\": set_defaults}\n        )"
    },
    {
      "chunk_id": 380,
      "source": "__internal__/data_repo/connexion/connexion/validators/json.py",
      "content": "class JSONResponseBodyValidator(AbstractResponseBodyValidator):\n    \"\"\"Response body validator for json content types.\"\"\"\n\n    @property\n    def validator(self) -> Draft4Validator:\n        return Draft4ResponseValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )\n\n    def _parse(self, stream: t.Generator[bytes, None, None]) -> t.Any:\n        body = b\"\".join(stream).decode(self._encoding)\n\n        if not body:\n            return None\n\n        try:\n            return json.loads(body)\n        except json.decoder.JSONDecodeError as e:\n            raise NonConformingResponseBody(str(e))\n\n    def _validate(self, body: dict):\n        try:\n            self.validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.warning(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise NonConformingResponseBody(\n                detail=f\"Response body does not conform to specification. {exception.message}{error_path_msg}\"\n            )"
    },
    {
      "chunk_id": 381,
      "source": "__internal__/data_repo/connexion/connexion/validators/json.py",
      "content": "class TextResponseBodyValidator(JSONResponseBodyValidator):\n    def _parse(self, stream: t.Generator[bytes, None, None]) -> str:  # type: ignore\n        body = b\"\".join(stream).decode(self._encoding)\n\n        try:\n            return json.loads(body)\n        except json.decoder.JSONDecodeError:\n            return body"
    },
    {
      "chunk_id": 382,
      "source": "__internal__/data_repo/connexion/connexion/validators/form_data.py",
      "content": "import logging\nimport typing as t\n\nfrom jsonschema import Draft4Validator, ValidationError\nfrom starlette.datastructures import Headers, UploadFile\nfrom starlette.formparsers import FormParser, MultiPartParser\nfrom starlette.types import Scope\n\nfrom connexion.exceptions import BadRequestProblem, ExtraParameterProblem\nfrom connexion.json_schema import Draft4RequestValidator, format_error_with_path\nfrom connexion.uri_parsing import AbstractURIParser\nfrom connexion.validators import AbstractRequestBodyValidator\n\nlogger = logging.getLogger(\"connexion.validators.form_data\")"
    },
    {
      "chunk_id": 383,
      "source": "__internal__/data_repo/connexion/connexion/validators/form_data.py",
      "content": "class FormDataValidator(AbstractRequestBodyValidator):\n    \"\"\"Request body validator for form content types.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        schema: dict,\n        required=False,\n        nullable=False,\n        encoding: str,\n        strict_validation: bool,\n        uri_parser: t.Optional[AbstractURIParser] = None,\n    ) -> None:\n        super().__init__(\n            schema=schema,\n            required=required,\n            nullable=nullable,\n            encoding=encoding,\n            strict_validation=strict_validation,\n        )\n        self._uri_parser = uri_parser\n\n    @property\n    def _validator(self):\n        return Draft4RequestValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )\n\n    @property\n    def _form_parser_cls(self):\n        return FormParser\n\n    async def _parse(self, stream: t.AsyncGenerator[bytes, None], scope: Scope) -> dict:\n        headers = Headers(scope=scope)\n        form_parser = self._form_parser_cls(headers, stream)\n        data = await form_parser.parse()\n\n        if self._uri_parser is not None:\n            # Don't parse file_data\n            form_data = {}\n            file_data: t.Dict[str, t.Union[str, t.List[str]]] = {}\n            for key in data.keys():\n                # Extract files\n                param_schema = self._schema.get(\"properties\", {}).get(key, {})\n                value = data.getlist(key)\n\n                def is_file(schema):\n                    return schema.get(\"type\") == \"string\" and schema.get(\"format\") in [\n                        \"binary\",\n                        \"base64\",\n                    ]\n\n                # Single file upload\n                if is_file(param_schema):\n                    # Unpack if single file received\n                    if len(value) == 1:\n                        file_data[key] = \"\"\n                    # If multiple files received, replace with array so validation will fail\n                    else:\n                        file_data[key] = [\"\"] * len(value)\n                # Multiple file upload, replace files with array of strings\n                elif is_file(param_schema.get(\"items\", {})):\n                    file_data[key] = [\"\"] * len(value)\n                # UploadFile received for non-file upload. Replace and let validation handle.\n                elif isinstance(value[0], UploadFile):\n                    file_data[key] = [\"\"] * len(value)\n                # No files, add multi-value to form data and let uri parser handle multi-value\n                else:\n                    form_data[key] = value\n\n            # Resolve form data, not file data\n            data = self._uri_parser.resolve_form(form_data)\n            # Add the files again\n            data.update(file_data)\n        else:\n            data = {k: data.getlist(k) for k in data}\n\n        return data\n\n    def _validate(self, body: t.Any) -> t.Optional[dict]:  # type: ignore[return]\n        if not isinstance(body, dict):\n            raise BadRequestProblem(\"Parsed body must be a mapping\")\n        if self._strict_validation:\n            self._validate_params_strictly(body)\n        try:\n            self._validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.error(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise BadRequestProblem(detail=f\"{exception.message}{error_path_msg}\")\n\n    def _validate_params_strictly(self, data: dict) -> None:\n        form_params = data.keys()\n        spec_params = self._schema.get(\"properties\", {}).keys()\n        errors = set(form_params).difference(set(spec_params))\n        if errors:\n            raise ExtraParameterProblem(param_type=\"formData\", extra_params=errors)"
    },
    {
      "chunk_id": 384,
      "source": "__internal__/data_repo/connexion/connexion/validators/form_data.py",
      "content": "class MultiPartFormDataValidator(FormDataValidator):\n    @property\n    def _form_parser_cls(self):\n        return MultiPartParser"
    },
    {
      "chunk_id": 385,
      "source": "__internal__/data_repo/connexion/connexion/validators/abstract.py",
      "content": "\"\"\"\nThis module defines a Validator interface with base functionality that can be subclassed\nfor custom validators provided to the RequestValidationMiddleware.\n\"\"\"\nimport copy\nimport json\nimport typing as t\n\nfrom starlette.datastructures import Headers, MutableHeaders\nfrom starlette.types import Receive, Scope, Send\n\nfrom connexion.exceptions import BadRequestProblem"
    },
    {
      "chunk_id": 386,
      "source": "__internal__/data_repo/connexion/connexion/validators/abstract.py",
      "content": "class AbstractRequestBodyValidator:\n    \"\"\"\n    Validator interface with base functionality that can be subclassed for custom validators.\n\n    .. note: Validators load the whole body into memory, which can be a problem for large payloads.\n    \"\"\"\n\n    MUTABLE_VALIDATION = False\n    \"\"\"\n    Whether mutations to the body during validation should be transmitted via the receive channel.\n    Note that this does not apply to the substitution of a missing body with the default body, which always\n    updates the receive channel.\n    \"\"\"\n    MAX_MESSAGE_LENGTH = 256000\n    \"\"\"Maximum message length that will be sent via the receive channel for mutated bodies.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        schema: dict,\n        required: bool = False,\n        nullable: bool = False,\n        encoding: str,\n        strict_validation: bool,\n        **kwargs,\n    ):\n        \"\"\"\n        :param schema: Schema of operation to validate\n        :param required: Whether RequestBody is required\n        :param nullable: Whether RequestBody is nullable\n        :param encoding: Encoding of body (passed via Content-Type header)\n        :param kwargs: Additional arguments for subclasses\n        :param strict_validation: Whether to allow parameters not defined in the spec\n        \"\"\"\n        self._schema = schema\n        self._nullable = nullable\n        self._required = required\n        self._encoding = encoding\n        self._strict_validation = strict_validation\n\n    async def _parse(\n        self, stream: t.AsyncGenerator[bytes, None], scope: Scope\n    ) -> t.Any:\n        \"\"\"Parse the incoming stream.\"\"\"\n\n    def _validate(self, body: t.Any) -> t.Optional[dict]:\n        \"\"\"\n        Validate the parsed body.\n\n        :raises: :class:`connexion.exceptions.BadRequestProblem`\n        \"\"\"\n\n    def _insert_body(\n        self, receive: Receive, *, body: t.Any, scope: Scope\n    ) -> t.Tuple[Receive, Scope]:\n        \"\"\"\n        Insert messages transmitting the body at the start of the `receive` channel.\n\n        This method updates the provided `scope` in place with the right `Content-Length` header.\n        \"\"\"\n        if body is None:\n            return receive, scope\n\n        bytes_body = json.dumps(body).encode(self._encoding)\n\n        # Update the content-length header\n        new_scope = scope.copy()\n        new_scope[\"headers\"] = copy.deepcopy(scope[\"headers\"])\n        headers = MutableHeaders(scope=new_scope)\n        headers[\"content-length\"] = str(len(bytes_body))\n\n        # Wrap in new receive channel\n        messages = (\n            {\n                \"type\": \"http.request\",\n                \"body\": bytes_body[i : i + self.MAX_MESSAGE_LENGTH],\n                \"more_body\": i + self.MAX_MESSAGE_LENGTH < len(bytes_body),\n            }\n            for i in range(0, len(bytes_body), self.MAX_MESSAGE_LENGTH)\n        )\n\n        receive = self._insert_messages(receive, messages=messages)\n\n        return receive, new_scope\n\n    @staticmethod\n    def _insert_messages(\n        receive: Receive, *, messages: t.Iterable[t.MutableMapping[str, t.Any]]\n    ) -> Receive:\n        \"\"\"Insert messages at the start of the `receive` channel.\"\"\"\n        # Ensure that messages is an iterator so each message is replayed once.\n        message_iterator = iter(messages)\n\n        async def receive_() -> t.MutableMapping[str, t.Any]:\n            try:\n                return next(message_iterator)\n            except StopIteration:\n                return await receive()\n\n        return receive_\n\n    async def wrap_receive(\n        self, receive: Receive, *, scope: Scope\n    ) -> t.Tuple[Receive, Scope]:\n        \"\"\"\n        Wrap the provided `receive` channel with request body validation.\n\n        This method updates the provided `scope` in place with the right `Content-Length` header.\n        \"\"\"\n        # Handle missing bodies\n        headers = Headers(scope=scope)\n        if not int(headers.get(\"content-length\", 0)):\n            body = self._schema.get(\"default\")\n            if body is None and self._required:\n                raise BadRequestProblem(\"RequestBody is required\")\n            # The default body is encoded as a `receive` channel to mimic an incoming body\n            receive, scope = self._insert_body(receive, body=body, scope=scope)\n\n        # The receive channel is converted to a stream for convenient access\n        messages = []\n\n        async def stream() -> t.AsyncGenerator[bytes, None]:\n            more_body = True\n            while more_body:\n                message = await receive()\n                messages.append(message)\n                more_body = message.get(\"more_body\", False)\n                yield message.get(\"body\", b\"\")\n            yield b\"\"\n\n        # The body is parsed and validated\n        body = await self._parse(stream(), scope=scope)\n        if not (body is None and self._nullable):\n            self._validate(body)\n\n        # If MUTABLE_VALIDATION is enabled, include any changes made during validation in the messages to send\n        if self.MUTABLE_VALIDATION:\n            # Include changes made during validation\n            receive, scope = self._insert_body(receive, body=body, scope=scope)\n        else:\n            # Serialize original messages\n            receive = self._insert_messages(receive, messages=messages)\n\n        return receive, scope"
    },
    {
      "chunk_id": 387,
      "source": "__internal__/data_repo/connexion/connexion/validators/abstract.py",
      "content": "class AbstractResponseBodyValidator:\n    \"\"\"\n    Validator interface with base functionality that can be subclassed for custom validators.\n\n    .. note: Validators load the whole body into memory, which can be a problem for large payloads.\n    \"\"\"\n\n    def __init__(\n        self,\n        scope: Scope,\n        *,\n        schema: dict,\n        nullable: bool = False,\n        encoding: str,\n    ) -> None:\n        self._scope = scope\n        self._schema = schema\n        self._nullable = nullable\n        self._encoding = encoding\n\n    def _parse(self, stream: t.Generator[bytes, None, None]) -> t.Any:\n        \"\"\"Parse the incoming stream.\"\"\"\n\n    def _validate(self, body: t.Any) -> t.Optional[dict]:\n        \"\"\"\n        Validate the body.\n\n        :raises: :class:`connexion.exceptions.NonConformingResponse`\n        \"\"\"\n\n    def wrap_send(self, send: Send) -> Send:\n        \"\"\"Wrap the provided send channel with response body validation\"\"\"\n\n        messages = []\n\n        async def send_(message: t.MutableMapping[str, t.Any]) -> None:\n            messages.append(message)\n\n            if message[\"type\"] == \"http.response.start\" or message.get(\n                \"more_body\", False\n            ):\n                return\n\n            stream = (message.get(\"body\", b\"\") for message in messages)\n            body = self._parse(stream)\n\n            if not (body is None and self._nullable):\n                self._validate(body)\n\n            while messages:\n                await send(messages.pop(0))\n\n        return send_"
    },
    {
      "chunk_id": 388,
      "source": "__internal__/data_repo/connexion/connexion/validators/parameter.py",
      "content": "import collections\nimport copy\nimport logging\n\nfrom jsonschema import Draft4Validator, ValidationError\n\nfrom connexion.exceptions import BadRequestProblem, ExtraParameterProblem\nfrom connexion.lifecycle import ConnexionRequest\nfrom connexion.utils import boolean, is_null, is_nullable\n\nlogger = logging.getLogger(\"connexion.validators.parameter\")\n\nTYPE_MAP = {\"integer\": int, \"number\": float, \"boolean\": boolean, \"object\": dict}\n\ntry:\n    draft4_format_checker = Draft4Validator.FORMAT_CHECKER  # type: ignore\nexcept AttributeError:  # jsonschema < 4.5.0\n    from jsonschema import draft4_format_checker"
    },
    {
      "chunk_id": 389,
      "source": "__internal__/data_repo/connexion/connexion/validators/parameter.py",
      "content": "class ParameterValidator:\n    def __init__(\n        self,\n        parameters,\n        uri_parser,\n        strict_validation=False,\n        security_query_params=None,\n    ):\n        \"\"\"\n        :param parameters: List of request parameter dictionaries\n        :param uri_parser: class to use for uri parsing\n        :param strict_validation: Flag indicating if parameters not in spec are allowed\n        :param security_query_params: List of query parameter names used for security.\n            These parameters will be ignored when checking for extra parameters in case of\n            strict validation.\n        \"\"\"\n        self.parameters = collections.defaultdict(list)\n        for p in parameters:\n            self.parameters[p[\"in\"]].append(p)\n\n        self.uri_parser = uri_parser\n        self.strict_validation = strict_validation\n        self.security_query_params = set(security_query_params or [])\n\n    @staticmethod\n    def validate_parameter(parameter_type, value, param, param_name=None):\n        if is_nullable(param) and is_null(value):\n            return\n\n        elif value is not None:\n            param = copy.deepcopy(param)\n            param = param.get(\"schema\", param)\n            try:\n                Draft4Validator(param, format_checker=draft4_format_checker).validate(\n                    value\n                )\n            except ValidationError as exception:\n                return str(exception)\n\n        elif param.get(\"required\"):\n            return \"Missing {parameter_type} parameter '{param[name]}'\".format(\n                **locals()\n            )\n\n    @staticmethod\n    def validate_parameter_list(request_params, spec_params):\n        request_params = set(request_params)\n        spec_params = set(spec_params)\n\n        return request_params.difference(spec_params)\n\n    def validate_query_parameter_list(self, request, security_params=None):\n        request_params = request.query_params.keys()\n        spec_params = [x[\"name\"] for x in self.parameters.get(\"query\", [])]\n        spec_params.extend(security_params or [])\n        return self.validate_parameter_list(request_params, spec_params)\n\n    def validate_query_parameter(self, param, request):\n        \"\"\"\n        Validate a single query parameter (request.args in Flask)\n\n        :type param: dict\n        :rtype: str\n        \"\"\"\n        val = request.query_params.get(param[\"name\"])\n        return self.validate_parameter(\"query\", val, param)\n\n    def validate_path_parameter(self, param, request):\n        val = request.path_params.get(param[\"name\"].replace(\"-\", \"_\"))\n        return self.validate_parameter(\"path\", val, param)\n\n    def validate_header_parameter(self, param, request):\n        val = request.headers.get(param[\"name\"])\n        return self.validate_parameter(\"header\", val, param)\n\n    def validate_cookie_parameter(self, param, request):\n        val = request.cookies.get(param[\"name\"])\n        return self.validate_parameter(\"cookie\", val, param)\n\n    def validate(self, scope):\n        logger.debug(\"%s validating parameters...\", scope.get(\"path\"))\n\n        request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n        self.validate_request(request)\n\n    def validate_request(self, request):\n        if self.strict_validation:\n            query_errors = self.validate_query_parameter_list(\n                request, security_params=self.security_query_params\n            )\n\n            if query_errors:\n                raise ExtraParameterProblem(\n                    param_type=\"query\", extra_params=query_errors\n                )\n\n        for param in self.parameters.get(\"query\", []):\n            error = self.validate_query_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"path\", []):\n            error = self.validate_path_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"header\", []):\n            error = self.validate_header_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"cookie\", []):\n            error = self.validate_cookie_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)"
    },
    {
      "chunk_id": 390,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/__init__.py",
      "content": "Sure, please provide the Python code you would like me to analyze."
    },
    {
      "chunk_id": 391,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "import functools\nimport re\nimport typing as t\n\nimport starlette.convertors\nfrom starlette.responses import JSONResponse as StarletteJSONResponse\nfrom starlette.responses import Response as StarletteResponse\nfrom starlette.types import Receive, Scope\n\nfrom connexion.frameworks.abstract import Framework\nfrom connexion.lifecycle import ConnexionRequest\nfrom connexion.uri_parsing import AbstractURIParser"
    },
    {
      "chunk_id": 392,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "class Starlette(Framework):\n    @staticmethod\n    def is_framework_response(response: t.Any) -> bool:\n        return isinstance(response, StarletteResponse)\n\n    @classmethod\n    def connexion_to_framework_response(cls, response):\n        return cls.build_response(\n            status_code=response.status_code,\n            content_type=response.content_type,\n            headers=response.headers,\n            data=response.body,\n        )\n\n    @classmethod\n    def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None,\n    ):\n        if isinstance(data, dict) or isinstance(data, list):\n            response_cls = StarletteJSONResponse\n        else:\n            response_cls = StarletteResponse\n\n        return response_cls(\n            content=data,\n            status_code=status_code,\n            media_type=content_type,\n            headers=headers,\n        )\n\n    @staticmethod\n    def get_request(*, scope: Scope, receive: Receive, uri_parser: AbstractURIParser, **kwargs) -> ConnexionRequest:  # type: ignore\n        return ConnexionRequest(scope, receive, uri_parser=uri_parser)"
    },
    {
      "chunk_id": 393,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "PATH_PARAMETER = re.compile(r\"\\{([^}]*)\\}\")\nPATH_PARAMETER_CONVERTERS = {\"integer\": \"int\", \"number\": \"float\", \"path\": \"path\"}"
    },
    {
      "chunk_id": 394,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "def convert_path_parameter(match, types):\n    name = match.group(1)\n    swagger_type = types.get(name)\n    converter = PATH_PARAMETER_CONVERTERS.get(swagger_type)\n    return f'{{{name.replace(\"-\", \"_\")}{\":\" if converter else \"\"}{converter or \"\"}}}'"
    },
    {
      "chunk_id": 395,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "def starlettify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> starlettify_path('/foo-bar/{my-param}')\n    '/foo-bar/{my_param}'\n\n    >>> starlettify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/{someint:int}'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)"
    },
    {
      "chunk_id": 396,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "class FloatConverter(starlette.convertors.FloatConvertor):\n    \"\"\"Starlette converter for OpenAPI number type\"\"\"\n\n    regex = r\"[+-]?[0-9]*(\\.[0-9]*)?\""
    },
    {
      "chunk_id": 397,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/starlette.py",
      "content": "class IntegerConverter(starlette.convertors.IntegerConvertor):\n    \"\"\"Starlette converter for OpenAPI integer type\"\"\"\n\n    regex = r\"[+-]?[0-9]+\""
    },
    {
      "chunk_id": 398,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "\"\"\"\nThis module defines functionality specific to the Flask framework.\n\"\"\"\nimport functools\nimport random\nimport re\nimport string\nimport typing as t\n\nimport flask\nimport werkzeug.routing\n\nfrom connexion import jsonifier\nfrom connexion.frameworks.abstract import Framework\nfrom connexion.lifecycle import WSGIRequest\nfrom connexion.uri_parsing import AbstractURIParser"
    },
    {
      "chunk_id": 399,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "class Flask(Framework):\n    @staticmethod\n    def is_framework_response(response: t.Any) -> bool:\n        return isinstance(response, flask.Response) or isinstance(\n            response, werkzeug.wrappers.Response\n        )\n\n    @classmethod\n    def connexion_to_framework_response(cls, response):\n        return cls.build_response(\n            content_type=response.content_type,\n            headers=response.headers,\n            status_code=response.status_code,\n            data=response.body,\n        )\n\n    @classmethod\n    def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None\n    ):\n        if cls.is_framework_response(data):\n            return flask.current_app.make_response((data, status_code, headers))\n\n        kwargs = {\n            \"mimetype\": content_type,\n            \"headers\": headers,\n            \"response\": data,\n            \"status\": status_code,\n        }\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        return flask.current_app.response_class(**kwargs)\n\n    @staticmethod\n    def get_request(*, uri_parser: AbstractURIParser, **kwargs) -> WSGIRequest:  # type: ignore\n        return WSGIRequest(\n            flask.request, uri_parser=uri_parser, view_args=flask.request.view_args\n        )"
    },
    {
      "chunk_id": 400,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "PATH_PARAMETER = re.compile(r\"\\{([^}]*)\\}\")\n\n# map Swagger type to flask path converter\n# see http://flask.pocoo.org/docs/0.10/api/#url-route-registrations\nPATH_PARAMETER_CONVERTERS = {\"integer\": \"int\", \"number\": \"float\", \"path\": \"path\"}"
    },
    {
      "chunk_id": 401,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "def flaskify_endpoint(identifier, randomize=None):\n    \"\"\"\n    Converts the provided identifier in a valid flask endpoint name\n\n    :type identifier: str\n    :param randomize: If specified, add this many random characters (upper case\n        and digits) to the endpoint name, separated by a pipe character.\n    :type randomize: int | None\n    :rtype: str\n\n    \"\"\"\n    result = identifier.replace(\".\", \"_\")\n    if randomize is None:\n        return result\n\n    chars = string.ascii_uppercase + string.digits\n    return \"{result}|{random_string}\".format(\n        result=result,\n        random_string=\"\".join(\n            random.SystemRandom().choice(chars) for _ in range(randomize)\n        ),\n    )"
    },
    {
      "chunk_id": 402,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "def convert_path_parameter(match, types):\n    name = match.group(1)\n    swagger_type = types.get(name)\n    converter = PATH_PARAMETER_CONVERTERS.get(swagger_type)\n    return \"<{}{}{}>\".format(\n        converter or \"\", \":\" if converter else \"\", name.replace(\"-\", \"_\")\n    )"
    },
    {
      "chunk_id": 403,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "def flaskify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> flaskify_path('/foo-bar/{my-param}')\n    '/foo-bar/<my_param>'\n\n    >>> flaskify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/<int:someint>'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)"
    },
    {
      "chunk_id": 404,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "class FlaskJSONProvider(flask.json.provider.DefaultJSONProvider):\n    \"\"\"Custom JSONProvider which adds connexion defaults on top of Flask's\"\"\"\n\n    @jsonifier.wrap_default\n    def default(self, o):\n        return super().default(o)"
    },
    {
      "chunk_id": 405,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "class NumberConverter(werkzeug.routing.BaseConverter):\n    \"\"\"Flask converter for OpenAPI number type\"\"\"\n\n    regex = r\"[+-]?[0-9]*(?:\\.[0-9]*)?\"\n\n    def to_python(self, value):\n        return float(value)"
    },
    {
      "chunk_id": 406,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/flask.py",
      "content": "class IntegerConverter(werkzeug.routing.BaseConverter):\n    \"\"\"Flask converter for OpenAPI integer type\"\"\"\n\n    regex = r\"[+-]?[0-9]+\"\n\n    def to_python(self, value):\n        return int(value)"
    },
    {
      "chunk_id": 407,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/abstract.py",
      "content": "import abc\nimport typing as t\n\nfrom typing_extensions import Protocol"
    },
    {
      "chunk_id": 408,
      "source": "__internal__/data_repo/connexion/connexion/frameworks/abstract.py",
      "content": "class Framework(Protocol):\n    @staticmethod\n    @abc.abstractmethod\n    def is_framework_response(response: t.Any) -> bool:\n        \"\"\"Return True if provided response is a framework type\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @abc.abstractmethod\n    def connexion_to_framework_response(cls, response):\n        \"\"\"Cast ConnexionResponse to framework response class\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    @abc.abstractmethod\n    def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None\n    ):\n        raise NotImplementedError\n\n    @staticmethod\n    @abc.abstractmethod\n    def get_request(*args, **kwargs):\n        \"\"\"Return a framework request from the context.\"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    @abc.abstractmethod\n    def get_body(request):\n        \"\"\"Get body from a framework request\"\"\"\n        raise NotImplementedError"
    },
    {
      "chunk_id": 409,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "# import sys\n# import os"
    },
    {
      "chunk_id": 410,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "extensions = [\n    'sphinx.ext.autodoc',\n    'sphinx_copybutton',\n    'sphinx_design',\n    'sphinx.ext.autosectionlabel',\n    'sphinxemoji.sphinxemoji',\n]\nautosectionlabel_prefix_document = True\n\nautoclass_content = 'both'\n\ntemplates_path = ['_templates']\nsource_suffix = '.rst'\nmaster_doc = 'index'\nproject = 'Connexion'\ncopyright = '2018, Zalando SE'\n\nfrom importlib.metadata import version\nrelease = version('connexion')\nversion = release.rsplit('.', 1)[0]\nexclude_patterns = ['_build']\npygments_style = 'sphinx'"
    },
    {
      "chunk_id": 411,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "try:\n    import sphinx_rtd_theme\n\n    html_theme = \"sphinx_rtd_theme\"\n\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n    html_theme_options = {\n        'navigation_depth': 2\n    }\n\n    html_context = {\n        'display_github': True,\n        'github_user': 'spec-first',\n        'github_repo': 'connexion',\n        'github_version': 'main',\n        'conf_py_path': '/docs/'\n    }\nexcept:\n    pass"
    },
    {
      "chunk_id": 412,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "html_static_path = ['_static']\nhtml_css_files = [\n    'css/default.css',\n]\nhtml_js_files = [\n    'js/guru_widget.js',\n]"
    },
    {
      "chunk_id": 413,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "latex_documents = [\n    ('index', 'Connexion.tex', 'Connexion Documentation',\n     'Zalando SE', 'manual'),\n]"
    },
    {
      "chunk_id": 414,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "man_pages = [\n    ('index', 'connexion', 'Connexion Documentation',\n     ['Zalando SE'], 1)\n]"
    },
    {
      "chunk_id": 415,
      "source": "__internal__/data_repo/connexion/docs/conf.py",
      "content": "texinfo_documents = [\n    ('index', 'Connexion', 'Connexion Documentation',\n     'Zalando SE', 'Connexion', 'One line description of project.',\n     'Miscellaneous'),\n]"
    }
  ]
}