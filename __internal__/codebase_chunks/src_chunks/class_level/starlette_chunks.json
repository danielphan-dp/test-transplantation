{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/starlette/starlette/__init__.py",
      "content": "__version__ = \"0.45.2\""
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport functools\nimport sys\nimport typing\nfrom contextlib import contextmanager\n\nfrom starlette.types import Scope\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import TypeGuard\nelse:  # pragma: no cover\n    from typing_extensions import TypeGuard\n\nhas_exceptiongroups = True\nif sys.version_info < (3, 11):  # pragma: no cover\n    try:\n        from exceptiongroup import BaseExceptionGroup  # type: ignore[unused-ignore,import-not-found]\n    except ImportError:\n        has_exceptiongroups = False"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "T = typing.TypeVar(\"T\")\nAwaitableCallable = typing.Callable[..., typing.Awaitable[T]]\n\n\n@typing.overload\ndef is_async_callable(obj: AwaitableCallable[T]) -> TypeGuard[AwaitableCallable[T]]: ...\n\n\n@typing.overload\ndef is_async_callable(obj: typing.Any) -> TypeGuard[AwaitableCallable[typing.Any]]: ...\n\n\ndef is_async_callable(obj: typing.Any) -> typing.Any:\n    while isinstance(obj, functools.partial):\n        obj = obj.func\n\n    return asyncio.iscoroutinefunction(obj) or (callable(obj) and asyncio.iscoroutinefunction(obj.__call__))"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "T_co = typing.TypeVar(\"T_co\", covariant=True)\n\n\nclass AwaitableOrContextManager(typing.Awaitable[T_co], typing.AsyncContextManager[T_co], typing.Protocol[T_co]): ..."
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "class SupportsAsyncClose(typing.Protocol):\n    async def close(self) -> None: ...  # pragma: no cover"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "SupportsAsyncCloseType = typing.TypeVar(\"SupportsAsyncCloseType\", bound=SupportsAsyncClose, covariant=False)\n\n\nclass AwaitableOrContextManagerWrapper(typing.Generic[SupportsAsyncCloseType]):\n    __slots__ = (\"aw\", \"entered\")\n\n    def __init__(self, aw: typing.Awaitable[SupportsAsyncCloseType]) -> None:\n        self.aw = aw\n\n    def __await__(self) -> typing.Generator[typing.Any, None, SupportsAsyncCloseType]:\n        return self.aw.__await__()\n\n    async def __aenter__(self) -> SupportsAsyncCloseType:\n        self.entered = await self.aw\n        return self.entered\n\n    async def __aexit__(self, *args: typing.Any) -> None | bool:\n        await self.entered.close()\n        return None"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "@contextmanager\ndef collapse_excgroups() -> typing.Generator[None, None, None]:\n    try:\n        yield\n    except BaseException as exc:\n        if has_exceptiongroups:  # pragma: no cover\n            while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:\n                exc = exc.exceptions[0]\n\n        raise exc"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/starlette/starlette/_utils.py",
      "content": "def get_route_path(scope: Scope) -> str:\n    path: str = scope[\"path\"]\n    root_path = scope.get(\"root_path\", \"\")\n    if not root_path:\n        return path\n\n    if not path.startswith(root_path):\n        return path\n\n    if path == root_path:\n        return \"\"\n\n    if path[len(root_path)] == \"/\":\n        return path[len(root_path) :]\n\n    return path"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/starlette/starlette/staticfiles.py",
      "content": "from __future__ import annotations\n\nimport errno\nimport importlib.util\nimport os\nimport stat\nimport typing\nfrom email.utils import parsedate\n\nimport anyio\nimport anyio.to_thread\n\nfrom starlette._utils import get_route_path\nfrom starlette.datastructures import URL, Headers\nfrom starlette.exceptions import HTTPException\nfrom starlette.responses import FileResponse, RedirectResponse, Response\nfrom starlette.types import Receive, Scope, Send\n\nPathLike = typing.Union[str, \"os.PathLike[str]\"]"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/starlette/starlette/staticfiles.py",
      "content": "class NotModifiedResponse(Response):\n    NOT_MODIFIED_HEADERS = (\n        \"cache-control\",\n        \"content-location\",\n        \"date\",\n        \"etag\",\n        \"expires\",\n        \"vary\",\n    )\n\n    def __init__(self, headers: Headers):\n        super().__init__(\n            status_code=304,\n            headers={name: value for name, value in headers.items() if name in self.NOT_MODIFIED_HEADERS},\n        )"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/starlette/starlette/staticfiles.py",
      "content": "class StaticFiles:\n    def __init__(\n        self,\n        *,\n        directory: PathLike | None = None,\n        packages: list[str | tuple[str, str]] | None = None,\n        html: bool = False,\n        check_dir: bool = True,\n        follow_symlink: bool = False,\n    ) -> None:\n        self.directory = directory\n        self.packages = packages\n        self.all_directories = self.get_directories(directory, packages)\n        self.html = html\n        self.config_checked = False\n        self.follow_symlink = follow_symlink\n        if check_dir and directory is not None and not os.path.isdir(directory):\n            raise RuntimeError(f\"Directory '{directory}' does not exist\")\n\n    def get_directories(\n        self,\n        directory: PathLike | None = None,\n        packages: list[str | tuple[str, str]] | None = None,\n    ) -> list[PathLike]:\n        \"\"\"\n        Given `directory` and `packages` arguments, return a list of all the\n        directories that should be used for serving static files from.\n        \"\"\"\n        directories = []\n        if directory is not None:\n            directories.append(directory)\n\n        for package in packages or []:\n            if isinstance(package, tuple):\n                package, statics_dir = package\n            else:\n                statics_dir = \"statics\"\n            spec = importlib.util.find_spec(package)\n            assert spec is not None, f\"Package {package!r} could not be found.\"\n            assert spec.origin is not None, f\"Package {package!r} could not be found.\"\n            package_directory = os.path.normpath(os.path.join(spec.origin, \"..\", statics_dir))\n            assert os.path.isdir(\n                package_directory\n            ), f\"Directory '{statics_dir!r}' in package {package!r} could not be found.\"\n            directories.append(package_directory)\n\n        return directories\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        The ASGI entry point.\n        \"\"\"\n        assert scope[\"type\"] == \"http\"\n\n        if not self.config_checked:\n            await self.check_config()\n            self.config_checked = True\n\n        path = self.get_path(scope)\n        response = await self.get_response(path, scope)\n        await response(scope, receive, send)\n\n    def get_path(self, scope: Scope) -> str:\n        \"\"\"\n        Given the ASGI scope, return the `path` string to serve up,\n        with OS specific path separators, and any '..', '.' components removed.\n        \"\"\"\n        route_path = get_route_path(scope)\n        return os.path.normpath(os.path.join(*route_path.split(\"/\")))\n\n    async def get_response(self, path: str, scope: Scope) -> Response:\n        \"\"\"\n        Returns an HTTP response, given the incoming path, method and request headers.\n        \"\"\"\n        if scope[\"method\"] not in (\"GET\", \"HEAD\"):\n            raise HTTPException(status_code=405)\n\n        try:\n            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, path)\n        except PermissionError:\n            raise HTTPException(status_code=401)\n        except OSError as exc:\n            # Filename is too long, so it can't be a valid static file.\n            if exc.errno == errno.ENAMETOOLONG:\n                raise HTTPException(status_code=404)\n\n            raise exc\n\n        if stat_result and stat.S_ISREG(stat_result.st_mode):\n            # We have a static file to serve.\n            return self.file_response(full_path, stat_result, scope)\n\n        elif stat_result and stat.S_ISDIR(stat_result.st_mode) and self.html:\n            # We're in HTML mode, and have got a directory URL.\n            # Check if we have 'index.html' file to serve.\n            index_path = os.path.join(path, \"index.html\")\n            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, index_path)\n            if stat_result is not None and stat.S_ISREG(stat_result.st_mode):\n                if not scope[\"path\"].endswith(\"/\"):\n                    # Directory URLs should redirect to always end in \"/\".\n                    url = URL(scope=scope)\n                    url = url.replace(path=url.path + \"/\")\n                    return RedirectResponse(url=url)\n                return self.file_response(full_path, stat_result, scope)\n\n        if self.html:\n            # Check for '404.html' if we're in HTML mode.\n            full_path, stat_result = await anyio.to_thread.run_sync(self.lookup_path, \"404.html\")\n            if stat_result and stat.S_ISREG(stat_result.st_mode):\n                return FileResponse(full_path, stat_result=stat_result, status_code=404)\n        raise HTTPException(status_code=404)\n\n    def lookup_path(self, path: str) -> tuple[str, os.stat_result | None]:\n        for directory in self.all_directories:\n            joined_path = os.path.join(directory, path)\n            if self.follow_symlink:\n                full_path = os.path.abspath(joined_path)\n            else:\n                full_path = os.path.realpath(joined_path)\n                directory = os.path.realpath(directory)\n            if os.path.commonpath([full_path, directory]) != directory:\n                # Don't allow misbehaving clients to break out of the static files\n                # directory.\n                continue\n            try:\n                return full_path, os.stat(full_path)\n            except (FileNotFoundError, NotADirectoryError):\n                continue\n        return \"\", None\n\n    def file_response(\n        self,\n        full_path: PathLike,\n        stat_result: os.stat_result,\n        scope: Scope,\n        status_code: int = 200,\n    ) -> Response:\n        request_headers = Headers(scope=scope)\n\n        response = FileResponse(full_path, status_code=status_code, stat_result=stat_result)\n        if self.is_not_modified(response.headers, request_headers):\n            return NotModifiedResponse(response.headers)\n        return response\n\n    async def check_config(self) -> None:\n        \"\"\"\n        Perform a one-off configuration check that StaticFiles is actually\n        pointed at a directory, so that we can raise loud errors rather than\n        just returning 404 responses.\n        \"\"\"\n        if self.directory is None:\n            return\n\n        try:\n            stat_result = await anyio.to_thread.run_sync(os.stat, self.directory)\n        except FileNotFoundError:\n            raise RuntimeError(f\"StaticFiles directory '{self.directory}' does not exist.\")\n        if not (stat.S_ISDIR(stat_result.st_mode) or stat.S_ISLNK(stat_result.st_mode)):\n            raise RuntimeError(f\"StaticFiles path '{self.directory}' is not a directory.\")\n\n    def is_not_modified(self, response_headers: Headers, request_headers: Headers) -> bool:\n        \"\"\"\n        Given the request and response headers, return `True` if an HTTP\n        \"Not Modified\" response could be returned instead.\n        \"\"\"\n        try:\n            if_none_match = request_headers[\"if-none-match\"]\n            etag = response_headers[\"etag\"]\n            if etag in [tag.strip(\" W/\") for tag in if_none_match.split(\",\")]:\n                return True\n        except KeyError:\n            pass\n\n        try:\n            if_modified_since = parsedate(request_headers[\"if-modified-since\"])\n            last_modified = parsedate(response_headers[\"last-modified\"])\n            if if_modified_since is not None and last_modified is not None and if_modified_since >= last_modified:\n                return True\n        except KeyError:\n            pass\n\n        return False"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/starlette/starlette/schemas.py",
      "content": "from __future__ import annotations\n\nimport inspect\nimport re\nimport typing\n\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import BaseRoute, Host, Mount, Route\n\ntry:\n    import yaml\nexcept ModuleNotFoundError:  # pragma: no cover\n    yaml = None  # type: ignore[assignment]"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/starlette/starlette/schemas.py",
      "content": "class OpenAPIResponse(Response):\n    media_type = \"application/vnd.oai.openapi\"\n\n    def render(self, content: typing.Any) -> bytes:\n        assert yaml is not None, \"`pyyaml` must be installed to use OpenAPIResponse.\"\n        assert isinstance(content, dict), \"The schema passed to OpenAPIResponse should be a dictionary.\"\n        return yaml.dump(content, default_flow_style=False).encode(\"utf-8\")"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/starlette/starlette/schemas.py",
      "content": "class EndpointInfo(typing.NamedTuple):\n    path: str\n    http_method: str\n    func: typing.Callable[..., typing.Any]"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/starlette/starlette/schemas.py",
      "content": "class BaseSchemaGenerator:\n    def get_schema(self, routes: list[BaseRoute]) -> dict[str, typing.Any]:\n        raise NotImplementedError()  # pragma: no cover\n\n    def get_endpoints(self, routes: list[BaseRoute]) -> list[EndpointInfo]:\n        \"\"\"\n        Given the routes, yields the following information:\n\n        - path\n            eg: /users/\n        - http_method\n            one of 'get', 'post', 'put', 'patch', 'delete', 'options'\n        - func\n            method ready to extract the docstring\n        \"\"\"\n        endpoints_info: list[EndpointInfo] = []\n\n        for route in routes:\n            if isinstance(route, (Mount, Host)):\n                routes = route.routes or []\n                if isinstance(route, Mount):\n                    path = self._remove_converter(route.path)\n                else:\n                    path = \"\"\n                sub_endpoints = [\n                    EndpointInfo(\n                        path=\"\".join((path, sub_endpoint.path)),\n                        http_method=sub_endpoint.http_method,\n                        func=sub_endpoint.func,\n                    )\n                    for sub_endpoint in self.get_endpoints(routes)\n                ]\n                endpoints_info.extend(sub_endpoints)\n\n            elif not isinstance(route, Route) or not route.include_in_schema:\n                continue\n\n            elif inspect.isfunction(route.endpoint) or inspect.ismethod(route.endpoint):\n                path = self._remove_converter(route.path)\n                for method in route.methods or [\"GET\"]:\n                    if method == \"HEAD\":\n                        continue\n                    endpoints_info.append(EndpointInfo(path, method.lower(), route.endpoint))\n            else:\n                path = self._remove_converter(route.path)\n                for method in [\"get\", \"post\", \"put\", \"patch\", \"delete\", \"options\"]:\n                    if not hasattr(route.endpoint, method):\n                        continue\n                    func = getattr(route.endpoint, method)\n                    endpoints_info.append(EndpointInfo(path, method.lower(), func))\n\n        return endpoints_info\n\n    def _remove_converter(self, path: str) -> str:\n        \"\"\"\n        Remove the converter from the path.\n        For example, a route like this:\n            Route(\"/users/{id:int}\", endpoint=get_user, methods=[\"GET\"])\n        Should be represented as `/users/{id}` in the OpenAPI schema.\n        \"\"\"\n        return _remove_converter_pattern.sub(\"}\", path)\n\n    def parse_docstring(self, func_or_method: typing.Callable[..., typing.Any]) -> dict[str, typing.Any]:\n        \"\"\"\n        Given a function, parse the docstring as YAML and return a dictionary of info.\n        \"\"\"\n        docstring = func_or_method.__doc__\n        if not docstring:\n            return {}\n\n        assert yaml is not None, \"`pyyaml` must be installed to use parse_docstring.\"\n\n        # We support having regular docstrings before the schema\n        # definition. Here we return just the schema part from\n        # the docstring.\n        docstring = docstring.split(\"---\")[-1]\n\n        parsed = yaml.safe_load(docstring)\n\n        if not isinstance(parsed, dict):\n            # A regular docstring (not yaml formatted) can return\n            # a simple string here, which wouldn't follow the schema.\n            return {}\n\n        return parsed\n\n    def OpenAPIResponse(self, request: Request) -> Response:\n        routes = request.app.routes\n        schema = self.get_schema(routes=routes)\n        return OpenAPIResponse(schema)"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/starlette/starlette/schemas.py",
      "content": "class SchemaGenerator(BaseSchemaGenerator):\n    def __init__(self, base_schema: dict[str, typing.Any]) -> None:\n        self.base_schema = base_schema\n\n    def get_schema(self, routes: list[BaseRoute]) -> dict[str, typing.Any]:\n        schema = dict(self.base_schema)\n        schema.setdefault(\"paths\", {})\n        endpoints_info = self.get_endpoints(routes)\n\n        for endpoint in endpoints_info:\n            parsed = self.parse_docstring(endpoint.func)\n\n            if not parsed:\n                continue\n\n            if endpoint.path not in schema[\"paths\"]:\n                schema[\"paths\"][endpoint.path] = {}\n\n            schema[\"paths\"][endpoint.path][endpoint.http_method] = parsed\n\n        return schema"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "from __future__ import annotations\n\nimport json\nimport typing\nfrom http import cookies as http_cookies\n\nimport anyio\n\nfrom starlette._utils import AwaitableOrContextManager, AwaitableOrContextManagerWrapper\nfrom starlette.datastructures import URL, Address, FormData, Headers, QueryParams, State\nfrom starlette.exceptions import HTTPException\nfrom starlette.formparsers import FormParser, MultiPartException, MultiPartParser\nfrom starlette.types import Message, Receive, Scope, Send\n\nif typing.TYPE_CHECKING:\n    from python_multipart.multipart import parse_options_header\n\n    from starlette.applications import Starlette\n    from starlette.routing import Router\nelse:\n    try:\n        try:\n            from python_multipart.multipart import parse_options_header\n        except ModuleNotFoundError:  # pragma: no cover\n            from multipart.multipart import parse_options_header\n    except ModuleNotFoundError:  # pragma: no cover\n        parse_options_header = None"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "SERVER_PUSH_HEADERS_TO_COPY = {\n    \"accept\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"cache-control\",\n    \"user-agent\",\n}"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "def cookie_parser(cookie_string: str) -> dict[str, str]:\n    \"\"\"\n    This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.\n\n    It attempts to mimic browser cookie parsing behavior: browsers and web servers\n    frequently disregard the spec (RFC 6265) when setting and reading cookies,\n    so we attempt to suit the common scenarios here.\n\n    This function has been adapted from Django 3.1.0.\n    Note: we are explicitly _NOT_ using `SimpleCookie.load` because it is based\n    on an outdated spec and will fail on lots of input we want to support\n    \"\"\"\n    cookie_dict: dict[str, str] = {}\n    for chunk in cookie_string.split(\";\"):\n        if \"=\" in chunk:\n            key, val = chunk.split(\"=\", 1)\n        else:\n            # Assume an empty name per\n            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091\n            key, val = \"\", chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            # unquote using Python's algorithm.\n            cookie_dict[key] = http_cookies._unquote(val)\n    return cookie_dict"
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "class ClientDisconnect(Exception):\n    pass"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "class HTTPConnection(typing.Mapping[str, typing.Any]):\n    \"\"\"\n    A base class for incoming HTTP connections, that is used to provide\n    any functionality that is common to both `Request` and `WebSocket`.\n    \"\"\"\n\n    def __init__(self, scope: Scope, receive: Receive | None = None) -> None:\n        assert scope[\"type\"] in (\"http\", \"websocket\")\n        self.scope = scope\n\n    def __getitem__(self, key: str) -> typing.Any:\n        return self.scope[key]\n\n    def __iter__(self) -> typing.Iterator[str]:\n        return iter(self.scope)\n\n    def __len__(self) -> int:\n        return len(self.scope)\n\n    # Don't use the `abc.Mapping.__eq__` implementation.\n    # Connection instances should never be considered equal\n    # unless `self is other`.\n    __eq__ = object.__eq__\n    __hash__ = object.__hash__\n\n    @property\n    def app(self) -> typing.Any:\n        return self.scope[\"app\"]\n\n    @property\n    def url(self) -> URL:\n        if not hasattr(self, \"_url\"):  # pragma: no branch\n            self._url = URL(scope=self.scope)\n        return self._url\n\n    @property\n    def base_url(self) -> URL:\n        if not hasattr(self, \"_base_url\"):\n            base_url_scope = dict(self.scope)\n            # This is used by request.url_for, it might be used inside a Mount which\n            # would have its own child scope with its own root_path, but the base URL\n            # for url_for should still be the top level app root path.\n            app_root_path = base_url_scope.get(\"app_root_path\", base_url_scope.get(\"root_path\", \"\"))\n            path = app_root_path\n            if not path.endswith(\"/\"):\n                path += \"/\"\n            base_url_scope[\"path\"] = path\n            base_url_scope[\"query_string\"] = b\"\"\n            base_url_scope[\"root_path\"] = app_root_path\n            self._base_url = URL(scope=base_url_scope)\n        return self._base_url\n\n    @property\n    def headers(self) -> Headers:\n        if not hasattr(self, \"_headers\"):\n            self._headers = Headers(scope=self.scope)\n        return self._headers\n\n    @property\n    def query_params(self) -> QueryParams:\n        if not hasattr(self, \"_query_params\"):  # pragma: no branch\n            self._query_params = QueryParams(self.scope[\"query_string\"])\n        return self._query_params\n\n    @property\n    def path_params(self) -> dict[str, typing.Any]:\n        return self.scope.get(\"path_params\", {})\n\n    @property\n    def cookies(self) -> dict[str, str]:\n        if not hasattr(self, \"_cookies\"):\n            cookies: dict[str, str] = {}\n            cookie_header = self.headers.get(\"cookie\")\n\n            if cookie_header:\n                cookies = cookie_parser(cookie_header)\n            self._cookies = cookies\n        return self._cookies\n\n    @property\n    def client(self) -> Address | None:\n        # client is a 2 item tuple of (host, port), None if missing\n        host_port = self.scope.get(\"client\")\n        if host_port is not None:\n            return Address(*host_port)\n        return None\n\n    @property\n    def session(self) -> dict[str, typing.Any]:\n        assert \"session\" in self.scope, \"SessionMiddleware must be installed to access request.session\"\n        return self.scope[\"session\"]  # type: ignore[no-any-return]\n\n    @property\n    def auth(self) -> typing.Any:\n        assert \"auth\" in self.scope, \"AuthenticationMiddleware must be installed to access request.auth\"\n        return self.scope[\"auth\"]\n\n    @property\n    def user(self) -> typing.Any:\n        assert \"user\" in self.scope, \"AuthenticationMiddleware must be installed to access request.user\"\n        return self.scope[\"user\"]\n\n    @property\n    def state(self) -> State:\n        if not hasattr(self, \"_state\"):\n            # Ensure 'state' has an empty dict if it's not already populated.\n            self.scope.setdefault(\"state\", {})\n            # Create a state instance with a reference to the dict in which it should\n            # store info\n            self._state = State(self.scope[\"state\"])\n        return self._state\n\n    def url_for(self, name: str, /, **path_params: typing.Any) -> URL:\n        url_path_provider: Router | Starlette | None = self.scope.get(\"router\") or self.scope.get(\"app\")\n        if url_path_provider is None:\n            raise RuntimeError(\"The `url_for` method can only be used inside a Starlette application or with a router.\")\n        url_path = url_path_provider.url_path_for(name, **path_params)\n        return url_path.make_absolute_url(base_url=self.base_url)"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "async def empty_receive() -> typing.NoReturn:\n    raise RuntimeError(\"Receive channel has not been made available\")"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "async def empty_send(message: Message) -> typing.NoReturn:\n    raise RuntimeError(\"Send channel has not been made available\")"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/starlette/starlette/requests.py",
      "content": "class Request(HTTPConnection):\n    _form: FormData | None\n\n    def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send):\n        super().__init__(scope)\n        assert scope[\"type\"] == \"http\"\n        self._receive = receive\n        self._send = send\n        self._stream_consumed = False\n        self._is_disconnected = False\n        self._form = None\n\n    @property\n    def method(self) -> str:\n        return typing.cast(str, self.scope[\"method\"])\n\n    @property\n    def receive(self) -> Receive:\n        return self._receive\n\n    async def stream(self) -> typing.AsyncGenerator[bytes, None]:\n        if hasattr(self, \"_body\"):\n            yield self._body\n            yield b\"\"\n            return\n        if self._stream_consumed:\n            raise RuntimeError(\"Stream consumed\")\n        while not self._stream_consumed:\n            message = await self._receive()\n            if message[\"type\"] == \"http.request\":\n                body = message.get(\"body\", b\"\")\n                if not message.get(\"more_body\", False):\n                    self._stream_consumed = True\n                if body:\n                    yield body\n            elif message[\"type\"] == \"http.disconnect\":  # pragma: no branch\n                self._is_disconnected = True\n                raise ClientDisconnect()\n        yield b\"\"\n\n    async def body(self) -> bytes:\n        if not hasattr(self, \"_body\"):\n            chunks: list[bytes] = []\n            async for chunk in self.stream():\n                chunks.append(chunk)\n            self._body = b\"\".join(chunks)\n        return self._body\n\n    async def json(self) -> typing.Any:\n        if not hasattr(self, \"_json\"):  # pragma: no branch\n            body = await self.body()\n            self._json = json.loads(body)\n        return self._json\n\n    async def _get_form(\n        self,\n        *,\n        max_files: int | float = 1000,\n        max_fields: int | float = 1000,\n        max_part_size: int = 1024 * 1024,\n    ) -> FormData:\n        if self._form is None:  # pragma: no branch\n            assert (\n                parse_options_header is not None\n            ), \"The `python-multipart` library must be installed to use form parsing.\"\n            content_type_header = self.headers.get(\"Content-Type\")\n            content_type: bytes\n            content_type, _ = parse_options_header(content_type_header)\n            if content_type == b\"multipart/form-data\":\n                try:\n                    multipart_parser = MultiPartParser(\n                        self.headers,\n                        self.stream(),\n                        max_files=max_files,\n                        max_fields=max_fields,\n                        max_part_size=max_part_size,\n                    )\n                    self._form = await multipart_parser.parse()\n                except MultiPartException as exc:\n                    if \"app\" in self.scope:\n                        raise HTTPException(status_code=400, detail=exc.message)\n                    raise exc\n            elif content_type == b\"application/x-www-form-urlencoded\":\n                form_parser = FormParser(self.headers, self.stream())\n                self._form = await form_parser.parse()\n            else:\n                self._form = FormData()\n        return self._form\n\n    def form(\n        self,\n        *,\n        max_files: int | float = 1000,\n        max_fields: int | float = 1000,\n        max_part_size: int = 1024 * 1024,\n    ) -> AwaitableOrContextManager[FormData]:\n        return AwaitableOrContextManagerWrapper(\n            self._get_form(max_files=max_files, max_fields=max_fields, max_part_size=max_part_size)\n        )\n\n    async def close(self) -> None:\n        if self._form is not None:  # pragma: no branch\n            await self._form.close()\n\n    async def is_disconnected(self) -> bool:\n        if not self._is_disconnected:\n            message: Message = {}\n\n            # If message isn't immediately available, move on\n            with anyio.CancelScope() as cs:\n                cs.cancel()\n                message = await self._receive()\n\n            if message.get(\"type\") == \"http.disconnect\":\n                self._is_disconnected = True\n\n        return self._is_disconnected\n\n    async def send_push_promise(self, path: str) -> None:\n        if \"http.response.push\" in self.scope.get(\"extensions\", {}):\n            raw_headers: list[tuple[bytes, bytes]] = []\n            for name in SERVER_PUSH_HEADERS_TO_COPY:\n                for value in self.headers.getlist(name):\n                    raw_headers.append((name.encode(\"latin-1\"), value.encode(\"latin-1\")))\n            await self._send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "```python"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "from __future__ import annotations\n\nimport contextlib\nimport inspect\nimport io\nimport json\nimport math\nimport sys\nimport typing\nfrom concurrent.futures import Future\nfrom types import GeneratorType\nfrom urllib.parse import unquote, urljoin\n\nimport anyio\nimport anyio.abc\nimport anyio.from_thread\nfrom anyio.streams.stapled import StapledObjectStream\n\nfrom starlette._utils import is_async_callable\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\nfrom starlette.websockets import WebSocketDisconnect\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import TypeGuard\nelse:  # pragma: no cover\n    from typing_extensions import TypeGuard\n\ntry:\n    import httpx\nexcept ModuleNotFoundError:  # pragma: no cover\n    raise RuntimeError(\n        \"The starlette.testclient module requires the httpx package to be installed.\\n\"\n        \"You can install this with:\\n\"\n        \"    $ pip install httpx\\n\"\n    )\n_PortalFactoryType = typing.Callable[[], typing.ContextManager[anyio.abc.BlockingPortal]]\n\nASGIInstance = typing.Callable[[Receive, Send], typing.Awaitable[None]]\nASGI2App = typing.Callable[[Scope], ASGIInstance]\nASGI3App = typing.Callable[[Scope, Receive, Send], typing.Awaitable[None]]\n\n\n_RequestData = typing.Mapping[str, typing.Union[str, typing.Iterable[str], bytes]]"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "def _is_asgi3(app: ASGI2App | ASGI3App) -> TypeGuard[ASGI3App]:\n    if inspect.isclass(app):\n        return hasattr(app, \"__await__\")\n    return is_async_callable(app)"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class _WrapASGI2:\n    \"\"\"\n    Provide an ASGI3 interface onto an ASGI2 app.\n    \"\"\"\n\n    def __init__(self, app: ASGI2App) -> None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        instance = self.app(scope)\n        await instance(receive, send)"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class _AsyncBackend(typing.TypedDict):\n    backend: str\n    backend_options: dict[str, typing.Any]"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class _Upgrade(Exception):\n    def __init__(self, session: WebSocketTestSession) -> None:\n        self.session = session"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class WebSocketDenialResponse(  # type: ignore[misc]\n    httpx.Response,\n    WebSocketDisconnect,\n):\n    \"\"\"\n    A special case of `WebSocketDisconnect`, raised in the `TestClient` if the\n    `WebSocket` is closed before being accepted with a `send_denial_response()`.\n    \"\"\""
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class WebSocketTestSession:\n    def __init__(\n        self,\n        app: ASGI3App,\n        scope: Scope,\n        portal_factory: _PortalFactoryType,\n    ) -> None:\n        self.app = app\n        self.scope = scope\n        self.accepted_subprotocol = None\n        self.portal_factory = portal_factory\n        self.extra_headers = None\n\n    def __enter__(self) -> WebSocketTestSession:\n        with contextlib.ExitStack() as stack:\n            self.portal = portal = stack.enter_context(self.portal_factory())\n            fut, cs = portal.start_task(self._run)\n            stack.callback(fut.result)\n            stack.callback(portal.call, cs.cancel)\n            self.send({\"type\": \"websocket.connect\"})\n            message = self.receive()\n            self._raise_on_close(message)\n            self.accepted_subprotocol = message.get(\"subprotocol\", None)\n            self.extra_headers = message.get(\"headers\", None)\n            stack.callback(self.close, 1000)\n            self.exit_stack = stack.pop_all()\n            return self\n\n    def __exit__(self, *args: typing.Any) -> bool | None:\n        return self.exit_stack.__exit__(*args)\n\n    async def _run(self, *, task_status: anyio.abc.TaskStatus[anyio.CancelScope]) -> None:\n        \"\"\"\n        The sub-thread in which the websocket session runs.\n        \"\"\"\n        send: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream(math.inf)\n        send_tx, send_rx = send\n        receive: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream(math.inf)\n        receive_tx, receive_rx = receive\n        with send_tx, send_rx, receive_tx, receive_rx, anyio.CancelScope() as cs:\n            self._receive_tx = receive_tx\n            self._send_rx = send_rx\n            task_status.started(cs)\n            await self.app(self.scope, receive_rx.receive, send_tx.send)\n\n            # wait for cs.cancel to be called before closing streams\n            await anyio.sleep_forever()\n\n    def _raise_on_close(self, message: Message) -> None:\n        if message[\"type\"] == \"websocket.close\":\n            raise WebSocketDisconnect(code=message.get(\"code\", 1000), reason=message.get(\"reason\", \"\"))\n        elif message[\"type\"] == \"websocket.http.response.start\":\n            status_code: int = message[\"status\"]\n            headers: list[tuple[bytes, bytes]] = message[\"headers\"]\n            body: list[bytes] = []\n            while True:\n                message = self.receive()\n                assert message[\"type\"] == \"websocket.http.response.body\"\n                body.append(message[\"body\"])\n                if not message.get(\"more_body\", False):\n                    break\n            raise WebSocketDenialResponse(status_code=status_code, headers=headers, content=b\"\".join(body))\n\n    def send(self, message: Message) -> None:\n        self.portal.call(self._receive_tx.send, message)\n\n    def send_text(self, data: str) -> None:\n        self.send({\"type\": \"websocket.receive\", \"text\": data})\n\n    def send_bytes(self, data: bytes) -> None:\n        self.send({\"type\": \"websocket.receive\", \"bytes\": data})\n\n    def send_json(self, data: typing.Any, mode: typing.Literal[\"text\", \"binary\"] = \"text\") -> None:\n        text = json.dumps(data, separators=(\",\", \":\"), ensure_ascii=False)\n        if mode == \"text\":\n            self.send({\"type\": \"websocket.receive\", \"text\": text})\n        else:\n            self.send({\"type\": \"websocket.receive\", \"bytes\": text.encode(\"utf-8\")})\n\n    def close(self, code: int = 1000, reason: str | None = None) -> None:\n        self.send({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n\n    def receive(self) -> Message:\n        return self.portal.call(self._send_rx.receive)\n\n    def receive_text(self) -> str:\n        message = self.receive()\n        self._raise_on_close(message)\n        return typing.cast(str, message[\"text\"])\n\n    def receive_bytes(self) -> bytes:\n        message = self.receive()\n        self._raise_on_close(message)\n        return typing.cast(bytes, message[\"bytes\"])\n\n    def receive_json(self, mode: typing.Literal[\"text\", \"binary\"] = \"text\") -> typing.Any:\n        message = self.receive()\n        self._raise_on_close(message)\n        if mode == \"text\":\n            text = message[\"text\"]\n        else:\n            text = message[\"bytes\"].decode(\"utf-8\")\n        return json.loads(text)"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class _TestClientTransport(httpx.BaseTransport):\n    def __init__(\n        self,\n        app: ASGI3App,\n        portal_factory: _PortalFactoryType,\n        raise_server_exceptions: bool = True,\n        root_path: str = \"\",\n        *,\n        client: tuple[str, int],\n        app_state: dict[str, typing.Any],\n    ) -> None:\n        self.app = app\n        self.raise_server_exceptions = raise_server_exceptions\n        self.root_path = root_path\n        self.portal_factory = portal_factory\n        self.app_state = app_state\n        self.client = client\n\n    def handle_request(self, request: httpx.Request) -> httpx.Response:\n        scheme = request.url.scheme\n        netloc = request.url.netloc.decode(encoding=\"ascii\")\n        path = request.url.path\n        raw_path = request.url.raw_path\n        query = request.url.query.decode(encoding=\"ascii\")\n\n        default_port = {\"http\": 80, \"ws\": 80, \"https\": 443, \"wss\": 443}[scheme]\n\n        if \":\" in netloc:\n            host, port_string = netloc.split(\":\", 1)\n            port = int(port_string)\n        else:\n            host = netloc\n            port = default_port\n\n        # Include the 'host' header.\n        if \"host\" in request.headers:\n            headers: list[tuple[bytes, bytes]] = []\n        elif port == default_port:  # pragma: no cover\n            headers = [(b\"host\", host.encode())]\n        else:  # pragma: no cover\n            headers = [(b\"host\", (f\"{host}:{port}\").encode())]\n\n        # Include other request headers.\n        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]\n\n        scope: dict[str, typing.Any]\n\n        if scheme in {\"ws\", \"wss\"}:\n            subprotocol = request.headers.get(\"sec-websocket-protocol\", None)\n            if subprotocol is None:\n                subprotocols: typing.Sequence[str] = []\n            else:\n                subprotocols = [value.strip() for value in subprotocol.split(\",\")]\n            scope = {\n                \"type\": \"websocket\",\n                \"path\": unquote(path),\n                \"raw_path\": raw_path.split(b\"?\", 1)[0],\n                \"root_path\": self.root_path,\n                \"scheme\": scheme,\n                \"query_string\": query.encode(),\n                \"headers\": headers,\n                \"client\": self.client,\n                \"server\": [host, port],\n                \"subprotocols\": subprotocols,\n                \"state\": self.app_state.copy(),\n                \"extensions\": {\"websocket.http.response\": {}},\n            }\n            session = WebSocketTestSession(self.app, scope, self.portal_factory)\n            raise _Upgrade(session)\n\n        scope = {\n            \"type\": \"http\",\n            \"http_version\": \"1.1\",\n            \"method\": request.method,\n            \"path\": unquote(path),\n            \"raw_path\": raw_path.split(b\"?\", 1)[0],\n            \"root_path\": self.root_path,\n            \"scheme\": scheme,\n            \"query_string\": query.encode(),\n            \"headers\": headers,\n            \"client\": self.client,\n            \"server\": [host, port],\n            \"extensions\": {\"http.response.debug\": {}},\n            \"state\": self.app_state.copy(),\n        }\n\n        request_complete = False\n        response_started = False\n        response_complete: anyio.Event\n        raw_kwargs: dict[str, typing.Any] = {\"stream\": io.BytesIO()}\n        template = None\n        context = None\n\n        async def receive() -> Message:\n            nonlocal request_complete\n\n            if request_complete:\n                if not response_complete.is_set():\n                    await response_complete.wait()\n                return {\"type\": \"http.disconnect\"}\n\n            body = request.read()\n            if isinstance(body, str):\n                body_bytes: bytes = body.encode(\"utf-8\")  # pragma: no cover\n            elif body is None:\n                body_bytes = b\"\"  # pragma: no cover\n            elif isinstance(body, GeneratorType):\n                try:  # pragma: no cover\n                    chunk = body.send(None)\n                    if isinstance(chunk, str):\n                        chunk = chunk.encode(\"utf-8\")\n                    return {\"type\": \"http.request\", \"body\": chunk, \"more_body\": True}\n                except StopIteration:  # pragma: no cover\n                    request_complete = True\n                    return {\"type\": \"http.request\", \"body\": b\"\"}\n            else:\n                body_bytes = body\n\n            request_complete = True\n            return {\"type\": \"http.request\", \"body\": body_bytes}\n\n        async def send(message: Message) -> None:\n            nonlocal raw_kwargs, response_started, template, context\n\n            if message[\"type\"] == \"http.response.start\":\n                assert not response_started, 'Received multiple \"http.response.start\" messages.'\n                raw_kwargs[\"status_code\"] = message[\"status\"]\n                raw_kwargs[\"headers\"] = [(key.decode(), value.decode()) for key, value in message.get(\"headers\", [])]\n                response_started = True\n            elif message[\"type\"] == \"http.response.body\":\n                assert response_started, 'Received \"http.response.body\" without \"http.response.start\".'\n                assert not response_complete.is_set(), 'Received \"http.response.body\" after response completed.'\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n                if request.method != \"HEAD\":\n                    raw_kwargs[\"stream\"].write(body)\n                if not more_body:\n                    raw_kwargs[\"stream\"].seek(0)\n                    response_complete.set()\n            elif message[\"type\"] == \"http.response.debug\":\n                template = message[\"info\"][\"template\"]\n                context = message[\"info\"][\"context\"]\n\n        try:\n            with self.portal_factory() as portal:\n                response_complete = portal.call(anyio.Event)\n                portal.call(self.app, scope, receive, send)\n        except BaseException as exc:\n            if self.raise_server_exceptions:\n                raise exc\n\n        if self.raise_server_exceptions:\n            assert response_started, \"TestClient did not receive any response.\"\n        elif not response_started:\n            raw_kwargs = {\n                \"status_code\": 500,\n                \"headers\": [],\n                \"stream\": io.BytesIO(),\n            }\n\n        raw_kwargs[\"stream\"] = httpx.ByteStream(raw_kwargs[\"stream\"].read())\n\n        response = httpx.Response(**raw_kwargs, request=request)\n        if template is not None:\n            response.template = template  # type: ignore[attr-defined]\n            response.context = context  # type: ignore[attr-defined]\n        return response"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/starlette/starlette/testclient.py",
      "content": "class TestClient(httpx.Client):\n    __test__ = False\n    task: Future[None]\n    portal: anyio.abc.BlockingPortal | None = None\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        base_url: str = \"http://testserver\",\n        raise_server_exceptions: bool = True,\n        root_path: str = \"\",\n        backend: typing.Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n        backend_options: dict[str, typing.Any] | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        headers: dict[str, str] | None = None,\n        follow_redirects: bool = True,\n        client: tuple[str, int] = (\"testclient\", 50000),\n    ) -> None:\n        self.async_backend = _AsyncBackend(backend=backend, backend_options=backend_options or {})\n        if _is_asgi3(app):\n            asgi_app = app\n        else:\n            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]\n            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]\n        self.app = asgi_app\n        self.app_state: dict[str, typing.Any] = {}\n        transport = _TestClientTransport(\n            self.app,\n            portal_factory=self._portal_factory,\n            raise_server_exceptions=raise_server_exceptions,\n            root_path=root_path,\n            app_state=self.app_state,\n            client=client,\n        )\n        if headers is None:\n            headers = {}\n        headers.setdefault(\"user-agent\", \"testclient\")\n        super().__init__(\n            base_url=base_url,\n            headers=headers,\n            transport=transport,\n            follow_redirects=follow_redirects,\n            cookies=cookies,\n        )\n\n    @contextlib.contextmanager\n    def _portal_factory(self) -> typing.Generator[anyio.abc.BlockingPortal, None, None]:\n        if self.portal is not None:\n            yield self.portal\n        else:\n            with anyio.from_thread.start_blocking_portal(**self.async_backend) as portal:\n                yield portal\n\n    def request(  # type: ignore[override]\n        self,\n        method: str,\n        url: httpx._types.URLTypes,\n        *,\n        content: httpx._types.RequestContent | None = None,\n        data: _RequestData | None = None,\n        files: httpx._types.RequestFiles | None = None,\n        json: typing.Any = None,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        url = self._merge_url(url)\n        return super().request(\n            method,\n            url,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def get(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().get(\n            url,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def options(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().options(\n            url,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def head(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().head(\n            url,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def post(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        content: httpx._types.RequestContent | None = None,\n        data: _RequestData | None = None,\n        files: httpx._types.RequestFiles | None = None,\n        json: typing.Any = None,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().post(\n            url,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def put(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        content: httpx._types.RequestContent | None = None,\n        data: _RequestData | None = None,\n        files: httpx._types.RequestFiles | None = None,\n        json: typing.Any = None,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().put(\n            url,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def patch(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        content: httpx._types.RequestContent | None = None,\n        data: _RequestData | None = None,\n        files: httpx._types.RequestFiles | None = None,\n        json: typing.Any = None,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().patch(\n            url,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def delete(  # type: ignore[override]\n        self,\n        url: httpx._types.URLTypes,\n        *,\n        params: httpx._types.QueryParamTypes | None = None,\n        headers: httpx._types.HeaderTypes | None = None,\n        cookies: httpx._types.CookieTypes | None = None,\n        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n        extensions: dict[str, typing.Any] | None = None,\n    ) -> httpx.Response:\n        return super().delete(\n            url,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            auth=auth,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n\n    def websocket_connect(\n        self,\n        url: str,\n        subprotocols: typing.Sequence[str] | None = None,\n        **kwargs: typing.Any,\n    ) -> WebSocketTestSession:\n        url = urljoin(\"ws://testserver\", url)\n        headers = kwargs.get(\"headers\", {})\n        headers.setdefault(\"connection\", \"upgrade\")\n        headers.setdefault(\"sec-websocket-key\", \"testserver==\")\n        headers.setdefault(\"sec-websocket-version\", \"13\")\n        if subprotocols is not None:\n            headers.setdefault(\"sec-websocket-protocol\", \", \".join(subprotocols))\n        kwargs[\"headers\"] = headers\n        try:\n            super().request(\"GET\", url, **kwargs)\n        except _Upgrade as exc:\n            session = exc.session\n        else:\n            raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n\n        return session\n\n    def __enter__(self) -> TestClient:\n        with contextlib.ExitStack() as stack:\n            self.portal = portal = stack.enter_context(anyio.from_thread.start_blocking_portal(**self.async_backend))\n\n            @stack.callback\n            def reset_portal() -> None:\n                self.portal = None\n\n            send: anyio.create_memory_object_stream[typing.MutableMapping[str, typing.Any] | None] = (\n                anyio.create_memory_object_stream(math.inf)\n            )\n            receive: anyio.create_memory_object_stream[typing.MutableMapping[str, typing.Any]] = (\n                anyio.create_memory_object_stream(math.inf)\n            )\n            for channel in (*send, *receive):\n                stack.callback(channel.close)\n            self.stream_send = StapledObjectStream(*send)\n            self.stream_receive = StapledObjectStream(*receive)\n            self.task = portal.start_task_soon(self.lifespan)\n            portal.call(self.wait_startup)\n\n            @stack.callback\n            def wait_shutdown() -> None:\n                portal.call(self.wait_shutdown)\n\n            self.exit_stack = stack.pop_all()\n\n        return self\n\n    def __exit__(self, *args: typing.Any) -> None:\n        self.exit_stack.close()\n\n    async def lifespan(self) -> None:\n        scope = {\"type\": \"lifespan\", \"state\": self.app_state}\n        try:\n            await self.app(scope, self.stream_receive.receive, self.stream_send.send)\n        finally:\n            await self.stream_send.send(None)\n\n    async def wait_startup(self) -> None:\n        await self.stream_receive.send({\"type\": \"lifespan.startup\"})\n\n        async def receive() -> typing.Any:\n            message = await self.stream_send.receive()\n            if message is None:\n                self.task.result()\n            return message\n\n        message = await receive()\n        assert message[\"type\"] in (\n            \"lifespan.startup.complete\",\n            \"lifespan.startup.failed\",\n        )\n        if message[\"type\"] == \"lifespan.startup.failed\":\n            await receive()\n\n    async def wait_shutdown(self) -> None:\n        async def receive() -> typing.Any:\n            message = await self.stream_send.receive()\n            if message is None:\n                self.task.result()\n            return message\n\n        await self.stream_receive.send({\"type\": \"lifespan.shutdown\"})\n        message = await receive()\n        assert message[\"type\"] in (\n            \"lifespan.shutdown.complete\",\n            \"lifespan.shutdown.failed\",\n        )\n        if message[\"type\"] == \"lifespan.shutdown.failed\":\n            await receive()\n```"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "from __future__ import annotations\n\nimport math\nimport typing\nimport uuid\n\nT = typing.TypeVar(\"T\")"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class Convertor(typing.Generic[T]):\n    regex: typing.ClassVar[str] = \"\"\n\n    def convert(self, value: str) -> T:\n        raise NotImplementedError()  # pragma: no cover\n\n    def to_string(self, value: T) -> str:\n        raise NotImplementedError()  # pragma: no cover"
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class StringConvertor(Convertor[str]):\n    regex = \"[^/]+\"\n\n    def convert(self, value: str) -> str:\n        return value\n\n    def to_string(self, value: str) -> str:\n        value = str(value)\n        assert \"/\" not in value, \"May not contain path separators\"\n        assert value, \"Must not be empty\"\n        return value"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class PathConvertor(Convertor[str]):\n    regex = \".*\"\n\n    def convert(self, value: str) -> str:\n        return str(value)\n\n    def to_string(self, value: str) -> str:\n        return str(value)"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class IntegerConvertor(Convertor[int]):\n    regex = \"[0-9]+\"\n\n    def convert(self, value: str) -> int:\n        return int(value)\n\n    def to_string(self, value: int) -> str:\n        value = int(value)\n        assert value >= 0, \"Negative integers are not supported\"\n        return str(value)"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class FloatConvertor(Convertor[float]):\n    regex = r\"[0-9]+(\\.[0-9]+)?\"\n\n    def convert(self, value: str) -> float:\n        return float(value)\n\n    def to_string(self, value: float) -> str:\n        value = float(value)\n        assert value >= 0.0, \"Negative floats are not supported\"\n        assert not math.isnan(value), \"NaN values are not supported\"\n        assert not math.isinf(value), \"Infinite values are not supported\"\n        return (\"%0.20f\" % value).rstrip(\"0\").rstrip(\".\")"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "class UUIDConvertor(Convertor[uuid.UUID]):\n    regex = \"[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}\"\n\n    def convert(self, value: str) -> uuid.UUID:\n        return uuid.UUID(value)\n\n    def to_string(self, value: uuid.UUID) -> str:\n        return str(value)"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "CONVERTOR_TYPES: dict[str, Convertor[typing.Any]] = {\n    \"str\": StringConvertor(),\n    \"path\": PathConvertor(),\n    \"int\": IntegerConvertor(),\n    \"float\": FloatConvertor(),\n    \"uuid\": UUIDConvertor(),\n}"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/starlette/starlette/convertors.py",
      "content": "def register_url_convertor(key: str, convertor: Convertor[typing.Any]) -> None:\n    CONVERTOR_TYPES[key] = convertor"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "from __future__ import annotations\n\nimport typing\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom tempfile import SpooledTemporaryFile\nfrom urllib.parse import unquote_plus\n\nfrom starlette.datastructures import FormData, Headers, UploadFile\n\nif typing.TYPE_CHECKING:\n    import python_multipart as multipart\n    from python_multipart.multipart import MultipartCallbacks, QuerystringCallbacks, parse_options_header\nelse:\n    try:\n        try:\n            import python_multipart as multipart\n            from python_multipart.multipart import parse_options_header\n        except ModuleNotFoundError:  # pragma: no cover\n            import multipart\n            from multipart.multipart import parse_options_header\n    except ModuleNotFoundError:  # pragma: no cover\n        multipart = None\n        parse_options_header = None"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "class FormMessage(Enum):\n    FIELD_START = 1\n    FIELD_NAME = 2\n    FIELD_DATA = 3\n    FIELD_END = 4\n    END = 5"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "@dataclass\nclass MultipartPart:\n    content_disposition: bytes | None = None\n    field_name: str = \"\"\n    data: bytearray = field(default_factory=bytearray)\n    file: UploadFile | None = None\n    item_headers: list[tuple[bytes, bytes]] = field(default_factory=list)"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "def _user_safe_decode(src: bytes | bytearray, codec: str) -> str:\n    try:\n        return src.decode(codec)\n    except (UnicodeDecodeError, LookupError):\n        return src.decode(\"latin-1\")"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "class MultiPartException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "class FormParser:\n    def __init__(self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]) -> None:\n        assert multipart is not None, \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.messages: list[tuple[FormMessage, bytes]] = []\n\n    def on_field_start(self) -> None:\n        message = (FormMessage.FIELD_START, b\"\")\n        self.messages.append(message)\n\n    def on_field_name(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_NAME, data[start:end])\n        self.messages.append(message)\n\n    def on_field_data(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_DATA, data[start:end])\n        self.messages.append(message)\n\n    def on_field_end(self) -> None:\n        message = (FormMessage.FIELD_END, b\"\")\n        self.messages.append(message)\n\n    def on_end(self) -> None:\n        message = (FormMessage.END, b\"\")\n        self.messages.append(message)\n\n    async def parse(self) -> FormData:\n        # Callbacks dictionary.\n        callbacks: QuerystringCallbacks = {\n            \"on_field_start\": self.on_field_start,\n            \"on_field_name\": self.on_field_name,\n            \"on_field_data\": self.on_field_data,\n            \"on_field_end\": self.on_field_end,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.QuerystringParser(callbacks)\n        field_name = b\"\"\n        field_value = b\"\"\n\n        items: list[tuple[str, str | UploadFile]] = []\n\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            if chunk:\n                parser.write(chunk)\n            else:\n                parser.finalize()\n            messages = list(self.messages)\n            self.messages.clear()\n            for message_type, message_bytes in messages:\n                if message_type == FormMessage.FIELD_START:\n                    field_name = b\"\"\n                    field_value = b\"\"\n                elif message_type == FormMessage.FIELD_NAME:\n                    field_name += message_bytes\n                elif message_type == FormMessage.FIELD_DATA:\n                    field_value += message_bytes\n                elif message_type == FormMessage.FIELD_END:\n                    name = unquote_plus(field_name.decode(\"latin-1\"))\n                    value = unquote_plus(field_value.decode(\"latin-1\"))\n                    items.append((name, value))\n\n        return FormData(items)"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/starlette/starlette/formparsers.py",
      "content": "class MultiPartParser:\n    max_file_size = 1024 * 1024  # 1MB\n\n    def __init__(\n        self,\n        headers: Headers,\n        stream: typing.AsyncGenerator[bytes, None],\n        *,\n        max_files: int | float = 1000,\n        max_fields: int | float = 1000,\n        max_part_size: int = 1024 * 1024,  # 1MB\n    ) -> None:\n        assert multipart is not None, \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.max_files = max_files\n        self.max_fields = max_fields\n        self.items: list[tuple[str, str | UploadFile]] = []\n        self._current_files = 0\n        self._current_fields = 0\n        self._current_partial_header_name: bytes = b\"\"\n        self._current_partial_header_value: bytes = b\"\"\n        self._current_part = MultipartPart()\n        self._charset = \"\"\n        self._file_parts_to_write: list[tuple[MultipartPart, bytes]] = []\n        self._file_parts_to_finish: list[MultipartPart] = []\n        self._files_to_close_on_error: list[SpooledTemporaryFile[bytes]] = []\n        self.max_part_size = max_part_size\n\n    def on_part_begin(self) -> None:\n        self._current_part = MultipartPart()\n\n    def on_part_data(self, data: bytes, start: int, end: int) -> None:\n        message_bytes = data[start:end]\n        if self._current_part.file is None:\n            if len(self._current_part.data) + len(message_bytes) > self.max_part_size:\n                raise MultiPartException(f\"Part exceeded maximum size of {int(self.max_part_size / 1024)}KB.\")\n            self._current_part.data.extend(message_bytes)\n        else:\n            self._file_parts_to_write.append((self._current_part, message_bytes))\n\n    def on_part_end(self) -> None:\n        if self._current_part.file is None:\n            self.items.append(\n                (\n                    self._current_part.field_name,\n                    _user_safe_decode(self._current_part.data, self._charset),\n                )\n            )\n        else:\n            self._file_parts_to_finish.append(self._current_part)\n            # The file can be added to the items right now even though it's not\n            # finished yet, because it will be finished in the `parse()` method, before\n            # self.items is used in the return value.\n            self.items.append((self._current_part.field_name, self._current_part.file))\n\n    def on_header_field(self, data: bytes, start: int, end: int) -> None:\n        self._current_partial_header_name += data[start:end]\n\n    def on_header_value(self, data: bytes, start: int, end: int) -> None:\n        self._current_partial_header_value += data[start:end]\n\n    def on_header_end(self) -> None:\n        field = self._current_partial_header_name.lower()\n        if field == b\"content-disposition\":\n            self._current_part.content_disposition = self._current_partial_header_value\n        self._current_part.item_headers.append((field, self._current_partial_header_value))\n        self._current_partial_header_name = b\"\"\n        self._current_partial_header_value = b\"\"\n\n    def on_headers_finished(self) -> None:\n        disposition, options = parse_options_header(self._current_part.content_disposition)\n        try:\n            self._current_part.field_name = _user_safe_decode(options[b\"name\"], self._charset)\n        except KeyError:\n            raise MultiPartException('The Content-Disposition header field \"name\" must be provided.')\n        if b\"filename\" in options:\n            self._current_files += 1\n            if self._current_files > self.max_files:\n                raise MultiPartException(f\"Too many files. Maximum number of files is {self.max_files}.\")\n            filename = _user_safe_decode(options[b\"filename\"], self._charset)\n            tempfile = SpooledTemporaryFile(max_size=self.max_file_size)\n            self._files_to_close_on_error.append(tempfile)\n            self._current_part.file = UploadFile(\n                file=tempfile,  # type: ignore[arg-type]\n                size=0,\n                filename=filename,\n                headers=Headers(raw=self._current_part.item_headers),\n            )\n        else:\n            self._current_fields += 1\n            if self._current_fields > self.max_fields:\n                raise MultiPartException(f\"Too many fields. Maximum number of fields is {self.max_fields}.\")\n            self._current_part.file = None\n\n    def on_end(self) -> None:\n        pass\n\n    async def parse(self) -> FormData:\n        # Parse the Content-Type header to get the multipart boundary.\n        _, params = parse_options_header(self.headers[\"Content-Type\"])\n        charset = params.get(b\"charset\", \"utf-8\")\n        if isinstance(charset, bytes):\n            charset = charset.decode(\"latin-1\")\n        self._charset = charset\n        try:\n            boundary = params[b\"boundary\"]\n        except KeyError:\n            raise MultiPartException(\"Missing boundary in multipart.\")\n\n        # Callbacks dictionary.\n        callbacks: MultipartCallbacks = {\n            \"on_part_begin\": self.on_part_begin,\n            \"on_part_data\": self.on_part_data,\n            \"on_part_end\": self.on_part_end,\n            \"on_header_field\": self.on_header_field,\n            \"on_header_value\": self.on_header_value,\n            \"on_header_end\": self.on_header_end,\n            \"on_headers_finished\": self.on_headers_finished,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.MultipartParser(boundary, callbacks)\n        try:\n            # Feed the parser with data from the request.\n            async for chunk in self.stream:\n                parser.write(chunk)\n                # Write file data, it needs to use await with the UploadFile methods\n                # that call the corresponding file methods *in a threadpool*,\n                # otherwise, if they were called directly in the callback methods above\n                # (regular, non-async functions), that would block the event loop in\n                # the main thread.\n                for part, data in self._file_parts_to_write:\n                    assert part.file  # for type checkers\n                    await part.file.write(data)\n                for part in self._file_parts_to_finish:\n                    assert part.file  # for type checkers\n                    await part.file.seek(0)\n                self._file_parts_to_write.clear()\n                self._file_parts_to_finish.clear()\n        except MultiPartException as exc:\n            # Close all the files if there was an error.\n            for file in self._files_to_close_on_error:\n                file.close()\n            raise exc\n\n        parser.finalize()\n        return FormData(self.items)"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/starlette/starlette/websockets.py",
      "content": "from __future__ import annotations\n\nimport enum\nimport json\nimport typing\n\nfrom starlette.requests import HTTPConnection\nfrom starlette.responses import Response\nfrom starlette.types import Message, Receive, Scope, Send"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/starlette/starlette/websockets.py",
      "content": "class WebSocketState(enum.Enum):\n    CONNECTING = 0\n    CONNECTED = 1\n    DISCONNECTED = 2\n    RESPONSE = 3"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/starlette/starlette/websockets.py",
      "content": "class WebSocketDisconnect(Exception):\n    def __init__(self, code: int = 1000, reason: str | None = None) -> None:\n        self.code = code\n        self.reason = reason or \"\""
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/starlette/starlette/websockets.py",
      "content": "class WebSocket(HTTPConnection):\n    def __init__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        super().__init__(scope)\n        assert scope[\"type\"] == \"websocket\"\n        self._receive = receive\n        self._send = send\n        self.client_state = WebSocketState.CONNECTING\n        self.application_state = WebSocketState.CONNECTING\n\n    async def receive(self) -> Message:\n        \"\"\"\n        Receive ASGI websocket messages, ensuring valid state transitions.\n        \"\"\"\n        if self.client_state == WebSocketState.CONNECTING:\n            message = await self._receive()\n            message_type = message[\"type\"]\n            if message_type != \"websocket.connect\":\n                raise RuntimeError(f'Expected ASGI message \"websocket.connect\", but got {message_type!r}')\n            self.client_state = WebSocketState.CONNECTED\n            return message\n        elif self.client_state == WebSocketState.CONNECTED:\n            message = await self._receive()\n            message_type = message[\"type\"]\n            if message_type not in {\"websocket.receive\", \"websocket.disconnect\"}:\n                raise RuntimeError(\n                    f'Expected ASGI message \"websocket.receive\" or \"websocket.disconnect\", but got {message_type!r}'\n                )\n            if message_type == \"websocket.disconnect\":\n                self.client_state = WebSocketState.DISCONNECTED\n            return message\n        else:\n            raise RuntimeError('Cannot call \"receive\" once a disconnect message has been received.')\n\n    async def send(self, message: Message) -> None:\n        \"\"\"\n        Send ASGI websocket messages, ensuring valid state transitions.\n        \"\"\"\n        if self.application_state == WebSocketState.CONNECTING:\n            message_type = message[\"type\"]\n            if message_type not in {\"websocket.accept\", \"websocket.close\", \"websocket.http.response.start\"}:\n                raise RuntimeError(\n                    'Expected ASGI message \"websocket.accept\", \"websocket.close\" or \"websocket.http.response.start\", '\n                    f\"but got {message_type!r}\"\n                )\n            if message_type == \"websocket.close\":\n                self.application_state = WebSocketState.DISCONNECTED\n            elif message_type == \"websocket.http.response.start\":\n                self.application_state = WebSocketState.RESPONSE\n            else:\n                self.application_state = WebSocketState.CONNECTED\n            await self._send(message)\n        elif self.application_state == WebSocketState.CONNECTED:\n            message_type = message[\"type\"]\n            if message_type not in {\"websocket.send\", \"websocket.close\"}:\n                raise RuntimeError(\n                    f'Expected ASGI message \"websocket.send\" or \"websocket.close\", but got {message_type!r}'\n                )\n            if message_type == \"websocket.close\":\n                self.application_state = WebSocketState.DISCONNECTED\n            try:\n                await self._send(message)\n            except OSError:\n                self.application_state = WebSocketState.DISCONNECTED\n                raise WebSocketDisconnect(code=1006)\n        elif self.application_state == WebSocketState.RESPONSE:\n            message_type = message[\"type\"]\n            if message_type != \"websocket.http.response.body\":\n                raise RuntimeError(f'Expected ASGI message \"websocket.http.response.body\", but got {message_type!r}')\n            if not message.get(\"more_body\", False):\n                self.application_state = WebSocketState.DISCONNECTED\n            await self._send(message)\n        else:\n            raise RuntimeError('Cannot call \"send\" once a close message has been sent.')\n\n    async def accept(\n        self,\n        subprotocol: str | None = None,\n        headers: typing.Iterable[tuple[bytes, bytes]] | None = None,\n    ) -> None:\n        headers = headers or []\n\n        if self.client_state == WebSocketState.CONNECTING:  # pragma: no branch\n            # If we haven't yet seen the 'connect' message, then wait for it first.\n            await self.receive()\n        await self.send({\"type\": \"websocket.accept\", \"subprotocol\": subprotocol, \"headers\": headers})\n\n    def _raise_on_disconnect(self, message: Message) -> None:\n        if message[\"type\"] == \"websocket.disconnect\":\n            raise WebSocketDisconnect(message[\"code\"], message.get(\"reason\"))\n\n    async def receive_text(self) -> str:\n        if self.application_state != WebSocketState.CONNECTED:\n            raise RuntimeError('WebSocket is not connected. Need to call \"accept\" first.')\n        message = await self.receive()\n        self._raise_on_disconnect(message)\n        return typing.cast(str, message[\"text\"])\n\n    async def receive_bytes(self) -> bytes:\n        if self.application_state != WebSocketState.CONNECTED:\n            raise RuntimeError('WebSocket is not connected. Need to call \"accept\" first.')\n        message = await self.receive()\n        self._raise_on_disconnect(message)\n        return typing.cast(bytes, message[\"bytes\"])\n\n    async def receive_json(self, mode: str = \"text\") -> typing.Any:\n        if mode not in {\"text\", \"binary\"}:\n            raise RuntimeError('The \"mode\" argument should be \"text\" or \"binary\".')\n        if self.application_state != WebSocketState.CONNECTED:\n            raise RuntimeError('WebSocket is not connected. Need to call \"accept\" first.')\n        message = await self.receive()\n        self._raise_on_disconnect(message)\n\n        if mode == \"text\":\n            text = message[\"text\"]\n        else:\n            text = message[\"bytes\"].decode(\"utf-8\")\n        return json.loads(text)\n\n    async def iter_text(self) -> typing.AsyncIterator[str]:\n        try:\n            while True:\n                yield await self.receive_text()\n        except WebSocketDisconnect:\n            pass\n\n    async def iter_bytes(self) -> typing.AsyncIterator[bytes]:\n        try:\n            while True:\n                yield await self.receive_bytes()\n        except WebSocketDisconnect:\n            pass\n\n    async def iter_json(self) -> typing.AsyncIterator[typing.Any]:\n        try:\n            while True:\n                yield await self.receive_json()\n        except WebSocketDisconnect:\n            pass\n\n    async def send_text(self, data: str) -> None:\n        await self.send({\"type\": \"websocket.send\", \"text\": data})\n\n    async def send_bytes(self, data: bytes) -> None:\n        await self.send({\"type\": \"websocket.send\", \"bytes\": data})\n\n    async def send_json(self, data: typing.Any, mode: str = \"text\") -> None:\n        if mode not in {\"text\", \"binary\"}:\n            raise RuntimeError('The \"mode\" argument should be \"text\" or \"binary\".')\n        text = json.dumps(data, separators=(\",\", \":\"), ensure_ascii=False)\n        if mode == \"text\":\n            await self.send({\"type\": \"websocket.send\", \"text\": text})\n        else:\n            await self.send({\"type\": \"websocket.send\", \"bytes\": text.encode(\"utf-8\")})\n\n    async def close(self, code: int = 1000, reason: str | None = None) -> None:\n        await self.send({\"type\": \"websocket.close\", \"code\": code, \"reason\": reason or \"\"})\n\n    async def send_denial_response(self, response: Response) -> None:\n        if \"websocket.http.response\" in self.scope.get(\"extensions\", {}):\n            await response(self.scope, self.receive, self.send)\n        else:\n            raise RuntimeError(\"The server doesn't support the Websocket Denial Response extension.\")"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/starlette/starlette/websockets.py",
      "content": "class WebSocketClose:\n    def __init__(self, code: int = 1000, reason: str | None = None) -> None:\n        self.code = code\n        self.reason = reason or \"\"\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await send({\"type\": \"websocket.close\", \"code\": self.code, \"reason\": self.reason})"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "import typing"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "if typing.TYPE_CHECKING:\n    from starlette.requests import Request\n    from starlette.responses import Response\n    from starlette.websockets import WebSocket"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "AppType = typing.TypeVar(\"AppType\")"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "Scope = typing.MutableMapping[str, typing.Any]\nMessage = typing.MutableMapping[str, typing.Any]"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "Receive = typing.Callable[[], typing.Awaitable[Message]]\nSend = typing.Callable[[Message], typing.Awaitable[None]]"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "ASGIApp = typing.Callable[[Scope, Receive, Send], typing.Awaitable[None]]"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "StatelessLifespan = typing.Callable[[AppType], typing.AsyncContextManager[None]]\nStatefulLifespan = typing.Callable[[AppType], typing.AsyncContextManager[typing.Mapping[str, typing.Any]]]\nLifespan = typing.Union[StatelessLifespan[AppType], StatefulLifespan[AppType]]"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/starlette/starlette/types.py",
      "content": "HTTPExceptionHandler = typing.Callable[[\"Request\", Exception], \"Response | typing.Awaitable[Response]\"]\nWebSocketExceptionHandler = typing.Callable[[\"WebSocket\", Exception], typing.Awaitable[None]]\nExceptionHandler = typing.Union[HTTPExceptionHandler, WebSocketExceptionHandler]"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/starlette/starlette/applications.py",
      "content": "from __future__ import annotations\n\nimport sys\nimport typing\nimport warnings\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nfrom starlette.datastructures import State, URLPath\nfrom starlette.middleware import Middleware, _MiddlewareFactory\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.errors import ServerErrorMiddleware\nfrom starlette.middleware.exceptions import ExceptionMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import BaseRoute, Router\nfrom starlette.types import ASGIApp, ExceptionHandler, Lifespan, Receive, Scope, Send\nfrom starlette.websockets import WebSocket"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/starlette/starlette/applications.py",
      "content": "class Starlette:\n    \"\"\"Creates an Starlette application.\"\"\"\n\n    def __init__(\n        self: AppType,\n        debug: bool = False,\n        routes: typing.Sequence[BaseRoute] | None = None,\n        middleware: typing.Sequence[Middleware] | None = None,\n        exception_handlers: typing.Mapping[typing.Any, ExceptionHandler] | None = None,\n        on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n        on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n        lifespan: Lifespan[AppType] | None = None,\n    ) -> None:\n        \"\"\"Initializes the application.\n\n        Parameters:\n            debug: Boolean indicating if debug tracebacks should be returned on errors.\n            routes: A list of routes to serve incoming HTTP and WebSocket requests.\n            middleware: A list of middleware to run for every request. A starlette\n                application will always automatically include two middleware classes.\n                `ServerErrorMiddleware` is added as the very outermost middleware, to handle\n                any uncaught errors occurring anywhere in the entire stack.\n                `ExceptionMiddleware` is added as the very innermost middleware, to deal\n                with handled exception cases occurring in the routing or endpoints.\n            exception_handlers: A mapping of either integer status codes,\n                or exception class types onto callables which handle the exceptions.\n                Exception handler callables should be of the form\n                `handler(request, exc) -> response` and may be either standard functions, or\n                async functions.\n            on_startup: A list of callables to run on application startup.\n                Startup handler callables do not take any arguments, and may be either\n                standard functions, or async functions.\n            on_shutdown: A list of callables to run on application shutdown.\n                Shutdown handler callables do not take any arguments, and may be either\n                standard functions, or async functions.\n            lifespan: A lifespan context function, which can be used to perform\n                startup and shutdown tasks. This is a newer style that replaces the\n                `on_startup` and `on_shutdown` handlers. Use one or the other, not both.\n        \"\"\"\n        # The lifespan context function is a newer style that replaces\n        # on_startup / on_shutdown handlers. Use one or the other, not both.\n        assert lifespan is None or (\n            on_startup is None and on_shutdown is None\n        ), \"Use either 'lifespan' or 'on_startup'/'on_shutdown', not both.\"\n\n        self.debug = debug\n        self.state = State()\n        self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)\n        self.exception_handlers = {} if exception_handlers is None else dict(exception_handlers)\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack: ASGIApp | None = None\n\n    def build_middleware_stack(self) -> ASGIApp:\n        debug = self.debug\n        error_handler = None\n        exception_handlers: dict[typing.Any, typing.Callable[[Request, Exception], Response]] = {}\n\n        for key, value in self.exception_handlers.items():\n            if key in (500, Exception):\n                error_handler = value\n            else:\n                exception_handlers[key] = value\n\n        middleware = (\n            [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]\n            + self.user_middleware\n            + [Middleware(ExceptionMiddleware, handlers=exception_handlers, debug=debug)]\n        )\n\n        app = self.router\n        for cls, args, kwargs in reversed(middleware):\n            app = cls(app, *args, **kwargs)\n        return app\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return self.router.routes\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        return self.router.url_path_for(name, **path_params)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        scope[\"app\"] = self\n        if self.middleware_stack is None:\n            self.middleware_stack = self.build_middleware_stack()\n        await self.middleware_stack(scope, receive, send)\n\n    def on_event(self, event_type: str) -> typing.Callable:  # type: ignore[type-arg]\n        return self.router.on_event(event_type)  # pragma: no cover\n\n    def mount(self, path: str, app: ASGIApp, name: str | None = None) -> None:\n        self.router.mount(path, app=app, name=name)  # pragma: no cover\n\n    def host(self, host: str, app: ASGIApp, name: str | None = None) -> None:\n        self.router.host(host, app=app, name=name)  # pragma: no cover\n\n    def add_middleware(\n        self,\n        middleware_class: _MiddlewareFactory[P],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> None:\n        if self.middleware_stack is not None:  # pragma: no cover\n            raise RuntimeError(\"Cannot add middleware after an application has started\")\n        self.user_middleware.insert(0, Middleware(middleware_class, *args, **kwargs))\n\n    def add_exception_handler(\n        self,\n        exc_class_or_status_code: int | type[Exception],\n        handler: ExceptionHandler,\n    ) -> None:  # pragma: no cover\n        self.exception_handlers[exc_class_or_status_code] = handler\n\n    def add_event_handler(\n        self,\n        event_type: str,\n        func: typing.Callable,  # type: ignore[type-arg]\n    ) -> None:  # pragma: no cover\n        self.router.add_event_handler(event_type, func)\n\n    def add_route(\n        self,\n        path: str,\n        route: typing.Callable[[Request], typing.Awaitable[Response] | Response],\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> None:  # pragma: no cover\n        self.router.add_route(path, route, methods=methods, name=name, include_in_schema=include_in_schema)\n\n    def add_websocket_route(\n        self,\n        path: str,\n        route: typing.Callable[[WebSocket], typing.Awaitable[None]],\n        name: str | None = None,\n    ) -> None:  # pragma: no cover\n        self.router.add_websocket_route(path, route, name=name)\n\n    def exception_handler(self, exc_class_or_status_code: int | type[Exception]) -> typing.Callable:  # type: ignore[type-arg]\n        warnings.warn(\n            \"The `exception_handler` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/exceptions/ for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.add_exception_handler(exc_class_or_status_code, func)\n            return func\n\n        return decorator\n\n    def route(\n        self,\n        path: str,\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> typing.Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [Route(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `route` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/routing/ for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.router.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator\n\n    def websocket_route(self, path: str, name: str | None = None) -> typing.Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [WebSocketRoute(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/routing/#websocket-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.router.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def middleware(self, middleware_type: str) -> typing.Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> middleware = [Middleware(...), ...]\n        >>> app = Starlette(middleware=middleware)\n        \"\"\"\n        warnings.warn(\n            \"The `middleware` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/middleware/#using-middleware for recommended approach.\",\n            DeprecationWarning,\n        )\n        assert middleware_type == \"http\", 'Currently only middleware(\"http\") is supported.'\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.add_middleware(BaseHTTPMiddleware, dispatch=func)\n            return func\n\n        return decorator"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/starlette/starlette/templating.py",
      "content": "from __future__ import annotations\n\nimport typing\nimport warnings\nfrom os import PathLike\n\nfrom starlette.background import BackgroundTask\nfrom starlette.datastructures import URL\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse\nfrom starlette.types import Receive, Scope, Send\n\ntry:\n    import jinja2\n\n    if hasattr(jinja2, \"pass_context\"):\n        pass_context = jinja2.pass_context\n    else:  # pragma: no cover\n        pass_context = jinja2.contextfunction  # type: ignore[attr-defined]\nexcept ModuleNotFoundError:  # pragma: no cover\n    jinja2 = None  # type: ignore[assignment]"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/starlette/starlette/templating.py",
      "content": "class _TemplateResponse(HTMLResponse):\n    def __init__(\n        self,\n        template: typing.Any,\n        context: dict[str, typing.Any],\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ):\n        self.template = template\n        self.context = context\n        content = template.render(context)\n        super().__init__(content, status_code, headers, media_type, background)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        request = self.context.get(\"request\", {})\n        extensions = request.get(\"extensions\", {})\n        if \"http.response.debug\" in extensions:  # pragma: no branch\n            await send(\n                {\n                    \"type\": \"http.response.debug\",\n                    \"info\": {\n                        \"template\": self.template,\n                        \"context\": self.context,\n                    },\n                }\n            )\n        await super().__call__(scope, receive, send)"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/starlette/starlette/templating.py",
      "content": "class Jinja2Templates:\n    \"\"\"\n    templates = Jinja2Templates(\"templates\")\n\n    return templates.TemplateResponse(\"index.html\", {\"request\": request})\n    \"\"\"\n\n    @typing.overload\n    def __init__(\n        self,\n        directory: str | PathLike[str] | typing.Sequence[str | PathLike[str]],\n        *,\n        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]] | None = None,\n        **env_options: typing.Any,\n    ) -> None: ...\n\n    @typing.overload\n    def __init__(\n        self,\n        *,\n        env: jinja2.Environment,\n        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]] | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        directory: str | PathLike[str] | typing.Sequence[str | PathLike[str]] | None = None,\n        *,\n        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]] | None = None,\n        env: jinja2.Environment | None = None,\n        **env_options: typing.Any,\n    ) -> None:\n        if env_options:\n            warnings.warn(\n                \"Extra environment options are deprecated. Use a preconfigured jinja2.Environment instead.\",\n                DeprecationWarning,\n            )\n        assert jinja2 is not None, \"jinja2 must be installed to use Jinja2Templates\"\n        assert bool(directory) ^ bool(env), \"either 'directory' or 'env' arguments must be passed\"\n        self.context_processors = context_processors or []\n        if directory is not None:\n            self.env = self._create_env(directory, **env_options)\n        elif env is not None:  # pragma: no branch\n            self.env = env\n\n        self._setup_env_defaults(self.env)\n\n    def _create_env(\n        self,\n        directory: str | PathLike[str] | typing.Sequence[str | PathLike[str]],\n        **env_options: typing.Any,\n    ) -> jinja2.Environment:\n        loader = jinja2.FileSystemLoader(directory)\n        env_options.setdefault(\"loader\", loader)\n        env_options.setdefault(\"autoescape\", True)\n\n        return jinja2.Environment(**env_options)\n\n    def _setup_env_defaults(self, env: jinja2.Environment) -> None:\n        @pass_context\n        def url_for(\n            context: dict[str, typing.Any],\n            name: str,\n            /,\n            **path_params: typing.Any,\n        ) -> URL:\n            request: Request = context[\"request\"]\n            return request.url_for(name, **path_params)\n\n        env.globals.setdefault(\"url_for\", url_for)\n\n    def get_template(self, name: str) -> jinja2.Template:\n        return self.env.get_template(name)\n\n    @typing.overload\n    def TemplateResponse(\n        self,\n        request: Request,\n        name: str,\n        context: dict[str, typing.Any] | None = None,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ) -> _TemplateResponse: ...\n\n    @typing.overload\n    def TemplateResponse(\n        self,\n        name: str,\n        context: dict[str, typing.Any] | None = None,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ) -> _TemplateResponse:\n        # Deprecated usage\n        ...\n\n    def TemplateResponse(self, *args: typing.Any, **kwargs: typing.Any) -> _TemplateResponse:\n        if args:\n            if isinstance(args[0], str):  # the first argument is template name (old style)\n                warnings.warn(\n                    \"The `name` is not the first parameter anymore. \"\n                    \"The first parameter should be the `Request` instance.\\n\"\n                    'Replace `TemplateResponse(name, {\"request\": request})` by `TemplateResponse(request, name)`.',\n                    DeprecationWarning,\n                )\n\n                name = args[0]\n                context = args[1] if len(args) > 1 else kwargs.get(\"context\", {})\n                status_code = args[2] if len(args) > 2 else kwargs.get(\"status_code\", 200)\n                headers = args[2] if len(args) > 2 else kwargs.get(\"headers\")\n                media_type = args[3] if len(args) > 3 else kwargs.get(\"media_type\")\n                background = args[4] if len(args) > 4 else kwargs.get(\"background\")\n\n                if \"request\" not in context:\n                    raise ValueError('context must include a \"request\" key')\n                request = context[\"request\"]\n            else:  # the first argument is a request instance (new style)\n                request = args[0]\n                name = args[1] if len(args) > 1 else kwargs[\"name\"]\n                context = args[2] if len(args) > 2 else kwargs.get(\"context\", {})\n                status_code = args[3] if len(args) > 3 else kwargs.get(\"status_code\", 200)\n                headers = args[4] if len(args) > 4 else kwargs.get(\"headers\")\n                media_type = args[5] if len(args) > 5 else kwargs.get(\"media_type\")\n                background = args[6] if len(args) > 6 else kwargs.get(\"background\")\n        else:  # all arguments are kwargs\n            if \"request\" not in kwargs:\n                warnings.warn(\n                    \"The `TemplateResponse` now requires the `request` argument.\\n\"\n                    'Replace `TemplateResponse(name, {\"context\": context})` by `TemplateResponse(request, name)`.',\n                    DeprecationWarning,\n                )\n                if \"request\" not in kwargs.get(\"context\", {}):\n                    raise ValueError('context must include a \"request\" key')\n\n            context = kwargs.get(\"context\", {})\n            request = kwargs.get(\"request\", context.get(\"request\"))\n            name = typing.cast(str, kwargs[\"name\"])\n            status_code = kwargs.get(\"status_code\", 200)\n            headers = kwargs.get(\"headers\")\n            media_type = kwargs.get(\"media_type\")\n            background = kwargs.get(\"background\")\n\n        context.setdefault(\"request\", request)\n        for context_processor in self.context_processors:\n            context.update(context_processor(request))\n\n        template = self.get_template(name)\n        return _TemplateResponse(\n            template,\n            context,\n            status_code=status_code,\n            headers=headers,\n            media_type=media_type,\n            background=background,\n        )"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "from __future__ import annotations\n\nimport functools\nimport inspect\nimport sys\nimport typing\nfrom urllib.parse import urlencode\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nfrom starlette._utils import is_async_callable\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import HTTPConnection, Request\nfrom starlette.responses import RedirectResponse\nfrom starlette.websockets import WebSocket\n\n_P = ParamSpec(\"_P\")"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "def has_required_scope(conn: HTTPConnection, scopes: typing.Sequence[str]) -> bool:\n    for scope in scopes:\n        if scope not in conn.auth.scopes:\n            return False\n    return True"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "def requires(\n    scopes: str | typing.Sequence[str],\n    status_code: int = 403,\n    redirect: str | None = None,\n) -> typing.Callable[[typing.Callable[_P, typing.Any]], typing.Callable[_P, typing.Any]]:\n    scopes_list = [scopes] if isinstance(scopes, str) else list(scopes)\n\n    def decorator(\n        func: typing.Callable[_P, typing.Any],\n    ) -> typing.Callable[_P, typing.Any]:\n        sig = inspect.signature(func)\n        for idx, parameter in enumerate(sig.parameters.values()):\n            if parameter.name == \"request\" or parameter.name == \"websocket\":\n                type_ = parameter.name\n                break\n        else:\n            raise Exception(f'No \"request\" or \"websocket\" argument on function \"{func}\"')\n\n        if type_ == \"websocket\":\n            # Handle websocket functions. (Always async)\n            @functools.wraps(func)\n            async def websocket_wrapper(*args: _P.args, **kwargs: _P.kwargs) -> None:\n                websocket = kwargs.get(\"websocket\", args[idx] if idx < len(args) else None)\n                assert isinstance(websocket, WebSocket)\n\n                if not has_required_scope(websocket, scopes_list):\n                    await websocket.close()\n                else:\n                    await func(*args, **kwargs)\n\n            return websocket_wrapper\n\n        elif is_async_callable(func):\n            # Handle async request/response functions.\n            @functools.wraps(func)\n            async def async_wrapper(*args: _P.args, **kwargs: _P.kwargs) -> typing.Any:\n                request = kwargs.get(\"request\", args[idx] if idx < len(args) else None)\n                assert isinstance(request, Request)\n\n                if not has_required_scope(request, scopes_list):\n                    if redirect is not None:\n                        orig_request_qparam = urlencode({\"next\": str(request.url)})\n                        next_url = f\"{request.url_for(redirect)}?{orig_request_qparam}\"\n                        return RedirectResponse(url=next_url, status_code=303)\n                    raise HTTPException(status_code=status_code)\n                return await func(*args, **kwargs)\n\n            return async_wrapper\n\n        else:\n            # Handle sync request/response functions.\n            @functools.wraps(func)\n            def sync_wrapper(*args: _P.args, **kwargs: _P.kwargs) -> typing.Any:\n                request = kwargs.get(\"request\", args[idx] if idx < len(args) else None)\n                assert isinstance(request, Request)\n\n                if not has_required_scope(request, scopes_list):\n                    if redirect is not None:\n                        orig_request_qparam = urlencode({\"next\": str(request.url)})\n                        next_url = f\"{request.url_for(redirect)}?{orig_request_qparam}\"\n                        return RedirectResponse(url=next_url, status_code=303)\n                    raise HTTPException(status_code=status_code)\n                return func(*args, **kwargs)\n\n            return sync_wrapper\n\n    return decorator"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class AuthenticationError(Exception):\n    pass"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class AuthenticationBackend:\n    async def authenticate(self, conn: HTTPConnection) -> tuple[AuthCredentials, BaseUser] | None:\n        raise NotImplementedError()  # pragma: no cover"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class AuthCredentials:\n    def __init__(self, scopes: typing.Sequence[str] | None = None):\n        self.scopes = [] if scopes is None else list(scopes)"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class BaseUser:\n    @property\n    def is_authenticated(self) -> bool:\n        raise NotImplementedError()  # pragma: no cover\n\n    @property\n    def display_name(self) -> str:\n        raise NotImplementedError()  # pragma: no cover\n\n    @property\n    def identity(self) -> str:\n        raise NotImplementedError()  # pragma: no cover"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class SimpleUser(BaseUser):\n    def __init__(self, username: str) -> None:\n        self.username = username\n\n    @property\n    def is_authenticated(self) -> bool:\n        return True\n\n    @property\n    def display_name(self) -> str:\n        return self.username"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/starlette/starlette/authentication.py",
      "content": "class UnauthenticatedUser(BaseUser):\n    @property\n    def is_authenticated(self) -> bool:\n        return False\n\n    @property\n    def display_name(self) -> str:\n        return \"\""
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/starlette/starlette/endpoints.py",
      "content": "from __future__ import annotations\n\nimport json\nimport typing\n\nfrom starlette import status\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import Message, Receive, Scope, Send\nfrom starlette.websockets import WebSocket"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/starlette/starlette/endpoints.py",
      "content": "class HTTPEndpoint:\n    def __init__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] == \"http\"\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n        self._allowed_methods = [\n            method\n            for method in (\"GET\", \"HEAD\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\")\n            if getattr(self, method.lower(), None) is not None\n        ]\n\n    def __await__(self) -> typing.Generator[typing.Any, None, None]:\n        return self.dispatch().__await__()\n\n    async def dispatch(self) -> None:\n        request = Request(self.scope, receive=self.receive)\n        handler_name = \"get\" if request.method == \"HEAD\" and not hasattr(self, \"head\") else request.method.lower()\n\n        handler: typing.Callable[[Request], typing.Any] = getattr(self, handler_name, self.method_not_allowed)\n        is_async = is_async_callable(handler)\n        if is_async:\n            response = await handler(request)\n        else:\n            response = await run_in_threadpool(handler, request)\n        await response(self.scope, self.receive, self.send)\n\n    async def method_not_allowed(self, request: Request) -> Response:\n        headers = {\"Allow\": \", \".join(self._allowed_methods)}\n        if \"app\" in self.scope:\n            raise HTTPException(status_code=405, headers=headers)\n        return PlainTextResponse(\"Method Not Allowed\", status_code=405, headers=headers)"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/starlette/starlette/endpoints.py",
      "content": "class WebSocketEndpoint:\n    encoding: str | None = None  # May be \"text\", \"bytes\", or \"json\".\n\n    def __init__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] == \"websocket\"\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n\n    def __await__(self) -> typing.Generator[typing.Any, None, None]:\n        return self.dispatch().__await__()\n\n    async def dispatch(self) -> None:\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        await self.on_connect(websocket)\n\n        close_code = status.WS_1000_NORMAL_CLOSURE\n\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":  # pragma: no branch\n                    close_code = int(message.get(\"code\") or status.WS_1000_NORMAL_CLOSURE)\n                    break\n        except Exception as exc:\n            close_code = status.WS_1011_INTERNAL_ERROR\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n\n    async def decode(self, websocket: WebSocket, message: Message) -> typing.Any:\n        if self.encoding == \"text\":\n            if \"text\" not in message:\n                await websocket.close(code=status.WS_1003_UNSUPPORTED_DATA)\n                raise RuntimeError(\"Expected text websocket messages, but got bytes\")\n            return message[\"text\"]\n\n        elif self.encoding == \"bytes\":\n            if \"bytes\" not in message:\n                await websocket.close(code=status.WS_1003_UNSUPPORTED_DATA)\n                raise RuntimeError(\"Expected bytes websocket messages, but got text\")\n            return message[\"bytes\"]\n\n        elif self.encoding == \"json\":\n            if message.get(\"text\") is not None:\n                text = message[\"text\"]\n            else:\n                text = message[\"bytes\"].decode(\"utf-8\")\n\n            try:\n                return json.loads(text)\n            except json.decoder.JSONDecodeError:\n                await websocket.close(code=status.WS_1003_UNSUPPORTED_DATA)\n                raise RuntimeError(\"Malformed JSON data received.\")\n\n        assert self.encoding is None, f\"Unsupported 'encoding' attribute {self.encoding}\"\n        return message[\"text\"] if message.get(\"text\") else message[\"bytes\"]\n\n    async def on_connect(self, websocket: WebSocket) -> None:\n        \"\"\"Override to handle an incoming websocket connection\"\"\"\n        await websocket.accept()\n\n    async def on_receive(self, websocket: WebSocket, data: typing.Any) -> None:\n        \"\"\"Override to handle an incoming websocket message\"\"\"\n\n    async def on_disconnect(self, websocket: WebSocket, close_code: int) -> None:\n        \"\"\"Override to handle a disconnecting websocket\"\"\""
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/starlette/starlette/_exception_handler.py",
      "content": "from __future__ import annotations\n\nimport typing\n\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.types import ASGIApp, ExceptionHandler, Message, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n\nExceptionHandlers = dict[typing.Any, ExceptionHandler]\nStatusHandlers = dict[int, ExceptionHandler]"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/starlette/starlette/_exception_handler.py",
      "content": "def _lookup_exception_handler(exc_handlers: ExceptionHandlers, exc: Exception) -> ExceptionHandler | None:\n    for cls in type(exc).__mro__:\n        if cls in exc_handlers:\n            return exc_handlers[cls]\n    return None"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/starlette/starlette/_exception_handler.py",
      "content": "def wrap_app_handling_exceptions(app: ASGIApp, conn: Request | WebSocket) -> ASGIApp:\n    exception_handlers: ExceptionHandlers\n    status_handlers: StatusHandlers\n    try:\n        exception_handlers, status_handlers = conn.scope[\"starlette.exception_handlers\"]\n    except KeyError:\n        exception_handlers, status_handlers = {}, {}\n\n    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n        response_started = False\n\n        async def sender(message: Message) -> None:\n            nonlocal response_started\n\n            if message[\"type\"] == \"http.response.start\":\n                response_started = True\n            await send(message)\n\n        try:\n            await app(scope, receive, sender)\n        except Exception as exc:\n            handler = None\n\n            if isinstance(exc, HTTPException):\n                handler = status_handlers.get(exc.status_code)\n\n            if handler is None:\n                handler = _lookup_exception_handler(exception_handlers, exc)\n\n            if handler is None:\n                raise exc\n\n            if response_started:\n                raise RuntimeError(\"Caught handled exception, but response already started.\") from exc\n\n            if is_async_callable(handler):\n                response = await handler(conn, exc)\n            else:\n                response = await run_in_threadpool(handler, conn, exc)  # type: ignore\n            if response is not None:\n                await response(scope, receive, sender)\n\n    return wrapped_app"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/starlette/starlette/status.py",
      "content": "\"\"\"\nHTTP codes\nSee HTTP Status Code Registry:\nhttps://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\nAnd RFC 2324 - https://tools.ietf.org/html/rfc2324\n\"\"\""
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/starlette/starlette/status.py",
      "content": "from __future__ import annotations"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/starlette/starlette/status.py",
      "content": "HTTP_100_CONTINUE = 100\nHTTP_101_SWITCHING_PROTOCOLS = 101\nHTTP_102_PROCESSING = 102\nHTTP_103_EARLY_HINTS = 103\nHTTP_200_OK = 200\nHTTP_201_CREATED = 201\nHTTP_202_ACCEPTED = 202\nHTTP_203_NON_AUTHORITATIVE_INFORMATION = 203\nHTTP_204_NO_CONTENT = 204\nHTTP_205_RESET_CONTENT = 205\nHTTP_206_PARTIAL_CONTENT = 206\nHTTP_207_MULTI_STATUS = 207\nHTTP_208_ALREADY_REPORTED = 208\nHTTP_226_IM_USED = 226\nHTTP_300_MULTIPLE_CHOICES = 300\nHTTP_301_MOVED_PERMANENTLY = 301\nHTTP_302_FOUND = 302\nHTTP_303_SEE_OTHER = 303\nHTTP_304_NOT_MODIFIED = 304\nHTTP_305_USE_PROXY = 305\nHTTP_306_RESERVED = 306\nHTTP_307_TEMPORARY_REDIRECT = 307\nHTTP_308_PERMANENT_REDIRECT = 308\nHTTP_400_BAD_REQUEST = 400\nHTTP_401_UNAUTHORIZED = 401\nHTTP_402_PAYMENT_REQUIRED = 402\nHTTP_403_FORBIDDEN = 403\nHTTP_404_NOT_FOUND = 404\nHTTP_405_METHOD_NOT_ALLOWED = 405\nHTTP_406_NOT_ACCEPTABLE = 406\nHTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407\nHTTP_408_REQUEST_TIMEOUT = 408\nHTTP_409_CONFLICT = 409\nHTTP_410_GONE = 410\nHTTP_411_LENGTH_REQUIRED = 411\nHTTP_412_PRECONDITION_FAILED = 412\nHTTP_413_REQUEST_ENTITY_TOO_LARGE = 413\nHTTP_414_REQUEST_URI_TOO_LONG = 414\nHTTP_415_UNSUPPORTED_MEDIA_TYPE = 415\nHTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = 416\nHTTP_417_EXPECTATION_FAILED = 417\nHTTP_418_IM_A_TEAPOT = 418\nHTTP_421_MISDIRECTED_REQUEST = 421\nHTTP_422_UNPROCESSABLE_ENTITY = 422\nHTTP_423_LOCKED = 423\nHTTP_424_FAILED_DEPENDENCY = 424\nHTTP_425_TOO_EARLY = 425\nHTTP_426_UPGRADE_REQUIRED = 426\nHTTP_428_PRECONDITION_REQUIRED = 428\nHTTP_429_TOO_MANY_REQUESTS = 429\nHTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431\nHTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451\nHTTP_500_INTERNAL_SERVER_ERROR = 500\nHTTP_501_NOT_IMPLEMENTED = 501\nHTTP_502_BAD_GATEWAY = 502\nHTTP_503_SERVICE_UNAVAILABLE = 503\nHTTP_504_GATEWAY_TIMEOUT = 504\nHTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505\nHTTP_506_VARIANT_ALSO_NEGOTIATES = 506\nHTTP_507_INSUFFICIENT_STORAGE = 507\nHTTP_508_LOOP_DETECTED = 508\nHTTP_510_NOT_EXTENDED = 510\nHTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/starlette/starlette/status.py",
      "content": "\"\"\"\nWebSocket codes\nhttps://www.iana.org/assignments/websocket/websocket.xml#close-code-number\nhttps://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n\"\"\""
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/starlette/starlette/status.py",
      "content": "WS_1000_NORMAL_CLOSURE = 1000\nWS_1001_GOING_AWAY = 1001\nWS_1002_PROTOCOL_ERROR = 1002\nWS_1003_UNSUPPORTED_DATA = 1003\nWS_1005_NO_STATUS_RCVD = 1005\nWS_1006_ABNORMAL_CLOSURE = 1006\nWS_1007_INVALID_FRAME_PAYLOAD_DATA = 1007\nWS_1008_POLICY_VIOLATION = 1008\nWS_1009_MESSAGE_TOO_BIG = 1009\nWS_1010_MANDATORY_EXT = 1010\nWS_1011_INTERNAL_ERROR = 1011\nWS_1012_SERVICE_RESTART = 1012\nWS_1013_TRY_AGAIN_LATER = 1013\nWS_1014_BAD_GATEWAY = 1014\nWS_1015_TLS_HANDSHAKE = 1015"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "```python"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "from __future__ import annotations\n\nimport contextlib\nimport functools\nimport inspect\nimport re\nimport traceback\nimport types\nimport typing\nimport warnings\nfrom contextlib import asynccontextmanager\nfrom enum import Enum\n\nfrom starlette._exception_handler import wrap_app_handling_exceptions\nfrom starlette._utils import get_route_path, is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.convertors import CONVERTOR_TYPES, Convertor\nfrom starlette.datastructures import URL, Headers, URLPath\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, RedirectResponse, Response\nfrom starlette.types import ASGIApp, Lifespan, Receive, Scope, Send\nfrom starlette.websockets import WebSocket, WebSocketClose"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class NoMatchFound(Exception):\n    \"\"\"\n    Raised by `.url_for(name, **path_params)` and `.url_path_for(name, **path_params)`\n    if no matching route exists.\n    \"\"\"\n\n    def __init__(self, name: str, path_params: dict[str, typing.Any]) -> None:\n        params = \", \".join(list(path_params.keys()))\n        super().__init__(f'No route exists for name \"{name}\" and params \"{params}\".')"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class Match(Enum):\n    NONE = 0\n    PARTIAL = 1\n    FULL = 2"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def iscoroutinefunction_or_partial(obj: typing.Any) -> bool:  # pragma: no cover\n    \"\"\"\n    Correctly determines if an object is a coroutine function,\n    including those wrapped in functools.partial objects.\n    \"\"\"\n    warnings.warn(\n        \"iscoroutinefunction_or_partial is deprecated, and will be removed in a future release.\",\n        DeprecationWarning,\n    )\n    while isinstance(obj, functools.partial):\n        obj = obj.func\n    return inspect.iscoroutinefunction(obj)"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def request_response(\n    func: typing.Callable[[Request], typing.Awaitable[Response] | Response],\n) -> ASGIApp:\n    \"\"\"\n    Takes a function or coroutine `func(request) -> response`,\n    and returns an ASGI application.\n    \"\"\"\n    f: typing.Callable[[Request], typing.Awaitable[Response]] = (\n        func if is_async_callable(func) else functools.partial(run_in_threadpool, func)  # type:ignore\n    )\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive, send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            response = await f(request)\n            await response(scope, receive, send)\n\n        await wrap_app_handling_exceptions(app, request)(scope, receive, send)\n\n    return app"
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def websocket_session(\n    func: typing.Callable[[WebSocket], typing.Awaitable[None]],\n) -> ASGIApp:\n    \"\"\"\n    Takes a coroutine `func(session)`, and returns an ASGI application.\n    \"\"\"\n    # assert asyncio.iscoroutinefunction(func), \"WebSocket endpoints must be async\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        session = WebSocket(scope, receive=receive, send=send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            await func(session)\n\n        await wrap_app_handling_exceptions(app, session)(scope, receive, send)\n\n    return app"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def get_name(endpoint: typing.Callable[..., typing.Any]) -> str:\n    return getattr(endpoint, \"__name__\", endpoint.__class__.__name__)"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def replace_params(\n    path: str,\n    param_convertors: dict[str, Convertor[typing.Any]],\n    path_params: dict[str, str],\n) -> tuple[str, dict[str, str]]:\n    for key, value in list(path_params.items()):\n        if \"{\" + key + \"}\" in path:\n            convertor = param_convertors[key]\n            value = convertor.to_string(value)\n            path = path.replace(\"{\" + key + \"}\", value)\n            path_params.pop(key)\n    return path, path_params"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "PARAM_REGEX = re.compile(\"{([a-zA-Z_][a-zA-Z0-9_]*)(:[a-zA-Z_][a-zA-Z0-9_]*)?}\")"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def compile_path(\n    path: str,\n) -> tuple[typing.Pattern[str], str, dict[str, Convertor[typing.Any]]]:\n    \"\"\"\n    Given a path string, like: \"/{username:str}\",\n    or a host string, like: \"{subdomain}.mydomain.org\", return a three-tuple\n    of (regex, format, {param_name:convertor}).\n    \"\"\"\n    is_host = not path.startswith(\"/\")\n\n    path_regex = \"^\"\n    path_format = \"\"\n    duplicated_params = set()\n\n    idx = 0\n    param_convertors = {}\n    for match in PARAM_REGEX.finditer(path):\n        param_name, convertor_type = match.groups(\"str\")\n        convertor_type = convertor_type.lstrip(\":\")\n        assert convertor_type in CONVERTOR_TYPES, f\"Unknown path convertor '{convertor_type}'\"\n        convertor = CONVERTOR_TYPES[convertor_type]\n\n        path_regex += re.escape(path[idx : match.start()])\n        path_regex += f\"(?P<{param_name}>{convertor.regex})\"\n\n        path_format += path[idx : match.start()]\n        path_format += \"{%s}\" % param_name\n\n        if param_name in param_convertors:\n            duplicated_params.add(param_name)\n\n        param_convertors[param_name] = convertor\n\n        idx = match.end()\n\n    if duplicated_params:\n        names = \", \".join(sorted(duplicated_params))\n        ending = \"s\" if len(duplicated_params) > 1 else \"\"\n        raise ValueError(f\"Duplicated param name{ending} {names} at path {path}\")\n\n    if is_host:\n        hostname = path[idx:].split(\":\")[0]\n        path_regex += re.escape(hostname) + \"$\"\n    else:\n        path_regex += re.escape(path[idx:]) + \"$\"\n\n    path_format += path[idx:]\n\n    return re.compile(path_regex), path_format, param_convertors"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class BaseRoute:\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        raise NotImplementedError()  # pragma: no cover\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        raise NotImplementedError()  # pragma: no cover\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        raise NotImplementedError()  # pragma: no cover\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        A route may be used in isolation as a stand-alone ASGI app.\n        This is a somewhat contrived case, as they'll almost always be used\n        within a Router, but could be useful for some tooling and minimal apps.\n        \"\"\"\n        match, child_scope = self.matches(scope)\n        if match == Match.NONE:\n            if scope[\"type\"] == \"http\":\n                response = PlainTextResponse(\"Not Found\", status_code=404)\n                await response(scope, receive, send)\n            elif scope[\"type\"] == \"websocket\":  # pragma: no branch\n                websocket_close = WebSocketClose()\n                await websocket_close(scope, receive, send)\n            return\n\n        scope.update(child_scope)\n        await self.handle(scope, receive, send)"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class Route(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: typing.Callable[..., typing.Any],\n        *,\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n        middleware: typing.Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.include_in_schema = include_in_schema\n\n        endpoint_handler = endpoint\n        while isinstance(endpoint_handler, functools.partial):\n            endpoint_handler = endpoint_handler.func\n        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):\n            self.app = request_response(endpoint)\n            if methods is None:\n                methods = [\"GET\"]\n        else:\n            self.app = endpoint\n\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n\n        if methods is None:\n            self.methods = None\n        else:\n            self.methods = {method.upper() for method in methods}\n            if \"GET\" in self.methods:\n                self.methods.add(\"HEAD\")\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, typing.Any]\n        if scope[\"type\"] == \"http\":\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"endpoint\": self.endpoint, \"path_params\": path_params}\n                if self.methods and scope[\"method\"] not in self.methods:\n                    return Match.PARTIAL, child_scope\n                else:\n                    return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        seen_params = set(path_params.keys())\n        expected_params = set(self.param_convertors.keys())\n\n        if name != self.name or seen_params != expected_params:\n            raise NoMatchFound(name, path_params)\n\n        path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n        assert not remaining_params\n        return URLPath(path=path, protocol=\"http\")\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.methods and scope[\"method\"] not in self.methods:\n            headers = {\"Allow\": \", \".join(self.methods)}\n            if \"app\" in scope:\n                raise HTTPException(status_code=405, headers=headers)\n            else:\n                response = PlainTextResponse(\"Method Not Allowed\", status_code=405, headers=headers)\n            await response(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return (\n            isinstance(other, Route)\n            and self.path == other.path\n            and self.endpoint == other.endpoint\n            and self.methods == other.methods\n        )\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        methods = sorted(self.methods or [])\n        path, name = self.path, self.name\n        return f\"{class_name}(path={path!r}, name={name!r}, methods={methods!r})\""
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class WebSocketRoute(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: typing.Callable[..., typing.Any],\n        *,\n        name: str | None = None,\n        middleware: typing.Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n\n        endpoint_handler = endpoint\n        while isinstance(endpoint_handler, functools.partial):\n            endpoint_handler = endpoint_handler.func\n        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):\n            self.app = websocket_session(endpoint)\n        else:\n            self.app = endpoint\n\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, typing.Any]\n        if scope[\"type\"] == \"websocket\":\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"endpoint\": self.endpoint, \"path_params\": path_params}\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        seen_params = set(path_params.keys())\n        expected_params = set(self.param_convertors.keys())\n\n        if name != self.name or seen_params != expected_params:\n            raise NoMatchFound(name, path_params)\n\n        path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n        assert not remaining_params\n        return URLPath(path=path, protocol=\"websocket\")\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, WebSocketRoute) and self.path == other.path and self.endpoint == other.endpoint\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}(path={self.path!r}, name={self.name!r})\""
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class Mount(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        app: ASGIApp | None = None,\n        routes: typing.Sequence[BaseRoute] | None = None,\n        name: str | None = None,\n        *,\n        middleware: typing.Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path == \"\" or path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        assert app is not None or routes is not None, \"Either 'app=...', or 'routes=' must be specified\"\n        self.path = path.rstrip(\"/\")\n        if app is not None:\n            self._base_app: ASGIApp = app\n        else:\n            self._base_app = Router(routes=routes)\n        self.app = self._base_app\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n        self.name = name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(self.path + \"/{path:path}\")\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return getattr(self._base_app, \"routes\", [])\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, typing.Any]\n        if scope[\"type\"] in (\"http\", \"websocket\"):  # pragma: no branch\n            root_path = scope.get(\"root_path\", \"\")\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                remaining_path = \"/\" + matched_params.pop(\"path\")\n                matched_path = route_path[: -len(remaining_path)]\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\n                    \"path_params\": path_params,\n                    \"app_root_path\": scope.get(\"app_root_path\", root_path),\n                    \"root_path\": root_path + matched_path,\n                    \"endpoint\": self.app,\n                }\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        if self.name is not None and name == self.name and \"path\" in path_params:\n            path_params[\"path\"] = path_params[\"path\"].lstrip(\"/\")\n            path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n            if not remaining_params:\n                return URLPath(path=path)\n        elif self.name is None or name.startswith(self.name + \":\"):\n            if self.name is None:\n                remaining_name = name\n            else:\n                remaining_name = name[len(self.name) + 1 :]\n            path_kwarg = path_params.get(\"path\")\n            path_params[\"path\"] = \"\"\n            path_prefix, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n            if path_kwarg is not None:\n                remaining_params[\"path\"] = path_kwarg\n            for route in self.routes or []:\n                try:\n                    url = route.url_path_for(remaining_name, **remaining_params)\n                    return URLPath(path=path_prefix.rstrip(\"/\") + str(url), protocol=url.protocol)\n                except NoMatchFound:\n                    pass\n        raise NoMatchFound(name, path_params)\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, Mount) and self.path == other.path and self.app == other.app\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        name = self.name or \"\"\n        return f\"{class_name}(path={self.path!r}, name={name!r}, app={self.app!r})\""
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class Host(BaseRoute):\n    def __init__(self, host: str, app: ASGIApp, name: str | None = None) -> None:\n        assert not host.startswith(\"/\"), \"Host must not start with '/'\"\n        self.host = host\n        self.app = app\n        self.name = name\n        self.host_regex, self.host_format, self.param_convertors = compile_path(host)\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return getattr(self.app, \"routes\", [])\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        if scope[\"type\"] in (\"http\", \"websocket\"):  # pragma:no branch\n            headers = Headers(scope=scope)\n            host = headers.get(\"host\", \"\").split(\":\")[0]\n            match = self.host_regex.match(host)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"path_params\": path_params, \"endpoint\": self.app}\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        if self.name is not None and name == self.name and \"path\" in path_params:\n            path = path_params.pop(\"path\")\n            host, remaining_params = replace_params(self.host_format, self.param_convertors, path_params)\n            if not remaining_params:\n                return URLPath(path=path, host=host)\n        elif self.name is None or name.startswith(self.name + \":\"):\n            if self.name is None:\n                remaining_name = name\n            else:\n                remaining_name = name[len(self.name) + 1 :]\n            host, remaining_params = replace_params(self.host_format, self.param_convertors, path_params)\n            for route in self.routes or []:\n                try:\n                    url = route.url_path_for(remaining_name, **remaining_params)\n                    return URLPath(path=str(url), protocol=url.protocol, host=host)\n                except NoMatchFound:\n                    pass\n        raise NoMatchFound(name, path_params)\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, Host) and self.host == other.host and self.app == other.app\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        name = self.name or \"\"\n        return f\"{class_name}(host={self.host!r}, name={name!r}, app={self.app!r})\""
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "_T = typing.TypeVar(\"_T\")\n\nclass _AsyncLiftContextManager(typing.AsyncContextManager[_T]):\n    def __init__(self, cm: typing.ContextManager[_T]):\n        self._cm = cm\n\n    async def __aenter__(self) -> _T:\n        return self._cm.__enter__()\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: types.TracebackType | None,\n    ) -> bool | None:\n        return self._cm.__exit__(exc_type, exc_value, traceback)"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "def _wrap_gen_lifespan_context(\n    lifespan_context: typing.Callable[[typing.Any], typing.Generator[typing.Any, typing.Any, typing.Any]],\n) -> typing.Callable[[typing.Any], typing.AsyncContextManager[typing.Any]]:\n    cmgr = contextlib.contextmanager(lifespan_context)\n\n    @functools.wraps(cmgr)\n    def wrapper(app: typing.Any) -> _AsyncLiftContextManager[typing.Any]:\n        return _AsyncLiftContextManager(cmgr(app))\n\n    return wrapper"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class _DefaultLifespan:\n    def __init__(self, router: Router):\n        self._router = router\n\n    async def __aenter__(self) -> None:\n        await self._router.startup()\n\n    async def __aexit__(self, *exc_info: object) -> None:\n        await self._router.shutdown()\n\n    def __call__(self: _T, app: object) -> _T:\n        return self"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/starlette/starlette/routing.py",
      "content": "class Router:\n    def __init__(\n        self,\n        routes: typing.Sequence[BaseRoute] | None = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp | None = None,\n        on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n        on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n        lifespan: Lifespan[typing.Any] | None = None,\n        *,\n        middleware: typing.Sequence[Middleware] | None = None,\n    ) -> None:\n        self.routes = [] if routes is None else list(routes)\n        self.redirect_slashes = redirect_slashes\n        self.default = self.not_found if default is None else default\n        self.on_startup = [] if on_startup is None else list(on_startup)\n        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)\n\n        if on_startup or on_shutdown:\n            warnings.warn(\n                \"The on_startup and on_shutdown parameters are deprecated, and they \"\n                \"will be removed on version 1.0. Use the lifespan parameter instead. \"\n                \"See more about it on https://www.starlette.io/lifespan/.\",\n                DeprecationWarning,\n            )\n            if lifespan:\n                warnings.warn(\n                    \"The `lifespan` parameter cannot be used with `on_startup` or \"\n                    \"`on_shutdown`. Both `on_startup` and `on_shutdown` will be \"\n                    \"ignored.\"\n                )\n\n        if lifespan is None:\n            self.lifespan_context: Lifespan[typing.Any] = _DefaultLifespan(self)\n\n        elif inspect.isasyncgenfunction(lifespan):\n            warnings.warn(\n                \"async generator function lifespans are deprecated, \"\n                \"use an @contextlib.asynccontextmanager function instead\",\n                DeprecationWarning,\n            )\n            self.lifespan_context = asynccontextmanager(\n                lifespan,\n            )\n        elif inspect.isgeneratorfunction(lifespan):\n            warnings.warn(\n                \"generator function lifespans are deprecated, \"\n                \"use an @contextlib.asynccontextmanager function instead\",\n                DeprecationWarning,\n            )\n            self.lifespan_context = _wrap_gen_lifespan_context(\n                lifespan,\n            )\n        else:\n            self.lifespan_context = lifespan\n\n        self.middleware_stack = self.app\n        if middleware:\n            for cls, args, kwargs in reversed(middleware):\n                self.middleware_stack = cls(self.middleware_stack, *args, **kwargs)\n\n    async def not_found(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] == \"websocket\":\n            websocket_close = WebSocketClose()\n            await websocket_close(scope, receive, send)\n            return\n\n        if \"app\" in scope:\n            raise HTTPException(status_code=404)\n        else:\n            response = PlainTextResponse(\"Not Found\", status_code=404)\n        await response(scope, receive, send)\n\n    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n        raise NoMatchFound(name, path_params)\n\n    async def startup(self) -> None:\n        \"\"\"\n        Run any `.on_startup` event handlers.\n        \"\"\"\n        for handler in self.on_startup:\n            if is_async_callable(handler):\n                await handler()\n            else:\n                handler()\n\n    async def shutdown(self) -> None:\n        \"\"\"\n        Run any `.on_shutdown` event handlers.\n        \"\"\"\n        for handler in self.on_shutdown:\n            if is_async_callable(handler):\n                await handler()\n            else:\n                handler()\n\n    async def lifespan(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Handle ASGI lifespan messages, which allows us to manage application\n        startup and shutdown events.\n        \"\"\"\n        started = False\n        app: typing.Any = scope.get(\"app\")\n        await receive()\n        try:\n            async with self.lifespan_context(app) as maybe_state:\n                if maybe_state is not None:\n                    if \"state\" not in scope:\n                        raise RuntimeError('The server does not support \"state\" in the lifespan scope.')\n                    scope[\"state\"].update(maybe_state)\n                await send({\"type\": \"lifespan.startup.complete\"})\n                started = True\n                await receive()\n        except BaseException:\n            exc_text = traceback.format_exc()\n            if started:\n                await send({\"type\": \"lifespan.shutdown.failed\", \"message\": exc_text})\n            else:\n                await send({\"type\": \"lifespan.startup.failed\", \"message\": exc_text})\n            raise\n        else:\n            await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        The main entry point to the Router class.\n        \"\"\"\n        await self.middleware_stack(scope, receive, send)\n\n    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] in (\"http\", \"websocket\", \"lifespan\")\n\n        if \"router\" not in scope:\n            scope[\"router\"] = self\n\n        if scope[\"type\"] == \"lifespan\":\n            await self.lifespan(scope, receive, send)\n            return\n\n        partial = None\n\n        for route in self.routes:\n            match, child_scope = route.matches(scope)\n            if match == Match.FULL:\n                scope.update(child_scope)\n                await route.handle(scope, receive, send)\n                return\n            elif match == Match.PARTIAL and partial is None:\n                partial = route\n                partial_scope = child_scope\n\n        if partial is not None:\n            scope.update(partial_scope)\n            await partial.handle(scope, receive, send)\n            return\n\n        route_path = get_route_path(scope)\n        if scope[\"type\"] == \"http\" and self.redirect_slashes and route_path != \"/\":\n            redirect_scope = dict(scope)\n            if route_path.endswith(\"/\"):\n                redirect_scope[\"path\"] = redirect_scope[\"path\"].rstrip(\"/\")\n            else:\n                redirect_scope[\"path\"] = redirect_scope[\"path\"] + \"/\"\n\n            for route in self.routes:\n                match, child_scope = route.matches(redirect_scope)\n                if match != Match.NONE:\n                    redirect_url = URL(scope=redirect_scope)\n                    response = RedirectResponse(url=str(redirect_url))\n                    await response(scope, receive, send)\n                    return\n\n        await self.default(scope, receive, send)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, Router) and self.routes == other.routes\n\n    def mount(self, path: str, app: ASGIApp, name: str | None = None) -> None:  # pragma: no cover\n        route = Mount(path, app=app, name=name)\n        self.routes.append(route)\n\n    def host(self, host: str, app: ASGIApp, name: str | None = None) -> None:  # pragma: no cover\n        route = Host(host, app=app, name=name)\n        self.routes.append(route)\n\n    def add_route(\n        self,\n        path: str,\n        endpoint: typing.Callable[[Request], typing.Awaitable[Response] | Response],\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> None:  # pragma: no cover\n        route = Route(\n            path,\n            endpoint=endpoint,\n            methods=methods,\n            name=name,\n            include_in_schema=include_in_schema,\n        )\n        self.routes.append(route)\n\n    def add_websocket_route(\n        self,\n        path: str,\n        endpoint: typing.Callable[[WebSocket], typing.Awaitable[None]],\n        name: str | None = None,\n    ) -> None:  # pragma: no cover\n        route = WebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def route(\n        self,\n        path: str,\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> typing.Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [Route(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `route` decorator is deprecated, and will be removed in version 1.0.0.\"\n            \"Refer to https://www.starlette.io/routing/#http-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator\n\n    def websocket_route(self, path: str, name: str | None = None) -> typing.Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [WebSocketRoute(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. Refer to \"\n            \"https://www.starlette.io/routing/#websocket-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def add_event_handler(self, event_type: str, func: typing.Callable[[], typing.Any]) -> None:  # pragma: no cover\n        assert event_type in (\"startup\", \"shutdown\")\n\n        if event_type == \"startup\":\n            self.on_startup.append(func)\n        else:\n            self.on_shutdown.append(func)\n\n    def on_event(self, event_type: str) -> typing.Callable:  # type: ignore[type-arg]\n        warnings.warn(\n            \"The `on_event` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/lifespan/ for recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]\n            self.add_event_handler(event_type, func)\n            return func\n\n        return decorator\n```"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "from __future__ import annotations\n\nimport typing\nfrom shlex import shlex\nfrom urllib.parse import SplitResult, parse_qsl, urlencode, urlsplit\n\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.types import Scope"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class Address(typing.NamedTuple):\n    host: str\n    port: int"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "_KeyType = typing.TypeVar(\"_KeyType\")\n_CovariantValueType = typing.TypeVar(\"_CovariantValueType\", covariant=True)"
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class URL:\n    def __init__(\n        self,\n        url: str = \"\",\n        scope: Scope | None = None,\n        **components: typing.Any,\n    ) -> None:\n        if scope is not None:\n            assert not url, 'Cannot set both \"url\" and \"scope\".'\n            assert not components, 'Cannot set both \"scope\" and \"**components\".'\n            scheme = scope.get(\"scheme\", \"http\")\n            server = scope.get(\"server\", None)\n            path = scope[\"path\"]\n            query_string = scope.get(\"query_string\", b\"\")\n\n            host_header = None\n            for key, value in scope[\"headers\"]:\n                if key == b\"host\":\n                    host_header = value.decode(\"latin-1\")\n                    break\n\n            if host_header is not None:\n                url = f\"{scheme}://{host_header}{path}\"\n            elif server is None:\n                url = path\n            else:\n                host, port = server\n                default_port = {\"http\": 80, \"https\": 443, \"ws\": 80, \"wss\": 443}[scheme]\n                if port == default_port:\n                    url = f\"{scheme}://{host}{path}\"\n                else:\n                    url = f\"{scheme}://{host}:{port}{path}\"\n\n            if query_string:\n                url += \"?\" + query_string.decode()\n        elif components:\n            assert not url, 'Cannot set both \"url\" and \"**components\".'\n            url = URL(\"\").replace(**components).components.geturl()\n\n        self._url = url\n\n    @property\n    def components(self) -> SplitResult:\n        if not hasattr(self, \"_components\"):\n            self._components = urlsplit(self._url)\n        return self._components\n\n    @property\n    def scheme(self) -> str:\n        return self.components.scheme\n\n    @property\n    def netloc(self) -> str:\n        return self.components.netloc\n\n    @property\n    def path(self) -> str:\n        return self.components.path\n\n    @property\n    def query(self) -> str:\n        return self.components.query\n\n    @property\n    def fragment(self) -> str:\n        return self.components.fragment\n\n    @property\n    def username(self) -> None | str:\n        return self.components.username\n\n    @property\n    def password(self) -> None | str:\n        return self.components.password\n\n    @property\n    def hostname(self) -> None | str:\n        return self.components.hostname\n\n    @property\n    def port(self) -> int | None:\n        return self.components.port\n\n    @property\n    def is_secure(self) -> bool:\n        return self.scheme in (\"https\", \"wss\")\n\n    def replace(self, **kwargs: typing.Any) -> URL:\n        if \"username\" in kwargs or \"password\" in kwargs or \"hostname\" in kwargs or \"port\" in kwargs:\n            hostname = kwargs.pop(\"hostname\", None)\n            port = kwargs.pop(\"port\", self.port)\n            username = kwargs.pop(\"username\", self.username)\n            password = kwargs.pop(\"password\", self.password)\n\n            if hostname is None:\n                netloc = self.netloc\n                _, _, hostname = netloc.rpartition(\"@\")\n\n                if hostname[-1] != \"]\":\n                    hostname = hostname.rsplit(\":\", 1)[0]\n\n            netloc = hostname\n            if port is not None:\n                netloc += f\":{port}\"\n            if username is not None:\n                userpass = username\n                if password is not None:\n                    userpass += f\":{password}\"\n                netloc = f\"{userpass}@{netloc}\"\n\n            kwargs[\"netloc\"] = netloc\n\n        components = self.components._replace(**kwargs)\n        return self.__class__(components.geturl())\n\n    def include_query_params(self, **kwargs: typing.Any) -> URL:\n        params = MultiDict(parse_qsl(self.query, keep_blank_values=True))\n        params.update({str(key): str(value) for key, value in kwargs.items()})\n        query = urlencode(params.multi_items())\n        return self.replace(query=query)\n\n    def replace_query_params(self, **kwargs: typing.Any) -> URL:\n        query = urlencode([(str(key), str(value)) for key, value in kwargs.items()])\n        return self.replace(query=query)\n\n    def remove_query_params(self, keys: str | typing.Sequence[str]) -> URL:\n        if isinstance(keys, str):\n            keys = [keys]\n        params = MultiDict(parse_qsl(self.query, keep_blank_values=True))\n        for key in keys:\n            params.pop(key, None)\n        query = urlencode(params.multi_items())\n        return self.replace(query=query)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return str(self) == str(other)\n\n    def __str__(self) -> str:\n        return self._url\n\n    def __repr__(self) -> str:\n        url = str(self)\n        if self.password:\n            url = str(self.replace(password=\"********\"))\n        return f\"{self.__class__.__name__}({repr(url)})\""
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class URLPath(str):\n    \"\"\"\n    A URL path string that may also hold an associated protocol and/or host.\n    Used by the routing to return `url_path_for` matches.\n    \"\"\"\n\n    def __new__(cls, path: str, protocol: str = \"\", host: str = \"\") -> URLPath:\n        assert protocol in (\"http\", \"websocket\", \"\")\n        return str.__new__(cls, path)\n\n    def __init__(self, path: str, protocol: str = \"\", host: str = \"\") -> None:\n        self.protocol = protocol\n        self.host = host\n\n    def make_absolute_url(self, base_url: str | URL) -> URL:\n        if isinstance(base_url, str):\n            base_url = URL(base_url)\n        if self.protocol:\n            scheme = {\n                \"http\": {True: \"https\", False: \"http\"},\n                \"websocket\": {True: \"wss\", False: \"ws\"},\n            }[self.protocol][base_url.is_secure]\n        else:\n            scheme = base_url.scheme\n\n        netloc = self.host or base_url.netloc\n        path = base_url.path.rstrip(\"/\") + str(self)\n        return URL(scheme=scheme, netloc=netloc, path=path)"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class Secret:\n    \"\"\"\n    Holds a string value that should not be revealed in tracebacks etc.\n    You should cast the value to `str` at the point it is required.\n    \"\"\"\n\n    def __init__(self, value: str):\n        self._value = value\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        return f\"{class_name}('**********')\"\n\n    def __str__(self) -> str:\n        return self._value\n\n    def __bool__(self) -> bool:\n        return bool(self._value)"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class CommaSeparatedStrings(typing.Sequence[str]):\n    def __init__(self, value: str | typing.Sequence[str]):\n        if isinstance(value, str):\n            splitter = shlex(value, posix=True)\n            splitter.whitespace = \",\"\n            splitter.whitespace_split = True\n            self._items = [item.strip() for item in splitter]\n        else:\n            self._items = list(value)\n\n    def __len__(self) -> int:\n        return len(self._items)\n\n    def __getitem__(self, index: int | slice) -> typing.Any:\n        return self._items[index]\n\n    def __iter__(self) -> typing.Iterator[str]:\n        return iter(self._items)\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        items = [item for item in self]\n        return f\"{class_name}({items!r})\"\n\n    def __str__(self) -> str:\n        return \", \".join(repr(item) for item in self)"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):\n    _dict: dict[_KeyType, _CovariantValueType]\n\n    def __init__(\n        self,\n        *args: ImmutableMultiDict[_KeyType, _CovariantValueType]\n        | typing.Mapping[_KeyType, _CovariantValueType]\n        | typing.Iterable[tuple[_KeyType, _CovariantValueType]],\n        **kwargs: typing.Any,\n    ) -> None:\n        assert len(args) < 2, \"Too many arguments.\"\n\n        value: typing.Any = args[0] if args else []\n        if kwargs:\n            value = ImmutableMultiDict(value).multi_items() + ImmutableMultiDict(kwargs).multi_items()\n\n        if not value:\n            _items: list[tuple[typing.Any, typing.Any]] = []\n        elif hasattr(value, \"multi_items\"):\n            value = typing.cast(ImmutableMultiDict[_KeyType, _CovariantValueType], value)\n            _items = list(value.multi_items())\n        elif hasattr(value, \"items\"):\n            value = typing.cast(typing.Mapping[_KeyType, _CovariantValueType], value)\n            _items = list(value.items())\n        else:\n            value = typing.cast(\"list[tuple[typing.Any, typing.Any]]\", value)\n            _items = list(value)\n\n        self._dict = {k: v for k, v in _items}\n        self._list = _items\n\n    def getlist(self, key: typing.Any) -> list[_CovariantValueType]:\n        return [item_value for item_key, item_value in self._list if item_key == key]\n\n    def keys(self) -> typing.KeysView[_KeyType]:\n        return self._dict.keys()\n\n    def values(self) -> typing.ValuesView[_CovariantValueType]:\n        return self._dict.values()\n\n    def items(self) -> typing.ItemsView[_KeyType, _CovariantValueType]:\n        return self._dict.items()\n\n    def multi_items(self) -> list[tuple[_KeyType, _CovariantValueType]]:\n        return list(self._list)\n\n    def __getitem__(self, key: _KeyType) -> _CovariantValueType:\n        return self._dict[key]\n\n    def __contains__(self, key: typing.Any) -> bool:\n        return key in self._dict\n\n    def __iter__(self) -> typing.Iterator[_KeyType]:\n        return iter(self.keys())\n\n    def __len__(self) -> int:\n        return len(self._dict)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return sorted(self._list) == sorted(other._list)\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        items = self.multi_items()\n        return f\"{class_name}({items!r})\""
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):\n    def __setitem__(self, key: typing.Any, value: typing.Any) -> None:\n        self.setlist(key, [value])\n\n    def __delitem__(self, key: typing.Any) -> None:\n        self._list = [(k, v) for k, v in self._list if k != key]\n        del self._dict[key]\n\n    def pop(self, key: typing.Any, default: typing.Any = None) -> typing.Any:\n        self._list = [(k, v) for k, v in self._list if k != key]\n        return self._dict.pop(key, default)\n\n    def popitem(self) -> tuple[typing.Any, typing.Any]:\n        key, value = self._dict.popitem()\n        self._list = [(k, v) for k, v in self._list if k != key]\n        return key, value\n\n    def poplist(self, key: typing.Any) -> list[typing.Any]:\n        values = [v for k, v in self._list if k == key]\n        self.pop(key)\n        return values\n\n    def clear(self) -> None:\n        self._dict.clear()\n        self._list.clear()\n\n    def setdefault(self, key: typing.Any, default: typing.Any = None) -> typing.Any:\n        if key not in self:\n            self._dict[key] = default\n            self._list.append((key, default))\n\n        return self[key]\n\n    def setlist(self, key: typing.Any, values: list[typing.Any]) -> None:\n        if not values:\n            self.pop(key, None)\n        else:\n            existing_items = [(k, v) for (k, v) in self._list if k != key]\n            self._list = existing_items + [(key, value) for value in values]\n            self._dict[key] = values[-1]\n\n    def append(self, key: typing.Any, value: typing.Any) -> None:\n        self._list.append((key, value))\n        self._dict[key] = value\n\n    def update(\n        self,\n        *args: MultiDict | typing.Mapping[typing.Any, typing.Any] | list[tuple[typing.Any, typing.Any]],\n        **kwargs: typing.Any,\n    ) -> None:\n        value = MultiDict(*args, **kwargs)\n        existing_items = [(k, v) for (k, v) in self._list if k not in value.keys()]\n        self._list = existing_items + value.multi_items()\n        self._dict.update(value)"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class QueryParams(ImmutableMultiDict[str, str]):\n    \"\"\"\n    An immutable multidict.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: ImmutableMultiDict[typing.Any, typing.Any]\n        | typing.Mapping[typing.Any, typing.Any]\n        | list[tuple[typing.Any, typing.Any]]\n        | str\n        | bytes,\n        **kwargs: typing.Any,\n    ) -> None:\n        assert len(args) < 2, \"Too many arguments.\"\n\n        value = args[0] if args else []\n\n        if isinstance(value, str):\n            super().__init__(parse_qsl(value, keep_blank_values=True), **kwargs)\n        elif isinstance(value, bytes):\n            super().__init__(parse_qsl(value.decode(\"latin-1\"), keep_blank_values=True), **kwargs)\n        else:\n            super().__init__(*args, **kwargs)  # type: ignore[arg-type]\n        self._list = [(str(k), str(v)) for k, v in self._list]\n        self._dict = {str(k): str(v) for k, v in self._dict.items()}\n\n    def __str__(self) -> str:\n        return urlencode(self._list)\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        query_string = str(self)\n        return f\"{class_name}({query_string!r})\""
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class UploadFile:\n    \"\"\"\n    An uploaded file included as part of the request data.\n    \"\"\"\n\n    def __init__(\n        self,\n        file: typing.BinaryIO,\n        *,\n        size: int | None = None,\n        filename: str | None = None,\n        headers: Headers | None = None,\n    ) -> None:\n        self.filename = filename\n        self.file = file\n        self.size = size\n        self.headers = headers or Headers()\n\n    @property\n    def content_type(self) -> str | None:\n        return self.headers.get(\"content-type\", None)\n\n    @property\n    def _in_memory(self) -> bool:\n        rolled_to_disk = getattr(self.file, \"_rolled\", True)\n        return not rolled_to_disk\n\n    async def write(self, data: bytes) -> None:\n        if self.size is not None:\n            self.size += len(data)\n\n        if self._in_memory:\n            self.file.write(data)\n        else:\n            await run_in_threadpool(self.file.write, data)\n\n    async def read(self, size: int = -1) -> bytes:\n        if self._in_memory:\n            return self.file.read(size)\n        return await run_in_threadpool(self.file.read, size)\n\n    async def seek(self, offset: int) -> None:\n        if self._in_memory:\n            self.file.seek(offset)\n        else:\n            await run_in_threadpool(self.file.seek, offset)\n\n    async def close(self) -> None:\n        if self._in_memory:\n            self.file.close()\n        else:\n            await run_in_threadpool(self.file.close)\n\n    def __repr__(self) -> str:\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"filename={self.filename!r}, \"\n            f\"size={self.size!r}, \"\n            f\"headers={self.headers!r})\"\n        )"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class FormData(ImmutableMultiDict[str, typing.Union[UploadFile, str]]):\n    \"\"\"\n    An immutable multidict, containing both file uploads and text input.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: FormData | typing.Mapping[str, str | UploadFile] | list[tuple[str, str | UploadFile]],\n        **kwargs: str | UploadFile,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n\n    async def close(self) -> None:\n        for key, value in self.multi_items():\n            if isinstance(value, UploadFile):\n                await value.close()"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class Headers(typing.Mapping[str, str]):\n    \"\"\"\n    An immutable, case-insensitive multidict.\n    \"\"\"\n\n    def __init__(\n        self,\n        headers: typing.Mapping[str, str] | None = None,\n        raw: list[tuple[bytes, bytes]] | None = None,\n        scope: typing.MutableMapping[str, typing.Any] | None = None,\n    ) -> None:\n        self._list: list[tuple[bytes, bytes]] = []\n        if headers is not None:\n            assert raw is None, 'Cannot set both \"headers\" and \"raw\".'\n            assert scope is None, 'Cannot set both \"headers\" and \"scope\".'\n            self._list = [(key.lower().encode(\"latin-1\"), value.encode(\"latin-1\")) for key, value in headers.items()]\n        elif raw is not None:\n            assert scope is None, 'Cannot set both \"raw\" and \"scope\".'\n            self._list = raw\n        elif scope is not None:\n            self._list = scope[\"headers\"] = list(scope[\"headers\"])\n\n    @property\n    def raw(self) -> list[tuple[bytes, bytes]]:\n        return list(self._list)\n\n    def keys(self) -> list[str]:  # type: ignore[override]\n        return [key.decode(\"latin-1\") for key, value in self._list]\n\n    def values(self) -> list[str]:  # type: ignore[override]\n        return [value.decode(\"latin-1\") for key, value in self._list]\n\n    def items(self) -> list[tuple[str, str]]:  # type: ignore[override]\n        return [(key.decode(\"latin-1\"), value.decode(\"latin-1\")) for key, value in self._list]\n\n    def getlist(self, key: str) -> list[str]:\n        get_header_key = key.lower().encode(\"latin-1\")\n        return [item_value.decode(\"latin-1\") for item_key, item_value in self._list if item_key == get_header_key]\n\n    def mutablecopy(self) -> MutableHeaders:\n        return MutableHeaders(raw=self._list[:])\n\n    def __getitem__(self, key: str) -> str:\n        get_header_key = key.lower().encode(\"latin-1\")\n        for header_key, header_value in self._list:\n            if header_key == get_header_key:\n                return header_value.decode(\"latin-1\")\n        raise KeyError(key)\n\n    def __contains__(self, key: typing.Any) -> bool:\n        get_header_key = key.lower().encode(\"latin-1\")\n        for header_key, header_value in self._list:\n            if header_key == get_header_key:\n                return True\n        return False\n\n    def __iter__(self) -> typing.Iterator[typing.Any]:\n        return iter(self.keys())\n\n    def __len__(self) -> int:\n        return len(self._list)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, Headers):\n            return False\n        return sorted(self._list) == sorted(other._list)\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        as_dict = dict(self.items())\n        if len(as_dict) == len(self):\n            return f\"{class_name}({as_dict!r})\"\n        return f\"{class_name}(raw={self.raw!r})\""
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class MutableHeaders(Headers):\n    def __setitem__(self, key: str, value: str) -> None:\n        \"\"\"\n        Set the header `key` to `value`, removing any duplicate entries.\n        Retains insertion order.\n        \"\"\"\n        set_key = key.lower().encode(\"latin-1\")\n        set_value = value.encode(\"latin-1\")\n\n        found_indexes: list[int] = []\n        for idx, (item_key, item_value) in enumerate(self._list):\n            if item_key == set_key:\n                found_indexes.append(idx)\n\n        for idx in reversed(found_indexes[1:]):\n            del self._list[idx]\n\n        if found_indexes:\n            idx = found_indexes[0]\n            self._list[idx] = (set_key, set_value)\n        else:\n            self._list.append((set_key, set_value))\n\n    def __delitem__(self, key: str) -> None:\n        \"\"\"\n        Remove the header `key`.\n        \"\"\"\n        del_key = key.lower().encode(\"latin-1\")\n\n        pop_indexes: list[int] = []\n        for idx, (item_key, item_value) in enumerate(self._list):\n            if item_key == del_key:\n                pop_indexes.append(idx)\n\n        for idx in reversed(pop_indexes):\n            del self._list[idx]\n\n    def __ior__(self, other: typing.Mapping[str, str]) -> MutableHeaders:\n        if not isinstance(other, typing.Mapping):\n            raise TypeError(f\"Expected a mapping but got {other.__class__.__name__}\")\n        self.update(other)\n        return self\n\n    def __or__(self, other: typing.Mapping[str, str]) -> MutableHeaders:\n        if not isinstance(other, typing.Mapping):\n            raise TypeError(f\"Expected a mapping but got {other.__class__.__name__}\")\n        new = self.mutablecopy()\n        new.update(other)\n        return new\n\n    @property\n    def raw(self) -> list[tuple[bytes, bytes]]:\n        return self._list\n\n    def setdefault(self, key: str, value: str) -> str:\n        \"\"\"\n        If the header `key` does not exist, then set it to `value`.\n        Returns the header value.\n        \"\"\"\n        set_key = key.lower().encode(\"latin-1\")\n        set_value = value.encode(\"latin-1\")\n\n        for idx, (item_key, item_value) in enumerate(self._list):\n            if item_key == set_key:\n                return item_value.decode(\"latin-1\")\n        self._list.append((set_key, set_value))\n        return value\n\n    def update(self, other: typing.Mapping[str, str]) -> None:\n        for key, val in other.items():\n            self[key] = val\n\n    def append(self, key: str, value: str) -> None:\n        \"\"\"\n        Append a header, preserving any duplicate entries.\n        \"\"\"\n        append_key = key.lower().encode(\"latin-1\")\n        append_value = value.encode(\"latin-1\")\n        self._list.append((append_key, append_value))\n\n    def add_vary_header(self, vary: str) -> None:\n        existing = self.get(\"vary\")\n        if existing is not None:\n            vary = \", \".join([existing, vary])\n        self[\"vary\"] = vary"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/starlette/starlette/datastructures.py",
      "content": "class State:\n    \"\"\"\n    An object that can be used to store arbitrary state.\n\n    Used for `request.state` and `app.state`.\n    \"\"\"\n\n    _state: dict[str, typing.Any]\n\n    def __init__(self, state: dict[str, typing.Any] | None = None):\n        if state is None:\n            state = {}\n        super().__setattr__(\"_state\", state)\n\n    def __setattr__(self, key: typing.Any, value: typing.Any) -> None:\n        self._state[key] = value\n\n    def __getattr__(self, key: typing.Any) -> typing.Any:\n        try:\n            return self._state[key]\n        except KeyError:\n            message = \"'{}' object has no attribute '{}'\"\n            raise AttributeError(message.format(self.__class__.__name__, key))\n\n    def __delattr__(self, key: typing.Any) -> None:\n        del self._state[key]"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "from __future__ import annotations\n\nimport hashlib\nimport http.cookies\nimport json\nimport os\nimport re\nimport stat\nimport typing\nimport warnings\nfrom datetime import datetime\nfrom email.utils import format_datetime, formatdate\nfrom functools import partial\nfrom mimetypes import guess_type\nfrom secrets import token_hex\nfrom urllib.parse import quote\n\nimport anyio\nimport anyio.to_thread\n\nfrom starlette.background import BackgroundTask\nfrom starlette.concurrency import iterate_in_threadpool\nfrom starlette.datastructures import URL, Headers, MutableHeaders\nfrom starlette.requests import ClientDisconnect\nfrom starlette.types import Receive, Scope, Send"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class Response:\n    media_type = None\n    charset = \"utf-8\"\n\n    def __init__(\n        self,\n        content: typing.Any = None,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ) -> None:\n        self.status_code = status_code\n        if media_type is not None:\n            self.media_type = media_type\n        self.background = background\n        self.body = self.render(content)\n        self.init_headers(headers)\n\n    def render(self, content: typing.Any) -> bytes | memoryview:\n        if content is None:\n            return b\"\"\n        if isinstance(content, (bytes, memoryview)):\n            return content\n        return content.encode(self.charset)  # type: ignore\n\n    def init_headers(self, headers: typing.Mapping[str, str] | None = None) -> None:\n        if headers is None:\n            raw_headers: list[tuple[bytes, bytes]] = []\n            populate_content_length = True\n            populate_content_type = True\n        else:\n            raw_headers = [(k.lower().encode(\"latin-1\"), v.encode(\"latin-1\")) for k, v in headers.items()]\n            keys = [h[0] for h in raw_headers]\n            populate_content_length = b\"content-length\" not in keys\n            populate_content_type = b\"content-type\" not in keys\n\n        body = getattr(self, \"body\", None)\n        if (\n            body is not None\n            and populate_content_length\n            and not (self.status_code < 200 or self.status_code in (204, 304))\n        ):\n            content_length = str(len(body))\n            raw_headers.append((b\"content-length\", content_length.encode(\"latin-1\")))\n\n        content_type = self.media_type\n        if content_type is not None and populate_content_type:\n            if content_type.startswith(\"text/\") and \"charset=\" not in content_type.lower():\n                content_type += \"; charset=\" + self.charset\n            raw_headers.append((b\"content-type\", content_type.encode(\"latin-1\")))\n\n        self.raw_headers = raw_headers\n\n    @property\n    def headers(self) -> MutableHeaders:\n        if not hasattr(self, \"_headers\"):\n            self._headers = MutableHeaders(raw=self.raw_headers)\n        return self._headers\n\n    def set_cookie(\n        self,\n        key: str,\n        value: str = \"\",\n        max_age: int | None = None,\n        expires: datetime | str | int | None = None,\n        path: str | None = \"/\",\n        domain: str | None = None,\n        secure: bool = False,\n        httponly: bool = False,\n        samesite: typing.Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n    ) -> None:\n        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()\n        cookie[key] = value\n        if max_age is not None:\n            cookie[key][\"max-age\"] = max_age\n        if expires is not None:\n            if isinstance(expires, datetime):\n                cookie[key][\"expires\"] = format_datetime(expires, usegmt=True)\n            else:\n                cookie[key][\"expires\"] = expires\n        if path is not None:\n            cookie[key][\"path\"] = path\n        if domain is not None:\n            cookie[key][\"domain\"] = domain\n        if secure:\n            cookie[key][\"secure\"] = True\n        if httponly:\n            cookie[key][\"httponly\"] = True\n        if samesite is not None:\n            assert samesite.lower() in [\n                \"strict\",\n                \"lax\",\n                \"none\",\n            ], \"samesite must be either 'strict', 'lax' or 'none'\"\n            cookie[key][\"samesite\"] = samesite\n        cookie_val = cookie.output(header=\"\").strip()\n        self.raw_headers.append((b\"set-cookie\", cookie_val.encode(\"latin-1\")))\n\n    def delete_cookie(\n        self,\n        key: str,\n        path: str = \"/\",\n        domain: str | None = None,\n        secure: bool = False,\n        httponly: bool = False,\n        samesite: typing.Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n    ) -> None:\n        self.set_cookie(\n            key,\n            max_age=0,\n            expires=0,\n            path=path,\n            domain=domain,\n            secure=secure,\n            httponly=httponly,\n            samesite=samesite,\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        prefix = \"websocket.\" if scope[\"type\"] == \"websocket\" else \"\"\n        await send(\n            {\n                \"type\": prefix + \"http.response.start\",\n                \"status\": self.status_code,\n                \"headers\": self.raw_headers,\n            }\n        )\n        await send({\"type\": prefix + \"http.response.body\", \"body\": self.body})\n\n        if self.background is not None:\n            await self.background()"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class HTMLResponse(Response):\n    media_type = \"text/html\""
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class PlainTextResponse(Response):\n    media_type = \"text/plain\""
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class JSONResponse(Response):\n    media_type = \"application/json\"\n\n    def __init__(\n        self,\n        content: typing.Any,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ) -> None:\n        super().__init__(content, status_code, headers, media_type, background)\n\n    def render(self, content: typing.Any) -> bytes:\n        return json.dumps(\n            content,\n            ensure_ascii=False,\n            allow_nan=False,\n            indent=None,\n            separators=(\",\", \":\"),\n        ).encode(\"utf-8\")"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class RedirectResponse(Response):\n    def __init__(\n        self,\n        url: str | URL,\n        status_code: int = 307,\n        headers: typing.Mapping[str, str] | None = None,\n        background: BackgroundTask | None = None,\n    ) -> None:\n        super().__init__(content=b\"\", status_code=status_code, headers=headers, background=background)\n        self.headers[\"location\"] = quote(str(url), safe=\":/%#?=@[]!$&'()*+,;\")"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "Content = typing.Union[str, bytes, memoryview]\nSyncContentStream = typing.Iterable[Content]\nAsyncContentStream = typing.AsyncIterable[Content]\nContentStream = typing.Union[AsyncContentStream, SyncContentStream]"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class StreamingResponse(Response):\n    body_iterator: AsyncContentStream\n\n    def __init__(\n        self,\n        content: ContentStream,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n    ) -> None:\n        if isinstance(content, typing.AsyncIterable):\n            self.body_iterator = content\n        else:\n            self.body_iterator = iterate_in_threadpool(content)\n        self.status_code = status_code\n        self.media_type = self.media_type if media_type is None else media_type\n        self.background = background\n        self.init_headers(headers)\n\n    async def listen_for_disconnect(self, receive: Receive) -> None:\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"http.disconnect\":\n                break\n\n    async def stream_response(self, send: Send) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": self.status_code,\n                \"headers\": self.raw_headers,\n            }\n        )\n        async for chunk in self.body_iterator:\n            if not isinstance(chunk, (bytes, memoryview)):\n                chunk = chunk.encode(self.charset)\n            await send({\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": True})\n\n        await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        spec_version = tuple(map(int, scope.get(\"asgi\", {}).get(\"spec_version\", \"2.0\").split(\".\")))\n\n        if spec_version >= (2, 4):\n            try:\n                await self.stream_response(send)\n            except OSError:\n                raise ClientDisconnect()\n        else:\n            async with anyio.create_task_group() as task_group:\n\n                async def wrap(func: typing.Callable[[], typing.Awaitable[None]]) -> None:\n                    await func()\n                    task_group.cancel_scope.cancel()\n\n                task_group.start_soon(wrap, partial(self.stream_response, send))\n                await wrap(partial(self.listen_for_disconnect, receive))\n\n        if self.background is not None:\n            await self.background()"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class MalformedRangeHeader(Exception):\n    def __init__(self, content: str = \"Malformed range header.\") -> None:\n        self.content = content"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class RangeNotSatisfiable(Exception):\n    def __init__(self, max_size: int) -> None:\n        self.max_size = max_size"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "_RANGE_PATTERN = re.compile(r\"(\\d*)-(\\d*)\")"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/starlette/starlette/responses.py",
      "content": "class FileResponse(Response):\n    chunk_size = 64 * 1024\n\n    def __init__(\n        self,\n        path: str | os.PathLike[str],\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        background: BackgroundTask | None = None,\n        filename: str | None = None,\n        stat_result: os.stat_result | None = None,\n        method: str | None = None,\n        content_disposition_type: str = \"attachment\",\n    ) -> None:\n        self.path = path\n        self.status_code = status_code\n        self.filename = filename\n        if method is not None:\n            warnings.warn(\n                \"The 'method' parameter is not used, and it will be removed.\",\n                DeprecationWarning,\n            )\n        if media_type is None:\n            media_type = guess_type(filename or path)[0] or \"text/plain\"\n        self.media_type = media_type\n        self.background = background\n        self.init_headers(headers)\n        self.headers.setdefault(\"accept-ranges\", \"bytes\")\n        if self.filename is not None:\n            content_disposition_filename = quote(self.filename)\n            if content_disposition_filename != self.filename:\n                content_disposition = f\"{content_disposition_type}; filename*=utf-8''{content_disposition_filename}\"\n            else:\n                content_disposition = f'{content_disposition_type}; filename=\"{self.filename}\"'\n            self.headers.setdefault(\"content-disposition\", content_disposition)\n        self.stat_result = stat_result\n        if stat_result is not None:\n            self.set_stat_headers(stat_result)\n\n    def set_stat_headers(self, stat_result: os.stat_result) -> None:\n        content_length = str(stat_result.st_size)\n        last_modified = formatdate(stat_result.st_mtime, usegmt=True)\n        etag_base = str(stat_result.st_mtime) + \"-\" + str(stat_result.st_size)\n        etag = f'\"{hashlib.md5(etag_base.encode(), usedforsecurity=False).hexdigest()}\"'\n\n        self.headers.setdefault(\"content-length\", content_length)\n        self.headers.setdefault(\"last-modified\", last_modified)\n        self.headers.setdefault(\"etag\", etag)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        send_header_only: bool = scope[\"method\"].upper() == \"HEAD\"\n        if self.stat_result is None:\n            try:\n                stat_result = await anyio.to_thread.run_sync(os.stat, self.path)\n                self.set_stat_headers(stat_result)\n            except FileNotFoundError:\n                raise RuntimeError(f\"File at path {self.path} does not exist.\")\n            else:\n                mode = stat_result.st_mode\n                if not stat.S_ISREG(mode):\n                    raise RuntimeError(f\"File at path {self.path} is not a file.\")\n        else:\n            stat_result = self.stat_result\n\n        headers = Headers(scope=scope)\n        http_range = headers.get(\"range\")\n        http_if_range = headers.get(\"if-range\")\n\n        if http_range is None or (http_if_range is not None and not self._should_use_range(http_if_range)):\n            await self._handle_simple(send, send_header_only)\n        else:\n            try:\n                ranges = self._parse_range_header(http_range, stat_result.st_size)\n            except MalformedRangeHeader as exc:\n                return await PlainTextResponse(exc.content, status_code=400)(scope, receive, send)\n            except RangeNotSatisfiable as exc:\n                response = PlainTextResponse(status_code=416, headers={\"Content-Range\": f\"*/{exc.max_size}\"})\n                return await response(scope, receive, send)\n\n            if len(ranges) == 1:\n                start, end = ranges[0]\n                await self._handle_single_range(send, start, end, stat_result.st_size, send_header_only)\n            else:\n                await self._handle_multiple_ranges(send, ranges, stat_result.st_size, send_header_only)\n\n        if self.background is not None:\n            await self.background()\n\n    async def _handle_simple(self, send: Send, send_header_only: bool) -> None:\n        await send({\"type\": \"http.response.start\", \"status\": self.status_code, \"headers\": self.raw_headers})\n        if send_header_only:\n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n        else:\n            async with await anyio.open_file(self.path, mode=\"rb\") as file:\n                more_body = True\n                while more_body:\n                    chunk = await file.read(self.chunk_size)\n                    more_body = len(chunk) == self.chunk_size\n                    await send({\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": more_body})\n\n    async def _handle_single_range(\n        self, send: Send, start: int, end: int, file_size: int, send_header_only: bool\n    ) -> None:\n        self.headers[\"content-range\"] = f\"bytes {start}-{end - 1}/{file_size}\"\n        self.headers[\"content-length\"] = str(end - start)\n        await send({\"type\": \"http.response.start\", \"status\": 206, \"headers\": self.raw_headers})\n        if send_header_only:\n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n        else:\n            async with await anyio.open_file(self.path, mode=\"rb\") as file:\n                await file.seek(start)\n                more_body = True\n                while more_body:\n                    chunk = await file.read(min(self.chunk_size, end - start))\n                    start += len(chunk)\n                    more_body = len(chunk) == self.chunk_size and start < end\n                    await send({\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": more_body})\n\n    async def _handle_multiple_ranges(\n        self,\n        send: Send,\n        ranges: list[tuple[int, int]],\n        file_size: int,\n        send_header_only: bool,\n    ) -> None:\n        # In firefox and chrome, they use boundary with 95-96 bits entropy (that's roughly 13 bytes).\n        boundary = token_hex(13)\n        content_length, header_generator = self.generate_multipart(\n            ranges, boundary, file_size, self.headers[\"content-type\"]\n        )\n        self.headers[\"content-range\"] = f\"multipart/byteranges; boundary={boundary}\"\n        self.headers[\"content-length\"] = str(content_length)\n        await send({\"type\": \"http.response.start\", \"status\": 206, \"headers\": self.raw_headers})\n        if send_header_only:\n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n        else:\n            async with await anyio.open_file(self.path, mode=\"rb\") as file:\n                for start, end in ranges:\n                    await send({\"type\": \"http.response.body\", \"body\": header_generator(start, end), \"more_body\": True})\n                    await file.seek(start)\n                    while start < end:\n                        chunk = await file.read(min(self.chunk_size, end - start))\n                        start += len(chunk)\n                        await send({\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": True})\n                    await send({\"type\": \"http.response.body\", \"body\": b\"\\n\", \"more_body\": True})\n                await send(\n                    {\n                        \"type\": \"http.response.body\",\n                        \"body\": f\"\\n--{boundary}--\\n\".encode(\"latin-1\"),\n                        \"more_body\": False,\n                    }\n                )\n\n    def _should_use_range(self, http_if_range: str) -> bool:\n        return http_if_range == self.headers[\"last-modified\"] or http_if_range == self.headers[\"etag\"]\n\n    @staticmethod\n    def _parse_range_header(http_range: str, file_size: int) -> list[tuple[int, int]]:\n        ranges: list[tuple[int, int]] = []\n        try:\n            units, range_ = http_range.split(\"=\", 1)\n        except ValueError:\n            raise MalformedRangeHeader()\n\n        units = units.strip().lower()\n\n        if units != \"bytes\":\n            raise MalformedRangeHeader(\"Only support bytes range\")\n\n        ranges = [\n            (\n                int(_[0]) if _[0] else file_size - int(_[1]),\n                int(_[1]) + 1 if _[0] and _[1] and int(_[1]) < file_size else file_size,\n            )\n            for _ in _RANGE_PATTERN.findall(range_)\n            if _ != (\"\", \"\")\n        ]\n\n        if len(ranges) == 0:\n            raise MalformedRangeHeader(\"Range header: range must be requested\")\n\n        if any(not (0 <= start < file_size) for start, _ in ranges):\n            raise RangeNotSatisfiable(file_size)\n\n        if any(start > end for start, end in ranges):\n            raise MalformedRangeHeader(\"Range header: start must be less than end\")\n\n        if len(ranges) == 1:\n            return ranges\n\n        # Merge ranges\n        result: list[tuple[int, int]] = []\n        for start, end in ranges:\n            for p in range(len(result)):\n                p_start, p_end = result[p]\n                if start > p_end:\n                    continue\n                elif end < p_start:\n                    result.insert(p, (start, end))  # THIS IS NOT REACHED!\n                    break\n                else:\n                    result[p] = (min(start, p_start), max(end, p_end))\n                    break\n            else:\n                result.append((start, end))\n\n        return result\n\n    def generate_multipart(\n        self,\n        ranges: typing.Sequence[tuple[int, int]],\n        boundary: str,\n        max_size: int,\n        content_type: str,\n    ) -> tuple[int, typing.Callable[[int, int], bytes]]:\n        r\"\"\"\n        Multipart response headers generator.\n\n        ```\n        --{boundary}\\n\n        Content-Type: {content_type}\\n\n        Content-Range: bytes {start}-{end-1}/{max_size}\\n\n        \\n\n        ..........content...........\\n\n        --{boundary}\\n\n        Content-Type: {content_type}\\n\n        Content-Range: bytes {start}-{end-1}/{max_size}\\n\n        \\n\n        ..........content...........\\n\n        --{boundary}--\\n\n        ```\n        \"\"\"\n        boundary_len = len(boundary)\n        static_header_part_len = 44 + boundary_len + len(content_type) + len(str(max_size))\n        content_length = sum(\n            (len(str(start)) + len(str(end - 1)) + static_header_part_len)  # Headers\n            + (end - start)  # Content\n            for start, end in ranges\n        ) + (\n            5 + boundary_len  # --boundary--\\n\n        )\n        return (\n            content_length,\n            lambda start, end: (\n                f\"--{boundary}\\n\"\n                f\"Content-Type: {content_type}\\n\"\n                f\"Content-Range: bytes {start}-{end-1}/{max_size}\\n\"\n                \"\\n\"\n            ).encode(\"latin-1\"),\n        )"
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "from __future__ import annotations\n\nimport os\nimport typing\nimport warnings\nfrom pathlib import Path"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "class undefined:\n    pass"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "class EnvironError(Exception):\n    pass"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "class Environ(typing.MutableMapping[str, str]):\n    def __init__(self, environ: typing.MutableMapping[str, str] = os.environ):\n        self._environ = environ\n        self._has_been_read: set[str] = set()\n\n    def __getitem__(self, key: str) -> str:\n        self._has_been_read.add(key)\n        return self._environ.__getitem__(key)\n\n    def __setitem__(self, key: str, value: str) -> None:\n        if key in self._has_been_read:\n            raise EnvironError(f\"Attempting to set environ['{key}'], but the value has already been read.\")\n        self._environ.__setitem__(key, value)\n\n    def __delitem__(self, key: str) -> None:\n        if key in self._has_been_read:\n            raise EnvironError(f\"Attempting to delete environ['{key}'], but the value has already been read.\")\n        self._environ.__delitem__(key)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        return iter(self._environ)\n\n    def __len__(self) -> int:\n        return len(self._environ)"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "environ = Environ()"
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "T = typing.TypeVar(\"T\")"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/starlette/starlette/config.py",
      "content": "class Config:\n    def __init__(\n        self,\n        env_file: str | Path | None = None,\n        environ: typing.Mapping[str, str] = environ,\n        env_prefix: str = \"\",\n    ) -> None:\n        self.environ = environ\n        self.env_prefix = env_prefix\n        self.file_values: dict[str, str] = {}\n        if env_file is not None:\n            if not os.path.isfile(env_file):\n                warnings.warn(f\"Config file '{env_file}' not found.\")\n            else:\n                self.file_values = self._read_file(env_file)\n\n    @typing.overload\n    def __call__(self, key: str, *, default: None) -> str | None: ...\n\n    @typing.overload\n    def __call__(self, key: str, cast: type[T], default: T = ...) -> T: ...\n\n    @typing.overload\n    def __call__(self, key: str, cast: type[str] = ..., default: str = ...) -> str: ...\n\n    @typing.overload\n    def __call__(\n        self,\n        key: str,\n        cast: typing.Callable[[typing.Any], T] = ...,\n        default: typing.Any = ...,\n    ) -> T: ...\n\n    @typing.overload\n    def __call__(self, key: str, cast: type[str] = ..., default: T = ...) -> T | str: ...\n\n    def __call__(\n        self,\n        key: str,\n        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n        default: typing.Any = undefined,\n    ) -> typing.Any:\n        return self.get(key, cast, default)\n\n    def get(\n        self,\n        key: str,\n        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n        default: typing.Any = undefined,\n    ) -> typing.Any:\n        key = self.env_prefix + key\n        if key in self.environ:\n            value = self.environ[key]\n            return self._perform_cast(key, value, cast)\n        if key in self.file_values:\n            value = self.file_values[key]\n            return self._perform_cast(key, value, cast)\n        if default is not undefined:\n            return self._perform_cast(key, default, cast)\n        raise KeyError(f\"Config '{key}' is missing, and has no default.\")\n\n    def _read_file(self, file_name: str | Path) -> dict[str, str]:\n        file_values: dict[str, str] = {}\n        with open(file_name) as input_file:\n            for line in input_file.readlines():\n                line = line.strip()\n                if \"=\" in line and not line.startswith(\"#\"):\n                    key, value = line.split(\"=\", 1)\n                    key = key.strip()\n                    value = value.strip().strip(\"\\\"'\")\n                    file_values[key] = value\n        return file_values\n\n    def _perform_cast(\n        self,\n        key: str,\n        value: typing.Any,\n        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n    ) -> typing.Any:\n        if cast is None or value is None:\n            return value\n        elif cast is bool and isinstance(value, str):\n            mapping = {\"true\": True, \"1\": True, \"false\": False, \"0\": False}\n            value = value.lower()\n            if value not in mapping:\n                raise ValueError(f\"Config '{key}' has value '{value}'. Not a valid bool.\")\n            return mapping[value]\n        try:\n            return cast(value)\n        except (TypeError, ValueError):\n            raise ValueError(f\"Config '{key}' has value '{value}'. Not a valid {cast.__name__}.\")"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "from __future__ import annotations\n\nimport functools\nimport sys\nimport typing\nimport warnings\n\nimport anyio.to_thread\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nP = ParamSpec(\"P\")\nT = typing.TypeVar(\"T\")"
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "async def run_until_first_complete(*args: tuple[typing.Callable, dict]) -> None:  # type: ignore[type-arg]\n    warnings.warn(\n        \"run_until_first_complete is deprecated and will be removed in a future version.\",\n        DeprecationWarning,\n    )\n\n    async with anyio.create_task_group() as task_group:\n\n        async def run(func: typing.Callable[[], typing.Coroutine]) -> None:  # type: ignore[type-arg]\n            await func()\n            task_group.cancel_scope.cancel()\n\n        for func, kwargs in args:\n            task_group.start_soon(run, functools.partial(func, **kwargs))"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "async def run_in_threadpool(func: typing.Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> T:\n    func = functools.partial(func, *args, **kwargs)\n    return await anyio.to_thread.run_sync(func)"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "class _StopIteration(Exception):\n    pass"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "def _next(iterator: typing.Iterator[T]) -> T:\n    # We can't raise `StopIteration` from within the threadpool iterator\n    # and catch it outside that context, so we coerce them into a different\n    # exception type.\n    try:\n        return next(iterator)\n    except StopIteration:\n        raise _StopIteration"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/starlette/starlette/concurrency.py",
      "content": "async def iterate_in_threadpool(\n    iterator: typing.Iterable[T],\n) -> typing.AsyncIterator[T]:\n    as_iterator = iter(iterator)\n    while True:\n        try:\n            yield await anyio.to_thread.run_sync(_next, as_iterator)\n        except _StopIteration:\n            break"
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/starlette/starlette/exceptions.py",
      "content": "from __future__ import annotations\n\nimport http\nfrom collections.abc import Mapping"
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/starlette/starlette/exceptions.py",
      "content": "class HTTPException(Exception):\n    def __init__(self, status_code: int, detail: str | None = None, headers: Mapping[str, str] | None = None) -> None:\n        if detail is None:\n            detail = http.HTTPStatus(status_code).phrase\n        self.status_code = status_code\n        self.detail = detail\n        self.headers = headers\n\n    def __str__(self) -> str:\n        return f\"{self.status_code}: {self.detail}\"\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        return f\"{class_name}(status_code={self.status_code!r}, detail={self.detail!r})\""
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/starlette/starlette/exceptions.py",
      "content": "class WebSocketException(Exception):\n    def __init__(self, code: int, reason: str | None = None) -> None:\n        self.code = code\n        self.reason = reason or \"\"\n\n    def __str__(self) -> str:\n        return f\"{self.code}: {self.reason}\"\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        return f\"{class_name}(code={self.code!r}, reason={self.reason!r})\""
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/starlette/starlette/background.py",
      "content": "from __future__ import annotations\n\nimport sys\nimport typing\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\n\nP = ParamSpec(\"P\")"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/starlette/starlette/background.py",
      "content": "class BackgroundTask:\n    def __init__(self, func: typing.Callable[P, typing.Any], *args: P.args, **kwargs: P.kwargs) -> None:\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.is_async = is_async_callable(func)\n\n    async def __call__(self) -> None:\n        if self.is_async:\n            await self.func(*self.args, **self.kwargs)\n        else:\n            await run_in_threadpool(self.func, *self.args, **self.kwargs)"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/starlette/starlette/background.py",
      "content": "class BackgroundTasks(BackgroundTask):\n    def __init__(self, tasks: typing.Sequence[BackgroundTask] | None = None):\n        self.tasks = list(tasks) if tasks else []\n\n    def add_task(self, func: typing.Callable[P, typing.Any], *args: P.args, **kwargs: P.kwargs) -> None:\n        task = BackgroundTask(func, *args, **kwargs)\n        self.tasks.append(task)\n\n    async def __call__(self) -> None:\n        for task in self.tasks:\n            await task()"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/starlette/starlette/middleware/__init__.py",
      "content": "from __future__ import annotations\n\nimport sys\nfrom collections.abc import Iterator\nfrom typing import Any, Protocol\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nfrom starlette.types import ASGIApp\n\nP = ParamSpec(\"P\")"
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/starlette/starlette/middleware/__init__.py",
      "content": "class _MiddlewareFactory(Protocol[P]):\n    def __call__(self, app: ASGIApp, /, *args: P.args, **kwargs: P.kwargs) -> ASGIApp: ...  # pragma: no cover"
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/starlette/starlette/middleware/__init__.py",
      "content": "class Middleware:\n    def __init__(\n        self,\n        cls: _MiddlewareFactory[P],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> None:\n        self.cls = cls\n        self.args = args\n        self.kwargs = kwargs\n\n    def __iter__(self) -> Iterator[Any]:\n        as_tuple = (self.cls, self.args, self.kwargs)\n        return iter(as_tuple)\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        args_strings = [f\"{value!r}\" for value in self.args]\n        option_strings = [f\"{key}={value!r}\" for key, value in self.kwargs.items()]\n        name = getattr(self.cls, \"__name__\", \"\")\n        args_repr = \", \".join([name] + args_strings + option_strings)\n        return f\"{class_name}({args_repr})\""
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/starlette/starlette/middleware/base.py",
      "content": "from __future__ import annotations\n\nimport typing\n\nimport anyio\n\nfrom starlette._utils import collapse_excgroups\nfrom starlette.requests import ClientDisconnect, Request\nfrom starlette.responses import AsyncContentStream, Response\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\n\nRequestResponseEndpoint = typing.Callable[[Request], typing.Awaitable[Response]]\nDispatchFunction = typing.Callable[[Request, RequestResponseEndpoint], typing.Awaitable[Response]]\nT = typing.TypeVar(\"T\")"
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/starlette/starlette/middleware/base.py",
      "content": "class _CachedRequest(Request):\n    \"\"\"\n    If the user calls Request.body() from their dispatch function\n    we cache the entire request body in memory and pass that to downstream middlewares,\n    but if they call Request.stream() then all we do is send an\n    empty body so that downstream things don't hang forever.\n    \"\"\"\n\n    def __init__(self, scope: Scope, receive: Receive):\n        super().__init__(scope, receive)\n        self._wrapped_rcv_disconnected = False\n        self._wrapped_rcv_consumed = False\n        self._wrapped_rc_stream = self.stream()\n\n    async def wrapped_receive(self) -> Message:\n        # wrapped_rcv state 1: disconnected\n        if self._wrapped_rcv_disconnected:\n            return {\"type\": \"http.disconnect\"}\n        # wrapped_rcv state 1: consumed but not yet disconnected\n        if self._wrapped_rcv_consumed:\n            if self._is_disconnected:\n                self._wrapped_rcv_disconnected = True\n                return {\"type\": \"http.disconnect\"}\n            msg = await self.receive()\n            if msg[\"type\"] != \"http.disconnect\":  # pragma: no cover\n                raise RuntimeError(f\"Unexpected message received: {msg['type']}\")\n            self._wrapped_rcv_disconnected = True\n            return msg\n\n        # wrapped_rcv state 3: not yet consumed\n        if getattr(self, \"_body\", None) is not None:\n            self._wrapped_rcv_consumed = True\n            return {\n                \"type\": \"http.request\",\n                \"body\": self._body,\n                \"more_body\": False,\n            }\n        elif self._stream_consumed:\n            self._wrapped_rcv_consumed = True\n            return {\n                \"type\": \"http.request\",\n                \"body\": b\"\",\n                \"more_body\": False,\n            }\n        else:\n            try:\n                stream = self.stream()\n                chunk = await stream.__anext__()\n                self._wrapped_rcv_consumed = self._stream_consumed\n                return {\n                    \"type\": \"http.request\",\n                    \"body\": chunk,\n                    \"more_body\": not self._stream_consumed,\n                }\n            except ClientDisconnect:\n                self._wrapped_rcv_disconnected = True\n                return {\"type\": \"http.disconnect\"}"
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/starlette/starlette/middleware/base.py",
      "content": "class BaseHTTPMiddleware:\n    def __init__(self, app: ASGIApp, dispatch: DispatchFunction | None = None) -> None:\n        self.app = app\n        self.dispatch_func = self.dispatch if dispatch is None else dispatch\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        request = _CachedRequest(scope, receive)\n        wrapped_receive = request.wrapped_receive\n        response_sent = anyio.Event()\n\n        async def call_next(request: Request) -> Response:\n            app_exc: Exception | None = None\n\n            async def receive_or_disconnect() -> Message:\n                if response_sent.is_set():\n                    return {\"type\": \"http.disconnect\"}\n\n                async with anyio.create_task_group() as task_group:\n\n                    async def wrap(func: typing.Callable[[], typing.Awaitable[T]]) -> T:\n                        result = await func()\n                        task_group.cancel_scope.cancel()\n                        return result\n\n                    task_group.start_soon(wrap, response_sent.wait)\n                    message = await wrap(wrapped_receive)\n\n                if response_sent.is_set():\n                    return {\"type\": \"http.disconnect\"}\n\n                return message\n\n            async def send_no_error(message: Message) -> None:\n                try:\n                    await send_stream.send(message)\n                except anyio.BrokenResourceError:\n                    return\n\n            async def coro() -> None:\n                nonlocal app_exc\n\n                with send_stream:\n                    try:\n                        await self.app(scope, receive_or_disconnect, send_no_error)\n                    except Exception as exc:\n                        app_exc = exc\n\n            task_group.start_soon(coro)\n\n            try:\n                message = await recv_stream.receive()\n                info = message.get(\"info\", None)\n                if message[\"type\"] == \"http.response.debug\" and info is not None:\n                    message = await recv_stream.receive()\n            except anyio.EndOfStream:\n                if app_exc is not None:\n                    raise app_exc\n                raise RuntimeError(\"No response returned.\")\n\n            assert message[\"type\"] == \"http.response.start\"\n\n            async def body_stream() -> typing.AsyncGenerator[bytes, None]:\n                async for message in recv_stream:\n                    assert message[\"type\"] == \"http.response.body\"\n                    body = message.get(\"body\", b\"\")\n                    if body:\n                        yield body\n                    if not message.get(\"more_body\", False):\n                        break\n\n                if app_exc is not None:\n                    raise app_exc\n\n            response = _StreamingResponse(status_code=message[\"status\"], content=body_stream(), info=info)\n            response.raw_headers = message[\"headers\"]\n            return response\n\n        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()\n        send_stream, recv_stream = streams\n        with recv_stream, send_stream, collapse_excgroups():\n            async with anyio.create_task_group() as task_group:\n                response = await self.dispatch_func(request, call_next)\n                await response(scope, wrapped_receive, send)\n                response_sent.set()\n                recv_stream.close()\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n        raise NotImplementedError()  # pragma: no cover"
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/starlette/starlette/middleware/base.py",
      "content": "class _StreamingResponse(Response):\n    def __init__(\n        self,\n        content: AsyncContentStream,\n        status_code: int = 200,\n        headers: typing.Mapping[str, str] | None = None,\n        media_type: str | None = None,\n        info: typing.Mapping[str, typing.Any] | None = None,\n    ) -> None:\n        self.info = info\n        self.body_iterator = content\n        self.status_code = status_code\n        self.media_type = media_type\n        self.init_headers(headers)\n        self.background = None\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.info is not None:\n            await send({\"type\": \"http.response.debug\", \"info\": self.info})\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": self.status_code,\n                \"headers\": self.raw_headers,\n            }\n        )\n\n        async for chunk in self.body_iterator:\n            await send({\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": True})\n\n        await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n\n        if self.background:\n            await self.background()"
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/starlette/starlette/middleware/trustedhost.py",
      "content": "from __future__ import annotations\n\nimport typing\n\nfrom starlette.datastructures import URL, Headers\nfrom starlette.responses import PlainTextResponse, RedirectResponse, Response\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nENFORCE_DOMAIN_WILDCARD = \"Domain wildcard patterns must be like '*.example.com'.\""
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/starlette/starlette/middleware/trustedhost.py",
      "content": "class TrustedHostMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        allowed_hosts: typing.Sequence[str] | None = None,\n        www_redirect: bool = True,\n    ) -> None:\n        if allowed_hosts is None:\n            allowed_hosts = [\"*\"]\n\n        for pattern in allowed_hosts:\n            assert \"*\" not in pattern[1:], ENFORCE_DOMAIN_WILDCARD\n            if pattern.startswith(\"*\") and pattern != \"*\":\n                assert pattern.startswith(\"*.\"), ENFORCE_DOMAIN_WILDCARD\n        self.app = app\n        self.allowed_hosts = list(allowed_hosts)\n        self.allow_any = \"*\" in allowed_hosts\n        self.www_redirect = www_redirect\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.allow_any or scope[\"type\"] not in (\n            \"http\",\n            \"websocket\",\n        ):  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n\n        headers = Headers(scope=scope)\n        host = headers.get(\"host\", \"\").split(\":\")[0]\n        is_valid_host = False\n        found_www_redirect = False\n        for pattern in self.allowed_hosts:\n            if host == pattern or (pattern.startswith(\"*\") and host.endswith(pattern[1:])):\n                is_valid_host = True\n                break\n            elif \"www.\" + host == pattern:\n                found_www_redirect = True\n\n        if is_valid_host:\n            await self.app(scope, receive, send)\n        else:\n            response: Response\n            if found_www_redirect and self.www_redirect:\n                url = URL(scope=scope)\n                redirect_url = url.replace(netloc=\"www.\" + url.netloc)\n                response = RedirectResponse(url=str(redirect_url))\n            else:\n                response = PlainTextResponse(\"Invalid host header\", status_code=400)\n            await response(scope, receive, send)"
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/starlette/starlette/middleware/gzip.py",
      "content": "import gzip\nimport io\nimport typing\n\nfrom starlette.datastructures import Headers, MutableHeaders\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send"
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/starlette/starlette/middleware/gzip.py",
      "content": "class GZipMiddleware:\n    def __init__(self, app: ASGIApp, minimum_size: int = 500, compresslevel: int = 9) -> None:\n        self.app = app\n        self.minimum_size = minimum_size\n        self.compresslevel = compresslevel\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] == \"http\":  # pragma: no branch\n            headers = Headers(scope=scope)\n            if \"gzip\" in headers.get(\"Accept-Encoding\", \"\"):\n                responder = GZipResponder(self.app, self.minimum_size, compresslevel=self.compresslevel)\n                await responder(scope, receive, send)\n                return\n        await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/starlette/starlette/middleware/gzip.py",
      "content": "class GZipResponder:\n    def __init__(self, app: ASGIApp, minimum_size: int, compresslevel: int = 9) -> None:\n        self.app = app\n        self.minimum_size = minimum_size\n        self.send: Send = unattached_send\n        self.initial_message: Message = {}\n        self.started = False\n        self.content_encoding_set = False\n        self.gzip_buffer = io.BytesIO()\n        self.gzip_file = gzip.GzipFile(mode=\"wb\", fileobj=self.gzip_buffer, compresslevel=compresslevel)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        self.send = send\n        with self.gzip_buffer, self.gzip_file:\n            await self.app(scope, receive, self.send_with_gzip)\n\n    async def send_with_gzip(self, message: Message) -> None:\n        message_type = message[\"type\"]\n        if message_type == \"http.response.start\":\n            self.initial_message = message\n            headers = Headers(raw=self.initial_message[\"headers\"])\n            self.content_encoding_set = \"content-encoding\" in headers\n        elif message_type == \"http.response.body\" and self.content_encoding_set:\n            if not self.started:\n                self.started = True\n                await self.send(self.initial_message)\n            await self.send(message)\n        elif message_type == \"http.response.body\" and not self.started:\n            self.started = True\n            body = message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n            if len(body) < self.minimum_size and not more_body:\n                await self.send(self.initial_message)\n                await self.send(message)\n            elif not more_body:\n                self.gzip_file.write(body)\n                self.gzip_file.close()\n                body = self.gzip_buffer.getvalue()\n\n                headers = MutableHeaders(raw=self.initial_message[\"headers\"])\n                headers[\"Content-Encoding\"] = \"gzip\"\n                headers[\"Content-Length\"] = str(len(body))\n                headers.add_vary_header(\"Accept-Encoding\")\n                message[\"body\"] = body\n\n                await self.send(self.initial_message)\n                await self.send(message)\n            else:\n                headers = MutableHeaders(raw=self.initial_message[\"headers\"])\n                headers[\"Content-Encoding\"] = \"gzip\"\n                headers.add_vary_header(\"Accept-Encoding\")\n                del headers[\"Content-Length\"]\n\n                self.gzip_file.write(body)\n                message[\"body\"] = self.gzip_buffer.getvalue()\n                self.gzip_buffer.seek(0)\n                self.gzip_buffer.truncate()\n\n                await self.send(self.initial_message)\n                await self.send(message)\n\n        elif message_type == \"http.response.body\":  # pragma: no branch\n            body = message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n\n            self.gzip_file.write(body)\n            if not more_body:\n                self.gzip_file.close()\n\n            message[\"body\"] = self.gzip_buffer.getvalue()\n            self.gzip_buffer.seek(0)\n            self.gzip_buffer.truncate()\n\n            await self.send(message)"
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/starlette/starlette/middleware/gzip.py",
      "content": "async def unattached_send(message: Message) -> typing.NoReturn:\n    raise RuntimeError(\"send awaitable not set\")  # pragma: no cover"
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/starlette/starlette/middleware/sessions.py",
      "content": "from __future__ import annotations\n\nimport json\nimport typing\nfrom base64 import b64decode, b64encode\n\nimport itsdangerous\nfrom itsdangerous.exc import BadSignature\n\nfrom starlette.datastructures import MutableHeaders, Secret\nfrom starlette.requests import HTTPConnection\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send"
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/starlette/starlette/middleware/sessions.py",
      "content": "class SessionMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        secret_key: str | Secret,\n        session_cookie: str = \"session\",\n        max_age: int | None = 14 * 24 * 60 * 60,  # 14 days, in seconds\n        path: str = \"/\",\n        same_site: typing.Literal[\"lax\", \"strict\", \"none\"] = \"lax\",\n        https_only: bool = False,\n        domain: str | None = None,\n    ) -> None:\n        self.app = app\n        self.signer = itsdangerous.TimestampSigner(str(secret_key))\n        self.session_cookie = session_cookie\n        self.max_age = max_age\n        self.path = path\n        self.security_flags = \"httponly; samesite=\" + same_site\n        if https_only:  # Secure flag can be used with HTTPS only\n            self.security_flags += \"; secure\"\n        if domain is not None:\n            self.security_flags += f\"; domain={domain}\"\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] not in (\"http\", \"websocket\"):  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n\n        connection = HTTPConnection(scope)\n        initial_session_was_empty = True\n\n        if self.session_cookie in connection.cookies:\n            data = connection.cookies[self.session_cookie].encode(\"utf-8\")\n            try:\n                data = self.signer.unsign(data, max_age=self.max_age)\n                scope[\"session\"] = json.loads(b64decode(data))\n                initial_session_was_empty = False\n            except BadSignature:\n                scope[\"session\"] = {}\n        else:\n            scope[\"session\"] = {}\n\n        async def send_wrapper(message: Message) -> None:\n            if message[\"type\"] == \"http.response.start\":\n                if scope[\"session\"]:\n                    # We have session data to persist.\n                    data = b64encode(json.dumps(scope[\"session\"]).encode(\"utf-8\"))\n                    data = self.signer.sign(data)\n                    headers = MutableHeaders(scope=message)\n                    header_value = \"{session_cookie}={data}; path={path}; {max_age}{security_flags}\".format(\n                        session_cookie=self.session_cookie,\n                        data=data.decode(\"utf-8\"),\n                        path=self.path,\n                        max_age=f\"Max-Age={self.max_age}; \" if self.max_age else \"\",\n                        security_flags=self.security_flags,\n                    )\n                    headers.append(\"Set-Cookie\", header_value)\n                elif not initial_session_was_empty:\n                    # The session has been cleared.\n                    headers = MutableHeaders(scope=message)\n                    header_value = \"{session_cookie}={data}; path={path}; {expires}{security_flags}\".format(\n                        session_cookie=self.session_cookie,\n                        data=\"null\",\n                        path=self.path,\n                        expires=\"expires=Thu, 01 Jan 1970 00:00:00 GMT; \",\n                        security_flags=self.security_flags,\n                    )\n                    headers.append(\"Set-Cookie\", header_value)\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)"
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/starlette/starlette/middleware/authentication.py",
      "content": "from __future__ import annotations\n\nimport typing\n\nfrom starlette.authentication import (\n    AuthCredentials,\n    AuthenticationBackend,\n    AuthenticationError,\n    UnauthenticatedUser,\n)\nfrom starlette.requests import HTTPConnection\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import ASGIApp, Receive, Scope, Send"
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/starlette/starlette/middleware/authentication.py",
      "content": "class AuthenticationMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        backend: AuthenticationBackend,\n        on_error: typing.Callable[[HTTPConnection, AuthenticationError], Response] | None = None,\n    ) -> None:\n        self.app = app\n        self.backend = backend\n        self.on_error: typing.Callable[[HTTPConnection, AuthenticationError], Response] = (\n            on_error if on_error is not None else self.default_on_error\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] not in [\"http\", \"websocket\"]:\n            await self.app(scope, receive, send)\n            return\n\n        conn = HTTPConnection(scope)\n        try:\n            auth_result = await self.backend.authenticate(conn)\n        except AuthenticationError as exc:\n            response = self.on_error(conn, exc)\n            if scope[\"type\"] == \"websocket\":\n                await send({\"type\": \"websocket.close\", \"code\": 1000})\n            else:\n                await response(scope, receive, send)\n            return\n\n        if auth_result is None:\n            auth_result = AuthCredentials(), UnauthenticatedUser()\n        scope[\"auth\"], scope[\"user\"] = auth_result\n        await self.app(scope, receive, send)\n\n    @staticmethod\n    def default_on_error(conn: HTTPConnection, exc: Exception) -> Response:\n        return PlainTextResponse(str(exc), status_code=400)"
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/starlette/starlette/middleware/wsgi.py",
      "content": "from __future__ import annotations\n\nimport io\nimport math\nimport sys\nimport typing\nimport warnings\n\nimport anyio\nfrom anyio.abc import ObjectReceiveStream, ObjectSendStream\n\nfrom starlette.types import Receive, Scope, Send\n\nwarnings.warn(\n    \"starlette.middleware.wsgi is deprecated and will be removed in a future release. \"\n    \"Please refer to https://github.com/abersheeran/a2wsgi as a replacement.\",\n    DeprecationWarning,\n)"
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/starlette/starlette/middleware/wsgi.py",
      "content": "def build_environ(scope: Scope, body: bytes) -> dict[str, typing.Any]:\n    \"\"\"\n    Builds a scope and request body into a WSGI environ object.\n    \"\"\"\n\n    script_name = scope.get(\"root_path\", \"\").encode(\"utf8\").decode(\"latin1\")\n    path_info = scope[\"path\"].encode(\"utf8\").decode(\"latin1\")\n    if path_info.startswith(script_name):\n        path_info = path_info[len(script_name) :]\n\n    environ = {\n        \"REQUEST_METHOD\": scope[\"method\"],\n        \"SCRIPT_NAME\": script_name,\n        \"PATH_INFO\": path_info,\n        \"QUERY_STRING\": scope[\"query_string\"].decode(\"ascii\"),\n        \"SERVER_PROTOCOL\": f\"HTTP/{scope['http_version']}\",\n        \"wsgi.version\": (1, 0),\n        \"wsgi.url_scheme\": scope.get(\"scheme\", \"http\"),\n        \"wsgi.input\": io.BytesIO(body),\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multithread\": True,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.run_once\": False,\n    }\n\n    # Get server name and port - required in WSGI, not in ASGI\n    server = scope.get(\"server\") or (\"localhost\", 80)\n    environ[\"SERVER_NAME\"] = server[0]\n    environ[\"SERVER_PORT\"] = server[1]\n\n    # Get client IP address\n    if scope.get(\"client\"):\n        environ[\"REMOTE_ADDR\"] = scope[\"client\"][0]\n\n    # Go through headers and make them into environ entries\n    for name, value in scope.get(\"headers\", []):\n        name = name.decode(\"latin1\")\n        if name == \"content-length\":\n            corrected_name = \"CONTENT_LENGTH\"\n        elif name == \"content-type\":\n            corrected_name = \"CONTENT_TYPE\"\n        else:\n            corrected_name = f\"HTTP_{name}\".upper().replace(\"-\", \"_\")\n        # HTTPbis say only ASCII chars are allowed in headers, but we latin1 just in\n        # case\n        value = value.decode(\"latin1\")\n        if corrected_name in environ:\n            value = environ[corrected_name] + \",\" + value\n        environ[corrected_name] = value\n    return environ"
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/starlette/starlette/middleware/wsgi.py",
      "content": "class WSGIMiddleware:\n    def __init__(self, app: typing.Callable[..., typing.Any]) -> None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] == \"http\"\n        responder = WSGIResponder(self.app, scope)\n        await responder(receive, send)"
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/starlette/starlette/middleware/wsgi.py",
      "content": "class WSGIResponder:\n    stream_send: ObjectSendStream[typing.MutableMapping[str, typing.Any]]\n    stream_receive: ObjectReceiveStream[typing.MutableMapping[str, typing.Any]]\n\n    def __init__(self, app: typing.Callable[..., typing.Any], scope: Scope) -> None:\n        self.app = app\n        self.scope = scope\n        self.status = None\n        self.response_headers = None\n        self.stream_send, self.stream_receive = anyio.create_memory_object_stream(math.inf)\n        self.response_started = False\n        self.exc_info: typing.Any = None\n\n    async def __call__(self, receive: Receive, send: Send) -> None:\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await receive()\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n        environ = build_environ(self.scope, body)\n\n        async with anyio.create_task_group() as task_group:\n            task_group.start_soon(self.sender, send)\n            async with self.stream_send:\n                await anyio.to_thread.run_sync(self.wsgi, environ, self.start_response)\n        if self.exc_info is not None:\n            raise self.exc_info[0].with_traceback(self.exc_info[1], self.exc_info[2])\n\n    async def sender(self, send: Send) -> None:\n        async with self.stream_receive:\n            async for message in self.stream_receive:\n                await send(message)\n\n    def start_response(\n        self,\n        status: str,\n        response_headers: list[tuple[str, str]],\n        exc_info: typing.Any = None,\n    ) -> None:\n        self.exc_info = exc_info\n        if not self.response_started:  # pragma: no branch\n            self.response_started = True\n            status_code_string, _ = status.split(\" \", 1)\n            status_code = int(status_code_string)\n            headers = [\n                (name.strip().encode(\"ascii\").lower(), value.strip().encode(\"ascii\"))\n                for name, value in response_headers\n            ]\n            anyio.from_thread.run(\n                self.stream_send.send,\n                {\n                    \"type\": \"http.response.start\",\n                    \"status\": status_code,\n                    \"headers\": headers,\n                },\n            )\n\n    def wsgi(\n        self,\n        environ: dict[str, typing.Any],\n        start_response: typing.Callable[..., typing.Any],\n    ) -> None:\n        for chunk in self.app(environ, start_response):\n            anyio.from_thread.run(\n                self.stream_send.send,\n                {\"type\": \"http.response.body\", \"body\": chunk, \"more_body\": True},\n            )\n\n        anyio.from_thread.run(self.stream_send.send, {\"type\": \"http.response.body\", \"body\": b\"\"})"
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/starlette/starlette/middleware/cors.py",
      "content": "from __future__ import annotations\n\nimport functools\nimport re\nimport typing\n\nfrom starlette.datastructures import Headers, MutableHeaders\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\n\nALL_METHODS = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")\nSAFELISTED_HEADERS = {\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"}"
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/starlette/starlette/middleware/cors.py",
      "content": "class CORSMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        allow_origins: typing.Sequence[str] = (),\n        allow_methods: typing.Sequence[str] = (\"GET\",),\n        allow_headers: typing.Sequence[str] = (),\n        allow_credentials: bool = False,\n        allow_origin_regex: str | None = None,\n        expose_headers: typing.Sequence[str] = (),\n        max_age: int = 600,\n    ) -> None:\n        if \"*\" in allow_methods:\n            allow_methods = ALL_METHODS\n\n        compiled_allow_origin_regex = None\n        if allow_origin_regex is not None:\n            compiled_allow_origin_regex = re.compile(allow_origin_regex)\n\n        allow_all_origins = \"*\" in allow_origins\n        allow_all_headers = \"*\" in allow_headers\n        preflight_explicit_allow_origin = not allow_all_origins or allow_credentials\n\n        simple_headers = {}\n        if allow_all_origins:\n            simple_headers[\"Access-Control-Allow-Origin\"] = \"*\"\n        if allow_credentials:\n            simple_headers[\"Access-Control-Allow-Credentials\"] = \"true\"\n        if expose_headers:\n            simple_headers[\"Access-Control-Expose-Headers\"] = \", \".join(expose_headers)\n\n        preflight_headers = {}\n        if preflight_explicit_allow_origin:\n            preflight_headers[\"Vary\"] = \"Origin\"\n        else:\n            preflight_headers[\"Access-Control-Allow-Origin\"] = \"*\"\n        preflight_headers.update(\n            {\n                \"Access-Control-Allow-Methods\": \", \".join(allow_methods),\n                \"Access-Control-Max-Age\": str(max_age),\n            }\n        )\n        allow_headers = sorted(SAFELISTED_HEADERS | set(allow_headers))\n        if allow_headers and not allow_all_headers:\n            preflight_headers[\"Access-Control-Allow-Headers\"] = \", \".join(allow_headers)\n        if allow_credentials:\n            preflight_headers[\"Access-Control-Allow-Credentials\"] = \"true\"\n\n        self.app = app\n        self.allow_origins = allow_origins\n        self.allow_methods = allow_methods\n        self.allow_headers = [h.lower() for h in allow_headers]\n        self.allow_all_origins = allow_all_origins\n        self.allow_all_headers = allow_all_headers\n        self.preflight_explicit_allow_origin = preflight_explicit_allow_origin\n        self.allow_origin_regex = compiled_allow_origin_regex\n        self.simple_headers = simple_headers\n        self.preflight_headers = preflight_headers\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n\n        method = scope[\"method\"]\n        headers = Headers(scope=scope)\n        origin = headers.get(\"origin\")\n\n        if origin is None:\n            await self.app(scope, receive, send)\n            return\n\n        if method == \"OPTIONS\" and \"access-control-request-method\" in headers:\n            response = self.preflight_response(request_headers=headers)\n            await response(scope, receive, send)\n            return\n\n        await self.simple_response(scope, receive, send, request_headers=headers)\n\n    def is_allowed_origin(self, origin: str) -> bool:\n        if self.allow_all_origins:\n            return True\n\n        if self.allow_origin_regex is not None and self.allow_origin_regex.fullmatch(origin):\n            return True\n\n        return origin in self.allow_origins\n\n    def preflight_response(self, request_headers: Headers) -> Response:\n        requested_origin = request_headers[\"origin\"]\n        requested_method = request_headers[\"access-control-request-method\"]\n        requested_headers = request_headers.get(\"access-control-request-headers\")\n\n        headers = dict(self.preflight_headers)\n        failures = []\n\n        if self.is_allowed_origin(origin=requested_origin):\n            if self.preflight_explicit_allow_origin:\n                headers[\"Access-Control-Allow-Origin\"] = requested_origin\n        else:\n            failures.append(\"origin\")\n\n        if requested_method not in self.allow_methods:\n            failures.append(\"method\")\n\n        if self.allow_all_headers and requested_headers is not None:\n            headers[\"Access-Control-Allow-Headers\"] = requested_headers\n        elif requested_headers is not None:\n            for header in [h.lower() for h in requested_headers.split(\",\")]:\n                if header.strip() not in self.allow_headers:\n                    failures.append(\"headers\")\n                    break\n\n        if failures:\n            failure_text = \"Disallowed CORS \" + \", \".join(failures)\n            return PlainTextResponse(failure_text, status_code=400, headers=headers)\n\n        return PlainTextResponse(\"OK\", status_code=200, headers=headers)\n\n    async def simple_response(self, scope: Scope, receive: Receive, send: Send, request_headers: Headers) -> None:\n        send = functools.partial(self.send, send=send, request_headers=request_headers)\n        await self.app(scope, receive, send)\n\n    async def send(self, message: Message, send: Send, request_headers: Headers) -> None:\n        if message[\"type\"] != \"http.response.start\":\n            await send(message)\n            return\n\n        message.setdefault(\"headers\", [])\n        headers = MutableHeaders(scope=message)\n        headers.update(self.simple_headers)\n        origin = request_headers[\"Origin\"]\n        has_cookie = \"cookie\" in request_headers\n\n        if self.allow_all_origins and has_cookie:\n            self.allow_explicit_origin(headers, origin)\n\n        elif not self.allow_all_origins and self.is_allowed_origin(origin=origin):\n            self.allow_explicit_origin(headers, origin)\n\n        await send(message)\n\n    @staticmethod\n    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:\n        headers[\"Access-Control-Allow-Origin\"] = origin\n        headers.add_vary_header(\"Origin\")"
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/starlette/starlette/middleware/exceptions.py",
      "content": "```python\nfrom __future__ import annotations\n\nimport typing\n\nfrom starlette._exception_handler import (\n    ExceptionHandlers,\n    StatusHandlers,\n    wrap_app_handling_exceptions,\n)\nfrom starlette.exceptions import HTTPException, WebSocketException\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import ASGIApp, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n```"
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/starlette/starlette/middleware/exceptions.py",
      "content": "```python\nclass ExceptionMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        handlers: typing.Mapping[typing.Any, typing.Callable[[Request, Exception], Response]] | None = None,\n        debug: bool = False,\n    ) -> None:\n        self.app = app\n        self.debug = debug  # TODO: We ought to handle 404 cases if debug is set.\n        self._status_handlers: StatusHandlers = {}\n        self._exception_handlers: ExceptionHandlers = {\n            HTTPException: self.http_exception,\n            WebSocketException: self.websocket_exception,\n        }\n        if handlers is not None:  # pragma: no branch\n            for key, value in handlers.items():\n                self.add_exception_handler(key, value)\n\n    def add_exception_handler(\n        self,\n        exc_class_or_status_code: int | type[Exception],\n        handler: typing.Callable[[Request, Exception], Response],\n    ) -> None:\n        if isinstance(exc_class_or_status_code, int):\n            self._status_handlers[exc_class_or_status_code] = handler\n        else:\n            assert issubclass(exc_class_or_status_code, Exception)\n            self._exception_handlers[exc_class_or_status_code] = handler\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] not in (\"http\", \"websocket\"):\n            await self.app(scope, receive, send)\n            return\n\n        scope[\"starlette.exception_handlers\"] = (\n            self._exception_handlers,\n            self._status_handlers,\n        )\n\n        conn: Request | WebSocket\n        if scope[\"type\"] == \"http\":\n            conn = Request(scope, receive, send)\n        else:\n            conn = WebSocket(scope, receive, send)\n\n        await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)\n\n    def http_exception(self, request: Request, exc: Exception) -> Response:\n        assert isinstance(exc, HTTPException)\n        if exc.status_code in {204, 304}:\n            return Response(status_code=exc.status_code, headers=exc.headers)\n        return PlainTextResponse(exc.detail, status_code=exc.status_code, headers=exc.headers)\n\n    async def websocket_exception(self, websocket: WebSocket, exc: Exception) -> None:\n        assert isinstance(exc, WebSocketException)\n        await websocket.close(code=exc.code, reason=exc.reason)  # pragma: no cover\n```"
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/starlette/starlette/middleware/httpsredirect.py",
      "content": "from starlette.datastructures import URL\nfrom starlette.responses import RedirectResponse\nfrom starlette.types import ASGIApp, Receive, Scope, Send"
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/starlette/starlette/middleware/httpsredirect.py",
      "content": "class HTTPSRedirectMiddleware:\n    def __init__(self, app: ASGIApp) -> None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] in (\"http\", \"websocket\") and scope[\"scheme\"] in (\"http\", \"ws\"):\n            url = URL(scope=scope)\n            redirect_scheme = {\"http\": \"https\", \"ws\": \"wss\"}[url.scheme]\n            netloc = url.hostname if url.port in (80, 443) else url.netloc\n            url = url.replace(scheme=redirect_scheme, netloc=netloc)\n            response = RedirectResponse(url, status_code=307)\n            await response(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "from __future__ import annotations\n\nimport html\nimport inspect\nimport sys\nimport traceback\nimport typing\n\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, PlainTextResponse, Response\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send"
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "STYLES = \"\"\"\np {\n    color: #211c1c;\n}\n.traceback-container {\n    border: 1px solid #038BB8;\n}\n.traceback-title {\n    background-color: #038BB8;\n    color: lemonchiffon;\n    padding: 12px;\n    font-size: 20px;\n    margin-top: 0px;\n}\n.frame-line {\n    padding-left: 10px;\n    font-family: monospace;\n}\n.frame-filename {\n    font-family: monospace;\n}\n.center-line {\n    background-color: #038BB8;\n    color: #f9f6e1;\n    padding: 5px 0px 5px 5px;\n}\n.lineno {\n    margin-right: 5px;\n}\n.frame-title {\n    font-weight: unset;\n    padding: 10px 10px 10px 10px;\n    background-color: #E4F4FD;\n    margin-right: 10px;\n    color: #191f21;\n    font-size: 17px;\n    border: 1px solid #c7dce8;\n}\n.collapse-btn {\n    float: right;\n    padding: 0px 5px 1px 5px;\n    border: solid 1px #96aebb;\n    cursor: pointer;\n}\n.collapsed {\n  display: none;\n}\n.source-code {\n  font-family: courier;\n  font-size: small;\n  padding-bottom: 10px;\n}\n\"\"\""
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "JS = \"\"\"\n<script type=\"text/javascript\">\n    function collapse(element){\n        const frameId = element.getAttribute(\"data-frame-id\");\n        const frame = document.getElementById(frameId);\n\n        if (frame.classList.contains(\"collapsed\")){\n            element.innerHTML = \"&#8210;\";\n            frame.classList.remove(\"collapsed\");\n        } else {\n            element.innerHTML = \"+\";\n            frame.classList.add(\"collapsed\");\n        }\n    }\n</script>\n\"\"\""
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "TEMPLATE = \"\"\"\n<html>\n    <head>\n        <style type='text/css'>\n            {styles}\n        </style>\n        <title>Starlette Debugger</title>\n    </head>\n    <body>\n        <h1>500 Server Error</h1>\n        <h2>{error}</h2>\n        <div class=\"traceback-container\">\n            <p class=\"traceback-title\">Traceback</p>\n            <div>{exc_html}</div>\n        </div>\n        {js}\n    </body>\n</html>\n\"\"\""
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "FRAME_TEMPLATE = \"\"\"\n<div>\n    <p class=\"frame-title\">File <span class=\"frame-filename\">{frame_filename}</span>,\n    line <i>{frame_lineno}</i>,\n    in <b>{frame_name}</b>\n    <span class=\"collapse-btn\" data-frame-id=\"{frame_filename}-{frame_lineno}\" onclick=\"collapse(this)\">{collapse_button}</span>\n    </p>\n    <div id=\"{frame_filename}-{frame_lineno}\" class=\"source-code {collapsed}\">{code_context}</div>\n</div>\n\"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "LINE = \"\"\"\n<p><span class=\"frame-line\">\n<span class=\"lineno\">{lineno}.</span> {line}</span></p>\n\"\"\""
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "CENTER_LINE = \"\"\"\n<p class=\"center-line\"><span class=\"frame-line center-line\">\n<span class=\"lineno\">{lineno}.</span> {line}</span></p>\n\"\"\""
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/starlette/starlette/middleware/errors.py",
      "content": "class ServerErrorMiddleware:\n    \"\"\"\n    Handles returning 500 responses when a server error occurs.\n\n    If 'debug' is set, then traceback responses will be returned,\n    otherwise the designated 'handler' will be called.\n\n    This middleware class should generally be used to wrap *everything*\n    else up, so that unhandled exceptions anywhere in the stack\n    always result in an appropriate 500 response.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        handler: typing.Callable[[Request, Exception], typing.Any] | None = None,\n        debug: bool = False,\n    ) -> None:\n        self.app = app\n        self.handler = handler\n        self.debug = debug\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        response_started = False\n\n        async def _send(message: Message) -> None:\n            nonlocal response_started, send\n\n            if message[\"type\"] == \"http.response.start\":\n                response_started = True\n            await send(message)\n\n        try:\n            await self.app(scope, receive, _send)\n        except Exception as exc:\n            request = Request(scope)\n            if self.debug:\n                # In debug mode, return traceback responses.\n                response = self.debug_response(request, exc)\n            elif self.handler is None:\n                # Use our default 500 error handler.\n                response = self.error_response(request, exc)\n            else:\n                # Use an installed 500 error handler.\n                if is_async_callable(self.handler):\n                    response = await self.handler(request, exc)\n                else:\n                    response = await run_in_threadpool(self.handler, request, exc)\n\n            if not response_started:\n                await response(scope, receive, send)\n\n            # We always continue to raise the exception.\n            # This allows servers to log the error, or allows test clients\n            # to optionally raise the error within the test case.\n            raise exc\n\n    def format_line(self, index: int, line: str, frame_lineno: int, frame_index: int) -> str:\n        values = {\n            # HTML escape - line could contain < or >\n            \"line\": html.escape(line).replace(\" \", \"&nbsp\"),\n            \"lineno\": (frame_lineno - frame_index) + index,\n        }\n\n        if index != frame_index:\n            return LINE.format(**values)\n        return CENTER_LINE.format(**values)\n\n    def generate_frame_html(self, frame: inspect.FrameInfo, is_collapsed: bool) -> str:\n        code_context = \"\".join(\n            self.format_line(\n                index,\n                line,\n                frame.lineno,\n                frame.index,  # type: ignore[arg-type]\n            )\n            for index, line in enumerate(frame.code_context or [])\n        )\n\n        values = {\n            # HTML escape - filename could contain < or >, especially if it's a virtual\n            # file e.g. <stdin> in the REPL\n            \"frame_filename\": html.escape(frame.filename),\n            \"frame_lineno\": frame.lineno,\n            # HTML escape - if you try very hard it's possible to name a function with <\n            # or >\n            \"frame_name\": html.escape(frame.function),\n            \"code_context\": code_context,\n            \"collapsed\": \"collapsed\" if is_collapsed else \"\",\n            \"collapse_button\": \"+\" if is_collapsed else \"&#8210;\",\n        }\n        return FRAME_TEMPLATE.format(**values)\n\n    def generate_html(self, exc: Exception, limit: int = 7) -> str:\n        traceback_obj = traceback.TracebackException.from_exception(exc, capture_locals=True)\n\n        exc_html = \"\"\n        is_collapsed = False\n        exc_traceback = exc.__traceback__\n        if exc_traceback is not None:\n            frames = inspect.getinnerframes(exc_traceback, limit)\n            for frame in reversed(frames):\n                exc_html += self.generate_frame_html(frame, is_collapsed)\n                is_collapsed = True\n\n        if sys.version_info >= (3, 13):  # pragma: no cover\n            exc_type_str = traceback_obj.exc_type_str\n        else:  # pragma: no cover\n            exc_type_str = traceback_obj.exc_type.__name__\n\n        # escape error class and text\n        error = f\"{html.escape(exc_type_str)}: {html.escape(str(traceback_obj))}\"\n\n        return TEMPLATE.format(styles=STYLES, js=JS, error=error, exc_html=exc_html)\n\n    def generate_plain_text(self, exc: Exception) -> str:\n        return \"\".join(traceback.format_exception(type(exc), exc, exc.__traceback__))\n\n    def debug_response(self, request: Request, exc: Exception) -> Response:\n        accept = request.headers.get(\"accept\", \"\")\n\n        if \"text/html\" in accept:\n            content = self.generate_html(exc)\n            return HTMLResponse(content, status_code=500)\n        content = self.generate_plain_text(exc)\n        return PlainTextResponse(content, status_code=500)\n\n    def error_response(self, request: Request, exc: Exception) -> Response:\n        return PlainTextResponse(\"Internal Server Error\", status_code=500)"
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/starlette/tests/middleware/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/starlette/tests/middleware/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/starlette/tests/middleware/__init__.py",
      "content": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def display(self):\n        print(self.value)"
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/starlette/tests/middleware/__init__.py",
      "content": "class AnotherClass:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        print(f\"Hello, {self.name}!\")"
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/starlette/tests/middleware/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "from __future__ import annotations\n\nimport contextvars\nfrom collections.abc import AsyncGenerator, AsyncIterator, Generator\nfrom contextlib import AsyncExitStack\nfrom typing import Any\n\nimport anyio\nimport pytest\nfrom anyio.abc import TaskStatus\n\nfrom starlette.applications import Starlette\nfrom starlette.background import BackgroundTask\nfrom starlette.middleware import Middleware, _MiddlewareFactory\nfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint\nfrom starlette.requests import ClientDisconnect, Request\nfrom starlette.responses import PlainTextResponse, Response, StreamingResponse\nfrom starlette.routing import Route, WebSocketRoute\nfrom starlette.testclient import TestClient\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "class CustomMiddleware(BaseHTTPMiddleware):\n    async def dispatch(\n        self,\n        request: Request,\n        call_next: RequestResponseEndpoint,\n    ) -> Response:\n        response = await call_next(request)\n        response.headers[\"Custom-Header\"] = \"Example\"\n        return response"
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def homepage(request: Request) -> PlainTextResponse:\n    return PlainTextResponse(\"Homepage\")"
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def exc(request: Request) -> None:\n    raise Exception(\"Exc\")"
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def exc_stream(request: Request) -> StreamingResponse:\n    return StreamingResponse(_generate_faulty_stream())"
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def _generate_faulty_stream() -> Generator[bytes, None, None]:\n    yield b\"Ok\"\n    raise Exception(\"Faulty Stream\")"
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "class NoResponse:\n    def __init__(\n        self,\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ):\n        pass\n\n    def __await__(self) -> Generator[Any, None, None]:\n        return self.dispatch().__await__()\n\n    async def dispatch(self) -> None:\n        pass"
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "async def websocket_endpoint(session: WebSocket) -> None:\n    await session.accept()\n    await session.send_text(\"Hello, world!\")\n    await session.close()"
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "app = Starlette(\n    routes=[\n        Route(\"/\", endpoint=homepage),\n        Route(\"/exc\", endpoint=exc),\n        Route(\"/exc-stream\", endpoint=exc_stream),\n        Route(\"/no-response\", endpoint=NoResponse),\n        WebSocketRoute(\"/ws\", endpoint=websocket_endpoint),\n    ],\n    middleware=[Middleware(CustomMiddleware)],\n)"
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_custom_middleware(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"Custom-Header\"] == \"Example\"\n\n    with pytest.raises(Exception) as ctx:\n        response = client.get(\"/exc\")\n    assert str(ctx.value) == \"Exc\"\n\n    with pytest.raises(Exception) as ctx:\n        response = client.get(\"/exc-stream\")\n    assert str(ctx.value) == \"Faulty Stream\"\n\n    with pytest.raises(RuntimeError):\n        response = client.get(\"/no-response\")\n\n    with client.websocket_connect(\"/ws\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, world!\""
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_state_data_across_multiple_middlewares(\n    test_client_factory: TestClientFactory,\n) -> None:\n    expected_value1 = \"foo\"\n    expected_value2 = \"bar\"\n\n    class aMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            request.state.foo = expected_value1\n            response = await call_next(request)\n            return response\n\n    class bMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            request.state.bar = expected_value2\n            response = await call_next(request)\n            response.headers[\"X-State-Foo\"] = request.state.foo\n            return response\n\n    class cMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            response = await call_next(request)\n            response.headers[\"X-State-Bar\"] = request.state.bar\n            return response\n\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\")\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage)],\n        middleware=[\n            Middleware(aMiddleware),\n            Middleware(bMiddleware),\n            Middleware(cMiddleware),\n        ],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"OK\"\n    assert response.headers[\"X-State-Foo\"] == expected_value1\n    assert response.headers[\"X-State-Bar\"] == expected_value2"
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_app_middleware_argument(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\")\n\n    app = Starlette(routes=[Route(\"/\", homepage)], middleware=[Middleware(CustomMiddleware)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"Custom-Header\"] == \"Example\""
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_fully_evaluated_response(test_client_factory: TestClientFactory) -> None:\n    class CustomMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> PlainTextResponse:\n            await call_next(request)\n            return PlainTextResponse(\"Custom\")\n\n    app = Starlette(middleware=[Middleware(CustomMiddleware)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\""
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "ctxvar: contextvars.ContextVar[str] = contextvars.ContextVar(\"ctxvar\")"
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "class CustomMiddlewareWithoutBaseHTTPMiddleware:\n    def __init__(self, app: ASGIApp) -> None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        ctxvar.set(\"set by middleware\")\n        await self.app(scope, receive, send)\n        assert ctxvar.get() == \"set by endpoint\""
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "class CustomMiddlewareUsingBaseHTTPMiddleware(BaseHTTPMiddleware):\n    async def dispatch(\n        self,\n        request: Request,\n        call_next: RequestResponseEndpoint,\n    ) -> Response:\n        ctxvar.set(\"set by middleware\")\n        resp = await call_next(request)\n        assert ctxvar.get() == \"set by endpoint\"\n        return resp  # pragma: no cover"
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.parametrize(\n    \"middleware_cls\",\n    [\n        CustomMiddlewareWithoutBaseHTTPMiddleware,\n        pytest.param(\n            CustomMiddlewareUsingBaseHTTPMiddleware,\n            marks=pytest.mark.xfail(\n                reason=(\n                    \"BaseHTTPMiddleware creates a TaskGroup which copies the context\"\n                    \"and erases any changes to it made within the TaskGroup\"\n                ),\n                raises=AssertionError,\n            ),\n        ),\n    ],\n)\ndef test_contextvars(\n    test_client_factory: TestClientFactory,\n    middleware_cls: _MiddlewareFactory[Any],\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert ctxvar.get() == \"set by middleware\"\n        ctxvar.set(\"set by endpoint\")\n        return PlainTextResponse(\"Homepage\")\n\n    app = Starlette(middleware=[Middleware(middleware_cls)], routes=[Route(\"/\", homepage)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200, response.content"
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_run_background_tasks_even_if_client_disconnects() -> None:\n    response_complete = anyio.Event()\n    background_task_run = anyio.Event()\n\n    async def sleep_and_set() -> None:\n        await anyio.sleep(0.1)\n        background_task_run.set()\n\n    async def endpoint_with_background_task(_: Request) -> PlainTextResponse:\n        return PlainTextResponse(background=BackgroundTask(sleep_and_set))\n\n    async def passthrough(\n        request: Request,\n        call_next: RequestResponseEndpoint,\n    ) -> Response:\n        return await call_next(request)\n\n    app = Starlette(\n        middleware=[Middleware(BaseHTTPMiddleware, dispatch=passthrough)],\n        routes=[Route(\"/\", endpoint_with_background_task)],\n    )\n\n    scope = {\n        \"type\": \"http\",\n        \"version\": \"3\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n    }\n\n    async def receive() -> Message:\n        raise NotImplementedError(\"Should not be called!\")\n\n    async def send(message: Message) -> None:\n        if message[\"type\"] == \"http.response.body\":\n            if not message.get(\"more_body\", False):  # pragma: no branch\n                response_complete.set()\n\n    await app(scope, receive, send)\n\n    assert background_task_run.is_set()"
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_do_not_block_on_background_tasks() -> None:\n    response_complete = anyio.Event()\n    events: list[str | Message] = []\n\n    async def sleep_and_set() -> None:\n        events.append(\"Background task started\")\n        await anyio.sleep(0.1)\n        events.append(\"Background task finished\")\n\n    async def endpoint_with_background_task(_: Request) -> PlainTextResponse:\n        return PlainTextResponse(content=\"Hello\", background=BackgroundTask(sleep_and_set))\n\n    async def passthrough(request: Request, call_next: RequestResponseEndpoint) -> Response:\n        return await call_next(request)\n\n    app = Starlette(\n        middleware=[Middleware(BaseHTTPMiddleware, dispatch=passthrough)],\n        routes=[Route(\"/\", endpoint_with_background_task)],\n    )\n\n    scope = {\n        \"type\": \"http\",\n        \"version\": \"3\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n    }\n\n    async def receive() -> Message:\n        raise NotImplementedError(\"Should not be called!\")\n\n    async def send(message: Message) -> None:\n        if message[\"type\"] == \"http.response.body\":\n            events.append(message)\n            if not message.get(\"more_body\", False):\n                response_complete.set()\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(app, scope, receive, send)\n        tg.start_soon(app, scope, receive, send)\n\n    assert events == [\n        {\"body\": b\"Hello\", \"more_body\": True, \"type\": \"http.response.body\"},\n        {\"body\": b\"\", \"more_body\": False, \"type\": \"http.response.body\"},\n        {\"body\": b\"Hello\", \"more_body\": True, \"type\": \"http.response.body\"},\n        {\"body\": b\"\", \"more_body\": False, \"type\": \"http.response.body\"},\n        \"Background task started\",\n        \"Background task started\",\n        \"Background task finished\",\n        \"Background task finished\",\n    ]"
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_run_context_manager_exit_even_if_client_disconnects() -> None:\n    response_complete = anyio.Event()\n    context_manager_exited = anyio.Event()\n\n    async def sleep_and_set() -> None:\n        await anyio.sleep(0.1)\n        context_manager_exited.set()\n\n    class ContextManagerMiddleware:\n        def __init__(self, app: ASGIApp):\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            async with AsyncExitStack() as stack:\n                stack.push_async_callback(sleep_and_set)\n                await self.app(scope, receive, send)\n\n    async def simple_endpoint(_: Request) -> PlainTextResponse:\n        return PlainTextResponse(background=BackgroundTask(sleep_and_set))\n\n    async def passthrough(\n        request: Request,\n        call_next: RequestResponseEndpoint,\n    ) -> Response:\n        return await call_next(request)\n\n    app = Starlette(\n        middleware=[\n            Middleware(BaseHTTPMiddleware, dispatch=passthrough),\n            Middleware(ContextManagerMiddleware),\n        ],\n        routes=[Route(\"/\", simple_endpoint)],\n    )\n\n    scope = {\n        \"type\": \"http\",\n        \"version\": \"3\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n    }\n\n    async def receive() -> Message:\n        raise NotImplementedError(\"Should not be called!\")\n\n    async def send(message: Message) -> None:\n        if message[\"type\"] == \"http.response.body\":\n            if not message.get(\"more_body\", False):  # pragma: no branch\n                response_complete.set()\n\n    await app(scope, receive, send)\n\n    assert context_manager_exited.is_set()"
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_app_receives_http_disconnect_while_sending_if_discarded(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class DiscardingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: Any,\n        ) -> PlainTextResponse:\n            downstream_app_response = await call_next(request)\n            body_generator = downstream_app_response.body_iterator\n            try:\n                await body_generator.__anext__()\n            finally:\n                await body_generator.aclose()\n\n            return PlainTextResponse(\"Custom\")\n\n    async def downstream_app(\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain\"),\n                ],\n            }\n        )\n        async with anyio.create_task_group() as task_group:\n\n            async def cancel_on_disconnect(\n                *,\n                task_status: TaskStatus[None] = anyio.TASK_STATUS_IGNORED,\n            ) -> None:\n                task_status.started()\n                while True:\n                    message = await receive()\n                    if message[\"type\"] == \"http.disconnect\":  # pragma: no branch\n                        task_group.cancel_scope.cancel()\n                        break\n\n            await task_group.start(cancel_on_disconnect)\n\n            with anyio.move_on_after(0.1):\n                while True:\n                    await send(\n                        {\n                            \"type\": \"http.response.body\",\n                            \"body\": b\"chunk \",\n                            \"more_body\": True,\n                        }\n                    )\n\n            pytest.fail(\"http.disconnect should have been received and canceled the scope\")  # pragma: no cover\n\n    app = DiscardingMiddleware(downstream_app)\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\""
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_app_receives_http_disconnect_after_sending_if_discarded(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class DiscardingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> PlainTextResponse:\n            await call_next(request)\n            return PlainTextResponse(\"Custom\")\n\n    async def downstream_app(\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain\"),\n                ],\n            }\n        )\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": b\"first chunk, \",\n                \"more_body\": True,\n            }\n        )\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": b\"second chunk\",\n                \"more_body\": True,\n            }\n        )\n        message = await receive()\n        assert message[\"type\"] == \"http.disconnect\"\n\n    app = DiscardingMiddleware(downstream_app)\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\""
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_stream_in_app_after_middleware_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            expected = [b\"a\", b\"\"]\n            async for chunk in request.stream():\n                assert chunk == expected.pop(0)\n            assert expected == []\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_stream_in_app_after_middleware_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"a\", b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_body_in_app_after_middleware_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            expected = [b\"a\", b\"\"]\n            async for chunk in request.stream():\n                assert chunk == expected.pop(0)\n            assert expected == []\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_body_in_app_after_middleware_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_stream_in_dispatch_after_app_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"a\", b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            resp = await call_next(request)\n            with pytest.raises(RuntimeError, match=\"Stream consumed\"):\n                async for _ in request.stream():\n                    raise AssertionError(\"should not be called\")  # pragma: no cover\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_stream_in_dispatch_after_app_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            resp = await call_next(request)\n            with pytest.raises(RuntimeError, match=\"Stream consumed\"):\n                async for _ in request.stream():\n                    raise AssertionError(\"should not be called\")  # pragma: no cover\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_read_request_stream_in_dispatch_wrapping_app_calls_body() -> None:\n    async def endpoint(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        async for chunk in request.stream():  # pragma: no branch\n            assert chunk == b\"2\"\n            break\n        await Response()(scope, receive, send)\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            expected = b\"1\"\n            response: Response | None = None\n            async for chunk in request.stream():  # pragma: no branch\n                assert chunk == expected\n                if expected == b\"1\":\n                    response = await call_next(request)\n                    expected = b\"3\"\n                else:\n                    break\n            assert response is not None\n            return response\n\n    async def rcv() -> AsyncGenerator[Message, None]:\n        yield {\"type\": \"http.request\", \"body\": b\"1\", \"more_body\": True}\n        yield {\"type\": \"http.request\", \"body\": b\"2\", \"more_body\": True}\n        yield {\"type\": \"http.request\", \"body\": b\"3\"}\n        raise AssertionError(  # pragma: no cover\n            \"Should not be called, no need to poll for disconnect\"\n        )\n\n    sent: list[Message] = []\n\n    async def send(msg: Message) -> None:\n        sent.append(msg)\n\n    app: ASGIApp = endpoint\n    app = ConsumingMiddleware(app)\n\n    rcv_stream = rcv()\n\n    await app({\"type\": \"http\"}, rcv_stream.__anext__, send)\n\n    assert sent == [\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [(b\"content-length\", b\"0\")],\n        },\n        {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False},\n    ]\n\n    await rcv_stream.aclose()"
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_stream_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"  # this buffers the request body in memory\n            resp = await call_next(request)\n            async for chunk in request.stream():\n                if chunk:\n                    assert chunk == b\"a\"\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_read_request_body_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"  # this buffers the request body in memory\n            resp = await call_next(request)\n            assert await request.body() == b\"a\"  # no problem here\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200"
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_read_request_disconnected_client() -> None:\n    async def endpoint(scope: Scope, receive: Receive, send: Send) -> None:\n        msg = await receive()\n        assert msg[\"type\"] == \"http.disconnect\"\n        await Response()(scope, receive, send)\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            response = await call_next(request)\n            disconnected = await request.is_disconnected()\n            assert disconnected is True\n            return response\n\n    scope = {\"type\": \"http\", \"method\": \"POST\", \"path\": \"/\"}\n\n    async def receive() -> AsyncGenerator[Message, None]:\n        yield {\"type\": \"http.disconnect\"}\n        raise AssertionError(\"Should not be called, would hang\")  # pragma: no cover\n\n    async def send(msg: Message) -> None:\n        if msg[\"type\"] == \"http.response.start\":\n            assert msg[\"status\"] == 200\n\n    app: ASGIApp = ConsumingMiddleware(endpoint)\n\n    rcv = receive()\n\n    await app(scope, rcv.__anext__, send)\n\n    await rcv.aclose()"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_read_request_disconnected_after_consuming_steam() -> None:\n    async def endpoint(scope: Scope, receive: Receive, send: Send) -> None:\n        msg = await receive()\n        assert msg.pop(\"more_body\", False) is False\n        assert msg == {\"type\": \"http.request\", \"body\": b\"hi\"}\n        msg = await receive()\n        assert msg == {\"type\": \"http.disconnect\"}\n        await Response()(scope, receive, send)\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            await request.body()\n            disconnected = await request.is_disconnected()\n            assert disconnected is True\n            response = await call_next(request)\n            return response\n\n    scope = {\"type\": \"http\", \"method\": \"POST\", \"path\": \"/\"}\n\n    async def receive() -> AsyncGenerator[Message, None]:\n        yield {\"type\": \"http.request\", \"body\": b\"hi\"}\n        yield {\"type\": \"http.disconnect\"}\n        raise AssertionError(\"Should not be called, would hang\")  # pragma: no cover\n\n    async def send(msg: Message) -> None:\n        if msg[\"type\"] == \"http.response.start\":\n            assert msg[\"status\"] == 200\n\n    app: ASGIApp = ConsumingMiddleware(endpoint)\n\n    rcv = receive()\n\n    await app(scope, rcv.__anext__, send)\n\n    await rcv.aclose()"
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_downstream_middleware_modifies_receive(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def endpoint(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = await request.body()\n        assert body == b\"foo foo \"\n        await Response()(scope, receive, send)\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            body = await request.body()\n            assert body == b\"foo \"\n            return await call_next(request)\n\n    def modifying_middleware(app: ASGIApp) -> ASGIApp:\n        async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n            async def wrapped_receive() -> Message:\n                msg = await receive()\n                if msg[\"type\"] == \"http.request\":  # pragma: no branch\n                    msg[\"body\"] = msg[\"body\"] * 2\n                return msg\n\n            await app(scope, wrapped_receive, send)\n\n        return wrapped_app\n\n    client = test_client_factory(ConsumingMiddleware(modifying_middleware(endpoint)))\n\n    resp = client.post(\"/\", content=b\"foo \")\n    assert resp.status_code == 200"
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "def test_pr_1519_comment_1236166180_example() -> None:\n    bodies: list[bytes] = []\n\n    class LogRequestBodySize(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            print(len(await request.body()))\n            return await call_next(request)\n\n    def replace_body_middleware(app: ASGIApp) -> ASGIApp:\n        async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n            async def wrapped_rcv() -> Message:\n                msg = await receive()\n                msg[\"body\"] += b\"-foo\"\n                return msg\n\n            await app(scope, wrapped_rcv, send)\n\n        return wrapped_app\n\n    async def endpoint(request: Request) -> Response:\n        body = await request.body()\n        bodies.append(body)\n        return Response()\n\n    app: ASGIApp = Starlette(routes=[Route(\"/\", endpoint, methods=[\"POST\"])])\n    app = replace_body_middleware(app)\n    app = LogRequestBodySize(app)\n\n    client = TestClient(app)\n    resp = client.post(\"/\", content=b\"Hello, World!\")\n    resp.raise_for_status()\n\n    assert bodies == [b\"Hello, World!-foo\"]"
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\nasync def test_multiple_middlewares_stacked_client_disconnected() -> None:\n    ordered_events: list[str] = []\n    unordered_events: list[str] = []\n\n    class MyMiddleware(BaseHTTPMiddleware):\n        def __init__(self, app: ASGIApp, version: int) -> None:\n            self.version = version\n            super().__init__(app)\n\n        async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n            ordered_events.append(f\"{self.version}:STARTED\")\n            res = await call_next(request)\n            ordered_events.append(f\"{self.version}:COMPLETED\")\n\n            def background() -> None:\n                unordered_events.append(f\"{self.version}:BACKGROUND\")\n\n            assert res.background is None\n            res.background = BackgroundTask(background)\n            return res\n\n    async def sleepy(request: Request) -> Response:\n        try:\n            await request.body()\n        except ClientDisconnect:\n            pass\n        else:  # pragma: no cover\n            raise AssertionError(\"Should have raised ClientDisconnect\")\n        return Response(b\"\")\n\n    app = Starlette(\n        routes=[Route(\"/\", sleepy)],\n        middleware=[Middleware(MyMiddleware, version=_ + 1) for _ in range(10)],\n    )\n\n    scope = {\n        \"type\": \"http\",\n        \"version\": \"3\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n    }\n\n    async def receive() -> AsyncIterator[Message]:\n        yield {\"type\": \"http.disconnect\"}\n\n    sent: list[Message] = []\n\n    async def send(message: Message) -> None:\n        sent.append(message)\n\n    await app(scope, receive().__anext__, send)\n\n    assert ordered_events == [\n        \"1:STARTED\",\n        \"2:STARTED\",\n        \"3:STARTED\",\n        \"4:STARTED\",\n        \"5:STARTED\",\n        \"6:STARTED\",\n        \"7:STARTED\",\n        \"8:STARTED\",\n        \"9:STARTED\",\n        \"10:STARTED\",\n        \"10:COMPLETED\",\n        \"9:COMPLETED\",\n        \"8:COMPLETED\",\n        \"7:COMPLETED\",\n        \"6:COMPLETED\",\n        \"5:COMPLETED\",\n        \"4:COMPLETED\",\n        \"3:COMPLETED\",\n        \"2:COMPLETED\",\n        \"1:COMPLETED\",\n    ]\n\n    assert sorted(unordered_events) == sorted(\n        [\n            \"1:BACKGROUND\",\n            \"2:BACKGROUND\",\n            \"3:BACKGROUND\",\n            \"4:BACKGROUND\",\n            \"5:BACKGROUND\",\n            \"6:BACKGROUND\",\n            \"7:BACKGROUND\",\n            \"8:BACKGROUND\",\n            \"9:BACKGROUND\",\n            \"10:BACKGROUND\",\n        ]\n    )\n\n    assert sent == [\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [(b\"content-length\", b\"0\")],\n        },\n        {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False},\n    ]"
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_base.py",
      "content": "@pytest.mark.anyio\n@pytest.mark.parametrize(\"send_body\", [True, False])\nasync def test_poll_for_disconnect_repeated(send_body: bool) -> None:\n    async def app_poll_disconnect(scope: Scope, receive: Receive, send: Send) -> None:\n        for _ in range(2):\n            msg = await receive()\n            while msg[\"type\"] == \"http.request\":\n                msg = await receive()\n            assert msg[\"type\"] == \"http.disconnect\"\n        await Response(b\"good!\")(scope, receive, send)\n\n    class MyMiddleware(BaseHTTPMiddleware):\n        async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n            return await call_next(request)\n\n    app = MyMiddleware(app_poll_disconnect)\n\n    scope = {\n        \"type\": \"http\",\n        \"version\": \"3\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n    }\n\n    async def receive() -> AsyncIterator[Message]:\n        if send_body:\n            yield {\"type\": \"http.request\", \"body\": b\"hello\", \"more_body\": True}\n            yield {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}\n        yield {\"type\": \"http.disconnect\"}\n        raise AssertionError(\"Should not be called, would hang\")  # pragma: no cover\n\n    sent: list[Message] = []\n\n    async def send(message: Message) -> None:\n        sent.append(message)\n\n    await app(scope, receive().__anext__, send)\n\n    assert sent == [\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [(b\"content-length\", b\"5\")],\n        },\n        {\"type\": \"http.response.body\", \"body\": b\"good!\", \"more_body\": True},\n        {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False},\n    ]"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "import sys\nfrom collections.abc import Iterable\nfrom typing import Any, Callable\n\nimport pytest\n\nfrom starlette._utils import collapse_excgroups\nfrom starlette.middleware.wsgi import WSGIMiddleware, build_environ\nfrom tests.types import TestClientFactory\n\nWSGIResponse = Iterable[bytes]\nStartResponse = Callable[..., Any]\nEnvironment = dict[str, Any]"
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def hello_world(\n    environ: Environment,\n    start_response: StartResponse,\n) -> WSGIResponse:\n    status = \"200 OK\"\n    output = b\"Hello World!\\n\"\n    headers = [\n        (\"Content-Type\", \"text/plain; charset=utf-8\"),\n        (\"Content-Length\", str(len(output))),\n    ]\n    start_response(status, headers)\n    return [output]"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def echo_body(\n    environ: Environment,\n    start_response: StartResponse,\n) -> WSGIResponse:\n    status = \"200 OK\"\n    output = environ[\"wsgi.input\"].read()\n    headers = [\n        (\"Content-Type\", \"text/plain; charset=utf-8\"),\n        (\"Content-Length\", str(len(output))),\n    ]\n    start_response(status, headers)\n    return [output]"
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def raise_exception(\n    environ: Environment,\n    start_response: StartResponse,\n) -> WSGIResponse:\n    raise RuntimeError(\"Something went wrong\")"
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def return_exc_info(\n    environ: Environment,\n    start_response: StartResponse,\n) -> WSGIResponse:\n    try:\n        raise RuntimeError(\"Something went wrong\")\n    except RuntimeError:\n        status = \"500 Internal Server Error\"\n        output = b\"Internal Server Error\"\n        headers = [\n            (\"Content-Type\", \"text/plain; charset=utf-8\"),\n            (\"Content-Length\", str(len(output))),\n        ]\n        start_response(status, headers, exc_info=sys.exc_info())\n        return [output]"
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_wsgi_get(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(hello_world)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello World!\\n\""
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_wsgi_post(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(echo_body)\n    client = test_client_factory(app)\n    response = client.post(\"/\", json={\"example\": 123})\n    assert response.status_code == 200\n    assert response.text == '{\"example\":123}'"
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_wsgi_exception(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(raise_exception)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError), collapse_excgroups():\n        client.get(\"/\")"
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_wsgi_exc_info(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(return_exc_info)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        response = client.get(\"/\")\n\n    app = WSGIMiddleware(return_exc_info)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.text == \"Internal Server Error\""
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_build_environ() -> None:\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"https\",\n        \"path\": \"/sub/\",\n        \"root_path\": \"/sub\",\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [\n            (b\"host\", b\"www.example.org\"),\n            (b\"content-type\", b\"application/json\"),\n            (b\"content-length\", b\"18\"),\n            (b\"accept\", b\"application/json\"),\n            (b\"accept\", b\"text/plain\"),\n        ],\n        \"client\": (\"134.56.78.4\", 1453),\n        \"server\": (\"www.example.org\", 443),\n    }\n    body = b'{\"example\":\"body\"}'\n    environ = build_environ(scope, body)\n    stream = environ.pop(\"wsgi.input\")\n    assert stream.read() == b'{\"example\":\"body\"}'\n    assert environ == {\n        \"CONTENT_LENGTH\": \"18\",\n        \"CONTENT_TYPE\": \"application/json\",\n        \"HTTP_ACCEPT\": \"application/json,text/plain\",\n        \"HTTP_HOST\": \"www.example.org\",\n        \"PATH_INFO\": \"/\",\n        \"QUERY_STRING\": \"a=123&b=456\",\n        \"REMOTE_ADDR\": \"134.56.78.4\",\n        \"REQUEST_METHOD\": \"GET\",\n        \"SCRIPT_NAME\": \"/sub\",\n        \"SERVER_NAME\": \"www.example.org\",\n        \"SERVER_PORT\": 443,\n        \"SERVER_PROTOCOL\": \"HTTP/1.1\",\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.multithread\": True,\n        \"wsgi.run_once\": False,\n        \"wsgi.url_scheme\": \"https\",\n        \"wsgi.version\": (1, 0),\n    }"
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_wsgi.py",
      "content": "def test_build_environ_encoding() -> None:\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"path\": \"/\u5c0f\u661f\",\n        \"root_path\": \"/\u4e2d\u56fd\",\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [],\n    }\n    environ = build_environ(scope, b\"\")\n    assert environ[\"SCRIPT_NAME\"] == \"/\u4e2d\u56fd\".encode().decode(\"latin-1\")\n    assert environ[\"PATH_INFO\"] == \"/\u5c0f\u661f\".encode().decode(\"latin-1\")"
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "import re\n\nfrom starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.sessions import SessionMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Mount, Route\nfrom starlette.testclient import TestClient\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def view_session(request: Request) -> JSONResponse:\n    return JSONResponse({\"session\": request.session})"
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "async def update_session(request: Request) -> JSONResponse:\n    data = await request.json()\n    request.session.update(data)\n    return JSONResponse({\"session\": request.session})"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "async def clear_session(request: Request) -> JSONResponse:\n    request.session.clear()\n    return JSONResponse({\"session\": request.session})"
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_session(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n            Route(\"/clear_session\", endpoint=clear_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\")],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    max_age_matches = re.search(r\"; Max-Age=([0-9]+);\", set_cookie)\n    assert max_age_matches is not None\n    assert int(max_age_matches[1]) == 14 * 24 * 3600\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = client.post(\"/clear_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_session_expires(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", max_age=-1)],\n    )\n    client = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # requests removes expired cookies from response.cookies, we need to\n    # fetch session id from the headers and pass it explicitly\n    expired_cookie_header = response.headers[\"set-cookie\"]\n    expired_session_match = re.search(r\"session=([^;]*);\", expired_cookie_header)\n    assert expired_session_match is not None\n    expired_session_value = expired_session_match[1]\n    client = test_client_factory(app, cookies={\"session\": expired_session_value})\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_secure_session(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n            Route(\"/clear_session\", endpoint=clear_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", https_only=True)],\n    )\n    secure_client = test_client_factory(app, base_url=\"https://testserver\")\n    unsecure_client = test_client_factory(app, base_url=\"http://testserver\")\n\n    response = unsecure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = unsecure_client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = unsecure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = secure_client.post(\"/clear_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_session_cookie_subpath(test_client_factory: TestClientFactory) -> None:\n    second_app = Starlette(\n        routes=[\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", path=\"/second_app\")],\n    )\n    app = Starlette(routes=[Mount(\"/second_app\", app=second_app)])\n    client = test_client_factory(app, base_url=\"http://testserver/second_app\")\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.status_code == 200\n    cookie = response.headers[\"set-cookie\"]\n    cookie_path_match = re.search(r\"; path=(\\S+);\", cookie)\n    assert cookie_path_match is not None\n    cookie_path = cookie_path_match.groups()[0]\n    assert cookie_path == \"/second_app\""
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_invalid_session_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\")],\n    )\n    client = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # we expect it to not raise an exception if we provide a bogus session cookie\n    client = test_client_factory(app, cookies={\"session\": \"invalid\"})\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_session_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", max_age=None)],\n    )\n    client: TestClient = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    assert \"Max-Age\" not in set_cookie\n\n    client.cookies.delete(\"session\")\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_session.py",
      "content": "def test_domain_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", domain=\".example.com\")],\n    )\n    client: TestClient = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    assert \"domain=.example.com\" in set_cookie\n\n    client.cookies.delete(\"session\")\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}"
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import ContentStream, PlainTextResponse, StreamingResponse\nfrom starlette.routing import Route\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "def test_gzip_responses(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"x\" * 4000, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"gzip\"\n    assert int(response.headers[\"Content-Length\"]) < 4000"
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "def test_gzip_not_in_accept_encoding(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"x\" * 4000, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"identity\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert \"Content-Encoding\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == 4000"
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "def test_gzip_ignored_for_small_responses(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert \"Content-Encoding\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == 2"
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "def test_gzip_streaming_response(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> StreamingResponse:\n        async def generator(bytes: bytes, count: int) -> ContentStream:\n            for index in range(count):\n                yield bytes\n\n        streaming = generator(bytes=b\"x\" * 400, count=10)\n        return StreamingResponse(streaming, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"gzip\"\n    assert \"Content-Length\" not in response.headers"
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_gzip.py",
      "content": "def test_gzip_ignored_for_responses_with_encoding_set(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> StreamingResponse:\n        async def generator(bytes: bytes, count: int) -> ContentStream:\n            for index in range(count):\n                yield bytes\n\n        streaming = generator(bytes=b\"x\" * 400, count=10)\n        return StreamingResponse(streaming, status_code=200, headers={\"Content-Encoding\": \"text\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip, text\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"text\"\n    assert \"Content-Length\" not in response.headers"
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_https_redirect.py",
      "content": "from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_https_redirect.py",
      "content": "def test_https_redirect_middleware(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(HTTPSRedirectMiddleware)],\n    )\n\n    client = test_client_factory(app, base_url=\"https://testserver\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", follow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:80\")\n    response = client.get(\"/\", follow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:443\")\n    response = client.get(\"/\", follow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:123\")\n    response = client.get(\"/\", follow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver:123/\""
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_trusted_host.py",
      "content": "from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.trustedhost import TrustedHostMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_trusted_host.py",
      "content": "def test_trusted_host_middleware(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(TrustedHostMiddleware, allowed_hosts=[\"testserver\", \"*.testserver\"])],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app, base_url=\"http://subdomain.testserver\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app, base_url=\"http://invalidhost\")\n    response = client.get(\"/\")\n    assert response.status_code == 400"
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_trusted_host.py",
      "content": "def test_default_allowed_hosts() -> None:\n    app = Starlette()\n    middleware = TrustedHostMiddleware(app)\n    assert middleware.allowed_hosts == [\"*\"]"
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_trusted_host.py",
      "content": "def test_www_redirect(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(TrustedHostMiddleware, allowed_hosts=[\"www.example.com\"])],\n    )\n\n    client = test_client_factory(app, base_url=\"https://example.com\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.url == \"https://www.example.com/\""
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "```"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.cors import CORSMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_all(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n                expose_headers=[\"X-Status\"],\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-headers\"] == \"X-Example\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n    assert response.headers[\"vary\"] == \"Origin\"\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test standard credentialed response\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_all_except_credentials(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n                expose_headers=[\"X-Status\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-allow-headers\"] == \"X-Example\"\n    assert \"access-control-allow-credentials\" not in response.headers\n    assert \"vary\" not in response.headers\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_specific_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"https://example.org\"],\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example, Content-Type\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-headers\"] == (\n        \"Accept, Accept-Language, Content-Language, Content-Type, X-Example\"\n    )\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers"
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_disallowed_preflight(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        pass  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"https://example.org\"],\n                allow_headers=[\"X-Example\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://another.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n        \"Access-Control-Request-Headers\": \"X-Nope\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 400\n    assert response.text == \"Disallowed CORS origin, method, headers\"\n    assert \"access-control-allow-origin\" not in response.headers\n\n    # Bug specific test, https://github.com/encode/starlette/pull/1199\n    # Test preflight response text with multiple disallowed headers\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Nope-1, X-Nope-2\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.text == \"Disallowed CORS headers\""
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_preflight_allows_request_origin_if_origins_wildcard_and_credentials_allowed(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        return  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_methods=[\"POST\"],\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n    }\n    response = client.options(\n        \"/\",\n        headers=headers,\n    )\n    assert response.status_code == 200\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n    assert response.headers[\"vary\"] == \"Origin\""
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_preflight_allow_all_methods(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        pass  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"])],\n    )\n\n    client = test_client_factory(app)\n\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n    }\n\n    for method in (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\"):\n        response = client.options(\"/\", headers=headers)\n        assert response.status_code == 200\n        assert method in response.headers[\"access-control-allow-methods\"]"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_all_methods(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[\n            Route(\n                \"/\",\n                endpoint=homepage,\n                methods=[\"delete\", \"get\", \"head\", \"options\", \"patch\", \"post\", \"put\"],\n            )\n        ],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"])],\n    )\n\n    client = test_client_factory(app)\n\n    headers = {\"Origin\": \"https://example.org\"}\n\n    for method in (\"patch\", \"post\", \"put\"):\n        response = getattr(client, method)(\"/\", headers=headers, json={})\n        assert response.status_code == 200\n    for method in (\"delete\", \"get\", \"head\", \"options\"):\n        response = getattr(client, method)(\"/\", headers=headers)\n        assert response.status_code == 200"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_origin_regex(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n                allow_origin_regex=\"https://.*\",\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test standard credentialed response\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test disallowed standard response\n    # Note that enforcement is a browser concern. The disallowed-ness is reflected\n    # in the lack of an \"access-control-allow-origin\" header in the response.\n    headers = {\"Origin\": \"http://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://another.com\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example, content-type\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://another.com\"\n    assert response.headers[\"access-control-allow-headers\"] == (\n        \"Accept, Accept-Language, Content-Language, Content-Type, X-Example\"\n    )\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test disallowed pre-flight response\n    headers = {\n        \"Origin\": \"http://another.com\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 400\n    assert response.text == \"Disallowed CORS origin\"\n    assert \"access-control-allow-origin\" not in response.headers"
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allow_origin_regex_fullmatch(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n                allow_origin_regex=r\"https://.*\\.example.org\",\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test standard response\n    headers = {\"Origin\": \"https://subdomain.example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://subdomain.example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test diallowed standard response\n    headers = {\"Origin\": \"https://subdomain.example.org.hacker.com\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers"
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_credentialed_requests_return_specific_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    # Test credentialed request\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_vary_header_defaults_to_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"https://example.org\"])],\n    )\n\n    headers = {\"Origin\": \"https://example.org\"}\n\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Origin\""
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_vary_header_is_not_set_for_non_credentialed_request(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding\""
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_vary_header_is_properly_set_for_credentialed_request(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Cookie\": \"foo=bar\", \"Origin\": \"https://someplace.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding, Origin\""
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_vary_header_is_properly_set_when_allow_origins_is_not_wildcard(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"https://example.org\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://example.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding, Origin\""
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_cors.py",
      "content": "def test_cors_allowed_origin_does_not_leak_between_credentialed_requests(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    response = client.get(\"/\", headers={\"Cookie\": \"foo=bar\", \"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"https://someplace.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert \"access-control-allow-credentials\" not in response.headers\n```"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "from typing import Any"
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "import pytest"
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "from starlette.applications import Starlette\nfrom starlette.background import BackgroundTask\nfrom starlette.middleware.errors import ServerErrorMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import Route\nfrom starlette.types import Receive, Scope, Send\nfrom tests.types import TestClientFactory"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_handler(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    def error_500(request: Request, exc: Exception) -> JSONResponse:\n        return JSONResponse({\"detail\": \"Server Error\"}, status_code=500)\n\n    app = ServerErrorMiddleware(app, handler=error_500)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.json() == {\"detail\": \"Server Error\"}"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_debug_text(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.headers[\"content-type\"].startswith(\"text/plain\")\n    assert \"RuntimeError: Something went wrong\" in response.text"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_debug_html(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\", headers={\"Accept\": \"text/html, */*\"})\n    assert response.status_code == 500\n    assert response.headers[\"content-type\"].startswith(\"text/html\")\n    assert \"RuntimeError\" in response.text"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_debug_after_response_sent(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(b\"\", status_code=204)\n        await response(scope, receive, send)\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        client.get(\"/\")"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_debug_not_http(test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    DebugMiddleware should just pass through any non-http messages as-is.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app)\n\n    with pytest.raises(RuntimeError):\n        client = test_client_factory(app)\n        with client.websocket_connect(\"/\"):\n            pass  # pragma: no cover"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_errors.py",
      "content": "def test_background_task(test_client_factory: TestClientFactory) -> None:\n    accessed_error_handler = False\n\n    def error_handler(request: Request, exc: Exception) -> Any:\n        nonlocal accessed_error_handler\n        accessed_error_handler = True\n\n    def raise_exception() -> None:\n        raise Exception(\"Something went wrong\")\n\n    async def endpoint(request: Request) -> Response:\n        task = BackgroundTask(raise_exception)\n        return Response(status_code=204, background=task)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=endpoint)],\n        exception_handlers={Exception: error_handler},\n    )\n\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 204\n    assert accessed_error_handler"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_middleware.py",
      "content": "from starlette.middleware import Middleware\nfrom starlette.types import ASGIApp, Receive, Scope, Send"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_middleware.py",
      "content": "class CustomMiddleware:  # pragma: no cover\n    def __init__(self, app: ASGIApp, foo: str, *, bar: int) -> None:\n        self.app = app\n        self.foo = foo\n        self.bar = bar\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_middleware.py",
      "content": "def test_middleware_repr() -> None:\n    middleware = Middleware(CustomMiddleware, \"foo\", bar=123)\n    assert repr(middleware) == \"Middleware(CustomMiddleware, 'foo', bar=123)\""
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/starlette/tests/middleware/test_middleware.py",
      "content": "def test_middleware_iter() -> None:\n    cls, args, kwargs = Middleware(CustomMiddleware, \"foo\", bar=123)\n    assert (cls, args, kwargs) == (CustomMiddleware, (\"foo\",), {\"bar\": 123})"
    }
  ]
}