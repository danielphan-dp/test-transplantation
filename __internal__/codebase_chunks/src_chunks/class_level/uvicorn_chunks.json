{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__init__.py",
      "content": "from uvicorn.config import Config\nfrom uvicorn.main import Server, main, run"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__init__.py",
      "content": "__version__ = \"0.34.0\""
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__init__.py",
      "content": "__all__ = [\"main\", \"run\", \"Config\", \"Server\"]"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport os\nimport platform\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom typing import IO, Any, Callable\n\nimport click\n\nimport uvicorn\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.config import (\n    HTTP_PROTOCOLS,\n    INTERFACES,\n    LIFESPAN,\n    LOG_LEVELS,\n    LOGGING_CONFIG,\n    LOOP_SETUPS,\n    SSL_PROTOCOL_VERSION,\n    WS_PROTOCOLS,\n    Config,\n    HTTPProtocolType,\n    InterfaceType,\n    LifespanType,\n    LoopSetupType,\n    WSProtocolType,\n)\nfrom uvicorn.server import Server, ServerState  # noqa: F401  # Used to be defined here.\nfrom uvicorn.supervisors import ChangeReload, Multiprocess\n\nLEVEL_CHOICES = click.Choice(list(LOG_LEVELS.keys()))\nHTTP_CHOICES = click.Choice(list(HTTP_PROTOCOLS.keys()))\nWS_CHOICES = click.Choice(list(WS_PROTOCOLS.keys()))\nLIFESPAN_CHOICES = click.Choice(list(LIFESPAN.keys()))\nLOOP_CHOICES = click.Choice([key for key in LOOP_SETUPS.keys() if key != \"none\"])\nINTERFACE_CHOICES = click.Choice(INTERFACES)\n\nSTARTUP_FAILURE = 3\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "def print_version(ctx: click.Context, param: click.Parameter, value: bool) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(\n        \"Running uvicorn {version} with {py_implementation} {py_version} on {system}\".format(  # noqa: UP032\n            version=uvicorn.__version__,\n            py_implementation=platform.python_implementation(),\n            py_version=platform.python_version(),\n            system=platform.system(),\n        )\n    )\n    ctx.exit()"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "@click.command(context_settings={\"auto_envvar_prefix\": \"UVICORN\"})\n@click.argument(\"app\", envvar=\"UVICORN_APP\")\n@click.option(\n    \"--host\",\n    type=str,\n    default=\"127.0.0.1\",\n    help=\"Bind socket to this host.\",\n    show_default=True,\n)\n@click.option(\n    \"--port\",\n    type=int,\n    default=8000,\n    help=\"Bind socket to this port. If 0, an available port will be picked.\",\n    show_default=True,\n)\n@click.option(\"--uds\", type=str, default=None, help=\"Bind to a UNIX domain socket.\")\n@click.option(\"--fd\", type=int, default=None, help=\"Bind to socket from this file descriptor.\")\n@click.option(\"--reload\", is_flag=True, default=False, help=\"Enable auto-reload.\")\n@click.option(\n    \"--reload-dir\",\n    \"reload_dirs\",\n    multiple=True,\n    help=\"Set reload directories explicitly, instead of using the current working\" \" directory.\",\n    type=click.Path(exists=True),\n)\n@click.option(\n    \"--reload-include\",\n    \"reload_includes\",\n    multiple=True,\n    help=\"Set glob patterns to include while watching for files. Includes '*.py' \"\n    \"by default; these defaults can be overridden with `--reload-exclude`. \"\n    \"This option has no effect unless watchfiles is installed.\",\n)\n@click.option(\n    \"--reload-exclude\",\n    \"reload_excludes\",\n    multiple=True,\n    help=\"Set glob patterns to exclude while watching for files. Includes \"\n    \"'.*, .py[cod], .sw.*, ~*' by default; these defaults can be overridden \"\n    \"with `--reload-include`. This option has no effect unless watchfiles is \"\n    \"installed.\",\n)\n@click.option(\n    \"--reload-delay\",\n    type=float,\n    default=0.25,\n    show_default=True,\n    help=\"Delay between previous and next check if application needs to be.\" \" Defaults to 0.25s.\",\n)\n@click.option(\n    \"--workers\",\n    default=None,\n    type=int,\n    help=\"Number of worker processes. Defaults to the $WEB_CONCURRENCY environment\"\n    \" variable if available, or 1. Not valid with --reload.\",\n)\n@click.option(\n    \"--loop\",\n    type=LOOP_CHOICES,\n    default=\"auto\",\n    help=\"Event loop implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--http\",\n    type=HTTP_CHOICES,\n    default=\"auto\",\n    help=\"HTTP protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws\",\n    type=WS_CHOICES,\n    default=\"auto\",\n    help=\"WebSocket protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-size\",\n    type=int,\n    default=16777216,\n    help=\"WebSocket max size message in bytes\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-queue\",\n    type=int,\n    default=32,\n    help=\"The maximum length of the WebSocket message queue.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-interval\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping interval in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-timeout\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping timeout in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-per-message-deflate\",\n    type=bool,\n    default=True,\n    help=\"WebSocket per-message-deflate compression\",\n    show_default=True,\n)\n@click.option(\n    \"--lifespan\",\n    type=LIFESPAN_CHOICES,\n    default=\"auto\",\n    help=\"Lifespan implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--interface\",\n    type=INTERFACE_CHOICES,\n    default=\"auto\",\n    help=\"Select ASGI3, ASGI2, or WSGI as the application interface.\",\n    show_default=True,\n)\n@click.option(\n    \"--env-file\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Environment configuration file.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-config\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Logging configuration file. Supported formats: .ini, .json, .yaml.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-level\",\n    type=LEVEL_CHOICES,\n    default=None,\n    help=\"Log level. [default: info]\",\n    show_default=True,\n)\n@click.option(\n    \"--access-log/--no-access-log\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable access log.\",\n)\n@click.option(\n    \"--use-colors/--no-use-colors\",\n    is_flag=True,\n    default=None,\n    help=\"Enable/Disable colorized logging.\",\n)\n@click.option(\n    \"--proxy-headers/--no-proxy-headers\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable X-Forwarded-Proto, X-Forwarded-For, X-Forwarded-Port to \" \"populate remote address info.\",\n)\n@click.option(\n    \"--server-header/--no-server-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Server header.\",\n)\n@click.option(\n    \"--date-header/--no-date-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Date header.\",\n)\n@click.option(\n    \"--forwarded-allow-ips\",\n    type=str,\n    default=None,\n    help=\"Comma separated list of IP Addresses, IP Networks, or literals \"\n    \"(e.g. UNIX Socket path) to trust with proxy headers. Defaults to the \"\n    \"$FORWARDED_ALLOW_IPS environment variable if available, or '127.0.0.1'. \"\n    \"The literal '*' means trust everything.\",\n)\n@click.option(\n    \"--root-path\",\n    type=str,\n    default=\"\",\n    help=\"Set the ASGI 'root_path' for applications submounted below a given URL path.\",\n)\n@click.option(\n    \"--limit-concurrency\",\n    type=int,\n    default=None,\n    help=\"Maximum number of concurrent connections or tasks to allow, before issuing\" \" HTTP 503 responses.\",\n)\n@click.option(\n    \"--backlog\",\n    type=int,\n    default=2048,\n    help=\"Maximum number of connections to hold in backlog\",\n)\n@click.option(\n    \"--limit-max-requests\",\n    type=int,\n    default=None,\n    help=\"Maximum number of requests to service before terminating the process.\",\n)\n@click.option(\n    \"--timeout-keep-alive\",\n    type=int,\n    default=5,\n    help=\"Close Keep-Alive connections if no new data is received within this timeout.\",\n    show_default=True,\n)\n@click.option(\n    \"--timeout-graceful-shutdown\",\n    type=int,\n    default=None,\n    help=\"Maximum number of seconds to wait for graceful shutdown.\",\n)\n@click.option(\"--ssl-keyfile\", type=str, default=None, help=\"SSL key file\", show_default=True)\n@click.option(\n    \"--ssl-certfile\",\n    type=str,\n    default=None,\n    help=\"SSL certificate file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-keyfile-password\",\n    type=str,\n    default=None,\n    help=\"SSL keyfile password\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-version\",\n    type=int,\n    default=int(SSL_PROTOCOL_VERSION),\n    help=\"SSL version to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-cert-reqs\",\n    type=int,\n    default=int(ssl.CERT_NONE),\n    help=\"Whether client certificate is required (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ca-certs\",\n    type=str,\n    default=None,\n    help=\"CA certificates file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ciphers\",\n    type=str,\n    default=\"TLSv1\",\n    help=\"Ciphers to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--header\",\n    \"headers\",\n    multiple=True,\n    help=\"Specify custom default HTTP response headers as a Name:Value pair\",\n)\n@click.option(\n    \"--version\",\n    is_flag=True,\n    callback=print_version,\n    expose_value=False,\n    is_eager=True,\n    help=\"Display the uvicorn version and exit.\",\n)\n@click.option(\n    \"--app-dir\",\n    default=\"\",\n    show_default=True,\n    help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n    \" Defaults to the current working directory.\",\n)\n@click.option(\n    \"--h11-max-incomplete-event-size\",\n    \"h11_max_incomplete_event_size\",\n    type=int,\n    default=None,\n    help=\"For h11, the maximum number of bytes to buffer of an incomplete event.\",\n)\n@click.option(\n    \"--factory\",\n    is_flag=True,\n    default=False,\n    help=\"Treat APP as an application factory, i.e. a () -> <ASGI app> callable.\",\n    show_default=True,\n)\ndef main(\n    app: str,\n    host: str,\n    port: int,\n    uds: str,\n    fd: int,\n    loop: LoopSetupType,\n    http: HTTPProtocolType,\n    ws: WSProtocolType,\n    ws_max_size: int,\n    ws_max_queue: int,\n    ws_ping_interval: float,\n    ws_ping_timeout: float,\n    ws_per_message_deflate: bool,\n    lifespan: LifespanType,\n    interface: InterfaceType,\n    reload: bool,\n    reload_dirs: list[str],\n    reload_includes: list[str],\n    reload_excludes: list[str],\n    reload_delay: float,\n    workers: int,\n    env_file: str,\n    log_config: str,\n    log_level: str,\n    access_log: bool,\n    proxy_headers: bool,\n    server_header: bool,\n    date_header: bool,\n    forwarded_allow_ips: str,\n    root_path: str,\n    limit_concurrency: int,\n    backlog: int,\n    limit_max_requests: int,\n    timeout_keep_alive: int,\n    timeout_graceful_shutdown: int | None,\n    ssl_keyfile: str,\n    ssl_certfile: str,\n    ssl_keyfile_password: str,\n    ssl_version: int,\n    ssl_cert_reqs: int,\n    ssl_ca_certs: str,\n    ssl_ciphers: str,\n    headers: list[str],\n    use_colors: bool,\n    app_dir: str,\n    h11_max_incomplete_event_size: int | None,\n    factory: bool,\n) -> None:\n    run(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        env_file=env_file,\n        log_config=LOGGING_CONFIG if log_config is None else log_config,\n        log_level=log_level,\n        access_log=access_log,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs or None,\n        reload_includes=reload_includes or None,\n        reload_excludes=reload_excludes or None,\n        reload_delay=reload_delay,\n        workers=workers,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=[header.split(\":\", 1) for header in headers],  # type: ignore[misc]\n        use_colors=use_colors,\n        factory=factory,\n        app_dir=app_dir,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "def run(\n    app: ASGIApplication | Callable[..., Any] | str,\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    uds: str | None = None,\n    fd: int | None = None,\n    loop: LoopSetupType = \"auto\",\n    http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n    ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n    ws_max_size: int = 16777216,\n    ws_max_queue: int = 32,\n    ws_ping_interval: float | None = 20.0,\n    ws_ping_timeout: float | None = 20.0,\n    ws_per_message_deflate: bool = True,\n    lifespan: LifespanType = \"auto\",\n    interface: InterfaceType = \"auto\",\n    reload: bool = False,\n    reload_dirs: list[str] | str | None = None,\n    reload_includes: list[str] | str | None = None,\n    reload_excludes: list[str] | str | None = None,\n    reload_delay: float = 0.25,\n    workers: int | None = None,\n    env_file: str | os.PathLike[str] | None = None,\n    log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n    log_level: str | int | None = None,\n    access_log: bool = True,\n    proxy_headers: bool = True,\n    server_header: bool = True,\n    date_header: bool = True,\n    forwarded_allow_ips: list[str] | str | None = None,\n    root_path: str = \"\",\n    limit_concurrency: int | None = None,\n    backlog: int = 2048,\n    limit_max_requests: int | None = None,\n    timeout_keep_alive: int = 5,\n    timeout_graceful_shutdown: int | None = None,\n    ssl_keyfile: str | os.PathLike[str] | None = None,\n    ssl_certfile: str | os.PathLike[str] | None = None,\n    ssl_keyfile_password: str | None = None,\n    ssl_version: int = SSL_PROTOCOL_VERSION,\n    ssl_cert_reqs: int = ssl.CERT_NONE,\n    ssl_ca_certs: str | None = None,\n    ssl_ciphers: str = \"TLSv1\",\n    headers: list[tuple[str, str]] | None = None,\n    use_colors: bool | None = None,\n    app_dir: str | None = None,\n    factory: bool = False,\n    h11_max_incomplete_event_size: int | None = None,\n) -> None:\n    if app_dir is not None:\n        sys.path.insert(0, app_dir)\n\n    config = Config(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs,\n        reload_includes=reload_includes,\n        reload_excludes=reload_excludes,\n        reload_delay=reload_delay,\n        workers=workers,\n        env_file=env_file,\n        log_config=log_config,\n        log_level=log_level,\n        access_log=access_log,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=headers,\n        use_colors=use_colors,\n        factory=factory,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )\n    server = Server(config=config)\n\n    if (config.reload or config.workers > 1) and not isinstance(app, str):\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.warning(\"You must pass the application as an import string to enable 'reload' or \" \"'workers'.\")\n        sys.exit(1)\n\n    try:\n        if config.should_reload:\n            sock = config.bind_socket()\n            ChangeReload(config, target=server.run, sockets=[sock]).run()\n        elif config.workers > 1:\n            sock = config.bind_socket()\n            Multiprocess(config, target=server.run, sockets=[sock]).run()\n        else:\n            server.run()\n    except KeyboardInterrupt:\n        pass  # pragma: full coverage\n    finally:\n        if config.uds and os.path.exists(config.uds):\n            os.remove(config.uds)  # pragma: py-win32\n\n    if not server.started and not config.should_reload and config.workers == 1:\n        sys.exit(STARTUP_FAILURE)"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "if __name__ == \"__main__\":\n    main()  # pragma: no cover"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "import importlib\nfrom typing import Any"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "class ImportFromStringError(Exception):\n    pass"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "def import_from_string(import_str: Any) -> Any:\n    if not isinstance(import_str, str):\n        return import_str\n\n    module_str, _, attrs_str = import_str.partition(\":\")\n    if not module_str or not attrs_str:\n        message = 'Import string \"{import_str}\" must be in format \"<module>:<attribute>\".'\n        raise ImportFromStringError(message.format(import_str=import_str))\n\n    try:\n        module = importlib.import_module(module_str)\n    except ModuleNotFoundError as exc:\n        if exc.name != module_str:\n            raise exc from None\n        message = 'Could not import module \"{module_str}\".'\n        raise ImportFromStringError(message.format(module_str=module_str))\n\n    instance = module\n    try:\n        for attr_str in attrs_str.split(\".\"):\n            instance = getattr(instance, attr_str)\n    except AttributeError:\n        message = 'Attribute \"{attrs_str}\" not found in module \"{module_str}\".'\n        raise ImportFromStringError(message.format(attrs_str=attrs_str, module_str=module_str))\n\n    return instance"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport platform\nimport signal\nimport socket\nimport sys\nimport threading\nimport time\nfrom collections.abc import Generator, Sequence\nfrom email.utils import formatdate\nfrom types import FrameType\nfrom typing import TYPE_CHECKING, Union\n\nimport click\n\nfrom uvicorn.config import Config\n\nif TYPE_CHECKING:\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n    Protocols = Union[H11Protocol, HttpToolsProtocol, WSProtocol, WebSocketProtocol]\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\nif sys.platform == \"win32\":  # pragma: py-not-win32\n    HANDLED_SIGNALS += (signal.SIGBREAK,)  # Windows signal 21. Sent by Ctrl+Break.\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "class ServerState:\n    \"\"\"\n    Shared servers state that is available between all protocol instances.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.total_requests = 0\n        self.connections: set[Protocols] = set()\n        self.tasks: set[asyncio.Task[None]] = set()\n        self.default_headers: list[tuple[bytes, bytes]] = []"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "class Server:\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.server_state = ServerState()\n\n        self.started = False\n        self.should_exit = False\n        self.force_exit = False\n        self.last_notified = 0.0\n\n        self._captured_signals: list[int] = []\n\n    def run(self, sockets: list[socket.socket] | None = None) -> None:\n        self.config.setup_event_loop()\n        return asyncio.run(self.serve(sockets=sockets))\n\n    async def serve(self, sockets: list[socket.socket] | None = None) -> None:\n        with self.capture_signals():\n            await self._serve(sockets)\n\n    async def _serve(self, sockets: list[socket.socket] | None = None) -> None:\n        process_id = os.getpid()\n\n        config = self.config\n        if not config.loaded:\n            config.load()\n\n        self.lifespan = config.lifespan_class(config)\n\n        message = \"Started server process [%d]\"\n        color_message = \"Started server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n        await self.startup(sockets=sockets)\n        if self.should_exit:\n            return\n        await self.main_loop()\n        await self.shutdown(sockets=sockets)\n\n        message = \"Finished server process [%d]\"\n        color_message = \"Finished server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n    async def startup(self, sockets: list[socket.socket] | None = None) -> None:\n        await self.lifespan.startup()\n        if self.lifespan.should_exit:\n            self.should_exit = True\n            return\n\n        config = self.config\n\n        def create_protocol(\n            _loop: asyncio.AbstractEventLoop | None = None,\n        ) -> asyncio.Protocol:\n            return config.http_protocol_class(  # type: ignore[call-arg]\n                config=config,\n                server_state=self.server_state,\n                app_state=self.lifespan.state,\n                _loop=_loop,\n            )\n\n        loop = asyncio.get_running_loop()\n\n        listeners: Sequence[socket.SocketType]\n        if sockets is not None:  # pragma: full coverage\n            # Explicitly passed a list of open sockets.\n            # We use this when the server is run from a Gunicorn worker.\n\n            def _share_socket(\n                sock: socket.SocketType,\n            ) -> socket.SocketType:  # pragma py-linux pragma: py-darwin\n                # Windows requires the socket be explicitly shared across\n                # multiple workers (processes).\n                from socket import fromshare  # type: ignore[attr-defined]\n\n                sock_data = sock.share(os.getpid())  # type: ignore[attr-defined]\n                return fromshare(sock_data)\n\n            self.servers: list[asyncio.base_events.Server] = []\n            for sock in sockets:\n                is_windows = platform.system() == \"Windows\"\n                if config.workers > 1 and is_windows:  # pragma: py-not-win32\n                    sock = _share_socket(sock)  # type: ignore[assignment]\n                server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n                self.servers.append(server)\n            listeners = sockets\n\n        elif config.fd is not None:  # pragma: py-win32\n            # Use an existing socket, from a file descriptor.\n            sock = socket.fromfd(config.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        elif config.uds is not None:  # pragma: py-win32\n            # Create a socket using UNIX domain socket.\n            uds_perms = 0o666\n            if os.path.exists(config.uds):\n                uds_perms = os.stat(config.uds).st_mode  # pragma: full coverage\n            server = await loop.create_unix_server(\n                create_protocol, path=config.uds, ssl=config.ssl, backlog=config.backlog\n            )\n            os.chmod(config.uds, uds_perms)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        else:\n            # Standard case. Create a socket from a host/port pair.\n            try:\n                server = await loop.create_server(\n                    create_protocol,\n                    host=config.host,\n                    port=config.port,\n                    ssl=config.ssl,\n                    backlog=config.backlog,\n                )\n            except OSError as exc:\n                logger.error(exc)\n                await self.lifespan.shutdown()\n                sys.exit(1)\n\n            assert server.sockets is not None\n            listeners = server.sockets\n            self.servers = [server]\n\n        if sockets is None:\n            self._log_started_message(listeners)\n        else:\n            # We're most likely running multiple workers, so a message has already been\n            # logged by `config.bind_socket()`.\n            pass  # pragma: full coverage\n\n        self.started = True\n\n    def _log_started_message(self, listeners: Sequence[socket.SocketType]) -> None:\n        config = self.config\n\n        if config.fd is not None:  # pragma: py-win32\n            sock = listeners[0]\n            logger.info(\n                \"Uvicorn running on socket %s (Press CTRL+C to quit)\",\n                sock.getsockname(),\n            )\n\n        elif config.uds is not None:  # pragma: py-win32\n            logger.info(\"Uvicorn running on unix socket %s (Press CTRL+C to quit)\", config.uds)\n\n        else:\n            addr_format = \"%s://%s:%d\"\n            host = \"0.0.0.0\" if config.host is None else config.host\n            if \":\" in host:\n                # It's an IPv6 address.\n                addr_format = \"%s://[%s]:%d\"\n\n            port = config.port\n            if port == 0:\n                port = listeners[0].getsockname()[1]\n\n            protocol_name = \"https\" if config.ssl else \"http\"\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger.info(\n                message,\n                protocol_name,\n                host,\n                port,\n                extra={\"color_message\": color_message},\n            )\n\n    async def main_loop(self) -> None:\n        counter = 0\n        should_exit = await self.on_tick(counter)\n        while not should_exit:\n            counter += 1\n            counter = counter % 864000\n            await asyncio.sleep(0.1)\n            should_exit = await self.on_tick(counter)\n\n    async def on_tick(self, counter: int) -> bool:\n        # Update the default headers, once per second.\n        if counter % 10 == 0:\n            current_time = time.time()\n            current_date = formatdate(current_time, usegmt=True).encode()\n\n            if self.config.date_header:\n                date_header = [(b\"date\", current_date)]\n            else:\n                date_header = []\n\n            self.server_state.default_headers = date_header + self.config.encoded_headers\n\n            # Callback to `callback_notify` once every `timeout_notify` seconds.\n            if self.config.callback_notify is not None:\n                if current_time - self.last_notified > self.config.timeout_notify:  # pragma: full coverage\n                    self.last_notified = current_time\n                    await self.config.callback_notify()\n\n        # Determine if we should exit.\n        if self.should_exit:\n            return True\n\n        max_requests = self.config.limit_max_requests\n        if max_requests is not None and self.server_state.total_requests >= max_requests:\n            logger.warning(f\"Maximum request limit of {max_requests} exceeded. Terminating process.\")\n            return True\n\n        return False\n\n    async def shutdown(self, sockets: list[socket.socket] | None = None) -> None:\n        logger.info(\"Shutting down\")\n\n        # Stop accepting new connections.\n        for server in self.servers:\n            server.close()\n        for sock in sockets or []:\n            sock.close()  # pragma: full coverage\n\n        # Request shutdown on all existing connections.\n        for connection in list(self.server_state.connections):\n            connection.shutdown()\n        await asyncio.sleep(0.1)\n\n        # When 3.10 is not supported anymore, use `async with asyncio.timeout(...):`.\n        try:\n            await asyncio.wait_for(\n                self._wait_tasks_to_complete(),\n                timeout=self.config.timeout_graceful_shutdown,\n            )\n        except asyncio.TimeoutError:\n            logger.error(\n                \"Cancel %s running task(s), timeout graceful shutdown exceeded\",\n                len(self.server_state.tasks),\n            )\n            for t in self.server_state.tasks:\n                t.cancel(msg=\"Task cancelled, timeout graceful shutdown exceeded\")\n\n        # Send the lifespan shutdown event, and wait for application shutdown.\n        if not self.force_exit:\n            await self.lifespan.shutdown()\n\n    async def _wait_tasks_to_complete(self) -> None:\n        # Wait for existing connections to finish sending responses.\n        if self.server_state.connections and not self.force_exit:\n            msg = \"Waiting for connections to close. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.connections and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        # Wait for existing tasks to complete.\n        if self.server_state.tasks and not self.force_exit:\n            msg = \"Waiting for background tasks to complete. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.tasks and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        for server in self.servers:\n            await server.wait_closed()\n\n    @contextlib.contextmanager\n    def capture_signals(self) -> Generator[None, None, None]:\n        # Signals can only be listened to from the main thread.\n        if threading.current_thread() is not threading.main_thread():\n            yield\n            return\n        # always use signal.signal, even if loop.add_signal_handler is available\n        # this allows to restore previous signal handlers later on\n        original_handlers = {sig: signal.signal(sig, self.handle_exit) for sig in HANDLED_SIGNALS}\n        try:\n            yield\n        finally:\n            for sig, handler in original_handlers.items():\n                signal.signal(sig, handler)\n        # If we did gracefully shut down due to a signal, try to\n        # trigger the expected behaviour now; multiple signals would be\n        # done LIFO, see https://stackoverflow.com/questions/48434964\n        for captured_signal in reversed(self._captured_signals):\n            signal.raise_signal(captured_signal)\n\n    def handle_exit(self, sig: int, frame: FrameType | None) -> None:\n        self._captured_signals.append(sig)\n        if self.should_exit and sig == signal.SIGINT:\n            self.force_exit = True  # pragma: full coverage\n        else:\n            self.should_exit = True"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport signal\nimport sys\nimport warnings\nfrom typing import Any\n\nfrom gunicorn.arbiter import Arbiter\nfrom gunicorn.workers.base import Worker\n\nfrom uvicorn.config import Config\nfrom uvicorn.server import Server\n\nwarnings.warn(\n    \"The `uvicorn.workers` module is deprecated. Please use `uvicorn-worker` package instead.\\n\"\n    \"For more details, see https://github.com/Kludex/uvicorn-worker.\",\n    DeprecationWarning,\n)"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "class UvicornWorker(Worker):\n    \"\"\"\n    A worker class for Gunicorn that interfaces with an ASGI consumer callable,\n    rather than a WSGI callable.\n    \"\"\"\n\n    CONFIG_KWARGS: dict[str, Any] = {\"loop\": \"auto\", \"http\": \"auto\"}\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.handlers = self.log.error_log.handlers\n        logger.setLevel(self.log.error_log.level)\n        logger.propagate = False\n\n        logger = logging.getLogger(\"uvicorn.access\")\n        logger.handlers = self.log.access_log.handlers\n        logger.setLevel(self.log.access_log.level)\n        logger.propagate = False\n\n        config_kwargs: dict = {\n            \"app\": None,\n            \"log_config\": None,\n            \"timeout_keep_alive\": self.cfg.keepalive,\n            \"timeout_notify\": self.timeout,\n            \"callback_notify\": self.callback_notify,\n            \"limit_max_requests\": self.max_requests,\n            \"forwarded_allow_ips\": self.cfg.forwarded_allow_ips,\n        }\n\n        if self.cfg.is_ssl:\n            ssl_kwargs = {\n                \"ssl_keyfile\": self.cfg.ssl_options.get(\"keyfile\"),\n                \"ssl_certfile\": self.cfg.ssl_options.get(\"certfile\"),\n                \"ssl_keyfile_password\": self.cfg.ssl_options.get(\"password\"),\n                \"ssl_version\": self.cfg.ssl_options.get(\"ssl_version\"),\n                \"ssl_cert_reqs\": self.cfg.ssl_options.get(\"cert_reqs\"),\n                \"ssl_ca_certs\": self.cfg.ssl_options.get(\"ca_certs\"),\n                \"ssl_ciphers\": self.cfg.ssl_options.get(\"ciphers\"),\n            }\n            config_kwargs.update(ssl_kwargs)\n\n        if self.cfg.settings[\"backlog\"].value:\n            config_kwargs[\"backlog\"] = self.cfg.settings[\"backlog\"].value\n\n        config_kwargs.update(self.CONFIG_KWARGS)\n\n        self.config = Config(**config_kwargs)\n\n    def init_process(self) -> None:\n        self.config.setup_event_loop()\n        super().init_process()\n\n    def init_signals(self) -> None:\n        # Reset signals so Gunicorn doesn't swallow subprocess return codes\n        # other signals are set up by Server.install_signal_handlers()\n        # See: https://github.com/encode/uvicorn/issues/894\n        for s in self.SIGNALS:\n            signal.signal(s, signal.SIG_DFL)\n\n        signal.signal(signal.SIGUSR1, self.handle_usr1)\n        # Don't let SIGUSR1 disturb active requests by interrupting system calls\n        signal.siginterrupt(signal.SIGUSR1, False)\n\n    def _install_sigquit_handler(self) -> None:\n        \"\"\"Install a SIGQUIT handler on workers.\n\n        - https://github.com/encode/uvicorn/issues/1116\n        - https://github.com/benoitc/gunicorn/issues/2604\n        \"\"\"\n\n        loop = asyncio.get_running_loop()\n        loop.add_signal_handler(signal.SIGQUIT, self.handle_exit, signal.SIGQUIT, None)\n\n    async def _serve(self) -> None:\n        self.config.app = self.wsgi\n        server = Server(config=self.config)\n        self._install_sigquit_handler()\n        await server.serve(sockets=self.sockets)\n        if not server.started:\n            sys.exit(Arbiter.WORKER_BOOT_ERROR)\n\n    def run(self) -> None:\n        return asyncio.run(self._serve())\n\n    async def callback_notify(self) -> None:\n        self.notify()"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "class UvicornH11Worker(UvicornWorker):\n    CONFIG_KWARGS = {\"loop\": \"asyncio\", \"http\": \"h11\"}"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__main__.py",
      "content": "import uvicorn"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__main__.py",
      "content": "if __name__ == \"__main__\":\n    uvicorn.main()"
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "\"\"\"\nSome light wrappers around Python's multiprocessing, to deal with cleanly\nstarting child processes.\n\"\"\""
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "from __future__ import annotations\n\nimport multiprocessing\nimport os\nimport sys\nfrom multiprocessing.context import SpawnProcess\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\n\nmultiprocessing.allow_connection_pickling()\nspawn = multiprocessing.get_context(\"spawn\")"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "def get_subprocess(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n) -> SpawnProcess:\n    \"\"\"\n    Called in the parent process, to instantiate a new child process instance.\n    The child is not yet started at this point.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    \"\"\"\n    # We pass across the stdin fileno, and reopen it in the child process.\n    # This is required for some debugging environments.\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    # The `sys.stdin` can be `None`, see https://docs.python.org/3/library/sys.html#sys.__stdin__.\n    except (AttributeError, OSError):\n        stdin_fileno = None\n\n    kwargs = {\n        \"config\": config,\n        \"target\": target,\n        \"sockets\": sockets,\n        \"stdin_fileno\": stdin_fileno,\n    }\n\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "def subprocess_started(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n    stdin_fileno: int | None,\n) -> None:\n    \"\"\"\n    Called when the child process starts.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    * stdin_fileno - The file number of sys.stdin, so that it can be reattached\n                     to the child process.\n    \"\"\"\n    # Re-open stdin.\n    if stdin_fileno is not None:\n        sys.stdin = os.fdopen(stdin_fileno)  # pragma: full coverage\n\n    # Logging needs to be setup again for each child.\n    config.configure_logging()\n\n    try:\n        # Now we can call into `Server.run(sockets=sockets)`\n        target(sockets=sockets)\n    except KeyboardInterrupt:  # pragma: no cover\n        # supress the exception to avoid a traceback from subprocess.Popen\n        # the parent already expects us to end, so no vital information is lost\n        pass"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "from __future__ import annotations\n\nimport http\nimport logging\nimport sys\nfrom copy import copy\nfrom typing import Literal\n\nimport click\n\nTRACE_LOG_LEVEL = 5"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class ColourizedFormatter(logging.Formatter):\n    \"\"\"\n    A custom log formatter class that:\n\n    * Outputs the LOG_LEVEL with an appropriate color.\n    * If a log call includes an `extra={\"color_message\": ...}` it will be used\n      for formatting the output, instead of the plain text message.\n    \"\"\"\n\n    level_name_colors = {\n        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),\n        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),\n        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),\n        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),\n        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),\n        logging.CRITICAL: lambda level_name: click.style(str(level_name), fg=\"bright_red\"),\n    }\n\n    def __init__(\n        self,\n        fmt: str | None = None,\n        datefmt: str | None = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: bool | None = None,\n    ):\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def color_level_name(self, level_name: str, level_no: int) -> str:\n        def default(level_name: str) -> str:\n            return str(level_name)  # pragma: no cover\n\n        func = self.level_name_colors.get(level_no, default)\n        return func(level_name)\n\n    def should_use_colors(self) -> bool:\n        return True  # pragma: no cover\n\n    def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        levelname = recordcopy.levelname\n        seperator = \" \" * (8 - len(recordcopy.levelname))\n        if self.use_colors:\n            levelname = self.color_level_name(levelname, recordcopy.levelno)\n            if \"color_message\" in recordcopy.__dict__:\n                recordcopy.msg = recordcopy.__dict__[\"color_message\"]\n                recordcopy.__dict__[\"message\"] = recordcopy.getMessage()\n        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator\n        return super().formatMessage(recordcopy)"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class DefaultFormatter(ColourizedFormatter):\n    def should_use_colors(self) -> bool:\n        return sys.stderr.isatty()  # pragma: no cover"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class AccessFormatter(ColourizedFormatter):\n    status_code_colours = {\n        1: lambda code: click.style(str(code), fg=\"bright_white\"),\n        2: lambda code: click.style(str(code), fg=\"green\"),\n        3: lambda code: click.style(str(code), fg=\"yellow\"),\n        4: lambda code: click.style(str(code), fg=\"red\"),\n        5: lambda code: click.style(str(code), fg=\"bright_red\"),\n    }\n\n    def get_status_code(self, status_code: int) -> str:\n        try:\n            status_phrase = http.HTTPStatus(status_code).phrase\n        except ValueError:\n            status_phrase = \"\"\n        status_and_phrase = f\"{status_code} {status_phrase}\"\n        if self.use_colors:\n\n            def default(code: int) -> str:\n                return status_and_phrase  # pragma: no cover\n\n            func = self.status_code_colours.get(status_code // 100, default)\n            return func(status_and_phrase)\n        return status_and_phrase\n\n    def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        (\n            client_addr,\n            method,\n            full_path,\n            http_version,\n            status_code,\n        ) = recordcopy.args  # type: ignore[misc]\n        status_code = self.get_status_code(int(status_code))  # type: ignore[arg-type]\n        request_line = f\"{method} {full_path} HTTP/{http_version}\"\n        if self.use_colors:\n            request_line = click.style(request_line, bold=True)\n        recordcopy.__dict__.update(\n            {\n                \"client_addr\": client_addr,\n                \"request_line\": request_line,\n                \"status_code\": status_code,\n            }\n        )\n        return super().formatMessage(recordcopy)"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom collections.abc import Awaitable\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Callable, Literal\n\nimport click\n\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def create_ssl_context(\n    certfile: str | os.PathLike[str],\n    keyfile: str | os.PathLike[str] | None,\n    password: str | None,\n    ssl_version: int,\n    cert_reqs: int,\n    ca_certs: str | os.PathLike[str] | None,\n    ciphers: str | None,\n) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:  # pragma: full coverage\n        return False"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        if pattern == \".*\":\n            continue  # pragma: py-darwin\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):  # pragma: full coverage\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n\n    directories = list(set(directories).difference(set(children)))\n\n    return list(set(patterns)), directories"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "class Config:\n    def __init__(\n        self,\n        app: ASGIApplication | Callable[..., Any] | str,\n        host: str = \"127.0.0.1\",\n        port: int = 8000,\n        uds: str | None = None,\n        fd: int | None = None,\n        loop: LoopSetupType = \"auto\",\n        http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n        ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n        ws_max_size: int = 16 * 1024 * 1024,\n        ws_max_queue: int = 32,\n        ws_ping_interval: float | None = 20.0,\n        ws_ping_timeout: float | None = 20.0,\n        ws_per_message_deflate: bool = True,\n        lifespan: LifespanType = \"auto\",\n        env_file: str | os.PathLike[str] | None = None,\n        log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n        log_level: str | int | None = None,\n        access_log: bool = True,\n        use_colors: bool | None = None,\n        interface: InterfaceType = \"auto\",\n        reload: bool = False,\n        reload_dirs: list[str] | str | None = None,\n        reload_delay: float = 0.25,\n        reload_includes: list[str] | str | None = None,\n        reload_excludes: list[str] | str | None = None,\n        workers: int | None = None,\n        proxy_headers: bool = True,\n        server_header: bool = True,\n        date_header: bool = True,\n        forwarded_allow_ips: list[str] | str | None = None,\n        root_path: str = \"\",\n        limit_concurrency: int | None = None,\n        limit_max_requests: int | None = None,\n        backlog: int = 2048,\n        timeout_keep_alive: int = 5,\n        timeout_notify: int = 30,\n        timeout_graceful_shutdown: int | None = None,\n        callback_notify: Callable[..., Awaitable[None]] | None = None,\n        ssl_keyfile: str | os.PathLike[str] | None = None,\n        ssl_certfile: str | os.PathLike[str] | None = None,\n        ssl_keyfile_password: str | None = None,\n        ssl_version: int = SSL_PROTOCOL_VERSION,\n        ssl_cert_reqs: int = ssl.CERT_NONE,\n        ssl_ca_certs: str | None = None,\n        ssl_ciphers: str = \"TLSv1\",\n        headers: list[tuple[str, str]] | None = None,\n        factory: bool = False,\n        h11_max_incomplete_event_size: int | None = None,\n    ):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n\n        self.loaded = False\n        self.configure_logging()\n\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n\n        if (reload_dirs or reload_includes or reload_excludes) and not self.should_reload:\n            logger.warning(\n                \"Current configuration will not reload as not all conditions are met, \" \"please refer to documentation.\"\n            )\n\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n\n            reload_dirs_tmp = self.reload_dirs.copy()\n\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:  # pragma: full coverage\n                            pass\n\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)  # pragma: full coverage\n\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning(\n                        \"Provided reload directories %s did not contain valid \"\n                        + \"directories, watching current working directory.\",\n                        reload_dirs,\n                    )\n                self.reload_dirs = [Path(os.getcwd())]\n\n            logger.info(\n                \"Will watch for changes in these directories: %s\",\n                sorted(list(map(str, self.reload_dirs))),\n            )\n\n        if env_file is not None:\n            from dotenv import load_dotenv\n\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n\n        if workers is None and \"WEB_CONCURRENCY\" in os.environ:\n            self.workers = int(os.environ[\"WEB_CONCURRENCY\"])\n\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1\")\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips  # pragma: full coverage\n\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')\n\n    @property\n    def asgi_version(self) -> Literal[\"2.0\", \"3.0\"]:\n        mapping: dict[str, Literal[\"2.0\", \"3.0\"]] = {\n            \"asgi2\": \"2.0\",\n            \"asgi3\": \"3.0\",\n            \"wsgi\": \"3.0\",\n        }\n        return mapping[self.interface]\n\n    @property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n\n    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, \"TRACE\")\n\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config[\"formatters\"][\"default\"][\"use_colors\"] = self.use_colors\n                    self.log_config[\"formatters\"][\"access\"][\"use_colors\"] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(\".json\"):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith((\".yaml\", \".yml\")):\n                import yaml\n\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger(\"uvicorn.error\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.access\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.asgi\").setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger(\"uvicorn.access\").handlers = []\n            logging.getLogger(\"uvicorn.access\").propagate = False\n\n    def load(self) -> None:\n        assert not self.loaded\n\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(\n                keyfile=self.ssl_keyfile,\n                certfile=self.ssl_certfile,\n                password=self.ssl_keyfile_password,\n                ssl_version=self.ssl_version,\n                cert_reqs=self.ssl_cert_reqs,\n                ca_certs=self.ssl_ca_certs,\n                ciphers=self.ssl_ciphers,\n            )\n        else:\n            self.ssl = None\n\n        encoded_headers = [(key.lower().encode(\"latin1\"), value.encode(\"latin1\")) for key, value in self.headers]\n        self.encoded_headers = (\n            [(b\"server\", b\"uvicorn\")] + encoded_headers\n            if b\"server\" not in dict(encoded_headers) and self.server_header\n            else encoded_headers\n        )\n\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error(\"Error loading ASGI app. %s\" % exc)\n            sys.exit(1)\n\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error(\"Error loading ASGI app factory: %s\", exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning(\n                    \"ASGI app factory detected. Using it, \" \"but please consider setting the --factory flag explicitly.\"\n                )\n\n        if self.interface == \"auto\":\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, \"__await__\")\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, \"__call__\", None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = \"asgi3\" if use_asgi_3 else \"asgi2\"\n\n        if self.interface == \"wsgi\":\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == \"asgi2\":\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n\n        self.loaded = True\n\n    def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)\n\n    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:  # pragma: py-win32\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 0o666\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = \"Uvicorn running on unix socket %s (Press CTRL+C to quit)\"\n            sock_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(sock_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [self.uds]\n        elif self.fd:  # pragma: py-win32\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = \"Uvicorn running on socket %s (Press CTRL+C to quit)\"\n            fd_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(fd_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = \"%s://%s:%d\"\n\n            if self.host and \":\" in self.host:  # pragma: full coverage\n                family = socket.AF_INET6\n                addr_format = \"%s://[%s]:%d\"\n\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            protocol_name = \"https\" if self.is_ssl else \"http\"\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={\"color_message\": color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "LOG_LEVELS: dict[str, int] = {\n    \"critical\": logging.CRITICAL,\n    \"error\": logging.ERROR,\n    \"warning\": logging.WARNING,\n    \"info\": logging.INFO,\n    \"debug\": logging.DEBUG,\n    \"trace\": TRACE_LOG_LEVEL,\n}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {\n    \"auto\": \"uvicorn.protocols.http.auto:AutoHTTPProtocol\",\n    \"h11\": \"uvicorn.protocols.http.h11_impl:H11Protocol\",\n    \"httptools\": \"uvicorn.protocols.http.httptools_impl:HttpToolsProtocol\",\n}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {\n    \"auto\": \"uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol\",\n    \"none\": None,\n    \"websockets\": \"uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol\",\n    \"wsproto\": \"uvicorn.protocols.websockets.wsproto_impl:WSProtocol\",\n}\nLIFESPAN: dict[LifespanType, str] = {\n    \"auto\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"on\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"off\": \"uvicorn.lifespan.off:LifespanOff\",\n}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {\n    \"none\": None,\n    \"auto\": \"uvicorn.loops.auto:auto_loop_setup\",\n    \"asyncio\": \"uvicorn.loops.asyncio:asyncio_setup\",\n    \"uvloop\": \"uvicorn.loops.uvloop:uvloop_setup\",\n}\nINTERFACES: list[InterfaceType] = [\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\n\nLOGGING_CONFIG: dict[str, Any] = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": \"%(levelprefix)s %(message)s\",\n            \"use_colors\": None,\n        },\n        \"access\": {\n            \"()\": \"uvicorn.logging.AccessFormatter\",\n            \"fmt\": '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n        },\n    },\n    \"handlers\": {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n        \"access\": {\n            \"formatter\": \"access\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"loggers\": {\n        \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"INFO\", \"propagate\": False},\n        \"uvicorn.error\": {\"level\": \"INFO\"},\n        \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"INFO\", \"propagate\": False},\n    },\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "```"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "Copyright (c) Django Software Foundation and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n\n    3. Neither the name of Django nor the names of its contributors may be used\n       to endorse or promote products derived from this software without\n       specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "from __future__ import annotations\n\nimport sys\nimport types\nfrom collections.abc import Awaitable, Iterable, MutableMapping\nfrom typing import Any, Callable, Literal, Optional, Protocol, TypedDict, Union\n\nif sys.version_info >= (3, 11):  # pragma: py-lt-311\n    from typing import NotRequired\nelse:  # pragma: py-gte-311\n    from typing_extensions import NotRequired"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class ASGIVersions(TypedDict):\n    spec_version: str\n    version: Literal[\"2.0\"] | Literal[\"3.0\"]"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPScope(TypedDict):\n    type: Literal[\"http\"]\n    asgi: ASGIVersions\n    http_version: str\n    method: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketScope(TypedDict):\n    type: Literal[\"websocket\"]\n    asgi: ASGIVersions\n    http_version: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    subprotocols: Iterable[str]\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanScope(TypedDict):\n    type: Literal[\"lifespan\"]\n    asgi: ASGIVersions\n    state: NotRequired[dict[str, Any]]"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPRequestEvent(TypedDict):\n    type: Literal[\"http.request\"]\n    body: bytes\n    more_body: bool"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseDebugEvent(TypedDict):\n    type: Literal[\"http.response.debug\"]\n    info: dict[str, object]"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseStartEvent(TypedDict):\n    type: Literal[\"http.response.start\"]\n    status: int\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]\n    trailers: NotRequired[bool]"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseBodyEvent(TypedDict):\n    type: Literal[\"http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseTrailersEvent(TypedDict):\n    type: Literal[\"http.response.trailers\"]\n    headers: Iterable[tuple[bytes, bytes]]\n    more_trailers: bool"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPServerPushEvent(TypedDict):\n    type: Literal[\"http.response.push\"]\n    path: str\n    headers: Iterable[tuple[bytes, bytes]]"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPDisconnectEvent(TypedDict):\n    type: Literal[\"http.disconnect\"]"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketConnectEvent(TypedDict):\n    type: Literal[\"websocket.connect\"]"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketAcceptEvent(TypedDict):\n    type: Literal[\"websocket.accept\"]\n    subprotocol: NotRequired[str | None]\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketReceiveEventBytes(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: bytes\n    text: NotRequired[None]"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketReceiveEventText(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: NotRequired[None]\n    text: str"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketSendEventBytes(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: bytes\n    text: NotRequired[None]"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketSendEventText(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: NotRequired[None]\n    text: str"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketResponseStartEvent(TypedDict):\n    type: Literal[\"websocket.http.response.start\"]\n    status: int\n    headers: Iterable[tuple[bytes, bytes]]"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketResponseBodyEvent(TypedDict):\n    type: Literal[\"websocket.http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketDisconnectEvent(TypedDict):\n    type: Literal[\"websocket.disconnect\"]\n    code: int\n    reason: NotRequired[str | None]"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketCloseEvent(TypedDict):\n    type: Literal[\"websocket.close\"]\n    code: NotRequired[int]\n    reason: NotRequired[str | None]"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupEvent(TypedDict):\n    type: Literal[\"lifespan.startup\"]"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown\"]"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.startup.complete\"]"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupFailedEvent(TypedDict):\n    type: Literal[\"lifespan.startup.failed\"]\n    message: str"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.complete\"]"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownFailedEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.failed\"]\n    message: str"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGIReceiveEvent = Union[\n    HTTPRequestEvent,\n    HTTPDisconnectEvent,\n    WebSocketConnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketDisconnectEvent,\n    LifespanStartupEvent,\n    LifespanShutdownEvent,\n]"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGISendEvent = Union[\n    HTTPResponseStartEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseTrailersEvent,\n    HTTPServerPushEvent,\n    HTTPDisconnectEvent,\n    WebSocketAcceptEvent,\n    WebSocketSendEvent,\n    WebSocketResponseStartEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketCloseEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupFailedEvent,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownFailedEvent,\n]"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGIReceiveCallable = Callable[[], Awaitable[ASGIReceiveEvent]]\nASGISendCallable = Callable[[ASGISendEvent], Awaitable[None]]"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class ASGI2Protocol(Protocol):\n    def __init__(self, scope: Scope) -> None: ...  # pragma: no cover\n\n    async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None: ...  # pragma: no cover"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGI2Application = type[ASGI2Protocol]\nASGI3Application = Callable[\n    [\n        Scope,\n        ASGIReceiveCallable,\n        ASGISendCallable,\n    ],\n    Awaitable[None],\n]\nASGIApplication = Union[ASGI2Application, ASGI3Application]\n```"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom uvicorn.supervisors.basereload import BaseReload\nfrom uvicorn.supervisors.multiprocess import Multiprocess"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "if TYPE_CHECKING:\n    ChangeReload: type[BaseReload]\nelse:\n    try:\n        from uvicorn.supervisors.watchfilesreload import WatchFilesReload as ChangeReload\n    except ImportError:  # pragma: no cover\n        from uvicorn.supervisors.statreload import StatReload as ChangeReload"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "__all__ = [\"Multiprocess\", \"ChangeReload\"]"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "from __future__ import annotations\n\nimport logging\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "class StatReload(BaseReload):\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"StatReload\"\n        self.mtimes: dict[Path, float] = {}\n\n        if config.reload_excludes or config.reload_includes:\n            logger.warning(\"--reload-include and --reload-exclude have no effect unless \" \"watchfiles is installed.\")\n\n    def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        for file in self.iter_py_files():\n            try:\n                mtime = file.stat().st_mtime\n            except OSError:  # pragma: nocover\n                continue\n\n            old_time = self.mtimes.get(file)\n            if old_time is None:\n                self.mtimes[file] = mtime\n                continue\n            elif mtime > old_time:\n                return [file]\n        return None\n\n    def restart(self) -> None:\n        self.mtimes = {}\n        return super().restart()\n\n    def iter_py_files(self) -> Iterator[Path]:\n        for reload_dir in self.config.reload_dirs:\n            for path in list(reload_dir.rglob(\"*.py\")):\n                yield path.resolve()"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport threading\nfrom multiprocessing import Pipe\nfrom socket import socket\nfrom typing import Any, Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nSIGNALS = {\n    getattr(signal, f\"SIG{x}\"): x\n    for x in \"INT TERM BREAK HUP QUIT TTIN TTOU USR1 USR2 WINCH\".split()\n    if hasattr(signal, f\"SIG{x}\")\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "class Process:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.real_target = target\n\n        self.parent_conn, self.child_conn = Pipe()\n        self.process = get_subprocess(config, self.target, sockets)\n\n    def ping(self, timeout: float = 5) -> bool:\n        self.parent_conn.send(b\"ping\")\n        if self.parent_conn.poll(timeout):\n            self.parent_conn.recv()\n            return True\n        return False\n\n    def pong(self) -> None:\n        self.child_conn.recv()\n        self.child_conn.send(b\"pong\")\n\n    def always_pong(self) -> None:\n        while True:\n            self.pong()\n\n    def target(self, sockets: list[socket] | None = None) -> Any:  # pragma: no cover\n        if os.name == \"nt\":  # pragma: py-not-win32\n            signal.signal(\n                signal.SIGBREAK,  # type: ignore[attr-defined]\n                lambda sig, frame: signal.raise_signal(signal.SIGTERM),\n            )\n\n        threading.Thread(target=self.always_pong, daemon=True).start()\n        return self.real_target(sockets)\n\n    def is_alive(self, timeout: float = 5) -> bool:\n        if not self.process.is_alive():\n            return False  # pragma: full coverage\n\n        return self.ping(timeout)\n\n    def start(self) -> None:\n        self.process.start()\n\n    def terminate(self) -> None:\n        if self.process.exitcode is None:  # Process is still running\n            assert self.process.pid is not None\n            if os.name == \"nt\":  # pragma: py-not-win32\n                os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)  # type: ignore[attr-defined]\n            else:\n                os.kill(self.process.pid, signal.SIGTERM)\n            logger.info(f\"Terminated child process [{self.process.pid}]\")\n\n            self.parent_conn.close()\n            self.child_conn.close()\n\n    def kill(self) -> None:\n        self.process.kill()\n\n    def join(self) -> None:\n        logger.info(f\"Waiting for child process [{self.process.pid}]\")\n        self.process.join()\n\n    @property\n    def pid(self) -> int | None:\n        return self.process.pid"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "class Multiprocess:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n\n        self.processes_num = config.workers\n        self.processes: list[Process] = []\n\n        self.should_exit = threading.Event()\n\n        self.signal_queue: list[int] = []\n        for sig in SIGNALS:\n            signal.signal(sig, lambda sig, frame: self.signal_queue.append(sig))\n\n    def init_processes(self) -> None:\n        for _ in range(self.processes_num):\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes.append(process)\n\n    def terminate_all(self) -> None:\n        for process in self.processes:\n            process.terminate()\n\n    def join_all(self) -> None:\n        for process in self.processes:\n            process.join()\n\n    def restart_all(self) -> None:\n        for idx, process in enumerate(self.processes):\n            process.terminate()\n            process.join()\n            new_process = Process(self.config, self.target, self.sockets)\n            new_process.start()\n            self.processes[idx] = new_process\n\n    def run(self) -> None:\n        message = f\"Started parent process [{os.getpid()}]\"\n        color_message = \"Started parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n        self.init_processes()\n\n        while not self.should_exit.wait(0.5):\n            self.handle_signals()\n            self.keep_subprocess_alive()\n\n        self.terminate_all()\n        self.join_all()\n\n        message = f\"Stopping parent process [{os.getpid()}]\"\n        color_message = \"Stopping parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n    def keep_subprocess_alive(self) -> None:\n        if self.should_exit.is_set():\n            return  # parent process is exiting, no need to keep subprocess alive\n\n        for idx, process in enumerate(self.processes):\n            if process.is_alive():\n                continue\n\n            process.kill()  # process is hung, kill it\n            process.join()\n\n            if self.should_exit.is_set():\n                return  # pragma: full coverage\n\n            logger.info(f\"Child process [{process.pid}] died\")\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes[idx] = process\n\n    def handle_signals(self) -> None:\n        for sig in tuple(self.signal_queue):\n            self.signal_queue.remove(sig)\n            sig_name = SIGNALS[sig]\n            sig_handler = getattr(self, f\"handle_{sig_name.lower()}\", None)\n            if sig_handler is not None:\n                sig_handler()\n            else:  # pragma: no cover\n                logger.debug(f\"Received signal {sig_name}, but no handler is defined for it.\")\n\n    def handle_int(self) -> None:\n        logger.info(\"Received SIGINT, exiting.\")\n        self.should_exit.set()\n\n    def handle_term(self) -> None:\n        logger.info(\"Received SIGTERM, exiting.\")\n        self.should_exit.set()\n\n    def handle_break(self) -> None:  # pragma: py-not-win32\n        logger.info(\"Received SIGBREAK, exiting.\")\n        self.should_exit.set()\n\n    def handle_hup(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGHUP, restarting processes.\")\n        self.restart_all()\n\n    def handle_ttin(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTIN, increasing the number of processes.\")\n        self.processes_num += 1\n        process = Process(self.config, self.target, self.sockets)\n        process.start()\n        self.processes.append(process)\n\n    def handle_ttou(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTOU, decreasing number of processes.\")\n        if self.processes_num <= 1:\n            logger.info(\"Already reached one process, cannot decrease the number of processes anymore.\")\n            return\n        self.processes_num -= 1\n        process = self.processes.pop()\n        process.terminate()\n        process.join()"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport sys\nimport threading\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom types import FrameType\nfrom typing import Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "class BaseReload:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n        self.should_exit = threading.Event()\n        self.pid = os.getpid()\n        self.is_restarting = False\n        self.reloader_name: str | None = None\n\n    def signal_handler(self, sig: int, frame: FrameType | None) -> None:  # pragma: full coverage\n        \"\"\"\n        A signal handler that is registered with the parent process.\n        \"\"\"\n        if sys.platform == \"win32\" and self.is_restarting:\n            self.is_restarting = False\n        else:\n            self.should_exit.set()\n\n    def run(self) -> None:\n        self.startup()\n        for changes in self:\n            if changes:\n                logger.warning(\n                    \"%s detected changes in %s. Reloading...\",\n                    self.reloader_name,\n                    \", \".join(map(_display_path, changes)),\n                )\n                self.restart()\n\n        self.shutdown()\n\n    def pause(self) -> None:\n        if self.should_exit.wait(self.config.reload_delay):\n            raise StopIteration()\n\n    def __iter__(self) -> Iterator[list[Path] | None]:\n        return self\n\n    def __next__(self) -> list[Path] | None:\n        return self.should_restart()\n\n    def startup(self) -> None:\n        message = f\"Started reloader process [{self.pid}] using {self.reloader_name}\"\n        color_message = \"Started reloader process [{}] using {}\".format(\n            click.style(str(self.pid), fg=\"cyan\", bold=True),\n            click.style(str(self.reloader_name), fg=\"cyan\", bold=True),\n        )\n        logger.info(message, extra={\"color_message\": color_message})\n\n        for sig in HANDLED_SIGNALS:\n            signal.signal(sig, self.signal_handler)\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()\n\n    def restart(self) -> None:\n        if sys.platform == \"win32\":  # pragma: py-not-win32\n            self.is_restarting = True\n            assert self.process.pid is not None\n            os.kill(self.process.pid, signal.CTRL_C_EVENT)\n        else:  # pragma: py-win32\n            self.process.terminate()\n        self.process.join()\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()\n\n    def shutdown(self) -> None:\n        if sys.platform == \"win32\":\n            self.should_exit.set()  # pragma: py-not-win32\n        else:\n            self.process.terminate()  # pragma: py-win32\n        self.process.join()\n\n        for sock in self.sockets:\n            sock.close()\n\n        message = f\"Stopping reloader process [{str(self.pid)}]\"\n        color_message = \"Stopping reloader process [{}]\".format(click.style(str(self.pid), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n    def should_restart(self) -> list[Path] | None:\n        raise NotImplementedError(\"Reload strategies should override should_restart()\")"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def _display_path(path: Path) -> str:\n    try:\n        return f\"'{path.relative_to(Path.cwd())}'\"\n    except ValueError:\n        return f\"'{path}'\""
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom watchfiles import watch\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "class FileFilter:\n    def __init__(self, config: Config):\n        default_includes = [\"*.py\"]\n        self.includes = [default for default in default_includes if default not in config.reload_excludes]\n        self.includes.extend(config.reload_includes)\n        self.includes = list(set(self.includes))\n\n        default_excludes = [\".*\", \".py[cod]\", \".sw.*\", \"~*\"]\n        self.excludes = [default for default in default_excludes if default not in config.reload_includes]\n        self.exclude_dirs = []\n        for e in config.reload_excludes:\n            p = Path(e)\n            try:\n                is_dir = p.is_dir()\n            except OSError:  # pragma: no cover\n                # gets raised on Windows for values like \"*.py\"\n                is_dir = False\n\n            if is_dir:\n                self.exclude_dirs.append(p)\n            else:\n                self.excludes.append(e)  # pragma: full coverage\n        self.excludes = list(set(self.excludes))\n\n    def __call__(self, path: Path) -> bool:\n        for include_pattern in self.includes:\n            if path.match(include_pattern):\n                if str(path).endswith(include_pattern):\n                    return True  # pragma: full coverage\n\n                for exclude_dir in self.exclude_dirs:\n                    if exclude_dir in path.parents:\n                        return False\n\n                for exclude_pattern in self.excludes:\n                    if path.match(exclude_pattern):\n                        return False  # pragma: full coverage\n\n                return True\n        return False"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "class WatchFilesReload(BaseReload):\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"WatchFiles\"\n        self.reload_dirs = []\n        for directory in config.reload_dirs:\n            if Path.cwd() not in directory.parents:\n                self.reload_dirs.append(directory)\n        if Path.cwd() not in self.reload_dirs:\n            self.reload_dirs.append(Path.cwd())\n\n        self.watch_filter = FileFilter(config)\n        self.watcher = watch(\n            *self.reload_dirs,\n            watch_filter=None,\n            stop_event=self.should_exit,\n            # using yield_on_timeout here mostly to make sure tests don't\n            # hang forever, won't affect the class's behavior\n            yield_on_timeout=True,\n        )\n\n    def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        changes = next(self.watcher)\n        if changes:\n            unique_paths = {Path(c[1]) for c in changes}\n            return [p for p in unique_paths if self.watch_filter(p)]\n        return None"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def display(self):\n        print(self.value)"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "class AnotherClass:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        print(f\"Hello, {self.name}!\")"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/asyncio.py",
      "content": "import asyncio\nimport logging\nimport sys\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/asyncio.py",
      "content": "def asyncio_setup(use_subprocess: bool = False) -> None:\n    if sys.platform == \"win32\" and use_subprocess:\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())  # pragma: full coverage"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/uvloop.py",
      "content": "import asyncio\n\nimport uvloop"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/uvloop.py",
      "content": "def uvloop_setup(use_subprocess: bool = False) -> None:\n    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/auto.py",
      "content": "def auto_loop_setup(use_subprocess: bool = False) -> None:\n    try:\n        import uvloop  # noqa\n    except ImportError:  # pragma: no cover\n        from uvicorn.loops.asyncio import asyncio_setup as loop_setup\n\n        loop_setup(use_subprocess=use_subprocess)\n    else:  # pragma: no cover\n        from uvicorn.loops.uvloop import uvloop_setup\n\n        uvloop_setup(use_subprocess=use_subprocess)"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/__init__.py",
      "content": "Sure, please provide the Python code you would like me to analyze."
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport urllib.parse\n\nfrom uvicorn._types import WWWScope"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "class ClientDisconnected(OSError): ..."
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        try:\n            info = socket_info.getpeername()\n            return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n        except OSError:  # pragma: no cover\n            # This case appears to inconsistently occur with uvloop\n            # bound to a unix domain socket.\n            return None\n\n    info = transport.get_extra_info(\"peername\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        info = socket_info.getsockname()\n\n        return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n    info = transport.get_extra_info(\"sockname\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def is_ssl(transport: asyncio.Transport) -> bool:\n    return bool(transport.get_extra_info(\"sslcontext\"))"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_client_addr(scope: WWWScope) -> str:\n    client = scope.get(\"client\")\n    if not client:\n        return \"\"\n    return \"%s:%d\" % client"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_path_with_query_string(scope: WWWScope) -> str:\n    path_with_query_string = urllib.parse.quote(scope[\"path\"])\n    if scope[\"query_string\"]:\n        path_with_query_string = \"{}?{}\".format(path_with_query_string, scope[\"query_string\"].decode(\"ascii\"))\n    return path_with_query_string"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def display(self):\n        print(self.value)"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "class AnotherClass:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        print(f\"Hello, {self.name}!\")"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "import asyncio\n\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\n\nCLOSE_HEADER = (b\"connection\", b\"close\")\n\nHIGH_WATER_LIMIT = 65536"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "class FlowControl:\n    def __init__(self, transport: asyncio.Transport) -> None:\n        self._transport = transport\n        self.read_paused = False\n        self.write_paused = False\n        self._is_writable_event = asyncio.Event()\n        self._is_writable_event.set()\n\n    async def drain(self) -> None:\n        await self._is_writable_event.wait()  # pragma: full coverage\n\n    def pause_reading(self) -> None:\n        if not self.read_paused:\n            self.read_paused = True\n            self._transport.pause_reading()\n\n    def resume_reading(self) -> None:\n        if self.read_paused:\n            self.read_paused = False\n            self._transport.resume_reading()\n\n    def pause_writing(self) -> None:\n        if not self.write_paused:  # pragma: full coverage\n            self.write_paused = True\n            self._is_writable_event.clear()\n\n    def resume_writing(self) -> None:\n        if self.write_paused:  # pragma: full coverage\n            self.write_paused = False\n            self._is_writable_event.set()"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "async def service_unavailable(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 503,\n            \"headers\": [\n                (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                (b\"content-length\", b\"19\"),\n                (b\"connection\", b\"close\"),\n            ],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"Service Unavailable\", \"more_body\": False})"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom typing import Any, Callable, Literal, cast\nfrom urllib.parse import unquote\n\nimport h11\nfrom h11._connection import DEFAULT_MAX_INCOMPLETE_EVENT_SIZE\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "def _get_status_phrase(status_code: int) -> bytes:\n    try:\n        return http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        return b\"\""
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "STATUS_PHRASES = {status_code: _get_status_phrase(status_code) for status_code in range(100, 600)}"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "class H11Protocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.conn = h11.Connection(\n            h11.SERVER,\n            config.h11_max_incomplete_event_size\n            if config.h11_max_incomplete_event_size is not None\n            else DEFAULT_MAX_INCOMPLETE_EVENT_SIZE,\n        )\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        # Timeouts\n        self.timeout_keep_alive_task: asyncio.TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        # Shared server state\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Per-connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n\n        # Per-request state\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]\n\n    # Protocol interface\n    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)\n\n    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.conn.our_state != h11.ERROR:\n            event = h11.ConnectionClosed()\n            try:\n                self.conn.send(event)\n            except h11.LocalProtocolError:\n                # Premature client disconnect\n                pass\n\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n\n    def eof_received(self) -> None:\n        pass\n\n    def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None\n\n    def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None\n\n    def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True\n\n    def _unsupported_upgrade_warning(self) -> None:\n        msg = \"Unsupported upgrade request.\"\n        self.logger.warning(msg)\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)\n\n    def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        if upgrade == b\"websocket\" and self._should_upgrade_to_ws():\n            return True\n        if upgrade is not None:\n            self._unsupported_upgrade_warning()\n        return False\n\n    def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        self.conn.receive_data(data)\n        self.handle_events()\n\n    def handle_events(self) -> None:\n        while True:\n            try:\n                event = self.conn.next_event()\n            except h11.RemoteProtocolError:\n                msg = \"Invalid HTTP request received.\"\n                self.logger.warning(msg)\n                self.send_400_response(msg)\n                return\n\n            if event is h11.NEED_DATA:\n                break\n\n            elif event is h11.PAUSED:\n                # This case can occur in HTTP pipelining, so we need to\n                # stop reading any more data, and ensure that at the end\n                # of the active request/response cycle we handle any\n                # events that have been buffered up.\n                self.flow.pause_reading()\n                break\n\n            elif isinstance(event, h11.Request):\n                self.headers = [(key.lower(), value) for key, value in event.headers]\n                raw_path, _, query_string = event.target.partition(b\"?\")\n                path = unquote(raw_path.decode(\"ascii\"))\n                full_path = self.root_path + path\n                full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n                self.scope = {\n                    \"type\": \"http\",\n                    \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n                    \"http_version\": event.http_version.decode(\"ascii\"),\n                    \"server\": self.server,\n                    \"client\": self.client,\n                    \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n                    \"method\": event.method.decode(\"ascii\"),\n                    \"root_path\": self.root_path,\n                    \"path\": full_path,\n                    \"raw_path\": full_raw_path,\n                    \"query_string\": query_string,\n                    \"headers\": self.headers,\n                    \"state\": self.app_state.copy(),\n                }\n                if self._should_upgrade():\n                    self.handle_websocket_upgrade(event)\n                    return\n\n                # Handle 503 responses when 'limit_concurrency' is exceeded.\n                if self.limit_concurrency is not None and (\n                    len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n                ):\n                    app = service_unavailable\n                    message = \"Exceeded concurrency limit.\"\n                    self.logger.warning(message)\n                else:\n                    app = self.app\n\n                # When starting to process a request, disable the keep-alive\n                # timeout. Normally we disable this when receiving data from\n                # client and set back when finishing processing its request.\n                # However, for pipelined requests processing finishes after\n                # already receiving the next request and thus the timer may\n                # be set here, which we don't want.\n                self._unset_keepalive_if_required()\n\n                self.cycle = RequestResponseCycle(\n                    scope=self.scope,\n                    conn=self.conn,\n                    transport=self.transport,\n                    flow=self.flow,\n                    logger=self.logger,\n                    access_logger=self.access_logger,\n                    access_log=self.access_log,\n                    default_headers=self.server_state.default_headers,\n                    message_event=asyncio.Event(),\n                    on_response=self.on_response_complete,\n                )\n                task = self.loop.create_task(self.cycle.run_asgi(app))\n                task.add_done_callback(self.tasks.discard)\n                self.tasks.add(task)\n\n            elif isinstance(event, h11.Data):\n                if self.conn.our_state is h11.DONE:\n                    continue\n                self.cycle.body += event.data\n                if len(self.cycle.body) > HIGH_WATER_LIMIT:\n                    self.flow.pause_reading()\n                self.cycle.message_event.set()\n\n            elif isinstance(event, h11.EndOfMessage):\n                if self.conn.our_state is h11.DONE:\n                    self.transport.resume_reading()\n                    self.conn.start_next_cycle()\n                    continue\n                self.cycle.more_body = False\n                self.cycle.message_event.set()\n                if self.conn.their_state == h11.MUST_CLOSE:\n                    break\n\n    def handle_websocket_upgrade(self, event: h11.Request) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:  # pragma: full coverage\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        output = [event.method, b\" \", event.target, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.headers:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)\n\n    def send_400_response(self, msg: str) -> None:\n        reason = STATUS_PHRASES[400]\n        headers: list[tuple[bytes, bytes]] = [\n            (b\"content-type\", b\"text/plain; charset=utf-8\"),\n            (b\"connection\", b\"close\"),\n        ]\n        event = h11.Response(status_code=400, headers=headers, reason=reason)\n        output = self.conn.send(event)\n        self.transport.write(output)\n\n        output = self.conn.send(event=h11.Data(data=msg.encode(\"ascii\")))\n        self.transport.write(output)\n\n        output = self.conn.send(event=h11.EndOfMessage())\n        self.transport.write(output)\n\n        self.transport.close()\n\n    def on_response_complete(self) -> None:\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        # Set a short Keep-Alive timeout.\n        self._unset_keepalive_if_required()\n\n        self.timeout_keep_alive_task = self.loop.call_later(self.timeout_keep_alive, self.timeout_keep_alive_handler)\n\n        # Unpause data reads if needed.\n        self.flow.resume_reading()\n\n        # Unblock any pipelined events.\n        if self.conn.our_state is h11.DONE and self.conn.their_state is h11.DONE:\n            self.conn.start_next_cycle()\n            self.handle_events()\n\n    def shutdown(self) -> None:\n        \"\"\"\n        Called by the server to commence a graceful shutdown.\n        \"\"\"\n        if self.cycle is None or self.cycle.response_complete:\n            event = h11.ConnectionClosed()\n            self.conn.send(event)\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False\n\n    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.flow.pause_writing()  # pragma: full coverage\n\n    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.flow.resume_writing()  # pragma: full coverage\n\n    def timeout_keep_alive_handler(self) -> None:\n        \"\"\"\n        Called on a keep-alive connection if no new data is received after a short\n        delay.\n        \"\"\"\n        if not self.transport.is_closing():\n            event = h11.ConnectionClosed()\n            self.conn.send(event)\n            self.transport.close()"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "class RequestResponseCycle:\n    def __init__(\n        self,\n        scope: HTTPScope,\n        conn: h11.Connection,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        on_response: Callable[..., None],\n    ) -> None:\n        self.scope = scope\n        self.conn = conn\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        # Connection state\n        self.disconnected = False\n        self.keep_alive = True\n        self.waiting_for_100_continue = conn.they_are_waiting_for_100_continue\n\n        # Request state\n        self.body = b\"\"\n        self.more_body = True\n\n        # Response state\n        self.response_started = False\n        self.response_complete = False\n\n    # ASGI exception wrapper\n    async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None\n\n    async def send_500_response(self) -> None:\n        response_start_event: HTTPResponseStartEvent = {\n            \"type\": \"http.response.start\",\n            \"status\": 500,\n            \"headers\": [\n                (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                (b\"connection\", b\"close\"),\n            ],\n        }\n        await self.send(response_start_event)\n        response_body_event: HTTPResponseBodyEvent = {\n            \"type\": \"http.response.body\",\n            \"body\": b\"Internal Server Error\",\n            \"more_body\": False,\n        }\n        await self.send(response_body_event)\n\n    # ASGI interface\n    async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            # Sending response status line and headers\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status,\n                )\n\n            # Write response status line and headers\n            reason = STATUS_PHRASES[status]\n            response = h11.Response(status_code=status, headers=headers, reason=reason)\n            output = self.conn.send(event=response)\n            self.transport.write(output)\n\n        elif not self.response_complete:\n            # Sending response body\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseBodyEvent\", message)\n\n            body = message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n\n            # Write response body\n            data = b\"\" if self.scope[\"method\"] == \"HEAD\" else body\n            output = self.conn.send(event=h11.Data(data=data))\n            self.transport.write(output)\n\n            # Handle response completion\n            if not more_body:\n                self.response_complete = True\n                self.message_event.set()\n                output = self.conn.send(event=h11.EndOfMessage())\n                self.transport.write(output)\n\n        else:\n            # Response already sent\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n        if self.response_complete:\n            if self.conn.our_state is h11.MUST_CLOSE or not self.keep_alive:\n                self.conn.send(event=h11.ConnectionClosed())\n                self.transport.close()\n            self.on_response()\n\n    async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            headers: list[tuple[str, str]] = []\n            event = h11.InformationalResponse(status_code=100, headers=headers, reason=\"Continue\")\n            output = self.conn.send(event=event)\n            self.transport.write(output)\n            self.waiting_for_100_continue = False\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n\n        message: HTTPRequestEvent = {\n            \"type\": \"http.request\",\n            \"body\": self.body,\n            \"more_body\": self.more_body,\n        }\n        self.body = b\"\"\n        return message"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "from __future__ import annotations"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "import asyncio"
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "AutoHTTPProtocol: type[asyncio.Protocol]\ntry:\n    import httptools  # noqa\nexcept ImportError:  # pragma: no cover\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n\n    AutoHTTPProtocol = H11Protocol\nelse:  # pragma: no cover\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n\n    AutoHTTPProtocol = HttpToolsProtocol"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nimport re\nimport urllib\nfrom asyncio.events import TimerHandle\nfrom collections import deque\nfrom typing import Any, Callable, Literal, cast\n\nimport httptools\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState\n\nHEADER_RE = re.compile(b'[\\x00-\\x1f\\x7f()<>@,;:[]={} \\t\\\\\"]')\nHEADER_VALUE_RE = re.compile(b\"[\\x00-\\x08\\x0a-\\x1f\\x7f]\")"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _get_status_line(status_code: int) -> bytes:\n    try:\n        phrase = http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        phrase = b\"\"\n    return b\"\".join([b\"HTTP/1.1 \", str(status_code).encode(), b\" \", phrase, b\"\\r\\n\"])\n\nSTATUS_LINE = {status_code: _get_status_line(status_code) for status_code in range(100, 600)}"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "class HttpToolsProtocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.parser = httptools.HttpRequestParser(self)\n\n        try:\n            self.parser.set_dangerous_leniencies(lenient_data_after_close=True)\n        except AttributeError:  # pragma: no cover\n            pass\n\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        self.timeout_keep_alive_task: TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n        self.pipeline: deque[tuple[RequestResponseCycle, ASGI3Application]] = deque()\n\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.expect_100_continue = False\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]\n\n    def connection_made(self, transport: asyncio.Transport) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)\n\n    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n\n        self.parser = None\n\n    def eof_received(self) -> None:\n        pass\n\n    def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None\n\n    def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None  # pragma: full coverage\n\n    def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True\n\n    def _unsupported_upgrade_warning(self) -> None:\n        self.logger.warning(\"Unsupported upgrade request.\")\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)\n\n    def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        return upgrade == b\"websocket\" and self._should_upgrade_to_ws()\n\n    def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        try:\n            self.parser.feed_data(data)\n        except httptools.HttpParserError:\n            msg = \"Invalid HTTP request received.\"\n            self.logger.warning(msg)\n            self.send_400_response(msg)\n            return\n        except httptools.HttpParserUpgrade:\n            if self._should_upgrade():\n                self.handle_websocket_upgrade()\n            else:\n                self._unsupported_upgrade_warning()\n\n    def handle_websocket_upgrade(self) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        method = self.scope[\"method\"].encode()\n        output = [method, b\" \", self.url, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.scope[\"headers\"]:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)\n\n    def send_400_response(self, msg: str) -> None:\n        content = [STATUS_LINE[400]]\n        for name, value in self.server_state.default_headers:\n            content.extend([name, b\": \", value, b\"\\r\\n\"])  # pragma: full coverage\n        content.extend(\n            [\n                b\"content-type: text/plain; charset=utf-8\\r\\n\",\n                b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n                b\"connection: close\\r\\n\",\n                b\"\\r\\n\",\n                msg.encode(\"ascii\"),\n            ]\n        )\n        self.transport.write(b\"\".join(content))\n        self.transport.close()\n\n    def on_message_begin(self) -> None:\n        self.url = b\"\"\n        self.expect_100_continue = False\n        self.headers = []\n        self.scope = {  # type: ignore[typeddict-item]\n            \"type\": \"http\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n            \"http_version\": \"1.1\",\n            \"server\": self.server,\n            \"client\": self.client,\n            \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n            \"root_path\": self.root_path,\n            \"headers\": self.headers,\n            \"state\": self.app_state.copy(),\n        }\n\n    def on_url(self, url: bytes) -> None:\n        self.url += url\n\n    def on_header(self, name: bytes, value: bytes) -> None:\n        name = name.lower()\n        if name == b\"expect\" and value.lower() == b\"100-continue\":\n            self.expect_100_continue = True\n        self.headers.append((name, value))\n\n    def on_headers_complete(self) -> None:\n        http_version = self.parser.get_http_version()\n        method = self.parser.get_method()\n        self.scope[\"method\"] = method.decode(\"ascii\")\n        if http_version != \"1.1\":\n            self.scope[\"http_version\"] = http_version\n        if self.parser.should_upgrade() and self._should_upgrade():\n            return\n        parsed_url = httptools.parse_url(self.url)\n        raw_path = parsed_url.path\n        path = raw_path.decode(\"ascii\")\n        if \"%\" in path:\n            path = urllib.parse.unquote(path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n        self.scope[\"path\"] = full_path\n        self.scope[\"raw_path\"] = full_raw_path\n        self.scope[\"query_string\"] = parsed_url.query or b\"\"\n\n        if self.limit_concurrency is not None and (\n            len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n        ):\n            app = service_unavailable\n            message = \"Exceeded concurrency limit.\"\n            self.logger.warning(message)\n        else:\n            app = self.app\n\n        existing_cycle = self.cycle\n        self.cycle = RequestResponseCycle(\n            scope=self.scope,\n            transport=self.transport,\n            flow=self.flow,\n            logger=self.logger,\n            access_logger=self.access_logger,\n            access_log=self.access_log,\n            default_headers=self.server_state.default_headers,\n            message_event=asyncio.Event(),\n            expect_100_continue=self.expect_100_continue,\n            keep_alive=http_version != \"1.0\",\n            on_response=self.on_response_complete,\n        )\n        if existing_cycle is None or existing_cycle.response_complete:\n            task = self.loop.create_task(self.cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.flow.pause_reading()\n            self.pipeline.appendleft((self.cycle, app))\n\n    def on_body(self, body: bytes) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.body += body\n        if len(self.cycle.body) > HIGH_WATER_LIMIT:\n            self.flow.pause_reading()\n        self.cycle.message_event.set()\n\n    def on_message_complete(self) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.more_body = False\n        self.cycle.message_event.set()\n\n    def on_response_complete(self) -> None:\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        self._unset_keepalive_if_required()\n\n        self.flow.resume_reading()\n\n        if self.pipeline:\n            cycle, app = self.pipeline.pop()\n            task = self.loop.create_task(cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.timeout_keep_alive_task = self.loop.call_later(\n                self.timeout_keep_alive, self.timeout_keep_alive_handler\n            )\n\n    def shutdown(self) -> None:\n        if self.cycle is None or self.cycle.response_complete:\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False\n\n    def pause_writing(self) -> None:\n        self.flow.pause_writing()  # pragma: full coverage\n\n    def resume_writing(self) -> None:\n        self.flow.resume_writing()  # pragma: full coverage\n\n    def timeout_keep_alive_handler(self) -> None:\n        if not self.transport.is_closing():\n            self.transport.close()"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "class RequestResponseCycle:\n    def __init__(\n        self,\n        scope: HTTPScope,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        expect_100_continue: bool,\n        keep_alive: bool,\n        on_response: Callable[..., None],\n    ):\n        self.scope = scope\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        self.disconnected = False\n        self.keep_alive = keep_alive\n        self.waiting_for_100_continue = expect_100_continue\n\n        self.body = b\"\"\n        self.more_body = True\n\n        self.response_started = False\n        self.response_complete = False\n        self.chunked_encoding: bool | None = None\n        self.expected_content_length = 0\n\n    async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None\n\n    async def send_500_response(self) -> None:\n        await self.send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 500,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                    (b\"content-length\", b\"21\"),\n                    (b\"connection\", b\"close\"),\n                ],\n            }\n        )\n        await self.send({\"type\": \"http.response.body\", \"body\": b\"Internal Server Error\", \"more_body\": False})\n\n    async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status_code = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status_code,\n                )\n\n            content = [STATUS_LINE[status_code]]\n\n            for name, value in headers:\n                if HEADER_RE.search(name):\n                    raise RuntimeError(\"Invalid HTTP header name.\")  # pragma: full coverage\n                if HEADER_VALUE_RE.search(value):\n                    raise RuntimeError(\"Invalid HTTP header value.\")\n\n                name = name.lower()\n                if name == b\"content-length\" and self.chunked_encoding is None:\n                    self.expected_content_length = int(value.decode())\n                    self.chunked_encoding = False\n                elif name == b\"transfer-encoding\" and value.lower() == b\"chunked\":\n                    self.expected_content_length = 0\n                    self.chunked_encoding = True\n                elif name == b\"connection\" and value.lower() == b\"close\":\n                    self.keep_alive = False\n                content.extend([name, b\": \", value, b\"\\r\\n\"])\n\n            if self.chunked_encoding is None and self.scope[\"method\"] != \"HEAD\" and status_code not in (204, 304):\n                self.chunked_encoding = True\n                content.append(b\"transfer-encoding: chunked\\r\\n\")\n\n            content.append(b\"\\r\\n\")\n            self.transport.write(b\"\".join(content))\n\n        elif not self.response_complete:\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n            body = cast(bytes, message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n\n            if self.scope[\"method\"] == \"HEAD\":\n                self.expected_content_length = 0\n            elif self.chunked_encoding:\n                if body:\n                    content = [b\"%x\\r\\n\" % len(body), body, b\"\\r\\n\"]\n                else:\n                    content = []\n                if not more_body:\n                    content.append(b\"0\\r\\n\\r\\n\")\n                self.transport.write(b\"\".join(content))\n            else:\n                num_bytes = len(body)\n                if num_bytes > self.expected_content_length:\n                    raise RuntimeError(\"Response content longer than Content-Length\")\n                else:\n                    self.expected_content_length -= num_bytes\n                self.transport.write(body)\n\n            if not more_body:\n                if self.expected_content_length != 0:\n                    raise RuntimeError(\"Response content shorter than Content-Length\")\n                self.response_complete = True\n                self.message_event.set()\n                if not self.keep_alive:\n                    self.transport.close()\n                self.on_response()\n\n        else:\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n            self.waiting_for_100_continue = False\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n        message: HTTPRequestEvent = {\"type\": \"http.request\", \"body\": self.body, \"more_body\": self.more_body}\n        self.body = b\"\"\n        return message"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def display(self):\n        print(self.value)"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "class AnotherClass:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        print(f\"Hello, {self.name}!\")"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport typing\nfrom typing import Literal, cast\nfrom urllib.parse import unquote\n\nimport wsproto\nfrom wsproto import ConnectionType, events\nfrom wsproto.connection import ConnectionState\nfrom wsproto.extensions import Extension, PerMessageDeflate\nfrom wsproto.utilities import LocalProtocolError, RemoteProtocolError\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "class WSProtocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, typing.Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()  # pragma: full coverage\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n        self.default_headers = server_state.default_headers\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # WebSocket state\n        self.queue: asyncio.Queue[WebSocketEvent] = asyncio.Queue()\n        self.handshake_complete = False\n        self.close_sent = False\n\n        # Rejection state\n        self.response_started = False\n\n        self.conn = wsproto.WSConnection(connection_type=ConnectionType.SERVER)\n\n        self.read_paused = False\n        self.writable = asyncio.Event()\n        self.writable.set()\n\n        # Buffers\n        self.bytes = b\"\"\n        self.text = \"\"\n\n    # Protocol interface\n\n    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n\n    def connection_lost(self, exc: Exception | None) -> None:\n        code = 1005 if self.handshake_complete else 1006\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code})\n        self.connections.remove(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.handshake_complete = True\n        if exc is None:\n            self.transport.close()\n\n    def eof_received(self) -> None:\n        pass\n\n    def data_received(self, data: bytes) -> None:\n        try:\n            self.conn.receive_data(data)\n        except RemoteProtocolError as err:\n            # TODO: Remove `type: ignore` when wsproto fixes the type annotation.\n            self.transport.write(self.conn.send(err.event_hint))  # type: ignore[arg-type]  # noqa: E501\n            self.transport.close()\n        else:\n            self.handle_events()\n\n    def handle_events(self) -> None:\n        for event in self.conn.events():\n            if isinstance(event, events.Request):\n                self.handle_connect(event)\n            elif isinstance(event, events.TextMessage):\n                self.handle_text(event)\n            elif isinstance(event, events.BytesMessage):\n                self.handle_bytes(event)\n            elif isinstance(event, events.CloseConnection):\n                self.handle_close(event)\n            elif isinstance(event, events.Ping):\n                self.handle_ping(event)\n\n    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.writable.clear()  # pragma: full coverage\n\n    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.writable.set()  # pragma: full coverage\n\n    def shutdown(self) -> None:\n        if self.handshake_complete:\n            self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1012})\n            output = self.conn.send(wsproto.events.CloseConnection(code=1012))\n            self.transport.write(output)\n        else:\n            self.send_500_response()\n        self.transport.close()\n\n    def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)\n\n    # Event handlers\n\n    def handle_connect(self, event: events.Request) -> None:\n        headers = [(b\"host\", event.host.encode())]\n        headers += [(key.lower(), value) for key, value in event.extra_headers]\n        raw_path, _, query_string = event.target.partition(\"?\")\n        path = unquote(raw_path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path.encode(\"ascii\")\n        self.scope: WebSocketScope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": headers,\n            \"subprotocols\": event.subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        self.queue.put_nowait({\"type\": \"websocket.connect\"})\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n\n    def handle_text(self, event: events.TextMessage) -> None:\n        self.text += event.data\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"text\": self.text})\n            self.text = \"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()\n\n    def handle_bytes(self, event: events.BytesMessage) -> None:\n        self.bytes += event.data\n        # todo: we may want to guard the size of self.bytes and self.text\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"bytes\": self.bytes})\n            self.bytes = b\"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()\n\n    def handle_close(self, event: events.CloseConnection) -> None:\n        if self.conn.state == ConnectionState.REMOTE_CLOSING:\n            self.transport.write(self.conn.send(event.response()))\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": event.code, \"reason\": event.reason})\n        self.transport.close()\n\n    def handle_ping(self, event: events.Ping) -> None:\n        self.transport.write(self.conn.send(event.response()))\n\n    def send_500_response(self) -> None:\n        if self.response_started or self.handshake_complete:\n            return  # we cannot send responses anymore\n        headers: list[tuple[bytes, bytes]] = [\n            (b\"content-type\", b\"text/plain; charset=utf-8\"),\n            (b\"connection\", b\"close\"),\n            (b\"content-length\", b\"21\"),\n        ]\n        output = self.conn.send(wsproto.events.RejectConnection(status_code=500, headers=headers, has_body=True))\n        output += self.conn.send(wsproto.events.RejectData(data=b\"Internal Server Error\"))\n        self.transport.write(output)\n\n    async def run_asgi(self) -> None:\n        try:\n            result = await self.app(self.scope, self.receive, self.send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:\n            self.transport.close()  # pragma: full coverage\n        except BaseException:\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            self.send_500_response()\n            self.transport.close()\n        else:\n            if not self.handshake_complete:\n                self.logger.error(\"ASGI callable returned without completing handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                self.transport.close()\n\n    async def send(self, message: ASGISendEvent) -> None:\n        await self.writable.wait()\n\n        message_type = message[\"type\"]\n\n        if not self.handshake_complete:\n            if message_type == \"websocket.accept\":\n                message = typing.cast(WebSocketAcceptEvent, message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                subprotocol = message.get(\"subprotocol\")\n                extra_headers = self.default_headers + list(message.get(\"headers\", []))\n                extensions: list[Extension] = []\n                if self.config.ws_per_message_deflate:\n                    extensions.append(PerMessageDeflate())\n                if not self.transport.is_closing():\n                    self.handshake_complete = True\n                    output = self.conn.send(\n                        wsproto.events.AcceptConnection(\n                            subprotocol=subprotocol,\n                            extensions=extensions,\n                            extra_headers=extra_headers,\n                        )\n                    )\n                    self.transport.write(output)\n\n            elif message_type == \"websocket.close\":\n                self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.handshake_complete = True\n                self.close_sent = True\n                event = events.RejectConnection(status_code=403, headers=[])\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.transport.close()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = typing.cast(WebSocketResponseStartEvent, message)\n                # ensure status code is in the valid range\n                if not (100 <= message[\"status\"] < 600):\n                    msg = \"Invalid HTTP status code '%d' in response.\"\n                    raise RuntimeError(msg % message[\"status\"])\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                self.handshake_complete = True\n                event = events.RejectConnection(\n                    status_code=message[\"status\"],\n                    headers=list(message[\"headers\"]),\n                    has_body=True,\n                )\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.response_started = True\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close' \"\n                    \"or 'websocket.http.response.start' \"\n                    \"but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.close_sent and not self.response_started:\n            try:\n                if message_type == \"websocket.send\":\n                    message = typing.cast(WebSocketSendEvent, message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    output = self.conn.send(wsproto.events.Message(data=data))  # type: ignore\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n\n                elif message_type == \"websocket.close\":\n                    message = typing.cast(WebSocketCloseEvent, message)\n                    self.close_sent = True\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n                    output = self.conn.send(wsproto.events.CloseConnection(code=code, reason=reason))\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n                        self.transport.close()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close',\" \" but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except LocalProtocolError as exc:\n                raise ClientDisconnected from exc\n        elif self.response_started:\n            if message_type == \"websocket.http.response.body\":\n                message = typing.cast(\"WebSocketResponseBodyEvent\", message)\n                body_finished = not message.get(\"more_body\", False)\n                reject_data = events.RejectData(data=message[\"body\"], body_finished=body_finished)\n                output = self.conn.send(reject_data)\n                self.transport.write(output)\n\n                if body_finished:\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                    self.close_sent = True\n                    self.transport.close()\n\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' \" \"but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close'.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> WebSocketEvent:\n        message = await self.queue.get()\n        if self.read_paused and self.queue.empty():\n            self.read_paused = False\n            self.transport.resume_reading()\n        return message"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom collections.abc import Sequence\nfrom typing import Any, Literal, Optional, cast\nfrom urllib.parse import unquote\n\nimport websockets\nimport websockets.legacy.handshake\nfrom websockets.datastructures import Headers\nfrom websockets.exceptions import ConnectionClosed\nfrom websockets.extensions.base import ServerExtensionFactory\nfrom websockets.extensions.permessage_deflate import ServerPerMessageDeflateFactory\nfrom websockets.legacy.server import HTTPResponse\nfrom websockets.server import WebSocketServerProtocol\nfrom websockets.typing import Subprotocol\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketConnectEvent,\n    WebSocketDisconnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "class Server:\n    closing = False\n\n    def register(self, ws: WebSocketServerProtocol) -> None:\n        pass\n\n    def unregister(self, ws: WebSocketServerProtocol) -> None:\n        pass\n\n    def is_serving(self) -> bool:\n        return not self.closing"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "class WebSocketProtocol(WebSocketServerProtocol):\n    extra_headers: list[tuple[str, str]]\n    logger: logging.Logger | logging.LoggerAdapter[Any]\n\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ):\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # Connection events\n        self.scope: WebSocketScope\n        self.handshake_started_event = asyncio.Event()\n        self.handshake_completed_event = asyncio.Event()\n        self.closed_event = asyncio.Event()\n        self.initial_response: HTTPResponse | None = None\n        self.connect_sent = False\n        self.lost_connection_before_handshake = False\n        self.accepted_subprotocol: Subprotocol | None = None\n\n        self.ws_server: Server = Server()  # type: ignore[assignment]\n\n        extensions: list[ServerExtensionFactory] = []\n        if self.config.ws_per_message_deflate:\n            extensions.append(ServerPerMessageDeflateFactory())\n\n        super().__init__(\n            ws_handler=self.ws_handler,\n            ws_server=self.ws_server,  # type: ignore[arg-type]\n            max_size=self.config.ws_max_size,\n            max_queue=self.config.ws_max_queue,\n            ping_interval=self.config.ws_ping_interval,\n            ping_timeout=self.config.ws_ping_timeout,\n            extensions=extensions,\n            logger=logging.getLogger(\"uvicorn.error\"),\n        )\n        self.server_header = None\n        self.extra_headers = [\n            (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in server_state.default_headers\n        ]\n\n    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n\n        super().connection_made(transport)\n\n    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.remove(self)\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.lost_connection_before_handshake = not self.handshake_completed_event.is_set()\n        self.handshake_completed_event.set()\n        super().connection_lost(exc)\n        if exc is None:\n            self.transport.close()\n\n    def shutdown(self) -> None:\n        self.ws_server.closing = True\n        if self.handshake_completed_event.is_set():\n            self.fail_connection(1012)\n        else:\n            self.send_500_response()\n        self.transport.close()\n\n    def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)\n\n    async def process_request(self, path: str, request_headers: Headers) -> HTTPResponse | None:\n        \"\"\"\n        This hook is called to determine if the websocket should return\n        an HTTP response and close.\n\n        Our behavior here is to start the ASGI application, and then wait\n        for either `accept` or `close` in order to determine if we should\n        close the connection.\n        \"\"\"\n        path_portion, _, query_string = path.partition(\"?\")\n\n        websockets.legacy.handshake.check_request(request_headers)\n\n        subprotocols: list[str] = []\n        for header in request_headers.get_all(\"Sec-WebSocket-Protocol\"):\n            subprotocols.extend([token.strip() for token in header.split(\",\")])\n\n        asgi_headers = [\n            (name.encode(\"ascii\"), value.encode(\"ascii\", errors=\"surrogateescape\"))\n            for name, value in request_headers.raw_items()\n        ]\n        path = unquote(path_portion)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + path_portion.encode(\"ascii\")\n\n        self.scope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": asgi_headers,\n            \"subprotocols\": subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n        await self.handshake_started_event.wait()\n        return self.initial_response\n\n    def process_subprotocol(\n        self, headers: Headers, available_subprotocols: Sequence[Subprotocol] | None\n    ) -> Subprotocol | None:\n        \"\"\"\n        We override the standard 'process_subprotocol' behavior here so that\n        we return whatever subprotocol is sent in the 'accept' message.\n        \"\"\"\n        return self.accepted_subprotocol\n\n    def send_500_response(self) -> None:\n        msg = b\"Internal Server Error\"\n        content = [\n            b\"HTTP/1.1 500 Internal Server Error\\r\\n\" b\"content-type: text/plain; charset=utf-8\\r\\n\",\n            b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n            b\"connection: close\\r\\n\",\n            b\"\\r\\n\",\n            msg,\n        ]\n        self.transport.write(b\"\".join(content))\n        # Allow handler task to terminate cleanly, as websockets doesn't cancel it by\n        # itself (see https://github.com/encode/uvicorn/issues/920)\n        self.handshake_started_event.set()\n\n    async def ws_handler(self, protocol: WebSocketServerProtocol, path: str) -> Any:  # type: ignore[override]\n        \"\"\"\n        This is the main handler function for the 'websockets' implementation\n        to call into. We just wait for close then return, and instead allow\n        'send' and 'receive' events to drive the flow.\n        \"\"\"\n        self.handshake_completed_event.set()\n        await self.wait_closed()\n\n    async def run_asgi(self) -> None:\n        \"\"\"\n        Wrapper around the ASGI callable, handling exceptions and unexpected\n        termination states.\n        \"\"\"\n        try:\n            result = await self.app(self.scope, self.asgi_receive, self.asgi_send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:  # pragma: full coverage\n            self.closed_event.set()\n            self.transport.close()\n        except BaseException:\n            self.closed_event.set()\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            if not self.handshake_started_event.is_set():\n                self.send_500_response()\n            else:\n                await self.handshake_completed_event.wait()\n            self.transport.close()\n        else:\n            self.closed_event.set()\n            if not self.handshake_started_event.is_set():\n                self.logger.error(\"ASGI callable returned without sending handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                await self.handshake_completed_event.wait()\n                self.transport.close()\n\n    async def asgi_send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if not self.handshake_started_event.is_set():\n            if message_type == \"websocket.accept\":\n                message = cast(\"WebSocketAcceptEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = None\n                self.accepted_subprotocol = cast(Optional[Subprotocol], message.get(\"subprotocol\"))\n                if \"headers\" in message:\n                    self.extra_headers.extend(\n                        # ASGI spec requires bytes\n                        # But for compatibility we need to convert it to strings\n                        (name.decode(\"latin-1\"), value.decode(\"latin-1\"))\n                        for name, value in message[\"headers\"]\n                    )\n                self.handshake_started_event.set()\n\n            elif message_type == \"websocket.close\":\n                message = cast(\"WebSocketCloseEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = (http.HTTPStatus.FORBIDDEN, [], b\"\")\n                self.handshake_started_event.set()\n                self.closed_event.set()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = cast(\"WebSocketResponseStartEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                # websockets requires the status to be an enum. look it up.\n                status = http.HTTPStatus(message[\"status\"])\n                headers = [\n                    (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in message.get(\"headers\", [])\n                ]\n                self.initial_response = (status, headers, b\"\")\n                self.handshake_started_event.set()\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close', \"\n                    \"or 'websocket.http.response.start' but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.closed_event.is_set() and self.initial_response is None:\n            await self.handshake_completed_event.wait()\n\n            try:\n                if message_type == \"websocket.send\":\n                    message = cast(\"WebSocketSendEvent\", message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    await self.send(data)  # type: ignore[arg-type]\n\n                elif message_type == \"websocket.close\":\n                    message = cast(\"WebSocketCloseEvent\", message)\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    await self.close(code, reason)\n                    self.closed_event.set()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close',\" \" but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except ConnectionClosed as exc:\n                raise ClientDisconnected from exc\n\n        elif self.initial_response is not None:\n            if message_type == \"websocket.http.response.body\":\n                message = cast(\"WebSocketResponseBodyEvent\", message)\n                body = self.initial_response[2] + message[\"body\"]\n                self.initial_response = self.initial_response[:2] + (body,)\n                if not message.get(\"more_body\", False):\n                    self.closed_event.set()\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' \" \"but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close' \" \"or response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n    async def asgi_receive(self) -> WebSocketDisconnectEvent | WebSocketConnectEvent | WebSocketReceiveEvent:\n        if not self.connect_sent:\n            self.connect_sent = True\n            return {\"type\": \"websocket.connect\"}\n\n        await self.handshake_completed_event.wait()\n\n        if self.lost_connection_before_handshake:\n            # If the handshake failed or the app closed before handshake completion,\n            # use 1006 Abnormal Closure.\n            return {\"type\": \"websocket.disconnect\", \"code\": 1006}\n\n        if self.closed_event.is_set():\n            return {\"type\": \"websocket.disconnect\", \"code\": 1005}\n\n        try:\n            data = await self.recv()\n        except ConnectionClosed:\n            self.closed_event.set()\n            if self.ws_server.closing:\n                return {\"type\": \"websocket.disconnect\", \"code\": 1012}\n            return {\"type\": \"websocket.disconnect\", \"code\": self.close_code or 1005, \"reason\": self.close_reason}\n\n        if isinstance(data, str):\n            return {\"type\": \"websocket.receive\", \"text\": data}\n        return {\"type\": \"websocket.receive\", \"bytes\": data}"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/auto.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport typing\n\nAutoWebSocketsProtocol: typing.Callable[..., asyncio.Protocol] | None\ntry:\n    import websockets  # noqa\nexcept ImportError:  # pragma: no cover\n    try:\n        import wsproto  # noqa\n    except ImportError:\n        AutoWebSocketsProtocol = None\n    else:\n        from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n        AutoWebSocketsProtocol = WSProtocol\nelse:\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n\n    AutoWebSocketsProtocol = WebSocketProtocol"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/asgi2.py",
      "content": "from uvicorn._types import (\n    ASGI2Application,\n    ASGIReceiveCallable,\n    ASGISendCallable,\n    Scope,\n)"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/asgi2.py",
      "content": "class ASGI2Middleware:\n    def __init__(self, app: \"ASGI2Application\"):\n        self.app = app\n\n    async def __call__(self, scope: \"Scope\", receive: \"ASGIReceiveCallable\", send: \"ASGISendCallable\") -> None:\n        instance = self.app(scope)\n        await instance(receive, send)"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/__init__.py",
      "content": "Sure, please provide the Python code you would like me to analyze."
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "from __future__ import annotations\n\nimport ipaddress\n\nfrom uvicorn._types import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "class ProxyHeadersMiddleware:\n    \"\"\"Middleware for handling known proxy headers\n\n    This middleware can be used when a known proxy is fronting the application,\n    and is trusted to be properly setting the `X-Forwarded-Proto` and\n    `X-Forwarded-For` headers with the connecting client information.\n\n    Modifies the `client` and `scheme` information so that they reference\n    the connecting client, rather that the connecting proxy.\n\n    References:\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#Proxies>\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For>\n    \"\"\"\n\n    def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str = \"127.0.0.1\") -> None:\n        self.app = app\n        self.trusted_hosts = _TrustedHosts(trusted_hosts)\n\n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        if scope[\"type\"] == \"lifespan\":\n            return await self.app(scope, receive, send)\n\n        client_addr = scope.get(\"client\")\n        client_host = client_addr[0] if client_addr else None\n\n        if client_host in self.trusted_hosts:\n            headers = dict(scope[\"headers\"])\n\n            if b\"x-forwarded-proto\" in headers:\n                x_forwarded_proto = headers[b\"x-forwarded-proto\"].decode(\"latin1\").strip()\n\n                if x_forwarded_proto in {\"http\", \"https\", \"ws\", \"wss\"}:\n                    if scope[\"type\"] == \"websocket\":\n                        scope[\"scheme\"] = x_forwarded_proto.replace(\"http\", \"ws\")\n                    else:\n                        scope[\"scheme\"] = x_forwarded_proto\n\n            if b\"x-forwarded-for\" in headers:\n                x_forwarded_for = headers[b\"x-forwarded-for\"].decode(\"latin1\")\n                host = self.trusted_hosts.get_trusted_client_host(x_forwarded_for)\n\n                if host:\n                    # If the x-forwarded-for header is empty then host is an empty string.\n                    # Only set the client if we actually got something usable.\n                    # See: https://github.com/encode/uvicorn/issues/1068\n\n                    # We've lost the connecting client's port information by now,\n                    # so only include the host.\n                    port = 0\n                    scope[\"client\"] = (host, port)\n\n        return await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "def _parse_raw_hosts(value: str) -> list[str]:\n    return [item.strip() for item in value.split(\",\")]"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "class _TrustedHosts:\n    \"\"\"Container for trusted hosts and networks\"\"\"\n\n    def __init__(self, trusted_hosts: list[str] | str) -> None:\n        self.always_trust: bool = trusted_hosts in (\"*\", [\"*\"])\n\n        self.trusted_literals: set[str] = set()\n        self.trusted_hosts: set[ipaddress.IPv4Address | ipaddress.IPv6Address] = set()\n        self.trusted_networks: set[ipaddress.IPv4Network | ipaddress.IPv6Network] = set()\n\n        # Notes:\n        # - We separate hosts from literals as there are many ways to write\n        #   an IPv6 Address so we need to compare by object.\n        # - We don't convert IP Address to single host networks (e.g. /32 / 128) as\n        #   it more efficient to do an address lookup in a set than check for\n        #   membership in each network.\n        # - We still allow literals as it might be possible that we receive a\n        #   something that isn't an IP Address e.g. a unix socket.\n\n        if not self.always_trust:\n            if isinstance(trusted_hosts, str):\n                trusted_hosts = _parse_raw_hosts(trusted_hosts)\n\n            for host in trusted_hosts:\n                # Note: because we always convert invalid IP types to literals it\n                # is not possible for the user to know they provided a malformed IP\n                # type - this may lead to unexpected / difficult to debug behaviour.\n\n                if \"/\" in host:\n                    # Looks like a network\n                    try:\n                        self.trusted_networks.add(ipaddress.ip_network(host))\n                    except ValueError:\n                        # Was not a valid IP Network\n                        self.trusted_literals.add(host)\n                else:\n                    try:\n                        self.trusted_hosts.add(ipaddress.ip_address(host))\n                    except ValueError:\n                        # Was not a valid IP Address\n                        self.trusted_literals.add(host)\n\n    def __contains__(self, host: str | None) -> bool:\n        if self.always_trust:\n            return True\n\n        if not host:\n            return False\n\n        try:\n            ip = ipaddress.ip_address(host)\n            if ip in self.trusted_hosts:\n                return True\n            return any(ip in net for net in self.trusted_networks)\n\n        except ValueError:\n            return host in self.trusted_literals\n\n    def get_trusted_client_host(self, x_forwarded_for: str) -> str:\n        \"\"\"Extract the client host from x_forwarded_for header\n\n        In general this is the first \"untrusted\" host in the forwarded for list.\n        \"\"\"\n        x_forwarded_for_hosts = _parse_raw_hosts(x_forwarded_for)\n\n        if self.always_trust:\n            return x_forwarded_for_hosts[0]\n\n        # Note: each proxy appends to the header list so check it in reverse order\n        for host in reversed(x_forwarded_for_hosts):\n            if host not in self:\n                return host\n\n        # All hosts are trusted meaning that the client was also a trusted proxy\n        # See https://github.com/encode/uvicorn/issues/1068#issuecomment-855371576\n        return x_forwarded_for_hosts[0]"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport concurrent.futures\nimport io\nimport sys\nimport warnings\nfrom collections import deque\nfrom collections.abc import Iterable\n\nfrom uvicorn._types import (\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    ASGISendEvent,\n    Environ,\n    ExcInfo,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n    StartResponse,\n    WSGIApp,\n)"
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "def build_environ(scope: HTTPScope, message: ASGIReceiveEvent, body: io.BytesIO) -> Environ:\n    \"\"\"\n    Builds a scope and request message into a WSGI environ object.\n    \"\"\"\n    script_name = scope.get(\"root_path\", \"\").encode(\"utf8\").decode(\"latin1\")\n    path_info = scope[\"path\"].encode(\"utf8\").decode(\"latin1\")\n    if path_info.startswith(script_name):\n        path_info = path_info[len(script_name) :]\n    environ = {\n        \"REQUEST_METHOD\": scope[\"method\"],\n        \"SCRIPT_NAME\": script_name,\n        \"PATH_INFO\": path_info,\n        \"QUERY_STRING\": scope[\"query_string\"].decode(\"ascii\"),\n        \"SERVER_PROTOCOL\": \"HTTP/%s\" % scope[\"http_version\"],\n        \"wsgi.version\": (1, 0),\n        \"wsgi.url_scheme\": scope.get(\"scheme\", \"http\"),\n        \"wsgi.input\": body,\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multithread\": True,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.run_once\": False,\n    }\n\n    # Get server name and port - required in WSGI, not in ASGI\n    server = scope.get(\"server\")\n    if server is None:\n        server = (\"localhost\", 80)\n    environ[\"SERVER_NAME\"] = server[0]\n    environ[\"SERVER_PORT\"] = server[1]\n\n    # Get client IP address\n    client = scope.get(\"client\")\n    if client is not None:\n        environ[\"REMOTE_ADDR\"] = client[0]\n\n    # Go through headers and make them into environ entries\n    for name, value in scope.get(\"headers\", []):\n        name_str: str = name.decode(\"latin1\")\n        if name_str == \"content-length\":\n            corrected_name = \"CONTENT_LENGTH\"\n        elif name_str == \"content-type\":\n            corrected_name = \"CONTENT_TYPE\"\n        else:\n            corrected_name = \"HTTP_%s\" % name_str.upper().replace(\"-\", \"_\")\n        # HTTPbis say only ASCII chars are allowed in headers, but we latin1\n        # just in case\n        value_str: str = value.decode(\"latin1\")\n        if corrected_name in environ:\n            corrected_name_environ = environ[corrected_name]\n            assert isinstance(corrected_name_environ, str)\n            value_str = corrected_name_environ + \",\" + value_str\n        environ[corrected_name] = value_str\n    return environ"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "class _WSGIMiddleware:\n    def __init__(self, app: WSGIApp, workers: int = 10):\n        warnings.warn(\n            \"Uvicorn's native WSGI implementation is deprecated, you \"\n            \"should switch to a2wsgi (`pip install a2wsgi`).\",\n            DeprecationWarning,\n        )\n        self.app = app\n        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=workers)\n\n    async def __call__(\n        self,\n        scope: HTTPScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -> None:\n        assert scope[\"type\"] == \"http\"\n        instance = WSGIResponder(self.app, self.executor, scope)\n        await instance(receive, send)"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "class WSGIResponder:\n    def __init__(\n        self,\n        app: WSGIApp,\n        executor: concurrent.futures.ThreadPoolExecutor,\n        scope: HTTPScope,\n    ):\n        self.app = app\n        self.executor = executor\n        self.scope = scope\n        self.status = None\n        self.response_headers = None\n        self.send_event = asyncio.Event()\n        self.send_queue: deque[ASGISendEvent | None] = deque()\n        self.loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()\n        self.response_started = False\n        self.exc_info: ExcInfo | None = None\n\n    async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        message: HTTPRequestEvent = await receive()  # type: ignore[assignment]\n        body = io.BytesIO(message.get(\"body\", b\"\"))\n        more_body = message.get(\"more_body\", False)\n        if more_body:\n            body.seek(0, io.SEEK_END)\n            while more_body:\n                body_message: HTTPRequestEvent = (\n                    await receive()  # type: ignore[assignment]\n                )\n                body.write(body_message.get(\"body\", b\"\"))\n                more_body = body_message.get(\"more_body\", False)\n            body.seek(0)\n        environ = build_environ(self.scope, message, body)\n        self.loop = asyncio.get_event_loop()\n        wsgi = self.loop.run_in_executor(self.executor, self.wsgi, environ, self.start_response)\n        sender = self.loop.create_task(self.sender(send))\n        try:\n            await asyncio.wait_for(wsgi, None)\n        finally:\n            self.send_queue.append(None)\n            self.send_event.set()\n            await asyncio.wait_for(sender, None)\n        if self.exc_info is not None:\n            raise self.exc_info[0].with_traceback(self.exc_info[1], self.exc_info[2])\n\n    async def sender(self, send: ASGISendCallable) -> None:\n        while True:\n            if self.send_queue:\n                message = self.send_queue.popleft()\n                if message is None:\n                    return\n                await send(message)\n            else:\n                await self.send_event.wait()\n                self.send_event.clear()\n\n    def start_response(\n        self,\n        status: str,\n        response_headers: Iterable[tuple[str, str]],\n        exc_info: ExcInfo | None = None,\n    ) -> None:\n        self.exc_info = exc_info\n        if not self.response_started:\n            self.response_started = True\n            status_code_str, _ = status.split(\" \", 1)\n            status_code = int(status_code_str)\n            headers = [(name.encode(\"ascii\"), value.encode(\"ascii\")) for name, value in response_headers]\n            http_response_start_event: HTTPResponseStartEvent = {\n                \"type\": \"http.response.start\",\n                \"status\": status_code,\n                \"headers\": headers,\n            }\n            self.send_queue.append(http_response_start_event)\n            self.loop.call_soon_threadsafe(self.send_event.set)\n\n    def wsgi(self, environ: Environ, start_response: StartResponse) -> None:\n        for chunk in self.app(environ, start_response):  # type: ignore\n            response_body: HTTPResponseBodyEvent = {\n                \"type\": \"http.response.body\",\n                \"body\": chunk,\n                \"more_body\": True,\n            }\n            self.send_queue.append(response_body)\n            self.loop.call_soon_threadsafe(self.send_event.set)\n\n        empty_body: HTTPResponseBodyEvent = {\n            \"type\": \"http.response.body\",\n            \"body\": b\"\",\n            \"more_body\": False,\n        }\n        self.send_queue.append(empty_body)\n        self.loop.call_soon_threadsafe(self.send_event.set)"
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "try:\n    from a2wsgi import WSGIMiddleware\nexcept ModuleNotFoundError:  # pragma: no cover\n    WSGIMiddleware = _WSGIMiddleware  # type: ignore[misc, assignment]"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "import logging\nfrom typing import Any\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    ASGISendEvent,\n    WWWScope,\n)\nfrom uvicorn.logging import TRACE_LOG_LEVEL\n\nPLACEHOLDER_FORMAT = {\n    \"body\": \"<{length} bytes>\",\n    \"bytes\": \"<{length} bytes>\",\n    \"text\": \"<{length} chars>\",\n    \"headers\": \"<...>\",\n}"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "def message_with_placeholders(message: Any) -> Any:\n    \"\"\"\n    Return an ASGI message, with any body-type content omitted and replaced\n    with a placeholder.\n    \"\"\"\n    new_message = message.copy()\n    for attr in PLACEHOLDER_FORMAT.keys():\n        if message.get(attr) is not None:\n            content = message[attr]\n            placeholder = PLACEHOLDER_FORMAT[attr].format(length=len(content))\n            new_message[attr] = placeholder\n    return new_message"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "class MessageLoggerMiddleware:\n    def __init__(self, app: \"ASGI3Application\"):\n        self.task_counter = 0\n        self.app = app\n        self.logger = logging.getLogger(\"uvicorn.asgi\")\n\n        def trace(message: Any, *args: Any, **kwargs: Any) -> None:\n            self.logger.log(TRACE_LOG_LEVEL, message, *args, **kwargs)\n\n        self.logger.trace = trace  # type: ignore\n\n    async def __call__(\n        self,\n        scope: \"WWWScope\",\n        receive: \"ASGIReceiveCallable\",\n        send: \"ASGISendCallable\",\n    ) -> None:\n        self.task_counter += 1\n\n        task_counter = self.task_counter\n        client = scope.get(\"client\")\n        prefix = \"%s:%d - ASGI\" % (client[0], client[1]) if client else \"ASGI\"\n\n        async def inner_receive() -> \"ASGIReceiveEvent\":\n            message = await receive()\n            logged_message = message_with_placeholders(message)\n            log_text = \"%s [%d] Receive %s\"\n            self.logger.trace(  # type: ignore\n                log_text, prefix, task_counter, logged_message\n            )\n            return message\n\n        async def inner_send(message: \"ASGISendEvent\") -> None:\n            logged_message = message_with_placeholders(message)\n            log_text = \"%s [%d] Send %s\"\n            self.logger.trace(  # type: ignore\n                log_text, prefix, task_counter, logged_message\n            )\n            await send(message)\n\n        logged_scope = message_with_placeholders(scope)\n        log_text = \"%s [%d] Started scope=%s\"\n        self.logger.trace(log_text, prefix, task_counter, logged_scope)  # type: ignore\n        try:\n            await self.app(scope, inner_receive, inner_send)\n        except BaseException as exc:\n            log_text = \"%s [%d] Raised exception\"\n            self.logger.trace(log_text, prefix, task_counter)  # type: ignore\n            raise exc from None\n        else:\n            log_text = \"%s [%d] Completed\"\n            self.logger.trace(log_text, prefix, task_counter)  # type: ignore"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/__init__.py",
      "content": "Sure, please provide the Python code you would like me to analyze."
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nfrom asyncio import Queue\nfrom typing import Any, Union\n\nfrom uvicorn import Config\nfrom uvicorn._types import (\n    LifespanScope,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupEvent,\n    LifespanStartupFailedEvent,\n)\n\nLifespanReceiveMessage = Union[LifespanStartupEvent, LifespanShutdownEvent]\nLifespanSendMessage = Union[\n    LifespanStartupFailedEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanShutdownCompleteEvent,\n]\n\nSTATE_TRANSITION_ERROR = \"Got invalid state transition on lifespan protocol.\""
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "class LifespanOn:\n    def __init__(self, config: Config) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.startup_event = asyncio.Event()\n        self.shutdown_event = asyncio.Event()\n        self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue()\n        self.error_occured = False\n        self.startup_failed = False\n        self.shutdown_failed = False\n        self.should_exit = False\n        self.state: dict[str, Any] = {}\n\n    async def startup(self) -> None:\n        self.logger.info(\"Waiting for application startup.\")\n\n        loop = asyncio.get_event_loop()\n        main_lifespan_task = loop.create_task(self.main())  # noqa: F841\n        # Keep a hard reference to prevent garbage collection\n        # See https://github.com/encode/uvicorn/pull/972\n        startup_event: LifespanStartupEvent = {\"type\": \"lifespan.startup\"}\n        await self.receive_queue.put(startup_event)\n        await self.startup_event.wait()\n\n        if self.startup_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application startup failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application startup complete.\")\n\n    async def shutdown(self) -> None:\n        if self.error_occured:\n            return\n        self.logger.info(\"Waiting for application shutdown.\")\n        shutdown_event: LifespanShutdownEvent = {\"type\": \"lifespan.shutdown\"}\n        await self.receive_queue.put(shutdown_event)\n        await self.shutdown_event.wait()\n\n        if self.shutdown_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application shutdown failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application shutdown complete.\")\n\n    async def main(self) -> None:\n        try:\n            app = self.config.loaded_app\n            scope: LifespanScope = {\n                \"type\": \"lifespan\",\n                \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.0\"},\n                \"state\": self.state,\n            }\n            await app(scope, self.receive, self.send)\n        except BaseException as exc:\n            self.asgi = None\n            self.error_occured = True\n            if self.startup_failed or self.shutdown_failed:\n                return\n            if self.config.lifespan == \"auto\":\n                msg = \"ASGI 'lifespan' protocol appears unsupported.\"\n                self.logger.info(msg)\n            else:\n                msg = \"Exception in 'lifespan' protocol\\n\"\n                self.logger.error(msg, exc_info=exc)\n        finally:\n            self.startup_event.set()\n            self.shutdown_event.set()\n\n    async def send(self, message: LifespanSendMessage) -> None:\n        assert message[\"type\"] in (\n            \"lifespan.startup.complete\",\n            \"lifespan.startup.failed\",\n            \"lifespan.shutdown.complete\",\n            \"lifespan.shutdown.failed\",\n        )\n\n        if message[\"type\"] == \"lifespan.startup.complete\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n\n        elif message[\"type\"] == \"lifespan.startup.failed\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n            self.startup_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])\n\n        elif message[\"type\"] == \"lifespan.shutdown.complete\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n\n        elif message[\"type\"] == \"lifespan.shutdown.failed\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n            self.shutdown_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])\n\n    async def receive(self) -> LifespanReceiveMessage:\n        return await self.receive_queue.get()"
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "from __future__ import annotations\n\nfrom typing import Any\n\nfrom uvicorn import Config"
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "class LifespanOff:\n    def __init__(self, config: Config) -> None:\n        self.should_exit = False\n        self.state: dict[str, Any] = {}\n\n    async def startup(self) -> None:\n        pass\n\n    async def shutdown(self) -> None:\n        pass"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "from __future__ import annotations as _annotations\n\nimport re\nimport subprocess\n\nfrom mkdocs.config import Config\nfrom mkdocs.structure.files import Files\nfrom mkdocs.structure.pages import Page"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def on_page_content(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each page after the markdown is converted to HTML.\"\"\"\n    html = add_hyperlink_to_pull_request(html, page, config, files)\n    return html"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def add_hyperlink_to_pull_request(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Add hyperlink on PRs mentioned on the release notes page.\n\n    If we find \"(#\\\\d+)\" it will be added an hyperlink to https://github.com/encode/uvicorn/pull/$1.\n    \"\"\"\n    if not page.file.name == \"release-notes\":\n        return html\n\n    return re.sub(r\"\\(#(\\d+)\\)\", r\"(<a href='https://github.com/encode/uvicorn/pull/\\1'>#\\1</a>)\", html)"
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def on_page_markdown(markdown: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each file after it is read and before it is converted to HTML.\"\"\"\n    markdown = uvicorn_print_help(markdown, page)\n    return markdown"
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def uvicorn_print_help(markdown: str, page: Page) -> str:\n    # if you don't filter to the specific route that needs this substitution, things will be very slow\n    if page.file.src_uri not in (\"index.md\", \"deployment.md\"):\n        return markdown\n\n    output = subprocess.run([\"uvicorn\", \"--help\"], capture_output=True, check=True)\n    logfire_help = output.stdout.decode()\n    return re.sub(r\"{{ *uvicorn_help *}}\", logfire_help, markdown)"
    }
  ]
}