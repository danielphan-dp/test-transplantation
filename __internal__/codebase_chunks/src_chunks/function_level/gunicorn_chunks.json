{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport errno\nimport os\nimport tempfile"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "class Pidfile:\n    \"\"\"\\\n    Manage a PID file. If a specific name is provided\n    it and '\"%s.oldpid\" % name' will be used. Otherwise\n    we create a temp file using os.mkstemp.\n    \"\"\"\n\n    def __init__(self, fname):\n        self.fname = fname\n        self.pid = None"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "def create(self, pid):\n        oldpid = self.validate()\n        if oldpid:\n            if oldpid == os.getpid():\n                return\n            msg = \"Already running on PID %s (or pid file '%s' is stale)\"\n            raise RuntimeError(msg % (oldpid, self.fname))\n\n        self.pid = pid\n\n        # Write pidfile\n        fdir = os.path.dirname(self.fname)\n        if fdir and not os.path.isdir(fdir):\n            raise RuntimeError(\"%s doesn't exist. Can't create pidfile.\" % fdir)\n        fd, fname = tempfile.mkstemp(dir=fdir)\n        os.write(fd, (\"%s\\n\" % self.pid).encode('utf-8'))\n        if self.fname:\n            os.rename(fname, self.fname)\n        else:\n            self.fname = fname\n        os.close(fd)\n\n        # set permissions to -rw-r--r--\n        os.chmod(self.fname, 420)"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "def rename(self, path):\n        self.unlink()\n        self.fname = path\n        self.create(self.pid)"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "def unlink(self):\n        \"\"\" delete pidfile\"\"\"\n        try:\n            with open(self.fname) as f:\n                pid1 = int(f.read() or 0)\n\n            if pid1 == self.pid:\n                os.unlink(self.fname)\n        except Exception:\n            pass"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/gunicorn/gunicorn/pidfile.py",
      "content": "def validate(self):\n        \"\"\" Validate pidfile and make it stale if needed\"\"\"\n        if not self.fname:\n            return\n        try:\n            with open(self.fname) as f:\n                try:\n                    wpid = int(f.read())\n                except ValueError:\n                    return\n\n                try:\n                    os.kill(wpid, 0)\n                    return wpid\n                except OSError as e:\n                    if e.args[0] == errno.EPERM:\n                        return wpid\n                    if e.args[0] == errno.ESRCH:\n                        return\n                    raise\n        except OSError as e:\n            if e.args[0] == errno.ENOENT:\n                return\n            raise"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/gunicorn/gunicorn/__init__.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/gunicorn/gunicorn/__init__.py",
      "content": "version_info = (23, 0, 0)\n__version__ = \".\".join([str(v) for v in version_info])\nSERVER = \"gunicorn\"\nSERVER_SOFTWARE = \"%s/%s\" % (SERVER, __version__)"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "import errno\nimport os\nimport socket\nimport ssl\nimport stat\nimport sys\nimport time\n\nfrom gunicorn import util"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "class BaseSocket:\n\n    def __init__(self, address, conf, log, fd=None):\n        self.log = log\n        self.conf = conf\n\n        self.cfg_addr = address\n        if fd is None:\n            sock = socket.socket(self.FAMILY, socket.SOCK_STREAM)\n            bound = False\n        else:\n            sock = socket.fromfd(fd, self.FAMILY, socket.SOCK_STREAM)\n            os.close(fd)\n            bound = True\n\n        self.sock = self.set_options(sock, bound=bound)\n\n    def __str__(self):\n        return \"<socket %d>\" % self.sock.fileno()\n\n    def __getattr__(self, name):\n        return getattr(self.sock, name)\n\n    def set_options(self, sock, bound=False):\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if (self.conf.reuse_port\n                and hasattr(socket, 'SO_REUSEPORT')):  # pragma: no cover\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except OSError as err:\n                if err.errno not in (errno.ENOPROTOOPT, errno.EINVAL):\n                    raise\n        if not bound:\n            self.bind(sock)\n        sock.setblocking(0)\n\n        # make sure that the socket can be inherited\n        if hasattr(sock, \"set_inheritable\"):\n            sock.set_inheritable(True)\n\n        sock.listen(self.conf.backlog)\n        return sock\n\n    def bind(self, sock):\n        sock.bind(self.cfg_addr)\n\n    def close(self):\n        if self.sock is None:\n            return\n\n        try:\n            self.sock.close()\n        except OSError as e:\n            self.log.info(\"Error while closing socket %s\", str(e))\n\n        self.sock = None"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "class TCPSocket(BaseSocket):\n\n    FAMILY = socket.AF_INET\n\n    def __str__(self):\n        if self.conf.is_ssl:\n            scheme = \"https\"\n        else:\n            scheme = \"http\"\n\n        addr = self.sock.getsockname()\n        return \"%s://%s:%d\" % (scheme, addr[0], addr[1])\n\n    def set_options(self, sock, bound=False):\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n        return super().set_options(sock, bound=bound)"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "class TCP6Socket(TCPSocket):\n\n    FAMILY = socket.AF_INET6\n\n    def __str__(self):\n        (host, port, _, _) = self.sock.getsockname()\n        return \"http://[%s]:%d\" % (host, port)"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "class UnixSocket(BaseSocket):\n\n    FAMILY = socket.AF_UNIX\n\n    def __init__(self, addr, conf, log, fd=None):\n        if fd is None:\n            try:\n                st = os.stat(addr)\n            except OSError as e:\n                if e.args[0] != errno.ENOENT:\n                    raise\n            else:\n                if stat.S_ISSOCK(st.st_mode):\n                    os.remove(addr)\n                else:\n                    raise ValueError(\"%r is not a socket\" % addr)\n        super().__init__(addr, conf, log, fd=fd)\n\n    def __str__(self):\n        return \"unix:%s\" % self.cfg_addr\n\n    def bind(self, sock):\n        old_umask = os.umask(self.conf.umask)\n        sock.bind(self.cfg_addr)\n        util.chown(self.cfg_addr, self.conf.uid, self.conf.gid)\n        os.umask(old_umask)"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "def _sock_type(addr):\n    if isinstance(addr, tuple):\n        if util.is_ipv6(addr[0]):\n            sock_type = TCP6Socket\n        else:\n            sock_type = TCPSocket\n    elif isinstance(addr, (str, bytes)):\n        sock_type = UnixSocket\n    else:\n        raise TypeError(\"Unable to create socket from: %r\" % addr)\n    return sock_type"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "def create_sockets(conf, log, fds=None):\n    \"\"\"\n    Create a new socket for the configured addresses or file descriptors.\n\n    If a configured address is a tuple then a TCP socket is created.\n    If it is a string, a Unix socket is created. Otherwise, a TypeError is\n    raised.\n    \"\"\"\n    listeners = []\n\n    # get it only once\n    addr = conf.address\n    fdaddr = [bind for bind in addr if isinstance(bind, int)]\n    if fds:\n        fdaddr += list(fds)\n    laddr = [bind for bind in addr if not isinstance(bind, int)]\n\n    # check ssl config early to raise the error on startup\n    # only the certfile is needed since it can contains the keyfile\n    if conf.certfile and not os.path.exists(conf.certfile):\n        raise ValueError('certfile \"%s\" does not exist' % conf.certfile)\n\n    if conf.keyfile and not os.path.exists(conf.keyfile):\n        raise ValueError('keyfile \"%s\" does not exist' % conf.keyfile)\n\n    # sockets are already bound\n    if fdaddr:\n        for fd in fdaddr:\n            sock = socket.fromfd(fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            sock_name = sock.getsockname()\n            sock_type = _sock_type(sock_name)\n            listener = sock_type(sock_name, conf, log, fd=fd)\n            listeners.append(listener)\n\n        return listeners\n\n    # no sockets is bound, first initialization of gunicorn in this env.\n    for addr in laddr:\n        sock_type = _sock_type(addr)\n        sock = None\n        for i in range(5):\n            try:\n                sock = sock_type(addr, conf, log)\n            except OSError as e:\n                if e.args[0] == errno.EADDRINUSE:\n                    log.error(\"Connection in use: %s\", str(addr))\n                if e.args[0] == errno.EADDRNOTAVAIL:\n                    log.error(\"Invalid address: %s\", str(addr))\n                msg = \"connection to {addr} failed: {error}\"\n                log.error(msg.format(addr=str(addr), error=str(e)))\n                if i < 5:\n                    log.debug(\"Retrying in 1 second.\")\n                    time.sleep(1)\n            else:\n                break\n\n        if sock is None:\n            log.error(\"Can't connect to %s\", str(addr))\n            sys.exit(1)\n\n        listeners.append(sock)\n\n    return listeners"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "def close_sockets(listeners, unlink=True):\n    for sock in listeners:\n        sock_name = sock.getsockname()\n        sock.close()\n        if unlink and _sock_type(sock_name) is UnixSocket:\n            os.unlink(sock_name)"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "def ssl_context(conf):\n    def default_ssl_context_factory():\n        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH, cafile=conf.ca_certs)\n        context.load_cert_chain(certfile=conf.certfile, keyfile=conf.keyfile)\n        context.verify_mode = conf.cert_reqs\n        if conf.ciphers:\n            context.set_ciphers(conf.ciphers)\n        return context\n\n    return conf.ssl_context(conf, default_ssl_context_factory)"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/gunicorn/gunicorn/sock.py",
      "content": "def ssl_wrap_socket(sock, conf):\n    return ssl_context(conf).wrap_socket(sock,\n                                         server_side=True,\n                                         suppress_ragged_eofs=conf.suppress_ragged_eofs,\n                                         do_handshake_on_connect=conf.do_handshake_on_connect)"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/gunicorn/gunicorn/__main__.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/gunicorn/gunicorn/__main__.py",
      "content": "from gunicorn.app.wsgiapp import run"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/gunicorn/gunicorn/__main__.py",
      "content": "if __name__ == \"__main__\":\n    # see config.py - argparse defaults to basename(argv[0]) == \"__main__.py\"\n    # todo: let runpy.run_module take care of argv[0] rewriting\n    run(prog=\"gunicorn\")"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/gunicorn/gunicorn/systemd.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\nimport socket\n\nSD_LISTEN_FDS_START = 3"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/gunicorn/gunicorn/systemd.py",
      "content": "def listen_fds(unset_environment=True):\n    \"\"\"\n    Get the number of sockets inherited from systemd socket activation.\n\n    :param unset_environment: clear systemd environment variables unless False\n    :type unset_environment: bool\n    :return: the number of sockets to inherit from systemd socket activation\n    :rtype: int\n\n    Returns zero immediately if $LISTEN_PID is not set to the current pid.\n    Otherwise, returns the number of systemd activation sockets specified by\n    $LISTEN_FDS.\n\n    When $LISTEN_PID matches the current pid, unsets the environment variables\n    unless the ``unset_environment`` flag is ``False``.\n\n    .. note::\n        Unlike the sd_listen_fds C function, this implementation does not set\n        the FD_CLOEXEC flag because the gunicorn arbiter never needs to do this.\n\n    .. seealso::\n        `<https://www.freedesktop.org/software/systemd/man/sd_listen_fds.html>`_\n\n    \"\"\"\n    fds = int(os.environ.get('LISTEN_FDS', 0))\n    listen_pid = int(os.environ.get('LISTEN_PID', 0))\n\n    if listen_pid != os.getpid():\n        return 0\n\n    if unset_environment:\n        os.environ.pop('LISTEN_PID', None)\n        os.environ.pop('LISTEN_FDS', None)\n\n    return fds"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/gunicorn/gunicorn/systemd.py",
      "content": "def sd_notify(state, logger, unset_environment=False):\n    \"\"\"Send a notification to systemd. state is a string; see\n    the man page of sd_notify (http://www.freedesktop.org/software/systemd/man/sd_notify.html)\n    for a description of the allowable values.\n\n    If the unset_environment parameter is True, sd_notify() will unset\n    the $NOTIFY_SOCKET environment variable before returning (regardless of\n    whether the function call itself succeeded or not). Further calls to\n    sd_notify() will then fail, but the variable is no longer inherited by\n    child processes.\n    \"\"\"\n\n    addr = os.environ.get('NOTIFY_SOCKET')\n    if addr is None:\n        # not run in a service, just a noop\n        return\n    try:\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC)\n        if addr[0] == '@':\n            addr = '\\0' + addr[1:]\n        sock.connect(addr)\n        sock.sendall(state.encode('utf-8'))\n    except Exception:\n        logger.debug(\"Exception while invoking sd_notify()\", exc_info=True)\n    finally:\n        if unset_environment:\n            os.environ.pop('NOTIFY_SOCKET')\n        sock.close()"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "import os\nimport os.path\nimport re\nimport sys\nimport time\nimport threading\n\nCOMPILED_EXT_RE = re.compile(r'py[co]$')"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "class Reloader(threading.Thread):\n    def __init__(self, extra_files=None, interval=1, callback=None):\n        super().__init__()\n        self.daemon = True\n        self._extra_files = set(extra_files or ())\n        self._interval = interval\n        self._callback = callback"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def add_extra_file(self, filename):\n        self._extra_files.add(filename)"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def get_files(self):\n        fnames = [\n            COMPILED_EXT_RE.sub('py', module.__file__)\n            for module in tuple(sys.modules.values())\n            if getattr(module, '__file__', None)\n        ]\n\n        fnames.extend(self._extra_files)\n\n        return fnames"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def run(self):\n        mtimes = {}\n        while True:\n            for filename in self.get_files():\n                try:\n                    mtime = os.stat(filename).st_mtime\n                except OSError:\n                    continue\n                old_time = mtimes.get(filename)\n                if old_time is None:\n                    mtimes[filename] = mtime\n                    continue\n                elif mtime > old_time:\n                    if self._callback:\n                        self._callback(filename)\n            time.sleep(self._interval)"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "has_inotify = False\nif sys.platform.startswith('linux'):\n    try:\n        from inotify.adapters import Inotify\n        import inotify.constants\n        has_inotify = True\n    except ImportError:\n        pass"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "if has_inotify:\n\n    class InotifyReloader(threading.Thread):\n        event_mask = (inotify.constants.IN_CREATE | inotify.constants.IN_DELETE\n                      | inotify.constants.IN_DELETE_SELF | inotify.constants.IN_MODIFY\n                      | inotify.constants.IN_MOVE_SELF | inotify.constants.IN_MOVED_FROM\n                      | inotify.constants.IN_MOVED_TO)\n\n        def __init__(self, extra_files=None, callback=None):\n            super().__init__()\n            self.daemon = True\n            self._callback = callback\n            self._dirs = set()\n            self._watcher = Inotify()\n\n            for extra_file in extra_files:\n                self.add_extra_file(extra_file)"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def add_extra_file(self, filename):\n            dirname = os.path.dirname(filename)\n\n            if dirname in self._dirs:\n                return\n\n            self._watcher.add_watch(dirname, mask=self.event_mask)\n            self._dirs.add(dirname)"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def get_dirs(self):\n            fnames = [\n                os.path.dirname(os.path.abspath(COMPILED_EXT_RE.sub('py', module.__file__)))\n                for module in tuple(sys.modules.values())\n                if getattr(module, '__file__', None)\n            ]\n\n            return set(fnames)"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "def run(self):\n            self._dirs = self.get_dirs()\n\n            for dirname in self._dirs:\n                if os.path.isdir(dirname):\n                    self._watcher.add_watch(dirname, mask=self.event_mask)\n\n            for event in self._watcher.event_gen():\n                if event is None:\n                    continue\n\n                filename = event[3]\n\n                self._callback(filename)"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "else:\n\n    class InotifyReloader:\n        def __init__(self, extra_files=None, callback=None):\n            raise ImportError('You must have the inotify module installed to '\n                              'use the inotify reloader')"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/gunicorn/gunicorn/reloader.py",
      "content": "preferred_reloader = InotifyReloader if has_inotify else Reloader\n\nreloader_engines = {\n    'auto': preferred_reloader,\n    'poll': Reloader,\n    'inotify': InotifyReloader,\n}"
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "import base64\nimport binascii\nimport json\nimport time\nimport logging\nlogging.Logger.manager.emittedNoHandlerWarning = 1  # noqa\nfrom logging.config import dictConfig\nfrom logging.config import fileConfig\nimport os\nimport socket\nimport sys\nimport threading\nimport traceback\n\nfrom gunicorn import util"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "SYSLOG_FACILITIES = {\n    \"auth\": 4,\n    \"authpriv\": 10,\n    \"cron\": 9,\n    \"daemon\": 3,\n    \"ftp\": 11,\n    \"kern\": 0,\n    \"lpr\": 6,\n    \"mail\": 2,\n    \"news\": 7,\n    \"security\": 4,  # DEPRECATED\n    \"syslog\": 5,\n    \"user\": 1,\n    \"uucp\": 8,\n    \"local0\": 16,\n    \"local1\": 17,\n    \"local2\": 18,\n    \"local3\": 19,\n    \"local4\": 20,\n    \"local5\": 21,\n    \"local6\": 22,\n    \"local7\": 23\n}\n\nCONFIG_DEFAULTS = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n    \"loggers\": {\n        \"gunicorn.error\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"error_console\"],\n            \"propagate\": True,\n            \"qualname\": \"gunicorn.error\"\n        },\n\n        \"gunicorn.access\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\"],\n            \"propagate\": True,\n            \"qualname\": \"gunicorn.access\"\n        }\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"generic\",\n            \"stream\": \"ext://sys.stdout\"\n        },\n        \"error_console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"generic\",\n            \"stream\": \"ext://sys.stderr\"\n        },\n    },\n    \"formatters\": {\n        \"generic\": {\n            \"format\": \"%(asctime)s [%(process)d] [%(levelname)s] %(message)s\",\n            \"datefmt\": \"[%Y-%m-%d %H:%M:%S %z]\",\n            \"class\": \"logging.Formatter\"\n        }\n    }\n}"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def loggers():\n    \"\"\" get list of all loggers \"\"\"\n    root = logging.root\n    existing = list(root.manager.loggerDict.keys())\n    return [logging.getLogger(name) for name in existing]"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "class SafeAtoms(dict):\n\n    def __init__(self, atoms):\n        dict.__init__(self)\n        for key, value in atoms.items():\n            if isinstance(value, str):\n                self[key] = value.replace('\"', '\\\\\"')\n            else:\n                self[key] = value\n\n    def __getitem__(self, k):\n        if k.startswith(\"{\"):\n            kl = k.lower()\n            if kl in self:\n                return super().__getitem__(kl)\n            else:\n                return \"-\"\n        if k in self:\n            return super().__getitem__(k)\n        else:\n            return '-'"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def parse_syslog_address(addr):\n\n    # unix domain socket type depends on backend\n    # SysLogHandler will try both when given None\n    if addr.startswith(\"unix://\"):\n        sock_type = None\n\n        # set socket type only if explicitly requested\n        parts = addr.split(\"#\", 1)\n        if len(parts) == 2:\n            addr = parts[0]\n            if parts[1] == \"dgram\":\n                sock_type = socket.SOCK_DGRAM\n\n        return (sock_type, addr.split(\"unix://\")[1])\n\n    if addr.startswith(\"udp://\"):\n        addr = addr.split(\"udp://\")[1]\n        socktype = socket.SOCK_DGRAM\n    elif addr.startswith(\"tcp://\"):\n        addr = addr.split(\"tcp://\")[1]\n        socktype = socket.SOCK_STREAM\n    else:\n        raise RuntimeError(\"invalid syslog address\")\n\n    if '[' in addr and ']' in addr:\n        host = addr.split(']')[0][1:].lower()\n    elif ':' in addr:\n        host = addr.split(':')[0].lower()\n    elif addr == \"\":\n        host = \"localhost\"\n    else:\n        host = addr.lower()\n\n    addr = addr.split(']')[-1]\n    if \":\" in addr:\n        port = addr.split(':', 1)[1]\n        if not port.isdigit():\n            raise RuntimeError(\"%r is not a valid port number.\" % port)\n        port = int(port)\n    else:\n        port = 514\n\n    return (socktype, (host, port))"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "class Logger:\n\n    LOG_LEVELS = {\n        \"critical\": logging.CRITICAL,\n        \"error\": logging.ERROR,\n        \"warning\": logging.WARNING,\n        \"info\": logging.INFO,\n        \"debug\": logging.DEBUG\n    }\n    loglevel = logging.INFO\n\n    error_fmt = r\"%(asctime)s [%(process)d] [%(levelname)s] %(message)s\"\n    datefmt = r\"[%Y-%m-%d %H:%M:%S %z]\"\n\n    access_fmt = \"%(message)s\"\n    syslog_fmt = \"[%(process)d] %(message)s\"\n\n    atoms_wrapper_class = SafeAtoms\n\n    def __init__(self, cfg):\n        self.error_log = logging.getLogger(\"gunicorn.error\")\n        self.error_log.propagate = False\n        self.access_log = logging.getLogger(\"gunicorn.access\")\n        self.access_log.propagate = False\n        self.error_handlers = []\n        self.access_handlers = []\n        self.logfile = None\n        self.lock = threading.Lock()\n        self.cfg = cfg\n        self.setup(cfg)"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def setup(self, cfg):\n        self.loglevel = self.LOG_LEVELS.get(cfg.loglevel.lower(), logging.INFO)\n        self.error_log.setLevel(self.loglevel)\n        self.access_log.setLevel(logging.INFO)\n\n        # set gunicorn.error handler\n        if self.cfg.capture_output and cfg.errorlog != \"-\":\n            for stream in sys.stdout, sys.stderr:\n                stream.flush()\n\n            self.logfile = open(cfg.errorlog, 'a+')\n            os.dup2(self.logfile.fileno(), sys.stdout.fileno())\n            os.dup2(self.logfile.fileno(), sys.stderr.fileno())\n\n        self._set_handler(self.error_log, cfg.errorlog,\n                          logging.Formatter(self.error_fmt, self.datefmt))\n\n        # set gunicorn.access handler\n        if cfg.accesslog is not None:\n            self._set_handler(\n                self.access_log, cfg.accesslog,\n                fmt=logging.Formatter(self.access_fmt), stream=sys.stdout\n            )\n\n        # set syslog handler\n        if cfg.syslog:\n            self._set_syslog_handler(\n                self.error_log, cfg, self.syslog_fmt, \"error\"\n            )\n            if not cfg.disable_redirect_access_to_syslog:\n                self._set_syslog_handler(\n                    self.access_log, cfg, self.syslog_fmt, \"access\"\n                )\n\n        if cfg.logconfig_dict:\n            config = CONFIG_DEFAULTS.copy()\n            config.update(cfg.logconfig_dict)\n            try:\n                dictConfig(config)\n            except (\n                    AttributeError,\n                    ImportError,\n                    ValueError,\n                    TypeError\n            ) as exc:\n                raise RuntimeError(str(exc))\n        elif cfg.logconfig_json:\n            config = CONFIG_DEFAULTS.copy()\n            if os.path.exists(cfg.logconfig_json):\n                try:\n                    config_json = json.load(open(cfg.logconfig_json))\n                    config.update(config_json)\n                    dictConfig(config)\n                except (\n                    json.JSONDecodeError,\n                    AttributeError,\n                    ImportError,\n                    ValueError,\n                    TypeError\n                ) as exc:\n                    raise RuntimeError(str(exc))\n        elif cfg.logconfig:\n            if os.path.exists(cfg.logconfig):\n                defaults = CONFIG_DEFAULTS.copy()\n                defaults['__file__'] = cfg.logconfig\n                defaults['here'] = os.path.dirname(cfg.logconfig)\n                fileConfig(cfg.logconfig, defaults=defaults,\n                           disable_existing_loggers=False)\n            else:\n                msg = \"Error: log config '%s' not found\"\n                raise RuntimeError(msg % cfg.logconfig)"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def critical(self, msg, *args, **kwargs):\n        self.error_log.critical(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def error(self, msg, *args, **kwargs):\n        self.error_log.error(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def warning(self, msg, *args, **kwargs):\n        self.error_log.warning(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def info(self, msg, *args, **kwargs):\n        self.error_log.info(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def debug(self, msg, *args, **kwargs):\n        self.error_log.debug(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def exception(self, msg, *args, **kwargs):\n        self.error_log.exception(msg, *args, **kwargs)"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def log(self, lvl, msg, *args, **kwargs):\n        if isinstance(lvl, str):\n            lvl = self.LOG_LEVELS.get(lvl.lower(), logging.INFO)\n        self.error_log.log(lvl, msg, *args, **kwargs)"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def atoms(self, resp, req, environ, request_time):\n        \"\"\" Gets atoms for log formatting.\n        \"\"\"\n        status = resp.status\n        if isinstance(status, str):\n            status = status.split(None, 1)[0]\n        atoms = {\n            'h': environ.get('REMOTE_ADDR', '-'),\n            'l': '-',\n            'u': self._get_user(environ) or '-',\n            't': self.now(),\n            'r': \"%s %s %s\" % (environ['REQUEST_METHOD'],\n                               environ['RAW_URI'],\n                               environ[\"SERVER_PROTOCOL\"]),\n            's': status,\n            'm': environ.get('REQUEST_METHOD'),\n            'U': environ.get('PATH_INFO'),\n            'q': environ.get('QUERY_STRING'),\n            'H': environ.get('SERVER_PROTOCOL'),\n            'b': getattr(resp, 'sent', None) is not None and str(resp.sent) or '-',\n            'B': getattr(resp, 'sent', None),\n            'f': environ.get('HTTP_REFERER', '-'),\n            'a': environ.get('HTTP_USER_AGENT', '-'),\n            'T': request_time.seconds,\n            'D': (request_time.seconds * 1000000) + request_time.microseconds,\n            'M': (request_time.seconds * 1000) + int(request_time.microseconds / 1000),\n            'L': \"%d.%06d\" % (request_time.seconds, request_time.microseconds),\n            'p': \"<%s>\" % os.getpid()\n        }\n\n        # add request headers\n        if hasattr(req, 'headers'):\n            req_headers = req.headers\n        else:\n            req_headers = req\n\n        if hasattr(req_headers, \"items\"):\n            req_headers = req_headers.items()\n\n        atoms.update({\"{%s}i\" % k.lower(): v for k, v in req_headers})\n\n        resp_headers = resp.headers\n        if hasattr(resp_headers, \"items\"):\n            resp_headers = resp_headers.items()\n\n        # add response headers\n        atoms.update({\"{%s}o\" % k.lower(): v for k, v in resp_headers})\n\n        # add environ variables\n        environ_variables = environ.items()\n        atoms.update({\"{%s}e\" % k.lower(): v for k, v in environ_variables})\n\n        return atoms"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def access(self, resp, req, environ, request_time):\n        \"\"\" See http://httpd.apache.org/docs/2.0/logs.html#combined\n        for format details\n        \"\"\"\n\n        if not (self.cfg.accesslog or self.cfg.logconfig or\n           self.cfg.logconfig_dict or self.cfg.logconfig_json or\n           (self.cfg.syslog and not self.cfg.disable_redirect_access_to_syslog)):\n            return\n\n        # wrap atoms:\n        # - make sure atoms will be test case insensitively\n        # - if atom doesn't exist replace it by '-'\n        safe_atoms = self.atoms_wrapper_class(\n            self.atoms(resp, req, environ, request_time)\n        )\n\n        try:\n            self.access_log.info(self.cfg.access_log_format, safe_atoms)\n        except Exception:\n            self.error(traceback.format_exc())"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def now(self):\n        \"\"\" return date in Apache Common Log Format \"\"\"\n        return time.strftime('[%d/%b/%Y:%H:%M:%S %z]')"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def reopen_files(self):\n        if self.cfg.capture_output and self.cfg.errorlog != \"-\":\n            for stream in sys.stdout, sys.stderr:\n                stream.flush()\n\n            with self.lock:\n                if self.logfile is not None:\n                    self.logfile.close()\n                self.logfile = open(self.cfg.errorlog, 'a+')\n                os.dup2(self.logfile.fileno(), sys.stdout.fileno())\n                os.dup2(self.logfile.fileno(), sys.stderr.fileno())\n\n        for log in loggers():\n            for handler in log.handlers:\n                if isinstance(handler, logging.FileHandler):\n                    handler.acquire()\n                    try:\n                        if handler.stream:\n                            handler.close()\n                            handler.stream = handler._open()\n                    finally:\n                        handler.release()"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def close_on_exec(self):\n        for log in loggers():\n            for handler in log.handlers:\n                if isinstance(handler, logging.FileHandler):\n                    handler.acquire()\n                    try:\n                        if handler.stream:\n                            util.close_on_exec(handler.stream.fileno())\n                    finally:\n                        handler.release()"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def _get_gunicorn_handler(self, log):\n        for h in log.handlers:\n            if getattr(h, \"_gunicorn\", False):\n                return h"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def _set_handler(self, log, output, fmt, stream=None):\n        # remove previous gunicorn log handler\n        h = self._get_gunicorn_handler(log)\n        if h:\n            log.handlers.remove(h)\n\n        if output is not None:\n            if output == \"-\":\n                h = logging.StreamHandler(stream)\n            else:\n                util.check_is_writable(output)\n                h = logging.FileHandler(output)\n                # make sure the user can reopen the file\n                try:\n                    os.chown(h.baseFilename, self.cfg.user, self.cfg.group)\n                except OSError:\n                    # it's probably OK there, we assume the user has given\n                    # /dev/null as a parameter.\n                    pass\n\n            h.setFormatter(fmt)\n            h._gunicorn = True\n            log.addHandler(h)"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def _set_syslog_handler(self, log, cfg, fmt, name):\n        # setup format\n        prefix = cfg.syslog_prefix or cfg.proc_name.replace(\":\", \".\")\n\n        prefix = \"gunicorn.%s.%s\" % (prefix, name)\n\n        # set format\n        fmt = logging.Formatter(r\"%s: %s\" % (prefix, fmt))\n\n        # syslog facility\n        try:\n            facility = SYSLOG_FACILITIES[cfg.syslog_facility.lower()]\n        except KeyError:\n            raise RuntimeError(\"unknown facility name\")\n\n        # parse syslog address\n        socktype, addr = parse_syslog_address(cfg.syslog_addr)\n\n        # finally setup the syslog handler\n        h = logging.handlers.SysLogHandler(address=addr,\n                                           facility=facility, socktype=socktype)\n\n        h.setFormatter(fmt)\n        h._gunicorn = True\n        log.addHandler(h)"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/gunicorn/gunicorn/glogging.py",
      "content": "def _get_user(self, environ):\n        user = None\n        http_auth = environ.get(\"HTTP_AUTHORIZATION\")\n        if http_auth and http_auth.lower().startswith('basic'):\n            auth = http_auth.split(\" \", 1)\n            if len(auth) == 2:\n                try:\n                    # b64decode doesn't accept unicode in Python < 3.3\n                    # so we need to convert it to a byte string\n                    auth = base64.b64decode(auth[1].strip().encode('utf-8'))\n                    # b64decode returns a byte string\n                    user = auth.split(b\":\", 1)[0].decode(\"UTF-8\")\n                except (TypeError, binascii.Error, UnicodeDecodeError) as exc:\n                    self.debug(\"Couldn't get username: %s\", exc)\n        return user"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "import ast\nimport email.utils\nimport errno\nimport fcntl\nimport html\nimport importlib\nimport inspect\nimport io\nimport logging\nimport os\nimport pwd\nimport random\nimport re\nimport socket\nimport sys\nimport textwrap\nimport time\nimport traceback\nimport warnings\n\ntry:\n    import importlib.metadata as importlib_metadata\nexcept (ModuleNotFoundError, ImportError):\n    import importlib_metadata\n\nfrom gunicorn.errors import AppImportError\nfrom gunicorn.workers import SUPPORTED_WORKERS\nimport urllib.parse"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "REDIRECT_TO = getattr(os, 'devnull', '/dev/null')\n\nhop_headers = set(\"\"\"\n    connection keep-alive proxy-authenticate proxy-authorization\n    te trailers transfer-encoding upgrade\n    server date\n    \"\"\".split())"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "try:\n    from setproctitle import setproctitle\n\n    def _setproctitle(title):\n        setproctitle(\"gunicorn: %s\" % title)\nexcept ImportError:\n    def _setproctitle(title):\n        pass"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def load_entry_point(distribution, group, name):\n    dist_obj = importlib_metadata.distribution(distribution)\n    eps = [ep for ep in dist_obj.entry_points\n           if ep.group == group and ep.name == name]\n    if not eps:\n        raise ImportError(\"Entry point %r not found\" % ((group, name),))\n    return eps[0].load()"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def load_class(uri, default=\"gunicorn.workers.sync.SyncWorker\",\n               section=\"gunicorn.workers\"):\n    if inspect.isclass(uri):\n        return uri\n    if uri.startswith(\"egg:\"):\n        entry_str = uri.split(\"egg:\")[1]\n        try:\n            dist, name = entry_str.rsplit(\"#\", 1)\n        except ValueError:\n            dist = entry_str\n            name = default\n\n        try:\n            return load_entry_point(dist, section, name)\n        except Exception:\n            exc = traceback.format_exc()\n            msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n            raise RuntimeError(msg % (uri, exc))\n    else:\n        components = uri.split('.')\n        if len(components) == 1:\n            while True:\n                if uri.startswith(\"#\"):\n                    uri = uri[1:]\n\n                if uri in SUPPORTED_WORKERS:\n                    components = SUPPORTED_WORKERS[uri].split(\".\")\n                    break\n\n                try:\n                    return load_entry_point(\n                        \"gunicorn\", section, uri\n                    )\n                except Exception:\n                    exc = traceback.format_exc()\n                    msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n                    raise RuntimeError(msg % (uri, exc))\n\n        klass = components.pop(-1)\n\n        try:\n            mod = importlib.import_module('.'.join(components))\n        except Exception:\n            exc = traceback.format_exc()\n            msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n            raise RuntimeError(msg % (uri, exc))\n        return getattr(mod, klass)"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "positionals = (\n    inspect.Parameter.POSITIONAL_ONLY,\n    inspect.Parameter.POSITIONAL_OR_KEYWORD,\n)"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def get_arity(f):\n    sig = inspect.signature(f)\n    arity = 0\n\n    for param in sig.parameters.values():\n        if param.kind in positionals:\n            arity += 1\n\n    return arity"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def get_username(uid):\n    \"\"\" get the username for a user id\"\"\"\n    return pwd.getpwuid(uid).pw_name"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def set_owner_process(uid, gid, initgroups=False):\n    \"\"\" set user and group of workers processes \"\"\"\n\n    if gid:\n        if uid:\n            try:\n                username = get_username(uid)\n            except KeyError:\n                initgroups = False\n\n        if initgroups:\n            os.initgroups(username, gid)\n        elif gid != os.getgid():\n            os.setgid(gid)\n\n    if uid and uid != os.getuid():\n        os.setuid(uid)"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def chown(path, uid, gid):\n    os.chown(path, uid, gid)"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "if sys.platform.startswith(\"win\"):\n    def _waitfor(func, pathname, waitall=False):\n        func(pathname)\n        if waitall:\n            dirname = pathname\n        else:\n            dirname, name = os.path.split(pathname)\n            dirname = dirname or '.'\n        timeout = 0.001\n        while timeout < 1.0:\n            L = os.listdir(dirname)\n            if not L if waitall else name in L:\n                return\n            time.sleep(timeout)\n            timeout *= 2\n        warnings.warn('tests may fail, delete still pending for ' + pathname,\n                      RuntimeWarning, stacklevel=4)\n\n    def _unlink(filename):\n        _waitfor(os.unlink, filename)\nelse:\n    _unlink = os.unlink"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def unlink(filename):\n    try:\n        _unlink(filename)\n    except OSError as error:\n        if error.errno not in (errno.ENOENT, errno.ENOTDIR):\n            raise"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def is_ipv6(addr):\n    try:\n        socket.inet_pton(socket.AF_INET6, addr)\n    except OSError:\n        return False\n    except ValueError:\n        return False\n    return True"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def parse_address(netloc, default_port='8000'):\n    if re.match(r'unix:(//)?', netloc):\n        return re.split(r'unix:(//)?', netloc)[-1]\n\n    if netloc.startswith(\"fd://\"):\n        fd = netloc[5:]\n        try:\n            return int(fd)\n        except ValueError:\n            raise RuntimeError(\"%r is not a valid file descriptor.\" % fd) from None\n\n    if netloc.startswith(\"tcp://\"):\n        netloc = netloc.split(\"tcp://\")[1]\n    host, port = netloc, default_port\n\n    if '[' in netloc and ']' in netloc:\n        host = netloc.split(']')[0][1:]\n        port = (netloc.split(']:') + [default_port])[1]\n    elif ':' in netloc:\n        host, port = (netloc.split(':') + [default_port])[:2]\n    elif netloc == \"\":\n        host, port = \"0.0.0.0\", default_port\n\n    try:\n        port = int(port)\n    except ValueError:\n        raise RuntimeError(\"%r is not a valid port number.\" % port)\n\n    return host.lower(), port"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def close_on_exec(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFD)\n    flags |= fcntl.FD_CLOEXEC\n    fcntl.fcntl(fd, fcntl.F_SETFD, flags)"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def set_non_blocking(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL) | os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def close(sock):\n    try:\n        sock.close()\n    except OSError:\n        pass"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "try:\n    from os import closerange\nexcept ImportError:\n    def closerange(fd_low, fd_high):\n        for fd in range(fd_low, fd_high):\n            try:\n                os.close(fd)\n            except OSError:\n                pass"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def write_chunk(sock, data):\n    if isinstance(data, str):\n        data = data.encode('utf-8')\n    chunk_size = \"%X\\r\\n\" % len(data)\n    chunk = b\"\".join([chunk_size.encode('utf-8'), data, b\"\\r\\n\"])\n    sock.sendall(chunk)"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def write(sock, data, chunked=False):\n    if chunked:\n        return write_chunk(sock, data)\n    sock.sendall(data)"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def write_nonblock(sock, data, chunked=False):\n    timeout = sock.gettimeout()\n    if timeout != 0.0:\n        try:\n            sock.setblocking(0)\n            return write(sock, data, chunked)\n        finally:\n            sock.setblocking(1)\n    else:\n        return write(sock, data, chunked)"
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def write_error(sock, status_int, reason, mesg):\n    html_error = textwrap.dedent(\"\"\"\\\n    <html>\n      <head>\n        <title>%(reason)s</title>\n      </head>\n      <body>\n        <h1><p>%(reason)s</p></h1>\n        %(mesg)s\n      </body>\n    </html>\n    \"\"\") % {\"reason\": reason, \"mesg\": html.escape(mesg)}\n\n    http = textwrap.dedent(\"\"\"\\\n    HTTP/1.1 %s %s\\r\n    Connection: close\\r\n    Content-Type: text/html\\r\n    Content-Length: %d\\r\n    \\r\n    %s\"\"\") % (str(status_int), reason, len(html_error), html_error)\n    write_nonblock(sock, http.encode('latin1'))"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def _called_with_wrong_args(f):\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the function raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                return False\n\n            tb = tb.tb_next\n\n        return True\n    finally:\n        del tb"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def import_app(module):\n    parts = module.split(\":\", 1)\n    if len(parts) == 1:\n        obj = \"application\"\n    else:\n        module, obj = parts[0], parts[1]\n\n    try:\n        mod = importlib.import_module(module)\n    except ImportError:\n        if module.endswith(\".py\") and os.path.exists(module):\n            msg = \"Failed to find application, did you mean '%s:%s'?\"\n            raise ImportError(msg % (module.rsplit(\".\", 1)[0], obj))\n        raise\n\n    try:\n        expression = ast.parse(obj, mode=\"eval\").body\n    except SyntaxError:\n        raise AppImportError(\n            \"Failed to parse %r as an attribute name or function call.\" % obj\n        )\n\n    if isinstance(expression, ast.Name):\n        name = expression.id\n        args = kwargs = None\n    elif isinstance(expression, ast.Call):\n        if not isinstance(expression.func, ast.Name):\n            raise AppImportError(\"Function reference must be a simple name: %r\" % obj)\n\n        name = expression.func.id\n\n        try:\n            args = [ast.literal_eval(arg) for arg in expression.args]\n            kwargs = {kw.arg: ast.literal_eval(kw.value) for kw in expression.keywords}\n        except ValueError:\n            raise AppImportError(\n                \"Failed to parse arguments as literal values: %r\" % obj\n            )\n    else:\n        raise AppImportError(\n            \"Failed to parse %r as an attribute name or function call.\" % obj\n        )\n\n    is_debug = logging.root.level == logging.DEBUG\n    try:\n        app = getattr(mod, name)\n    except AttributeError:\n        if is_debug:\n            traceback.print_exception(*sys.exc_info())\n        raise AppImportError(\"Failed to find attribute %r in %r.\" % (name, module))\n\n    if args is not None:\n        try:\n            app = app(*args, **kwargs)\n        except TypeError as e:\n            if _called_with_wrong_args(app):\n                raise AppImportError(\n                    \"\".join(traceback.format_exception_only(TypeError, e)).strip()\n                )\n            raise\n\n    if app is None:\n        raise AppImportError(\"Failed to find application object: %r\" % obj)\n\n    if not callable(app):\n        raise AppImportError(\"Application object must be callable.\")\n    return app"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def getcwd():\n    try:\n        a = os.stat(os.environ['PWD'])\n        b = os.stat(os.getcwd())\n        if a.st_ino == b.st_ino and a.st_dev == b.st_dev:\n            cwd = os.environ['PWD']\n        else:\n            cwd = os.getcwd()\n    except Exception:\n        cwd = os.getcwd()\n    return cwd"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def http_date(timestamp=None):\n    \"\"\"Return the current date and time formatted for a message header.\"\"\"\n    if timestamp is None:\n        timestamp = time.time()\n    s = email.utils.formatdate(timestamp, localtime=False, usegmt=True)\n    return s"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def is_hoppish(header):\n    return header.lower().strip() in hop_headers"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def daemonize(enable_stdio_inheritance=False):\n    \"\"\"\\\n    Standard daemonization of a process.\n    http://www.faqs.org/faqs/unix-faq/programmer/faq/ section 1.7\n    \"\"\"\n    if 'GUNICORN_FD' not in os.environ:\n        if os.fork():\n            os._exit(0)\n        os.setsid()\n\n        if os.fork():\n            os._exit(0)\n\n        os.umask(0o22)\n\n        if not enable_stdio_inheritance:\n            closerange(0, 3)\n\n            fd_null = os.open(REDIRECT_TO, os.O_RDWR)\n            os.set_inheritable(fd_null, True)\n\n            if fd_null != 0:\n                os.dup2(fd_null, 0)\n\n            os.dup2(fd_null, 1)\n            os.dup2(fd_null, 2)\n\n        else:\n            fd_null = os.open(REDIRECT_TO, os.O_RDWR)\n\n            if fd_null != 0:\n                os.close(0)\n                os.dup2(fd_null, 0)\n\n            def redirect(stream, fd_expect):\n                try:\n                    fd = stream.fileno()\n                    if fd == fd_expect and stream.isatty():\n                        os.close(fd)\n                        os.dup2(fd_null, fd)\n                except AttributeError:\n                    pass\n\n            redirect(sys.stdout, 1)\n            redirect(sys.stderr, 2)"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def seed():\n    try:\n        random.seed(os.urandom(64))\n    except NotImplementedError:\n        random.seed('%s.%s' % (time.time(), os.getpid()))"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def check_is_writable(path):\n    try:\n        with open(path, 'a') as f:\n            f.close()\n    except OSError as e:\n        raise RuntimeError(\"Error: '%s' isn't writable [%r]\" % (path, e))"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def to_bytestring(value, encoding=\"utf8\"):\n    \"\"\"Converts a string argument to a byte string\"\"\"\n    if isinstance(value, bytes):\n        return value\n    if not isinstance(value, str):\n        raise TypeError('%r is not a string' % value)\n\n    return value.encode(encoding)"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def has_fileno(obj):\n    if not hasattr(obj, \"fileno\"):\n        return False\n\n    try:\n        obj.fileno()\n    except (AttributeError, OSError, io.UnsupportedOperation):\n        return False\n\n    return True"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def warn(msg):\n    print(\"!!!\", file=sys.stderr)\n\n    lines = msg.splitlines()\n    for i, line in enumerate(lines):\n        if i == 0:\n            line = \"WARNING: %s\" % line\n        print(\"!!! %s\" % line, file=sys.stderr)\n\n    print(\"!!!\\n\", file=sys.stderr)\n    sys.stderr.flush()"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def make_fail_app(msg):\n    msg = to_bytestring(msg)\n\n    def app(environ, start_response):\n        start_response(\"500 Internal Server Error\", [\n            (\"Content-Type\", \"text/plain\"),\n            (\"Content-Length\", str(len(msg)))\n        ])\n        return [msg]\n\n    return app"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def split_request_uri(uri):\n    if uri.startswith(\"//\"):\n        parts = urllib.parse.urlsplit(\".\" + uri)\n        return parts._replace(path=parts.path[1:])\n\n    return urllib.parse.urlsplit(uri)"
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def reraise(tp, value, tb=None):\n    try:\n        if value is None:\n            value = tp()\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:\n        value = None\n        tb = None"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def bytes_to_str(b):\n    if isinstance(b, str):\n        return b\n    return str(b, 'latin1')"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/gunicorn/gunicorn/util.py",
      "content": "def unquote_to_wsgi_str(string):\n    return urllib.parse.unquote_to_bytes(string).decode('latin-1')"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/gunicorn/gunicorn/debug.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n\"\"\"The debug module contains utilities and functions for better\ndebugging Gunicorn.\"\"\"\n\nimport sys\nimport linecache\nimport re\nimport inspect\n\n__all__ = ['spew', 'unspew']\n\n_token_spliter = re.compile(r'\\W+')"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/gunicorn/gunicorn/debug.py",
      "content": "class Spew:\n\n    def __init__(self, trace_names=None, show_values=True):\n        self.trace_names = trace_names\n        self.show_values = show_values"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/gunicorn/gunicorn/debug.py",
      "content": "def __call__(self, frame, event, arg):\n        if event == 'line':\n            lineno = frame.f_lineno\n            if '__file__' in frame.f_globals:\n                filename = frame.f_globals['__file__']\n                if (filename.endswith('.pyc') or\n                        filename.endswith('.pyo')):\n                    filename = filename[:-1]\n                name = frame.f_globals['__name__']\n                line = linecache.getline(filename, lineno)\n            else:\n                name = '[unknown]'\n                try:\n                    src = inspect.getsourcelines(frame)\n                    line = src[lineno]\n                except OSError:\n                    line = 'Unknown code named [%s].  VM instruction #%d' % (\n                        frame.f_code.co_name, frame.f_lasti)\n            if self.trace_names is None or name in self.trace_names:\n                print('%s:%s: %s' % (name, lineno, line.rstrip()))\n                if not self.show_values:\n                    return self\n                details = []\n                tokens = _token_spliter.split(line)\n                for tok in tokens:\n                    if tok in frame.f_globals:\n                        details.append('%s=%r' % (tok, frame.f_globals[tok]))\n                    if tok in frame.f_locals:\n                        details.append('%s=%r' % (tok, frame.f_locals[tok]))\n                if details:\n                    print(\"\\t%s\" % ' '.join(details))\n        return self"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/gunicorn/gunicorn/debug.py",
      "content": "def spew(trace_names=None, show_values=False):\n    \"\"\"Install a trace hook which writes incredibly detailed logs\n    about what code is being executed to stdout.\n    \"\"\"\n    sys.settrace(Spew(trace_names, show_values))"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/gunicorn/gunicorn/debug.py",
      "content": "def unspew():\n    \"\"\"Remove the trace hook installed by spew.\n    \"\"\"\n    sys.settrace(None)"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "```python"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "import argparse\nimport copy\nimport grp\nimport inspect\nimport ipaddress\nimport os\nimport pwd\nimport re\nimport shlex\nimport ssl\nimport sys\nimport textwrap\n\nfrom gunicorn import __version__, util\nfrom gunicorn.errors import ConfigError\nfrom gunicorn.reloader import reloader_engines"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "KNOWN_SETTINGS = []\nPLATFORM = sys.platform"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def make_settings(ignore=None):\n    settings = {}\n    ignore = ignore or ()\n    for s in KNOWN_SETTINGS:\n        setting = s()\n        if setting.name in ignore:\n            continue\n        settings[setting.name] = setting.copy()\n    return settings"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def auto_int(_, x):\n    # for compatible with octal numbers in python3\n    if re.match(r'0(\\d)', x, re.IGNORECASE):\n        x = x.replace('0', '0o', 1)\n    return int(x, 0)"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Config:\n\n    def __init__(self, usage=None, prog=None):\n        self.settings = make_settings()\n        self.usage = usage\n        self.prog = prog or os.path.basename(sys.argv[0])\n        self.env_orig = os.environ.copy()\n\n    def __str__(self):\n        lines = []\n        kmax = max(len(k) for k in self.settings)\n        for k in sorted(self.settings):\n            v = self.settings[k].value\n            if callable(v):\n                v = \"<{}()>\".format(v.__qualname__)\n            lines.append(\"{k:{kmax}} = {v}\".format(k=k, v=v, kmax=kmax))\n        return \"\\n\".join(lines)\n\n    def __getattr__(self, name):\n        if name not in self.settings:\n            raise AttributeError(\"No configuration setting for: %s\" % name)\n        return self.settings[name].get()\n\n    def __setattr__(self, name, value):\n        if name != \"settings\" and name in self.settings:\n            raise AttributeError(\"Invalid access!\")\n        super().__setattr__(name, value)\n\n    def set(self, name, value):\n        if name not in self.settings:\n            raise AttributeError(\"No configuration setting for: %s\" % name)\n        self.settings[name].set(value)\n\n    def get_cmd_args_from_env(self):\n        if 'GUNICORN_CMD_ARGS' in self.env_orig:\n            return shlex.split(self.env_orig['GUNICORN_CMD_ARGS'])\n        return []\n\n    def parser(self):\n        kwargs = {\n            \"usage\": self.usage,\n            \"prog\": self.prog\n        }\n        parser = argparse.ArgumentParser(**kwargs)\n        parser.add_argument(\"-v\", \"--version\",\n                            action=\"version\", default=argparse.SUPPRESS,\n                            version=\"%(prog)s (version \" + __version__ + \")\\n\",\n                            help=\"show program's version number and exit\")\n        parser.add_argument(\"args\", nargs=\"*\", help=argparse.SUPPRESS)\n\n        keys = sorted(self.settings, key=self.settings.__getitem__)\n        for k in keys:\n            self.settings[k].add_option(parser)\n\n        return parser\n\n    @property\n    def worker_class_str(self):\n        uri = self.settings['worker_class'].get()\n\n        if isinstance(uri, str):\n            # are we using a threaded worker?\n            is_sync = uri.endswith('SyncWorker') or uri == 'sync'\n            if is_sync and self.threads > 1:\n                return \"gthread\"\n            return uri\n        return uri.__name__\n\n    @property\n    def worker_class(self):\n        uri = self.settings['worker_class'].get()\n\n        # are we using a threaded worker?\n        is_sync = isinstance(uri, str) and (uri.endswith('SyncWorker') or uri == 'sync')\n        if is_sync and self.threads > 1:\n            uri = \"gunicorn.workers.gthread.ThreadWorker\"\n\n        worker_class = util.load_class(uri)\n        if hasattr(worker_class, \"setup\"):\n            worker_class.setup()\n        return worker_class\n\n    @property\n    def address(self):\n        s = self.settings['bind'].get()\n        return [util.parse_address(util.bytes_to_str(bind)) for bind in s]\n\n    @property\n    def uid(self):\n        return self.settings['user'].get()\n\n    @property\n    def gid(self):\n        return self.settings['group'].get()\n\n    @property\n    def proc_name(self):\n        pn = self.settings['proc_name'].get()\n        if pn is not None:\n            return pn\n        else:\n            return self.settings['default_proc_name'].get()\n\n    @property\n    def logger_class(self):\n        uri = self.settings['logger_class'].get()\n        if uri == \"simple\":\n            # support the default\n            uri = LoggerClass.default\n\n        # if default logger is in use, and statsd is on, automagically switch\n        # to the statsd logger\n        if uri == LoggerClass.default:\n            if 'statsd_host' in self.settings and self.settings['statsd_host'].value is not None:\n                uri = \"gunicorn.instrument.statsd.Statsd\"\n\n        logger_class = util.load_class(\n            uri,\n            default=\"gunicorn.glogging.Logger\",\n            section=\"gunicorn.loggers\")\n\n        if hasattr(logger_class, \"install\"):\n            logger_class.install()\n        return logger_class\n\n    @property\n    def is_ssl(self):\n        return self.certfile or self.keyfile\n\n    @property\n    def ssl_options(self):\n        opts = {}\n        for name, value in self.settings.items():\n            if value.section == 'SSL':\n                opts[name] = value.get()\n        return opts\n\n    @property\n    def env(self):\n        raw_env = self.settings['raw_env'].get()\n        env = {}\n\n        if not raw_env:\n            return env\n\n        for e in raw_env:\n            s = util.bytes_to_str(e)\n            try:\n                k, v = s.split('=', 1)\n            except ValueError:\n                raise RuntimeError(\"environment setting %r invalid\" % s)\n\n            env[k] = v\n\n        return env\n\n    @property\n    def sendfile(self):\n        if self.settings['sendfile'].get() is not None:\n            return False\n\n        if 'SENDFILE' in os.environ:\n            sendfile = os.environ['SENDFILE'].lower()\n            return sendfile in ['y', '1', 'yes', 'true']\n\n        return True\n\n    @property\n    def reuse_port(self):\n        return self.settings['reuse_port'].get()\n\n    @property\n    def paste_global_conf(self):\n        raw_global_conf = self.settings['raw_paste_global_conf'].get()\n        if raw_global_conf is None:\n            return None\n\n        global_conf = {}\n        for e in raw_global_conf:\n            s = util.bytes_to_str(e)\n            try:\n                k, v = re.split(r'(?<!\\\\)=', s, 1)\n            except ValueError:\n                raise RuntimeError(\"environment setting %r invalid\" % s)\n            k = k.replace('\\\\=', '=')\n            v = v.replace('\\\\=', '=')\n            global_conf[k] = v\n\n        return global_conf"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SettingMeta(type):\n    def __new__(cls, name, bases, attrs):\n        super_new = super().__new__\n        parents = [b for b in bases if isinstance(b, SettingMeta)]\n        if not parents:\n            return super_new(cls, name, bases, attrs)\n\n        attrs[\"order\"] = len(KNOWN_SETTINGS)\n        attrs[\"validator\"] = staticmethod(attrs[\"validator\"])\n\n        new_class = super_new(cls, name, bases, attrs)\n        new_class.fmt_desc(attrs.get(\"desc\", \"\"))\n        KNOWN_SETTINGS.append(new_class)\n        return new_class\n\n    def fmt_desc(cls, desc):\n        desc = textwrap.dedent(desc).strip()\n        setattr(cls, \"desc\", desc)\n        setattr(cls, \"short\", desc.splitlines()[0])"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Setting:\n    name = None\n    value = None\n    section = None\n    cli = None\n    validator = None\n    type = None\n    meta = None\n    action = None\n    default = None\n    short = None\n    desc = None\n    nargs = None\n    const = None\n\n    def __init__(self):\n        if self.default is not None:\n            self.set(self.default)\n\n    def add_option(self, parser):\n        if not self.cli:\n            return\n        args = tuple(self.cli)\n\n        help_txt = \"%s [%s]\" % (self.short, self.default)\n        help_txt = help_txt.replace(\"%\", \"%%\")\n\n        kwargs = {\n            \"dest\": self.name,\n            \"action\": self.action or \"store\",\n            \"type\": self.type or str,\n            \"default\": None,\n            \"help\": help_txt\n        }\n\n        if self.meta is not None:\n            kwargs['metavar'] = self.meta\n\n        if kwargs[\"action\"] != \"store\":\n            kwargs.pop(\"type\")\n\n        if self.nargs is not None:\n            kwargs[\"nargs\"] = self.nargs\n\n        if self.const is not None:\n            kwargs[\"const\"] = self.const\n\n        parser.add_argument(*args, **kwargs)\n\n    def copy(self):\n        return copy.copy(self)\n\n    def get(self):\n        return self.value\n\n    def set(self, val):\n        if not callable(self.validator):\n            raise TypeError('Invalid validator: %s' % self.name)\n        self.value = self.validator(val)\n\n    def __lt__(self, other):\n        return (self.section == other.section and\n                self.order < other.order)\n    __cmp__ = __lt__\n\n    def __repr__(self):\n        return \"<%s.%s object at %x with value %r>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            id(self),\n            self.value,\n        )"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "Setting = SettingMeta('Setting', (Setting,), {})"
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_bool(val):\n    if val is None:\n        return\n\n    if isinstance(val, bool):\n        return val\n    if not isinstance(val, str):\n        raise TypeError(\"Invalid type for casting: %s\" % val)\n    if val.lower().strip() == \"true\":\n        return True\n    elif val.lower().strip() == \"false\":\n        return False\n    else:\n        raise ValueError(\"Invalid boolean: %s\" % val)"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_dict(val):\n    if not isinstance(val, dict):\n        raise TypeError(\"Value is not a dictionary: %s \" % val)\n    return val"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_pos_int(val):\n    if not isinstance(val, int):\n        val = int(val, 0)\n    else:\n        # Booleans are ints!\n        val = int(val)\n    if val < 0:\n        raise ValueError(\"Value must be positive: %s\" % val)\n    return val"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_ssl_version(val):\n    if val != SSLVersion.default:\n        sys.stderr.write(\"Warning: option `ssl_version` is deprecated and it is ignored. Use ssl_context instead.\\n\")\n    return val"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_string(val):\n    if val is None:\n        return None\n    if not isinstance(val, str):\n        raise TypeError(\"Not a string: %s\" % val)\n    return val.strip()"
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_file_exists(val):\n    if val is None:\n        return None\n    if not os.path.exists(val):\n        raise ValueError(\"File %s does not exists.\" % val)\n    return val"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_list_string(val):\n    if not val:\n        return []\n\n    # legacy syntax\n    if isinstance(val, str):\n        val = [val]\n\n    return [validate_string(v) for v in val]"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_list_of_existing_files(val):\n    return [validate_file_exists(v) for v in validate_list_string(val)]"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_string_to_addr_list(val):\n    val = validate_string_to_list(val)\n\n    for addr in val:\n        if addr == \"*\":\n            continue\n        _vaid_ip = ipaddress.ip_address(addr)\n\n    return val"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_string_to_list(val):\n    val = validate_string(val)\n\n    if not val:\n        return []\n\n    return [v.strip() for v in val.split(\",\") if v]"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_class(val):\n    if inspect.isfunction(val) or inspect.ismethod(val):\n        val = val()\n    if inspect.isclass(val):\n        return val\n    return validate_string(val)"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_callable(arity):\n    def _validate_callable(val):\n        if isinstance(val, str):\n            try:\n                mod_name, obj_name = val.rsplit(\".\", 1)\n            except ValueError:\n                raise TypeError(\"Value '%s' is not import string. \"\n                                \"Format: module[.submodules...].object\" % val)\n            try:\n                mod = __import__(mod_name, fromlist=[obj_name])\n                val = getattr(mod, obj_name)\n            except ImportError as e:\n                raise TypeError(str(e))\n            except AttributeError:\n                raise TypeError(\"Can not load '%s' from '%s'\"\n                                \"\" % (obj_name, mod_name))\n        if not callable(val):\n            raise TypeError(\"Value is not callable: %s\" % val)\n        if arity != -1 and arity != util.get_arity(val):\n            raise TypeError(\"Value must have an arity of: %s\" % arity)\n        return val\n    return _validate_callable"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_user(val):\n    if val is None:\n        return os.geteuid()\n    if isinstance(val, int):\n        return val\n    elif val.isdigit():\n        return int(val)\n    else:\n        try:\n            return pwd.getpwnam(val).pw_uid\n        except KeyError:\n            raise ConfigError(\"No such user: '%s'\" % val)"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_group(val):\n    if val is None:\n        return os.getegid()\n\n    if isinstance(val, int):\n        return val\n    elif val.isdigit():\n        return int(val)\n    else:\n        try:\n            return grp.getgrnam(val).gr_gid\n        except KeyError:\n            raise ConfigError(\"No such group: '%s'\" % val)"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_post_request(val):\n    val = validate_callable(-1)(val)\n\n    largs = util.get_arity(val)\n    if largs == 4:\n        return val\n    elif largs == 3:\n        return lambda worker, req, env, _r: val(worker, req, env)\n    elif largs == 2:\n        return lambda worker, req, _e, _r: val(worker, req)\n    else:\n        raise TypeError(\"Value must have an arity of: 4\")"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_chdir(val):\n    # valid if the value is a string\n    val = validate_string(val)\n\n    # transform relative paths\n    path = os.path.abspath(os.path.normpath(os.path.join(util.getcwd(), val)))\n\n    # test if the path exists\n    if not os.path.exists(path):\n        raise ConfigError(\"can't chdir to %r\" % val)\n\n    return path"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_statsd_address(val):\n    val = validate_string(val)\n    if val is None:\n        return None\n\n    # As of major release 20, util.parse_address would recognize unix:PORT\n    # as a UDS address, breaking backwards compatibility. We defend against\n    # that regression here (this is also unit-tested).\n    # Feel free to remove in the next major release.\n    unix_hostname_regression = re.match(r'^unix:(\\d+)$', val)\n    if unix_hostname_regression:\n        return ('unix', int(unix_hostname_regression.group(1)))\n\n    try:\n        address = util.parse_address(val, default_port='8125')\n    except RuntimeError:\n        raise TypeError(\"Value must be one of ('host:port', 'unix://PATH')\")\n\n    return address"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_reload_engine(val):\n    if val not in reloader_engines:\n        raise ConfigError(\"Invalid reload_engine: %r\" % val)\n\n    return val"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def get_default_config_file():\n    config_path = os.path.join(os.path.abspath(os.getcwd()),\n                               'gunicorn.conf.py')\n    if os.path.exists(config_path):\n        return config_path\n    return None"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ConfigFile(Setting):\n    name = \"config\"\n    section = \"Config File\"\n    cli = [\"-c\", \"--config\"]\n    meta = \"CONFIG\"\n    validator = validate_string\n    default = \"./gunicorn.conf.py\"\n    desc = \"\"\"\\\n        :ref:`The Gunicorn config file<configuration_file>`.\n\n        A string of the form ``PATH``, ``file:PATH``, or ``python:MODULE_NAME``.\n\n        Only has an effect when specified on the command line or as part of an\n        application specific configuration.\n\n        By default, a file named ``gunicorn.conf.py`` will be read from the same\n        directory where gunicorn is being run.\n\n        .. versionchanged:: 19.4\n           Loading the config from a Python module requires the ``python:``\n           prefix.\n        \"\"\""
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WSGIApp(Setting):\n    name = \"wsgi_app\"\n    section = \"Config File\"\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A WSGI application path in pattern ``$(MODULE_NAME):$(VARIABLE_NAME)``.\n\n        .. versionadded:: 20.1.0\n        \"\"\""
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Bind(Setting):\n    name = \"bind\"\n    action = \"append\"\n    section = \"Server Socket\"\n    cli = [\"-b\", \"--bind\"]\n    meta = \"ADDRESS\"\n    validator = validate_list_string\n\n    if 'PORT' in os.environ:\n        default = ['0.0.0.0:{0}'.format(os.environ.get('PORT'))]\n    else:\n        default = ['127.0.0.1:8000']\n\n    desc = \"\"\"\\\n        The socket to bind.\n\n        A string of the form: ``HOST``, ``HOST:PORT``, ``unix:PATH``,\n        ``fd://FD``. An IP is a valid ``HOST``.\n\n        .. versionchanged:: 20.0\n           Support for ``fd://FD`` got added.\n\n        Multiple addresses can be bound. ex.::\n\n            $ gunicorn -b 127.0.0.1:8000 -b [::1]:8000 test:app\n\n        will bind the `test:app` application on localhost both on ipv6\n        and ipv4 interfaces.\n\n        If the ``PORT`` environment variable is defined, the default\n        is ``['0.0.0.0:$PORT']``. If it is not defined, the default\n        is ``['127.0.0.1:8000']``.\n        \"\"\""
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Backlog(Setting):\n    name = \"backlog\"\n    section = \"Server Socket\"\n    cli = [\"--backlog\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 2048\n    desc = \"\"\"\\\n        The maximum number of pending connections.\n\n        This refers to the number of clients that can be waiting to be served.\n        Exceeding this number results in the client getting an error when\n        attempting to connect. It should only affect servers under significant\n        load.\n\n        Must be a positive integer. Generally set in the 64-2048 range.\n        \"\"\""
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Workers(Setting):\n    name = \"workers\"\n    section = \"Worker Processes\"\n    cli = [\"-w\", \"--workers\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = int(os.environ.get(\"WEB_CONCURRENCY\", 1))\n    desc = \"\"\"\\\n        The number of worker processes for handling requests.\n\n        A positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\n        You'll want to vary this a bit to find the best for your particular\n        application's work load.\n\n        By default, the value of the ``WEB_CONCURRENCY`` environment variable,\n        which is set by some Platform-as-a-Service providers such as Heroku. If\n        it is not defined, the default is ``1``.\n        \"\"\""
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerClass(Setting):\n    name = \"worker_class\"\n    section = \"Worker Processes\"\n    cli = [\"-k\", \"--worker-class\"]\n    meta = \"STRING\"\n    validator = validate_class\n    default = \"sync\"\n    desc = \"\"\"\\\n        The type of workers to use.\n\n        The default class (``sync``) should handle most \"normal\" types of\n        workloads. You'll want to read :doc:`design` for information on when\n        you might want to choose one of the other worker classes. Required\n        libraries may be installed using setuptools' ``extras_require`` feature.\n\n        A string referring to one of the following bundled classes:\n\n        * ``sync``\n        * ``eventlet`` - Requires eventlet >= 0.24.1 (or install it via\n          ``pip install gunicorn[eventlet]``)\n        * ``gevent``   - Requires gevent >= 1.4 (or install it via\n          ``pip install gunicorn[gevent]``)\n        * ``tornado``  - Requires tornado >= 0.2 (or install it via\n          ``pip install gunicorn[tornado]``)\n        * ``gthread``  - Python 2 requires the futures package to be installed\n          (or install it via ``pip install gunicorn[gthread]``)\n\n        Optionally, you can provide your own worker by giving Gunicorn a\n        Python path to a subclass of ``gunicorn.workers.base.Worker``.\n        This alternative syntax will load the gevent class:\n        ``gunicorn.workers.ggevent.GeventWorker``.\n        \"\"\""
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerThreads(Setting):\n    name = \"threads\"\n    section = \"Worker Processes\"\n    cli = [\"--threads\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 1\n    desc = \"\"\"\\\n        The number of worker threads for handling requests.\n\n        Run each worker with the specified number of threads.\n\n        A positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\n        You'll want to vary this a bit to find the best for your particular\n        application's work load.\n\n        If it is not defined, the default is ``1``.\n\n        This setting only affects the Gthread worker type.\n\n        .. note::\n           If you try to use the ``sync`` worker type and set the ``threads``\n           setting to more than 1, the ``gthread`` worker type will be used\n           instead.\n        \"\"\""
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerConnections(Setting):\n    name = \"worker_connections\"\n    section = \"Worker Processes\"\n    cli = [\"--worker-connections\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 1000\n    desc = \"\"\"\\\n        The maximum number of simultaneous clients.\n\n        This setting only affects the ``gthread``, ``eventlet`` and ``gevent`` worker types.\n        \"\"\""
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class MaxRequests(Setting):\n    name = \"max_requests\"\n    section = \"Worker Processes\"\n    cli = [\"--max-requests\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 0\n    desc = \"\"\"\\\n        The maximum number of requests a worker will process before restarting.\n\n        Any value greater than zero will limit the number of requests a worker\n        will process before automatically restarting. This is a simple method\n        to help limit the damage of memory leaks.\n\n        If this is set to zero (the default) then the automatic worker\n        restarts are disabled.\n        \"\"\""
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class MaxRequestsJitter(Setting):\n    name = \"max_requests_jitter\"\n    section = \"Worker Processes\"\n    cli = [\"--max-requests-jitter\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 0\n    desc = \"\"\"\\\n        The maximum jitter to add to the *max_requests* setting.\n\n        The jitter causes the restart per worker to be randomized by\n        ``randint(0, max_requests_jitter)``. This is intended to stagger worker\n        restarts to avoid all workers restarting at the same time.\n\n        .. versionadded:: 19.2\n        \"\"\""
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Timeout(Setting):\n    name = \"timeout\"\n    section = \"Worker Processes\"\n    cli = [\"-t\", \"--timeout\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 30\n    desc = \"\"\"\\\n        Workers silent for more than this many seconds are killed and restarted.\n\n        Value is a positive number or 0. Setting it to 0 has the effect of\n        infinite timeouts by disabling timeouts for all workers entirely.\n\n        Generally, the default of thirty seconds should suffice. Only set this\n        noticeably higher if you're sure of the repercussions for sync workers.\n        For the non sync workers it just means that the worker process is still\n        communicating and is not tied to the length of time required to handle a\n        single request.\n        \"\"\""
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class GracefulTimeout(Setting):\n    name = \"graceful_timeout\"\n    section = \"Worker Processes\"\n    cli = [\"--graceful-timeout\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 30\n    desc = \"\"\"\\\n        Timeout for graceful workers restart.\n\n        After receiving a restart signal, workers have this much time to finish\n        serving requests. Workers still alive after the timeout (starting from\n        the receipt of the restart signal) are force killed.\n        \"\"\""
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Keepalive(Setting):\n    name = \"keepalive\"\n    section = \"Worker Processes\"\n    cli = [\"--keep-alive\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 2\n    desc = \"\"\"\\\n        The number of seconds to wait for requests on a Keep-Alive connection.\n\n        Generally set in the 1-5 seconds range for servers with direct connection\n        to the client (e.g. when you don't have separate load balancer). When\n        Gunicorn is deployed behind a load balancer, it often makes sense to\n        set this to a higher value.\n\n        .. note::\n           ``sync`` worker does not support persistent connections and will\n           ignore this option.\n        \"\"\""
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LimitRequestLine(Setting):\n    name = \"limit_request_line\"\n    section = \"Security\"\n    cli = [\"--limit-request-line\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 4094\n    desc = \"\"\"\\\n        The maximum size of HTTP request line in bytes.\n\n        This parameter is used to limit the allowed size of a client's\n        HTTP request-line. Since the request-line consists of the HTTP\n        method, URI, and protocol version, this directive places a\n        restriction on the length of a request-URI allowed for a request\n        on the server. A server needs this value to be large enough to\n        hold any of its resource names, including any information that\n        might be passed in the query part of a GET request. Value is a number\n        from 0 (unlimited) to 8190.\n\n        This parameter can be used to prevent any DDOS attack.\n        \"\"\""
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LimitRequestFields(Setting):\n    name = \"limit_request_fields\"\n    section = \"Security\"\n    cli = [\"--limit-request-fields\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 100\n    desc = \"\"\"\\\n        Limit the number of HTTP headers fields in a request.\n\n        This parameter is used to limit the number of headers in a request to\n        prevent DDOS attack. Used with the *limit_request_field_size* it allows\n        more safety. By default this value is 100 and can't be larger than\n        32768.\n        \"\"\""
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LimitRequestFieldSize(Setting):\n    name = \"limit_request_field_size\"\n    section = \"Security\"\n    cli = [\"--limit-request-field_size\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 8190\n    desc = \"\"\"\\\n        Limit the allowed size of an HTTP request header field.\n\n        Value is a positive number or 0. Setting it to 0 will allow unlimited\n        header field sizes.\n\n        .. warning::\n           Setting this parameter to a very high or unlimited value can open\n           up for DDOS attacks.\n        \"\"\""
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Reload(Setting):\n    name = \"reload\"\n    section = 'Debugging'\n    cli = ['--reload']\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n\n    desc = '''\\\n        Restart workers when code changes.\n\n        This setting is intended for development. It will cause workers to be\n        restarted whenever application code changes.\n\n        The reloader is incompatible with application preloading. When using a\n        paste configuration be sure that the server block does not import any\n        application code or the reload will not work as designed.\n\n        The default behavior is to attempt inotify with a fallback to file\n        system polling. Generally, inotify should be preferred if available\n        because it consumes less system resources.\n\n        .. note::\n           In order to use the inotify reloader, you must have the ``inotify``\n           package installed.\n        '''"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ReloadEngine(Setting):\n    name = \"reload_engine\"\n    section = \"Debugging\"\n    cli = [\"--reload-engine\"]\n    meta = \"STRING\"\n    validator = validate_reload_engine\n    default = \"auto\"\n    desc = \"\"\"\\\n        The implementation that should be used to power :ref:`reload`.\n\n        Valid engines are:\n\n        * ``'auto'``\n        * ``'poll'``\n        * ``'inotify'`` (requires inotify)\n\n        .. versionadded:: 19.7\n        \"\"\""
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ReloadExtraFiles(Setting):\n    name = \"reload_extra_files\"\n    action = \"append\"\n    section = \"Debugging\"\n    cli = [\"--reload-extra-file\"]\n    meta = \"FILES\"\n    validator = validate_list_of_existing_files\n    default = []\n    desc = \"\"\"\\\n        Extends :ref:`reload` option to also watch and reload on additional files\n        (e.g., templates, configurations, specifications, etc.).\n\n        .. versionadded:: 19.8\n        \"\"\""
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Spew(Setting):\n    name = \"spew\"\n    section = \"Debugging\"\n    cli = [\"--spew\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Install a trace function that spews every line executed by the server.\n\n        This is the nuclear option.\n        \"\"\""
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ConfigCheck(Setting):\n    name = \"check_config\"\n    section = \"Debugging\"\n    cli = [\"--check-config\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Check the configuration and exit. The exit status is 0 if the\n        configuration is correct, and 1 if the configuration is incorrect.\n        \"\"\""
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PrintConfig(Setting):\n    name = \"print_config\"\n    section = \"Debugging\"\n    cli = [\"--print-config\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Print the configuration settings as fully resolved. Implies :ref:`check-config`.\n        \"\"\""
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PreloadApp(Setting):\n    name = \"preload_app\"\n    section = \"Server Mechanics\"\n    cli = [\"--preload\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Load application code before the worker processes are forked.\n\n        By preloading an application you can save some RAM resources as well as\n        speed up server boot times. Although, if you defer application loading\n        to each worker process, you can reload your application code easily by\n        restarting workers.\n        \"\"\""
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Sendfile(Setting):\n    name = \"sendfile\"\n    section = \"Server Mechanics\"\n    cli = [\"--no-sendfile\"]\n    validator = validate_bool\n    action = \"store_const\"\n    const = False\n\n    desc = \"\"\"\\\n        Disables the use of ``sendfile()``.\n\n        If not set, the value of the ``SENDFILE`` environment variable is used\n        to enable or disable its usage.\n\n        .. versionadded:: 19.2\n        .. versionchanged:: 19.4\n           Swapped ``--sendfile`` with ``--no-sendfile`` to actually allow\n           disabling.\n        .. versionchanged:: 19.6\n           added support for the ``SENDFILE`` environment variable\n        \"\"\""
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ReusePort(Setting):\n    name = \"reuse_port\"\n    section = \"Server Mechanics\"\n    cli = [\"--reuse-port\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n\n    desc = \"\"\"\\\n        Set the ``SO_REUSEPORT`` flag on the listening socket.\n\n        .. versionadded:: 19.8\n        \"\"\""
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Chdir(Setting):\n    name = \"chdir\"\n    section = \"Server Mechanics\"\n    cli = [\"--chdir\"]\n    validator = validate_chdir\n    default = util.getcwd()\n    default_doc = \"``'.'``\"\n    desc = \"\"\"\\\n        Change directory to specified directory before loading apps.\n        \"\"\""
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Daemon(Setting):\n    name = \"daemon\"\n    section = \"Server Mechanics\"\n    cli = [\"-D\", \"--daemon\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Daemonize the Gunicorn process.\n\n        Detaches the server from the controlling terminal and enters the\n        background.\n        \"\"\""
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Env(Setting):\n    name = \"raw_env\"\n    action = \"append\"\n    section = \"Server Mechanics\"\n    cli = [\"-e\", \"--env\"]\n    meta = \"ENV\"\n    validator = validate_list_string\n    default = []\n\n    desc = \"\"\"\\\n        Set environment variables in the execution environment.\n\n        Should be a list of strings in the ``key=value`` format.\n\n        For example on the command line:\n\n        .. code-block:: console\n\n            $ gunicorn -b 127.0.0.1:8000 --env FOO=1 test:app\n\n        Or in the configuration file:\n\n        .. code-block:: python\n\n            raw_env = [\"FOO=1\"]\n        \"\"\""
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Pidfile(Setting):\n    name = \"pidfile\"\n    section = \"Server Mechanics\"\n    cli = [\"-p\", \"--pid\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A filename to use for the PID file.\n\n        If not set, no PID file will be written.\n        \"\"\""
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerTmpDir(Setting):\n    name = \"worker_tmp_dir\"\n    section = \"Server Mechanics\"\n    cli = [\"--worker-tmp-dir\"]\n    meta = \"DIR\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A directory to use for the worker heartbeat temporary file.\n\n        If not set, the default temporary directory will be used.\n\n        .. note::\n           The current heartbeat system involves calling ``os.fchmod`` on\n           temporary file handlers and may block a worker for arbitrary time\n           if the directory is on a disk-backed filesystem.\n\n           See :ref:`blocking-os-fchmod` for more detailed information\n           and a solution for avoiding this problem.\n        \"\"\""
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class User(Setting):\n    name = \"user\"\n    section = \"Server Mechanics\"\n    cli = [\"-u\", \"--user\"]\n    meta = \"USER\"\n    validator = validate_user\n    default = os.geteuid()\n    default_doc = \"``os.geteuid()``\"\n    desc = \"\"\"\\\n        Switch worker processes to run as this user.\n\n        A valid user id (as an integer) or the name of a user that can be\n        retrieved with a call to ``pwd.getpwnam(value)`` or ``None`` to not\n        change the worker process user.\n        \"\"\""
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Group(Setting):\n    name = \"group\"\n    section = \"Server Mechanics\"\n    cli = [\"-g\", \"--group\"]\n    meta = \"GROUP\"\n    validator = validate_group\n    default = os.getegid()\n    default_doc = \"``os.getegid()``\"\n    desc = \"\"\"\\\n        Switch worker process to run as this group.\n\n        A valid group id (as an integer) or the name of a user that can be\n        retrieved with a call to ``pwd.getgrnam(value)`` or ``None`` to not\n        change the worker processes group.\n        \"\"\""
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Umask(Setting):\n    name = \"umask\"\n    section = \"Server Mechanics\"\n    cli = [\"-m\", \"--umask\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = auto_int\n    default = 0\n    desc = \"\"\"\\\n        A bit mask for the file mode on files written by Gunicorn.\n\n        Note that this affects unix socket permissions.\n\n        A valid value for the ``os.umask(mode)`` call or a string compatible\n        with ``int(value, 0)`` (``0`` means Python guesses the base, so values\n        like ``0``, ``0xFF``, ``0022`` are valid for decimal, hex, and octal\n        representations)\n        \"\"\""
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Initgroups(Setting):\n    name = \"initgroups\"\n    section = \"Server Mechanics\"\n    cli = [\"--initgroups\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n\n    desc = \"\"\"\\\n        If true, set the worker process's group access list with all of the\n        groups of which the specified username is a member, plus the specified\n        group id.\n\n        .. versionadded:: 19.7\n        \"\"\""
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class TmpUploadDir(Setting):\n    name = \"tmp_upload_dir\"\n    section = \"Server Mechanics\"\n    meta = \"DIR\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        Directory to store temporary request data as they are read.\n\n        This may disappear in the near future.\n\n        This path should be writable by the process permissions set for Gunicorn\n        workers. If not specified, Gunicorn will choose a system generated\n        temporary directory.\n        \"\"\""
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SecureSchemeHeader(Setting):\n    name = \"secure_scheme_headers\"\n    section = \"Server Mechanics\"\n    validator = validate_dict\n    default = {\n        \"X-FORWARDED-PROTOCOL\": \"ssl\",\n        \"X-FORWARDED-PROTO\": \"https\",\n        \"X-FORWARDED-SSL\": \"on\"\n    }\n    desc = \"\"\"\\\n\n        A dictionary containing headers and values that the front-end proxy\n        uses to indicate HTTPS requests. If the source IP is permitted by\n        :ref:`forwarded-allow-ips` (below), *and* at least one request header matches\n        a key-value pair listed in this dictionary, then Gunicorn will set\n        ``wsgi.url_scheme`` to ``https``, so your application can tell that the\n        request is secure.\n\n        If the other headers listed in this dictionary are not present in the request, they will be ignored,\n        but if the other headers are present and do not match the provided values, then\n        the request will fail to parse. See the note below for more detailed examples of this behaviour.\n\n        The dictionary should map upper-case header names to exact string\n        values. The value comparisons are case-sensitive, unlike the header\n        names, so make sure they're exactly what your front-end proxy sends\n        when handling HTTPS requests.\n\n        It is important that your front-end proxy configuration ensures that\n        the headers defined here can not be passed directly from the client.\n        \"\"\""
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ForwardedAllowIPS(Setting):\n    name = \"forwarded_allow_ips\"\n    section = \"Server Mechanics\"\n    cli = [\"--forwarded-allow-ips\"]\n    meta = \"STRING\"\n    validator = validate_string_to_addr_list\n    default = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1,::1\")\n    desc = \"\"\"\\\n        Front-end's IPs from which allowed to handle set secure headers.\n        (comma separated).\n\n        Set to ``*`` to disable checking of front-end IPs. This is useful for setups\n        where you don't know in advance the IP address of front-end, but\n        instead have ensured via other means that only your\n        authorized front-ends can access Gunicorn.\n\n        By default, the value of the ``FORWARDED_ALLOW_IPS`` environment\n        variable. If it is not defined, the default is ``\"127.0.0.1,::1\"``.\n\n        .. note::\n\n            This option does not affect UNIX socket connections. Connections not associated with\n            an IP address are treated as allowed, unconditionally.\n\n        .. note::\n\n            The interplay between the request headers, the value of ``forwarded_allow_ips``, and the value of\n            ``secure_scheme_headers`` is complex. Various scenarios are documented below to further elaborate.\n            In each case, we have a request from the remote address 134.213.44.18, and the default value of\n            ``secure_scheme_headers``:\n\n            .. code::\n\n                secure_scheme_headers = {\n                    'X-FORWARDED-PROTOCOL': 'ssl',\n                    'X-FORWARDED-PROTO': 'https',\n                    'X-FORWARDED-SSL': 'on'\n                }\n\n\n            .. list-table::\n                :header-rows: 1\n                :align: center\n                :widths: auto\n\n                * - ``forwarded-allow-ips``\n                  - Secure Request Headers\n                  - Result\n                  - Explanation\n                * - .. code::\n\n                        [\"127.0.0.1\"]\n                  - .. code::\n\n                        X-Forwarded-Proto: https\n                  - .. code::\n\n                        wsgi.url_scheme = \"http\"\n                  - IP address was not allowed\n                * - .. code::\n\n                        \"*\"\n                  - <none>\n                  - .. code::\n\n                        wsgi.url_scheme = \"http\"\n                  - IP address allowed, but no secure headers provided\n                * - .. code::\n\n                        \"*\"\n                  - .. code::\n\n                        X-Forwarded-Proto: https\n                  - .. code::\n\n                        wsgi.url_scheme = \"https\"\n                  - IP address allowed, one request header matched\n                * - .. code::\n\n                        [\"134.213.44.18\"]\n                  - .. code::\n\n                        X-Forwarded-Ssl: on\n                        X-Forwarded-Proto: http\n                  - ``InvalidSchemeHeaders()`` raised\n                  - IP address allowed, but the two secure headers disagreed on if HTTPS was used\n\n\n        \"\"\""
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class AccessLog(Setting):\n    name = \"accesslog\"\n    section = \"Logging\"\n    cli = [\"--access-logfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        The Access log file to write to.\n\n        ``'-'`` means log to stdout.\n        \"\"\""
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class DisableRedirectAccessToSyslog(Setting):\n    name = \"disable_redirect_access_to_syslog\"\n    section = \"Logging\"\n    cli = [\"--disable-redirect-access-to-syslog\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n    Disable redirect access logs to syslog.\n\n    .. versionadded:: 19.8\n    \"\"\""
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class AccessLogFormat(Setting):\n    name = \"access_log_format\"\n    section = \"Logging\"\n    cli = [\"--access-logformat\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n    desc = \"\"\"\\\n        The access log format.\n\n        ===========  ===========\n        Identifier   Description\n        ===========  ===========\n        h            remote address\n        l            ``'-'``\n        u            user name (if HTTP Basic auth used)\n        t            date of the request\n        r            status line (e.g. ``GET / HTTP/1.1``)\n        m            request method\n        U            URL path without query string\n        q            query string\n        H            protocol\n        s            status\n        B            response length\n        b            response length or ``'-'`` (CLF format)\n        f            referrer (note: header is ``referer``)\n        a            user agent\n        T            request time in seconds\n        M            request time in milliseconds\n        D            request time in microseconds\n        L            request time in decimal seconds\n        p            process ID\n        {header}i    request header\n        {header}o    response header\n        {variable}e  environment variable\n        ===========  ===========\n\n        Use lowercase for header and environment variable names, and put\n        ``{...}x`` names inside ``%(...)s``. For example::\n\n            %({x-forwarded-for}i)s\n        \"\"\""
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ErrorLog(Setting):\n    name = \"errorlog\"\n    section = \"Logging\"\n    cli = [\"--error-logfile\", \"--log-file\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = '-'\n    desc = \"\"\"\\\n        The Error log file to write to.\n\n        Using ``'-'`` for FILE makes gunicorn log to stderr.\n\n        .. versionchanged:: 19.2\n           Log to stderr by default.\n\n        \"\"\""
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Loglevel(Setting):\n    name = \"loglevel\"\n    section = \"Logging\"\n    cli = [\"--log-level\"]\n    meta = \"LEVEL\"\n    validator = validate_string\n    default = \"info\"\n    desc = \"\"\"\\\n        The granularity of Error log outputs.\n\n        Valid level names are:\n\n        * ``'debug'``\n        * ``'info'``\n        * ``'warning'``\n        * ``'error'``\n        * ``'critical'``\n        \"\"\""
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class CaptureOutput(Setting):\n    name = \"capture_output\"\n    section = \"Logging\"\n    cli = [\"--capture-output\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n        Redirect stdout/stderr to specified file in :ref:`errorlog`.\n\n        .. versionadded:: 19.6\n        \"\"\""
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LoggerClass(Setting):\n    name = \"logger_class\"\n    section = \"Logging\"\n    cli = [\"--logger-class\"]\n    meta = \"STRING\"\n    validator = validate_class\n    default = \"gunicorn.glogging.Logger\"\n    desc = \"\"\"\\\n        The logger you want to use to log events in Gunicorn.\n\n        The default class (``gunicorn.glogging.Logger``) handles most\n        normal usages in logging. It provides error and access logging.\n\n        You can provide your own logger by giving Gunicorn a Python path to a\n        class that quacks like ``gunicorn.glogging.Logger``.\n        \"\"\""
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LogConfig(Setting):\n    name = \"logconfig\"\n    section = \"Logging\"\n    cli = [\"--log-config\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    The log config file to use.\n    Gunicorn uses the standard Python logging module's Configuration\n    file format.\n    \"\"\""
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LogConfigDict(Setting):\n    name = \"logconfig_dict\"\n    section = \"Logging\"\n    validator = validate_dict\n    default = {}\n    desc = \"\"\"\\\n    The log config dictionary to use, using the standard Python\n    logging module's dictionary configuration format. This option\n    takes precedence over the :ref:`logconfig` and :ref:`logconfig-json` options,\n    which uses the older file configuration format and JSON\n    respectively.\n\n    Format: https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig\n\n    For more context you can look at the default configuration dictionary for logging,\n    which can be found at ``gunicorn.glogging.CONFIG_DEFAULTS``.\n\n    .. versionadded:: 19.8\n    \"\"\""
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class LogConfigJson(Setting):\n    name = \"logconfig_json\"\n    section = \"Logging\"\n    cli = [\"--log-config-json\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    The log config to read config from a JSON file\n\n    Format: https://docs.python.org/3/library/logging.config.html#logging.config.jsonConfig\n\n    .. versionadded:: 20.0\n    \"\"\""
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SyslogTo(Setting):\n    name = \"syslog_addr\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-to\"]\n    meta = \"SYSLOG_ADDR\"\n    validator = validate_string\n\n    if PLATFORM == \"darwin\":\n        default = \"unix:///var/run/syslog\"\n    elif PLATFORM in ('freebsd', 'dragonfly', ):\n        default = \"unix:///var/run/log\"\n    elif PLATFORM == \"openbsd\":\n        default = \"unix:///dev/log\"\n    else:\n        default = \"udp://localhost:514\"\n\n    desc = \"\"\"\\\n    Address to send syslog messages.\n\n    Address is a string of the form:\n\n    * ``unix://PATH#TYPE`` : for unix domain socket. ``TYPE`` can be ``stream``\n      for the stream driver or ``dgram`` for the dgram driver.\n      ``stream`` is the default.\n    * ``udp://HOST:PORT`` : for UDP sockets\n    * ``tcp://HOST:PORT`` : for TCP sockets\n\n    \"\"\""
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Syslog(Setting):\n    name = \"syslog\"\n    section = \"Logging\"\n    cli = [\"--log-syslog\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n    Send *Gunicorn* logs to syslog.\n\n    .. versionchanged:: 19.8\n       You can now disable sending access logs by using the\n       :ref:`disable-redirect-access-to-syslog` setting.\n    \"\"\""
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SyslogPrefix(Setting):\n    name = \"syslog_prefix\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-prefix\"]\n    meta = \"SYSLOG_PREFIX\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    Makes Gunicorn use the parameter as program-name in the syslog entries.\n\n    All entries will be prefixed by ``gunicorn.<prefix>``. By default the\n    program name is the name of the process.\n    \"\"\""
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SyslogFacility(Setting):\n    name = \"syslog_facility\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-facility\"]\n    meta = \"SYSLOG_FACILITY\"\n    validator = validate_string\n    default = \"user\"\n    desc = \"\"\"\\\n    Syslog facility name\n    \"\"\""
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class EnableStdioInheritance(Setting):\n    name = \"enable_stdio_inheritance\"\n    section = \"Logging\"\n    cli = [\"-R\", \"--enable-stdio-inheritance\"]\n    validator = validate_bool\n    default = False\n    action = \"store_true\"\n    desc = \"\"\"\\\n    Enable stdio inheritance.\n\n    Enable inheritance for stdio file descriptors in daemon mode.\n\n    Note: To disable the Python stdout buffering, you can to set the user\n    environment variable ``PYTHONUNBUFFERED`` .\n    \"\"\""
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class StatsdHost(Setting):\n    name = \"statsd_host\"\n    section = \"Logging\"\n    cli = [\"--statsd-host\"]\n    meta = \"STATSD_ADDR\"\n    default = None\n    validator = validate_statsd_address\n    desc = \"\"\"\\\n    The address of the StatsD server to log to.\n\n    Address is a string of the form:\n\n    * ``unix://PATH`` : for a unix domain socket.\n    * ``HOST:PORT`` : for a network address\n\n    .. versionadded:: 19.1\n    \"\"\""
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class DogstatsdTags(Setting):\n    name = \"dogstatsd_tags\"\n    section = \"Logging\"\n    cli = [\"--dogstatsd-tags\"]\n    meta = \"DOGSTATSD_TAGS\"\n    default = \"\"\n    validator = validate_string\n    desc = \"\"\"\\\n    A comma-delimited list of datadog statsd (dogstatsd) tags to append to\n    statsd metrics.\n\n    .. versionadded:: 20\n    \"\"\""
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class StatsdPrefix(Setting):\n    name = \"statsd_prefix\"\n    section = \"Logging\"\n    cli = [\"--statsd-prefix\"]\n    meta = \"STATSD_PREFIX\"\n    default = \"\"\n    validator = validate_string\n    desc = \"\"\"\\\n    Prefix to use when emitting statsd metrics (a trailing ``.`` is added,\n    if not provided).\n\n    .. versionadded:: 19.2\n    \"\"\""
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Procname(Setting):\n    name = \"proc_name\"\n    section = \"Process Naming\"\n    cli = [\"-n\", \"--name\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A base to use with setproctitle for process naming.\n\n        This affects things like ``ps`` and ``top``. If you're going to be\n        running more than one instance of Gunicorn you'll probably want to set a\n        name to tell them apart. This requires that you install the setproctitle\n        module.\n\n        If not set, the *default_proc_name* setting will be used.\n        \"\"\""
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class DefaultProcName(Setting):\n    name = \"default_proc_name\"\n    section = \"Process Naming\"\n    validator = validate_string\n    default = \"gunicorn\"\n    desc = \"\"\"\\\n        Internal setting that is adjusted for each type of application.\n        \"\"\""
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PythonPath(Setting):\n    name = \"pythonpath\"\n    section = \"Server Mechanics\"\n    cli = [\"--pythonpath\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A comma-separated list of directories to add to the Python path.\n\n        e.g.\n        ``'/home/djangoprojects/myproject,/home/python/mylibrary'``.\n        \"\"\""
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Paste(Setting):\n    name = \"paste\"\n    section = \"Server Mechanics\"\n    cli = [\"--paste\", \"--paster\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        Load a PasteDeploy config file. The argument may contain a ``#``\n        symbol followed by the name of an app section from the config file,\n        e.g. ``production.ini#admin``.\n\n        At this time, using alternate server blocks is not supported. Use the\n        command line arguments to control server configuration instead.\n        \"\"\""
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class OnStarting(Setting):\n    name = \"on_starting\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def on_starting(server):\n        pass\n    default = staticmethod(on_starting)\n    desc = \"\"\"\\\n        Called just before the master process is initialized.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\""
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class OnReload(Setting):\n    name = \"on_reload\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def on_reload(server):\n        pass\n    default = staticmethod(on_reload)\n    desc = \"\"\"\\\n        Called to recycle workers during a reload via SIGHUP.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\""
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WhenReady(Setting):\n    name = \"when_ready\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def when_ready(server):\n        pass\n    default = staticmethod(when_ready)\n    desc = \"\"\"\\\n        Called just after the server is started.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\""
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Prefork(Setting):\n    name = \"pre_fork\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def pre_fork(server, worker):\n        pass\n    default = staticmethod(pre_fork)\n    desc = \"\"\"\\\n        Called just before a worker is forked.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        new Worker.\n        \"\"\""
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Postfork(Setting):\n    name = \"post_fork\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def post_fork(server, worker):\n        pass\n    default = staticmethod(post_fork)\n    desc = \"\"\"\\\n        Called just after a worker has been forked.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        new Worker.\n        \"\"\""
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PostWorkerInit(Setting):\n    name = \"post_worker_init\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def post_worker_init(worker):\n        pass\n\n    default = staticmethod(post_worker_init)\n    desc = \"\"\"\\\n        Called just after a worker has initialized the application.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\""
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerInt(Setting):\n    name = \"worker_int\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def worker_int(worker):\n        pass\n\n    default = staticmethod(worker_int)\n    desc = \"\"\"\\\n        Called just after a worker exited on SIGINT or SIGQUIT.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\""
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerAbort(Setting):\n    name = \"worker_abort\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def worker_abort(worker):\n        pass\n\n    default = staticmethod(worker_abort)\n    desc = \"\"\"\\\n        Called when a worker received the SIGABRT signal.\n\n        This call generally happens on timeout.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\""
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PreExec(Setting):\n    name = \"pre_exec\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n\n    def pre_exec(server):\n        pass\n    default = staticmethod(pre_exec)\n    desc = \"\"\"\\\n        Called just before a new master process is forked.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\""
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PreRequest(Setting):\n    name = \"pre_request\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def pre_request(worker, req):\n        worker.log.debug(\"%s %s\", req.method, req.path)\n    default = staticmethod(pre_request)\n    desc = \"\"\"\\\n        Called just before a worker processes the request.\n\n        The callable needs to accept two instance variables for the Worker and\n        the Request.\n        \"\"\""
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PostRequest(Setting):\n    name = \"post_request\"\n    section = \"Server Hooks\"\n    validator = validate_post_request\n    type = callable\n\n    def post_request(worker, req, environ, resp):\n        pass\n    default = staticmethod(post_request)\n    desc = \"\"\"\\\n        Called after a worker processes the request.\n\n        The callable needs to accept two instance variables for the Worker and\n        the Request.\n        \"\"\""
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ChildExit(Setting):\n    name = \"child_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def child_exit(server, worker):\n        pass\n    default = staticmethod(child_exit)\n    desc = \"\"\"\\\n        Called just after a worker has been exited, in the master process.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        the just-exited Worker.\n\n        .. versionadded:: 19.7\n        \"\"\""
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class WorkerExit(Setting):\n    name = \"worker_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def worker_exit(server, worker):\n        pass\n    default = staticmethod(worker_exit)\n    desc = \"\"\"\\\n        Called just after a worker has been exited, in the worker process.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        the just-exited Worker.\n        \"\"\""
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class NumWorkersChanged(Setting):\n    name = \"nworkers_changed\"\n    section = \"Server Hooks\"\n    validator = validate_callable(3)\n    type = callable\n\n    def nworkers_changed(server, new_value, old_value):\n        pass\n    default = staticmethod(nworkers_changed)\n    desc = \"\"\"\\\n        Called just after *num_workers* has been changed.\n\n        The callable needs to accept an instance variable of the Arbiter and\n        two integers of number of workers after and before change.\n\n        If the number of workers is set for the first time, *old_value* would\n        be ``None``.\n        \"\"\""
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class OnExit(Setting):\n    name = \"on_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n\n    def on_exit(server):\n        pass\n\n    default = staticmethod(on_exit)\n    desc = \"\"\"\\\n        Called just before exiting Gunicorn.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\""
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class NewSSLContext(Setting):\n    name = \"ssl_context\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n\n    def ssl_context(config, default_ssl_context_factory):\n        return default_ssl_context_factory()\n\n    default = staticmethod(ssl_context)\n    desc = \"\"\"\\\n        Called when SSLContext is needed.\n\n        Allows customizing SSL context.\n\n        The callable needs to accept an instance variable for the Config and\n        a factory function that returns default SSLContext which is initialized\n        with certificates, private key, cert_reqs, and ciphers according to\n        config and can be further customized by the callable.\n        The callable needs to return SSLContext object.\n\n        Following example shows a configuration file that sets the minimum TLS version to 1.3:\n\n        .. code-block:: python\n\n            def ssl_context(conf, default_ssl_context_factory):\n                import ssl\n                context = default_ssl_context_factory()\n                context.minimum_version = ssl.TLSVersion.TLSv1_3\n                return context\n\n        .. versionadded:: 21.0\n        \"\"\""
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ProxyProtocol(Setting):\n    name = \"proxy_protocol\"\n    section = \"Server Mechanics\"\n    cli = [\"--proxy-protocol\"]\n    validator = validate_bool\n    default = False\n    action = \"store_true\"\n    desc = \"\"\"\\\n        Enable detect PROXY protocol (PROXY mode).\n\n        Allow using HTTP and Proxy together. It may be useful for work with\n        stunnel as HTTPS frontend and Gunicorn as HTTP server.\n\n        PROXY protocol: http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt\n\n        Example for stunnel config::\n\n            [https]\n            protocol = proxy\n            accept  = 443\n            connect = 80\n            cert = /etc/ssl/certs/stunnel.pem\n            key = /etc/ssl/certs/stunnel.key\n        \"\"\""
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ProxyAllowFrom(Setting):\n    name = \"proxy_allow_ips\"\n    section = \"Server Mechanics\"\n    cli = [\"--proxy-allow-from\"]\n    validator = validate_string_to_addr_list\n    default = \"127.0.0.1,::1\"\n    desc = \"\"\"\\\n        Front-end's IPs from which allowed accept proxy requests (comma separated).\n\n        Set to ``*`` to disable checking of front-end IPs. This is useful for setups\n        where you don't know in advance the IP address of front-end, but\n        instead have ensured via other means that only your\n        authorized front-ends can access Gunicorn.\n\n        .. note::\n\n            This option does not affect UNIX socket connections. Connections not associated with\n            an IP address are treated as allowed, unconditionally.\n        \"\"\""
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class KeyFile(Setting):\n    name = \"keyfile\"\n    section = \"SSL\"\n    cli = [\"--keyfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL key file\n    \"\"\""
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class CertFile(Setting):\n    name = \"certfile\"\n    section = \"SSL\"\n    cli = [\"--certfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL certificate file\n    \"\"\""
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SSLVersion(Setting):\n    name = \"ssl_version\"\n    section = \"SSL\"\n    cli = [\"--ssl-version\"]\n    validator = validate_ssl_version\n\n    if hasattr(ssl, \"PROTOCOL_TLS\"):\n        default = ssl.PROTOCOL_TLS\n    else:\n        default = ssl.PROTOCOL_SSLv23\n\n    default = ssl.PROTOCOL_SSLv23\n    desc = \"\"\"\\\n    SSL version to use (see stdlib ssl module's).\n\n    .. deprecated:: 21.0\n       The option is deprecated and it is currently ignored. Use :ref:`ssl-context` instead.\n\n    ============= ============\n    --ssl-version Description\n    ============= ============\n    SSLv3         SSLv3 is not-secure and is strongly discouraged.\n    SSLv23        Alias for TLS. Deprecated in Python 3.6, use TLS.\n    TLS           Negotiate highest possible version between client/server.\n                  Can yield SSL. (Python 3.6+)\n    TLSv1         TLS 1.0\n    TLSv1_1       TLS 1.1 (Python 3.4+)\n    TLSv1_2       TLS 1.2 (Python 3.4+)\n    TLS_SERVER    Auto-negotiate the highest protocol version like TLS,\n                  but only support server-side SSLSocket connections.\n                  (Python 3.6+)\n    ============= ============\n\n    .. versionchanged:: 19.7\n       The default value has been changed from ``ssl.PROTOCOL_TLSv1`` to\n       ``ssl.PROTOCOL_SSLv23``.\n    .. versionchanged:: 20.0\n       This setting now accepts string names based on ``ssl.PROTOCOL_``\n       constants.\n    .. versionchanged:: 20.0.1\n       The default value has been changed from ``ssl.PROTOCOL_SSLv23`` to\n       ``ssl.PROTOCOL_TLS`` when Python >= 3.6 .\n    \"\"\""
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class CertReqs(Setting):\n    name = \"cert_reqs\"\n    section = \"SSL\"\n    cli = [\"--cert-reqs\"]\n    validator = validate_pos_int\n    default = ssl.CERT_NONE\n    desc = \"\"\"\\\n    Whether client certificate is required (see stdlib ssl module's)\n\n    ===========  ===========================\n    --cert-reqs      Description\n    ===========  ===========================\n    `0`          no client verification\n    `1`          ssl.CERT_OPTIONAL\n    `2`          ssl.CERT_REQUIRED\n    ===========  ===========================\n    \"\"\""
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class CACerts(Setting):\n    name = \"ca_certs\"\n    section = \"SSL\"\n    cli = [\"--ca-certs\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    CA certificates file\n    \"\"\""
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class SuppressRaggedEOFs(Setting):\n    name = \"suppress_ragged_eofs\"\n    section = \"SSL\"\n    cli = [\"--suppress-ragged-eofs\"]\n    action = \"store_true\"\n    default = True\n    validator = validate_bool\n    desc = \"\"\"\\\n    Suppress ragged EOFs (see stdlib ssl module's)\n    \"\"\""
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class DoHandshakeOnConnect(Setting):\n    name = \"do_handshake_on_connect\"\n    section = \"SSL\"\n    cli = [\"--do-handshake-on-connect\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n    Whether to perform SSL handshake on socket connect (see stdlib ssl module's)\n    \"\"\""
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class Ciphers(Setting):\n    name = \"ciphers\"\n    section = \"SSL\"\n    cli = [\"--ciphers\"]\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL Cipher suite to use, in the format of an OpenSSL cipher list.\n\n    By default we use the default cipher list from Python's ``ssl`` module,\n    which contains ciphers considered strong at the time of each Python\n    release.\n\n    As a recommended alternative, the Open Web App Security Project (OWASP)\n    offers `a vetted set of strong cipher strings rated A+ to C-\n    <https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet>`_.\n    OWASP provides details on user-agent compatibility at each security level.\n\n    See the `OpenSSL Cipher List Format Documentation\n    <https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT>`_\n    for details on the format of an OpenSSL cipher list.\n    \"\"\""
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PasteGlobalConf(Setting):\n    name = \"raw_paste_global_conf\"\n    action = \"append\"\n    section = \"Server Mechanics\"\n    cli = [\"--paste-global\"]\n    meta = \"CONF\"\n    validator = validate_list_string\n    default = []\n\n    desc = \"\"\"\\\n        Set a PasteDeploy global config variable in ``key=value`` form.\n\n        The option can be specified multiple times.\n\n        The variables are passed to the PasteDeploy entrypoint. Example::\n\n            $ gunicorn -b 127.0.0.1:8000 --paste development.ini --paste-global FOO=1 --paste-global BAR=2\n\n        .. versionadded:: 19.7\n        \"\"\""
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PermitObsoleteFolding(Setting):\n    name = \"permit_obsolete_folding\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-obsolete-folding\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit requests employing obsolete HTTP line folding mechanism\n\n        The folding mechanism was deprecated by rfc7230 Section 3.2.4 and will not be\n         employed in HTTP request headers from standards-compliant HTTP clients.\n\n        This option is provided to diagnose backwards-incompatible changes.\n        Use with care and only if necessary. Temporary; the precise effect of this option may\n        change in a future version, or it may be removed altogether.\n\n        .. versionadded:: 23.0.0\n        \"\"\""
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class StripHeaderSpaces(Setting):\n    name = \"strip_header_spaces\"\n    section = \"Server Mechanics\"\n    cli = [\"--strip-header-spaces\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Strip spaces present between the header name and the the ``:``.\n\n        This is known to induce vulnerabilities and is not compliant with the HTTP/1.1 standard.\n        See https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn.\n\n        Use with care and only if necessary. Deprecated; scheduled for removal in 25.0.0\n\n        .. versionadded:: 20.0.1\n        \"\"\""
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PermitUnconventionalHTTPMethod(Setting):\n    name = \"permit_unconventional_http_method\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-unconventional-http-method\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit HTTP methods not matching conventions, such as IANA registration guidelines\n\n        This permits request methods of length less than 3 or more than 20,\n        methods with lowercase characters or methods containing the # character.\n        HTTP methods are case sensitive by definition, and merely uppercase by convention.\n\n        If unset, Gunicorn will apply nonstandard restrictions and cause 400 response status\n        in cases where otherwise 501 status is expected. While this option does modify that\n        behaviour, it should not be depended upon to guarantee standards-compliant behaviour.\n        Rather, it is provided temporarily, to assist in diagnosing backwards-incompatible\n        changes around the incomplete application of those restrictions.\n\n        Use with care and only if necessary. Temporary; scheduled for removal in 24.0.0\n\n        .. versionadded:: 22.0.0\n        \"\"\""
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class PermitUnconventionalHTTPVersion(Setting):\n    name = \"permit_unconventional_http_version\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-unconventional-http-version\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit HTTP version not matching conventions of 2023\n\n        This disables the refusal of likely malformed request lines.\n        It is unusual to specify HTTP 1 versions other than 1.0 and 1.1.\n\n        This option is provided to diagnose backwards-incompatible changes.\n        Use with care and only if necessary. Temporary; the precise effect of this option may\n        change in a future version, or it may be removed altogether.\n\n        .. versionadded:: 22.0.0\n        \"\"\""
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class CasefoldHTTPMethod(Setting):\n    name = \"casefold_http_method\"\n    section = \"Server Mechanics\"\n    cli = [\"--casefold-http-method\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n         Transform received HTTP methods to uppercase\n\n         HTTP methods are case sensitive by definition, and merely uppercase by convention.\n\n         This option is provided because previous versions of gunicorn defaulted to this behaviour.\n\n         Use with care and only if necessary. Deprecated; scheduled for removal in 24.0.0\n\n         .. versionadded:: 22.0.0\n         \"\"\""
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "def validate_header_map_behaviour(val):\n    # FIXME: refactor all of this subclassing stdlib argparse\n\n    if val is None:\n        return\n\n    if not isinstance(val, str):\n        raise TypeError(\"Invalid type for casting: %s\" % val)\n    if val.lower().strip() == \"drop\":\n        return \"drop\"\n    elif val.lower().strip() == \"refuse\":\n        return \"refuse\"\n    elif val.lower().strip() == \"dangerous\":\n        return \"dangerous\"\n    else:\n        raise ValueError(\"Invalid header map behaviour: %s\" % val)"
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/gunicorn/gunicorn/config.py",
      "content": "class ForwarderHeaders(Setting):\n    name = \"forwarder_headers\"\n    section = \"Server Mechanics\"\n    cli = [\"--forwarder-headers\"]\n    validator = validate_string_to_list\n    default = \"SCRIPT_NAME,PATH_INFO\"\n    desc = \"\"\"\\\n\n        A list containing upper-case header field names that the front-end proxy\n        (see :ref:`forwarded-allow-ips`) sets, to be used in WSGI environment.\n\n        This option has no effect for"
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "import errno\nimport os\nimport random\nimport select\nimport signal\nimport sys\nimport time\nimport traceback\nimport socket\n\nfrom gunicorn.errors import HaltServer, AppImportError\nfrom gunicorn.pidfile import Pidfile\nfrom gunicorn import sock, systemd, util\n\nfrom gunicorn import __version__, SERVER_SOFTWARE"
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "class Arbiter:\n    \"\"\"\n    Arbiter maintain the workers processes alive. It launches or\n    kills them if needed. It also manages application reloading\n    via SIGHUP/USR2.\n    \"\"\"\n\n    # A flag indicating if a worker failed to\n    # to boot. If a worker process exist with\n    # this error code, the arbiter will terminate.\n    WORKER_BOOT_ERROR = 3\n\n    # A flag indicating if an application failed to be loaded\n    APP_LOAD_ERROR = 4\n\n    START_CTX = {}\n\n    LISTENERS = []\n    WORKERS = {}\n    PIPE = []\n\n    # I love dynamic languages\n    SIG_QUEUE = []\n    SIGNALS = [getattr(signal, \"SIG%s\" % x)\n               for x in \"HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH\".split()]\n    SIG_NAMES = dict(\n        (getattr(signal, name), name[3:].lower()) for name in dir(signal)\n        if name[:3] == \"SIG\" and name[3] != \"_\"\n    )"
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def __init__(self, app):\n        os.environ[\"SERVER_SOFTWARE\"] = SERVER_SOFTWARE\n\n        self._num_workers = None\n        self._last_logged_active_worker_count = None\n        self.log = None\n\n        self.setup(app)\n\n        self.pidfile = None\n        self.systemd = False\n        self.worker_age = 0\n        self.reexec_pid = 0\n        self.master_pid = 0\n        self.master_name = \"Master\"\n\n        cwd = util.getcwd()\n\n        args = sys.argv[:]\n        args.insert(0, sys.executable)\n\n        # init start context\n        self.START_CTX = {\n            \"args\": args,\n            \"cwd\": cwd,\n            0: sys.executable\n        }"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def _get_num_workers(self):\n        return self._num_workers\n\n    def _set_num_workers(self, value):\n        old_value = self._num_workers\n        self._num_workers = value\n        self.cfg.nworkers_changed(self, value, old_value)\n    num_workers = property(_get_num_workers, _set_num_workers)"
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def setup(self, app):\n        self.app = app\n        self.cfg = app.cfg\n\n        if self.log is None:\n            self.log = self.cfg.logger_class(app.cfg)\n\n        # reopen files\n        if 'GUNICORN_PID' in os.environ:\n            self.log.reopen_files()\n\n        self.worker_class = self.cfg.worker_class\n        self.address = self.cfg.address\n        self.num_workers = self.cfg.workers\n        self.timeout = self.cfg.timeout\n        self.proc_name = self.cfg.proc_name\n\n        self.log.debug('Current configuration:\\n{0}'.format(\n            '\\n'.join(\n                '  {0}: {1}'.format(config, value.value)\n                for config, value\n                in sorted(self.cfg.settings.items(),\n                          key=lambda setting: setting[1]))))\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        if self.cfg.preload_app:\n            self.app.wsgi()"
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def start(self):\n        \"\"\"\\\n        Initialize the arbiter. Start listening and set pidfile if needed.\n        \"\"\"\n        self.log.info(\"Starting gunicorn %s\", __version__)\n\n        if 'GUNICORN_PID' in os.environ:\n            self.master_pid = int(os.environ.get('GUNICORN_PID'))\n            self.proc_name = self.proc_name + \".2\"\n            self.master_name = \"Master.2\"\n\n        self.pid = os.getpid()\n        if self.cfg.pidfile is not None:\n            pidname = self.cfg.pidfile\n            if self.master_pid != 0:\n                pidname += \".2\"\n            self.pidfile = Pidfile(pidname)\n            self.pidfile.create(self.pid)\n        self.cfg.on_starting(self)\n\n        self.init_signals()\n\n        if not self.LISTENERS:\n            fds = None\n            listen_fds = systemd.listen_fds()\n            if listen_fds:\n                self.systemd = True\n                fds = range(systemd.SD_LISTEN_FDS_START,\n                            systemd.SD_LISTEN_FDS_START + listen_fds)\n\n            elif self.master_pid:\n                fds = []\n                for fd in os.environ.pop('GUNICORN_FD').split(','):\n                    fds.append(int(fd))\n\n            if not (self.cfg.reuse_port and hasattr(socket, 'SO_REUSEPORT')):\n                self.LISTENERS = sock.create_sockets(self.cfg, self.log, fds)\n\n        listeners_str = \",\".join([str(lnr) for lnr in self.LISTENERS])\n        self.log.debug(\"Arbiter booted\")\n        self.log.info(\"Listening at: %s (%s)\", listeners_str, self.pid)\n        self.log.info(\"Using worker: %s\", self.cfg.worker_class_str)\n        systemd.sd_notify(\"READY=1\\nSTATUS=Gunicorn arbiter booted\", self.log)\n\n        # check worker class requirements\n        if hasattr(self.worker_class, \"check_config\"):\n            self.worker_class.check_config(self.cfg, self.log)\n\n        self.cfg.when_ready(self)"
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def init_signals(self):\n        \"\"\"\\\n        Initialize master signal handling. Most of the signals\n        are queued. Child signals only wake up the master.\n        \"\"\"\n        # close old PIPE\n        for p in self.PIPE:\n            os.close(p)\n\n        # initialize the pipe\n        self.PIPE = pair = os.pipe()\n        for p in pair:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        self.log.close_on_exec()\n\n        # initialize all signals\n        for s in self.SIGNALS:\n            signal.signal(s, self.signal)\n        signal.signal(signal.SIGCHLD, self.handle_chld)"
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def signal(self, sig, frame):\n        if len(self.SIG_QUEUE) < 5:\n            self.SIG_QUEUE.append(sig)\n            self.wakeup()"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def run(self):\n        \"Main master loop.\"\n        self.start()\n        util._setproctitle(\"master [%s]\" % self.proc_name)\n\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None\n                if sig is None:\n                    self.sleep()\n                    self.murder_workers()\n                    self.manage_workers()\n                    continue\n\n                if sig not in self.SIG_NAMES:\n                    self.log.info(\"Ignoring unknown signal: %s\", sig)\n                    continue\n\n                signame = self.SIG_NAMES.get(sig)\n                handler = getattr(self, \"handle_%s\" % signame, None)\n                if not handler:\n                    self.log.error(\"Unhandled signal: %s\", signame)\n                    continue\n                self.log.info(\"Handling signal: %s\", signame)\n                handler()\n                self.wakeup()\n        except (StopIteration, KeyboardInterrupt):\n            self.halt()\n        except HaltServer as inst:\n            self.halt(reason=inst.reason, exit_status=inst.exit_status)\n        except SystemExit:\n            raise\n        except Exception:\n            self.log.error(\"Unhandled exception in main loop\",\n                           exc_info=True)\n            self.stop(False)\n            if self.pidfile is not None:\n                self.pidfile.unlink()\n            sys.exit(-1)"
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_chld(self, sig, frame):\n        \"SIGCHLD handling\"\n        self.reap_workers()\n        self.wakeup()"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_hup(self):\n        \"\"\"\\\n        HUP handling.\n        - Reload configuration\n        - Start the new worker processes with a new configuration\n        - Gracefully shutdown the old worker processes\n        \"\"\"\n        self.log.info(\"Hang up: %s\", self.master_name)\n        self.reload()"
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_term(self):\n        \"SIGTERM handling\"\n        raise StopIteration"
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_int(self):\n        \"SIGINT handling\"\n        self.stop(False)\n        raise StopIteration"
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_quit(self):\n        \"SIGQUIT handling\"\n        self.stop(False)\n        raise StopIteration"
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_ttin(self):\n        \"\"\"\\\n        SIGTTIN handling.\n        Increases the number of workers by one.\n        \"\"\"\n        self.num_workers += 1\n        self.manage_workers()"
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_ttou(self):\n        \"\"\"\\\n        SIGTTOU handling.\n        Decreases the number of workers by one.\n        \"\"\"\n        if self.num_workers <= 1:\n            return\n        self.num_workers -= 1\n        self.manage_workers()"
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_usr1(self):\n        \"\"\"\\\n        SIGUSR1 handling.\n        Kill all workers by sending them a SIGUSR1\n        \"\"\"\n        self.log.reopen_files()\n        self.kill_workers(signal.SIGUSR1)"
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_usr2(self):\n        \"\"\"\\\n        SIGUSR2 handling.\n        Creates a new arbiter/worker set as a fork of the current\n        arbiter without affecting old workers. Use this to do live\n        deployment with the ability to backout a change.\n        \"\"\"\n        self.reexec()"
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def handle_winch(self):\n        \"\"\"SIGWINCH handling\"\"\"\n        if self.cfg.daemon:\n            self.log.info(\"graceful stop of workers\")\n            self.num_workers = 0\n            self.kill_workers(signal.SIGTERM)\n        else:\n            self.log.debug(\"SIGWINCH ignored. Not daemonized\")"
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def maybe_promote_master(self):\n        if self.master_pid == 0:\n            return\n\n        if self.master_pid != os.getppid():\n            self.log.info(\"Master has been promoted.\")\n            # reset master infos\n            self.master_name = \"Master\"\n            self.master_pid = 0\n            self.proc_name = self.cfg.proc_name\n            del os.environ['GUNICORN_PID']\n            # rename the pidfile\n            if self.pidfile is not None:\n                self.pidfile.rename(self.cfg.pidfile)\n            # reset proctitle\n            util._setproctitle(\"master [%s]\" % self.proc_name)"
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def wakeup(self):\n        \"\"\"\\\n        Wake up the arbiter by writing to the PIPE\n        \"\"\"\n        try:\n            os.write(self.PIPE[1], b'.')\n        except OSError as e:\n            if e.errno not in [errno.EAGAIN, errno.EINTR]:\n                raise"
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def halt(self, reason=None, exit_status=0):\n        \"\"\" halt arbiter \"\"\"\n        self.stop()\n\n        log_func = self.log.info if exit_status == 0 else self.log.error\n        log_func(\"Shutting down: %s\", self.master_name)\n        if reason is not None:\n            log_func(\"Reason: %s\", reason)\n\n        if self.pidfile is not None:\n            self.pidfile.unlink()\n        self.cfg.on_exit(self)\n        sys.exit(exit_status)"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def sleep(self):\n        \"\"\"\\\n        Sleep until PIPE is readable or we timeout.\n        A readable PIPE means a signal occurred.\n        \"\"\"\n        try:\n            ready = select.select([self.PIPE[0]], [], [], 1.0)\n            if not ready[0]:\n                return\n            while os.read(self.PIPE[0], 1):\n                pass\n        except OSError as e:\n            # TODO: select.error is a subclass of OSError since Python 3.3.\n            error_number = getattr(e, 'errno', e.args[0])\n            if error_number not in [errno.EAGAIN, errno.EINTR]:\n                raise\n        except KeyboardInterrupt:\n            sys.exit()"
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def stop(self, graceful=True):\n        \"\"\"\\\n        Stop workers\n\n        :attr graceful: boolean, If True (the default) workers will be\n        killed gracefully  (ie. trying to wait for the current connection)\n        \"\"\"\n        unlink = (\n            self.reexec_pid == self.master_pid == 0\n            and not self.systemd\n            and not self.cfg.reuse_port\n        )\n        sock.close_sockets(self.LISTENERS, unlink)\n\n        self.LISTENERS = []\n        sig = signal.SIGTERM\n        if not graceful:\n            sig = signal.SIGQUIT\n        limit = time.time() + self.cfg.graceful_timeout\n        # instruct the workers to exit\n        self.kill_workers(sig)\n        # wait until the graceful timeout\n        while self.WORKERS and time.time() < limit:\n            time.sleep(0.1)\n\n        self.kill_workers(signal.SIGKILL)"
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def reexec(self):\n        \"\"\"\\\n        Relaunch the master and workers.\n        \"\"\"\n        if self.reexec_pid != 0:\n            self.log.warning(\"USR2 signal ignored. Child exists.\")\n            return\n\n        if self.master_pid != 0:\n            self.log.warning(\"USR2 signal ignored. Parent exists.\")\n            return\n\n        master_pid = os.getpid()\n        self.reexec_pid = os.fork()\n        if self.reexec_pid != 0:\n            return\n\n        self.cfg.pre_exec(self)\n\n        environ = self.cfg.env_orig.copy()\n        environ['GUNICORN_PID'] = str(master_pid)\n\n        if self.systemd:\n            environ['LISTEN_PID'] = str(os.getpid())\n            environ['LISTEN_FDS'] = str(len(self.LISTENERS))\n        else:\n            environ['GUNICORN_FD'] = ','.join(\n                str(lnr.fileno()) for lnr in self.LISTENERS)\n\n        os.chdir(self.START_CTX['cwd'])\n\n        # exec the process using the original environment\n        os.execvpe(self.START_CTX[0], self.START_CTX['args'], environ)"
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def reload(self):\n        old_address = self.cfg.address\n\n        # reset old environment\n        for k in self.cfg.env:\n            if k in self.cfg.env_orig:\n                # reset the key to the value it had before\n                # we launched gunicorn\n                os.environ[k] = self.cfg.env_orig[k]\n            else:\n                # delete the value set by gunicorn\n                try:\n                    del os.environ[k]\n                except KeyError:\n                    pass\n\n        # reload conf\n        self.app.reload()\n        self.setup(self.app)\n\n        # reopen log files\n        self.log.reopen_files()\n\n        # do we need to change listener ?\n        if old_address != self.cfg.address:\n            # close all listeners\n            for lnr in self.LISTENERS:\n                lnr.close()\n            # init new listeners\n            self.LISTENERS = sock.create_sockets(self.cfg, self.log)\n            listeners_str = \",\".join([str(lnr) for lnr in self.LISTENERS])\n            self.log.info(\"Listening at: %s\", listeners_str)\n\n        # do some actions on reload\n        self.cfg.on_reload(self)\n\n        # unlink pidfile\n        if self.pidfile is not None:\n            self.pidfile.unlink()\n\n        # create new pidfile\n        if self.cfg.pidfile is not None:\n            self.pidfile = Pidfile(self.cfg.pidfile)\n            self.pidfile.create(self.pid)\n\n        # set new proc_name\n        util._setproctitle(\"master [%s]\" % self.proc_name)\n\n        # spawn new workers\n        for _ in range(self.cfg.workers):\n            self.spawn_worker()\n\n        # manage workers\n        self.manage_workers()"
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def murder_workers(self):\n        \"\"\"\\\n        Kill unused/idle workers\n        \"\"\"\n        if not self.timeout:\n            return\n        workers = list(self.WORKERS.items())\n        for (pid, worker) in workers:\n            try:\n                if time.monotonic() - worker.tmp.last_update() <= self.timeout:\n                    continue\n            except (OSError, ValueError):\n                continue\n\n            if not worker.aborted:\n                self.log.critical(\"WORKER TIMEOUT (pid:%s)\", pid)\n                worker.aborted = True\n                self.kill_worker(pid, signal.SIGABRT)\n            else:\n                self.kill_worker(pid, signal.SIGKILL)"
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def reap_workers(self):\n        \"\"\"\\\n        Reap workers to avoid zombie processes\n        \"\"\"\n        try:\n            while True:\n                wpid, status = os.waitpid(-1, os.WNOHANG)\n                if not wpid:\n                    break\n                if self.reexec_pid == wpid:\n                    self.reexec_pid = 0\n                else:\n                    # A worker was terminated. If the termination reason was\n                    # that it could not boot, we'll shut it down to avoid\n                    # infinite start/stop cycles.\n                    exitcode = status >> 8\n                    if exitcode != 0:\n                        self.log.error('Worker (pid:%s) exited with code %s', wpid, exitcode)\n                    if exitcode == self.WORKER_BOOT_ERROR:\n                        reason = \"Worker failed to boot.\"\n                        raise HaltServer(reason, self.WORKER_BOOT_ERROR)\n                    if exitcode == self.APP_LOAD_ERROR:\n                        reason = \"App failed to load.\"\n                        raise HaltServer(reason, self.APP_LOAD_ERROR)\n\n                    if exitcode > 0:\n                        # If the exit code of the worker is greater than 0,\n                        # let the user know.\n                        self.log.error(\"Worker (pid:%s) exited with code %s.\",\n                                       wpid, exitcode)\n                    elif status > 0:\n                        # If the exit code of the worker is 0 and the status\n                        # is greater than 0, then it was most likely killed\n                        # via a signal.\n                        try:\n                            sig_name = signal.Signals(status).name\n                        except ValueError:\n                            sig_name = \"code {}\".format(status)\n                        msg = \"Worker (pid:{}) was sent {}!\".format(\n                            wpid, sig_name)\n\n                        # Additional hint for SIGKILL\n                        if status == signal.SIGKILL:\n                            msg += \" Perhaps out of memory?\"\n                        self.log.error(msg)\n\n                    worker = self.WORKERS.pop(wpid, None)\n                    if not worker:\n                        continue\n                    worker.tmp.close()\n                    self.cfg.child_exit(self, worker)\n        except OSError as e:\n            if e.errno != errno.ECHILD:\n                raise"
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def manage_workers(self):\n        \"\"\"\\\n        Maintain the number of workers by spawning or killing\n        as required.\n        \"\"\"\n        if len(self.WORKERS) < self.num_workers:\n            self.spawn_workers()\n\n        workers = self.WORKERS.items()\n        workers = sorted(workers, key=lambda w: w[1].age)\n        while len(workers) > self.num_workers:\n            (pid, _) = workers.pop(0)\n            self.kill_worker(pid, signal.SIGTERM)\n\n        active_worker_count = len(workers)\n        if self._last_logged_active_worker_count != active_worker_count:\n            self._last_logged_active_worker_count = active_worker_count\n            self.log.debug(\"{0} workers\".format(active_worker_count),\n                           extra={\"metric\": \"gunicorn.workers\",\n                                  \"value\": active_worker_count,\n                                  \"mtype\": \"gauge\"})"
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def spawn_worker(self):\n        self.worker_age += 1\n        worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,\n                                   self.app, self.timeout / 2.0,\n                                   self.cfg, self.log)\n        self.cfg.pre_fork(self, worker)\n        pid = os.fork()\n        if pid != 0:\n            worker.pid = pid\n            self.WORKERS[pid] = worker\n            return pid\n\n        # Do not inherit the temporary files of other workers\n        for sibling in self.WORKERS.values():\n            sibling.tmp.close()\n\n        # Process Child\n        worker.pid = os.getpid()\n        try:\n            util._setproctitle(\"worker [%s]\" % self.proc_name)\n            self.log.info(\"Booting worker with pid: %s\", worker.pid)\n            if self.cfg.reuse_port:\n                worker.sockets = sock.create_sockets(self.cfg, self.log)\n            self.cfg.post_fork(self, worker)\n            worker.init_process()\n            sys.exit(0)\n        except SystemExit:\n            raise\n        except AppImportError as e:\n            self.log.debug(\"Exception while loading the application\",\n                           exc_info=True)\n            print(\"%s\" % e, file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(self.APP_LOAD_ERROR)\n        except Exception:\n            self.log.exception(\"Exception in worker process\")\n            if not worker.booted:\n                sys.exit(self.WORKER_BOOT_ERROR)\n            sys.exit(-1)\n        finally:\n            self.log.info(\"Worker exiting (pid: %s)\", worker.pid)\n            try:\n                worker.tmp.close()\n                self.cfg.worker_exit(self, worker)\n            except Exception:\n                self.log.warning(\"Exception during worker exit:\\n%s\",\n                                 traceback.format_exc())"
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def spawn_workers(self):\n        \"\"\"\\\n        Spawn new workers as needed.\n\n        This is where a worker process leaves the main loop\n        of the master process.\n        \"\"\"\n\n        for _ in range(self.num_workers - len(self.WORKERS)):\n            self.spawn_worker()\n            time.sleep(0.1 * random.random())"
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def kill_workers(self, sig):\n        \"\"\"\\\n        Kill all workers with the signal `sig`\n        :attr sig: `signal.SIG*` value\n        \"\"\"\n        worker_pids = list(self.WORKERS.keys())\n        for pid in worker_pids:\n            self.kill_worker(pid, sig)"
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/gunicorn/gunicorn/arbiter.py",
      "content": "def kill_worker(self, pid, sig):\n        \"\"\"\\\n        Kill a worker\n\n        :attr pid: int, worker pid\n        :attr sig: `signal.SIG*` value\n         \"\"\"\n        try:\n            os.kill(pid, sig)\n        except OSError as e:\n            if e.errno == errno.ESRCH:\n                try:\n                    worker = self.WORKERS.pop(pid)\n                    worker.tmp.close()\n                    self.cfg.worker_exit(self, worker)\n                    return\n                except (KeyError, OSError):\n                    return\n            raise"
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/gunicorn/gunicorn/errors.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/gunicorn/gunicorn/errors.py",
      "content": "# We don't need to call super() in __init__ methods of our\n# BaseException and Exception classes because we also define\n# our own __str__ methods so there is no need to pass 'message'\n# to the base class to get a meaningful output from 'str(exc)'.\n# pylint: disable=super-init-not-called"
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/gunicorn/gunicorn/errors.py",
      "content": "# we inherit from BaseException here to make sure to not be caught\n# at application level\nclass HaltServer(BaseException):\n    def __init__(self, reason, exit_status=1):\n        self.reason = reason\n        self.exit_status = exit_status\n\n    def __str__(self):\n        return \"<HaltServer %r %d>\" % (self.reason, self.exit_status)"
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/gunicorn/gunicorn/errors.py",
      "content": "class ConfigError(Exception):\n    \"\"\" Exception raised on config error \"\"\""
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/gunicorn/gunicorn/errors.py",
      "content": "class AppImportError(Exception):\n    \"\"\" Exception raised when loading an application \"\"\""
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "import logging\nimport socket\nfrom re import sub\n\nfrom gunicorn.glogging import Logger\n\n# Instrumentation constants\nMETRIC_VAR = \"metric\"\nVALUE_VAR = \"value\"\nMTYPE_VAR = \"mtype\"\nGAUGE_TYPE = \"gauge\"\nCOUNTER_TYPE = \"counter\"\nHISTOGRAM_TYPE = \"histogram\""
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "class Statsd(Logger):\n    \"\"\"statsD-based instrumentation, that passes as a logger\n    \"\"\"\n    def __init__(self, cfg):\n        Logger.__init__(self, cfg)\n        self.prefix = sub(r\"^(.+[^.]+)\\.*$\", \"\\\\g<1>.\", cfg.statsd_prefix)\n\n        if isinstance(cfg.statsd_host, str):\n            address_family = socket.AF_UNIX\n        else:\n            address_family = socket.AF_INET\n\n        try:\n            self.sock = socket.socket(address_family, socket.SOCK_DGRAM)\n            self.sock.connect(cfg.statsd_host)\n        except Exception:\n            self.sock = None\n\n        self.dogstatsd_tags = cfg.dogstatsd_tags"
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "# Log errors and warnings\n    def critical(self, msg, *args, **kwargs):\n        Logger.critical(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.critical\", 1)"
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def error(self, msg, *args, **kwargs):\n        Logger.error(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.error\", 1)"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def warning(self, msg, *args, **kwargs):\n        Logger.warning(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.warning\", 1)"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def exception(self, msg, *args, **kwargs):\n        Logger.exception(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.exception\", 1)"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "# Special treatment for info, the most common log level\n    def info(self, msg, *args, **kwargs):\n        self.log(logging.INFO, msg, *args, **kwargs)"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "# skip the run-of-the-mill logs\n    def debug(self, msg, *args, **kwargs):\n        self.log(logging.DEBUG, msg, *args, **kwargs)"
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def log(self, lvl, msg, *args, **kwargs):\n        \"\"\"Log a given statistic if metric, value and type are present\n        \"\"\"\n        try:\n            extra = kwargs.get(\"extra\", None)\n            if extra is not None:\n                metric = extra.get(METRIC_VAR, None)\n                value = extra.get(VALUE_VAR, None)\n                typ = extra.get(MTYPE_VAR, None)\n                if metric and value and typ:\n                    if typ == GAUGE_TYPE:\n                        self.gauge(metric, value)\n                    elif typ == COUNTER_TYPE:\n                        self.increment(metric, value)\n                    elif typ == HISTOGRAM_TYPE:\n                        self.histogram(metric, value)\n                    else:\n                        pass\n\n            # Log to parent logger only if there is something to say\n            if msg:\n                Logger.log(self, lvl, msg, *args, **kwargs)\n        except Exception:\n            Logger.warning(self, \"Failed to log to statsd\", exc_info=True)"
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "# access logging\n    def access(self, resp, req, environ, request_time):\n        \"\"\"Measure request duration\n        request_time is a datetime.timedelta\n        \"\"\"\n        Logger.access(self, resp, req, environ, request_time)\n        duration_in_ms = request_time.seconds * 1000 + float(request_time.microseconds) / 10 ** 3\n        status = resp.status\n        if isinstance(status, bytes):\n            status = status.decode('utf-8')\n        if isinstance(status, str):\n            status = int(status.split(None, 1)[0])\n        self.histogram(\"gunicorn.request.duration\", duration_in_ms)\n        self.increment(\"gunicorn.requests\", 1)\n        self.increment(\"gunicorn.request.status.%d\" % status, 1)"
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "# statsD methods\n    # you can use those directly if you want\n    def gauge(self, name, value):\n        self._sock_send(\"{0}{1}:{2}|g\".format(self.prefix, name, value))"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def increment(self, name, value, sampling_rate=1.0):\n        self._sock_send(\"{0}{1}:{2}|c|@{3}\".format(self.prefix, name, value, sampling_rate))"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def decrement(self, name, value, sampling_rate=1.0):\n        self._sock_send(\"{0}{1}:-{2}|c|@{3}\".format(self.prefix, name, value, sampling_rate))"
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def histogram(self, name, value):\n        self._sock_send(\"{0}{1}:{2}|ms\".format(self.prefix, name, value))"
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/gunicorn/gunicorn/instrument/statsd.py",
      "content": "def _sock_send(self, msg):\n        try:\n            if isinstance(msg, str):\n                msg = msg.encode(\"ascii\")\n\n            # http://docs.datadoghq.com/guides/dogstatsd/#datagram-format\n            if self.dogstatsd_tags:\n                msg = msg + b\"|#\" + self.dogstatsd_tags.encode('ascii')\n\n            if self.sock:\n                self.sock.send(msg)\n        except Exception:\n            Logger.warning(self, \"Error sending message to statsd\", exc_info=True)"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/__init__.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/__init__.py",
      "content": "from gunicorn.http.message import Message, Request\nfrom gunicorn.http.parser import RequestParser"
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/__init__.py",
      "content": "__all__ = ['Message', 'Request', 'RequestParser']"
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "import io\nimport logging\nimport os\nimport re\nimport sys\n\nfrom gunicorn.http.message import TOKEN_RE\nfrom gunicorn.http.errors import ConfigurationProblem, InvalidHeader, InvalidHeaderName\nfrom gunicorn import SERVER_SOFTWARE, SERVER\nfrom gunicorn import util"
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "BLKSIZE = 0x3FFFFFFF\n\nHEADER_VALUE_RE = re.compile(r'[ \\t\\x21-\\x7e\\x80-\\xff]*')\n\nlog = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "class FileWrapper:\n\n    def __init__(self, filelike, blksize=8192):\n        self.filelike = filelike\n        self.blksize = blksize\n        if hasattr(filelike, 'close'):\n            self.close = filelike.close\n\n    def __getitem__(self, key):\n        data = self.filelike.read(self.blksize)\n        if data:\n            return data\n        raise IndexError"
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "class WSGIErrorsWrapper(io.RawIOBase):\n\n    def __init__(self, cfg):\n        errorlog = logging.getLogger(\"gunicorn.error\")\n        handlers = errorlog.handlers\n        self.streams = []\n\n        if cfg.errorlog == \"-\":\n            self.streams.append(sys.stderr)\n            handlers = handlers[1:]\n\n        for h in handlers:\n            if hasattr(h, \"stream\"):\n                self.streams.append(h.stream)\n\n    def write(self, data):\n        for stream in self.streams:\n            try:\n                stream.write(data)\n            except UnicodeError:\n                stream.write(data.encode(\"UTF-8\"))\n            stream.flush()"
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def base_environ(cfg):\n    return {\n        \"wsgi.errors\": WSGIErrorsWrapper(cfg),\n        \"wsgi.version\": (1, 0),\n        \"wsgi.multithread\": False,\n        \"wsgi.multiprocess\": (cfg.workers > 1),\n        \"wsgi.run_once\": False,\n        \"wsgi.file_wrapper\": FileWrapper,\n        \"wsgi.input_terminated\": True,\n        \"SERVER_SOFTWARE\": SERVER_SOFTWARE,\n    }"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def default_environ(req, sock, cfg):\n    env = base_environ(cfg)\n    env.update({\n        \"wsgi.input\": req.body,\n        \"gunicorn.socket\": sock,\n        \"REQUEST_METHOD\": req.method,\n        \"QUERY_STRING\": req.query,\n        \"RAW_URI\": req.uri,\n        \"SERVER_PROTOCOL\": \"HTTP/%s\" % \".\".join([str(v) for v in req.version])\n    })\n    return env"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def proxy_environ(req):\n    info = req.proxy_protocol_info\n\n    if not info:\n        return {}\n\n    return {\n        \"PROXY_PROTOCOL\": info[\"proxy_protocol\"],\n        \"REMOTE_ADDR\": info[\"client_addr\"],\n        \"REMOTE_PORT\": str(info[\"client_port\"]),\n        \"PROXY_ADDR\": info[\"proxy_addr\"],\n        \"PROXY_PORT\": str(info[\"proxy_port\"]),\n    }"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def create(req, sock, client, server, cfg):\n    resp = Response(req, sock, cfg)\n\n    environ = default_environ(req, sock, cfg)\n\n    host = None\n    script_name = os.environ.get(\"SCRIPT_NAME\", \"\")\n\n    for hdr_name, hdr_value in req.headers:\n        if hdr_name == \"EXPECT\":\n            if hdr_value.lower() == \"100-continue\":\n                sock.send(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        elif hdr_name == 'HOST':\n            host = hdr_value\n        elif hdr_name == \"SCRIPT_NAME\":\n            script_name = hdr_value\n        elif hdr_name == \"CONTENT-TYPE\":\n            environ['CONTENT_TYPE'] = hdr_value\n            continue\n        elif hdr_name == \"CONTENT-LENGTH\":\n            environ['CONTENT_LENGTH'] = hdr_value\n            continue\n\n        key = 'HTTP_' + hdr_name.replace('-', '_')\n        if key in environ:\n            hdr_value = \"%s,%s\" % (environ[key], hdr_value)\n        environ[key] = hdr_value\n\n    environ['wsgi.url_scheme'] = req.scheme\n\n    if isinstance(client, str):\n        environ['REMOTE_ADDR'] = client\n    elif isinstance(client, bytes):\n        environ['REMOTE_ADDR'] = client.decode()\n    else:\n        environ['REMOTE_ADDR'] = client[0]\n        environ['REMOTE_PORT'] = str(client[1])\n\n    if isinstance(server, str):\n        server = server.split(\":\")\n        if len(server) == 1:\n            if host:\n                server = host.split(':')\n                if len(server) == 1:\n                    if req.scheme == \"http\":\n                        server.append(80)\n                    elif req.scheme == \"https\":\n                        server.append(443)\n                    else:\n                        server.append('')\n            else:\n                server.append('')\n    environ['SERVER_NAME'] = server[0]\n    environ['SERVER_PORT'] = str(server[1])\n\n    path_info = req.path\n    if script_name:\n        if not path_info.startswith(script_name):\n            raise ConfigurationProblem(\n                \"Request path %r does not start with SCRIPT_NAME %r\" %\n                (path_info, script_name))\n        path_info = path_info[len(script_name):]\n    environ['PATH_INFO'] = util.unquote_to_wsgi_str(path_info)\n    environ['SCRIPT_NAME'] = script_name\n\n    environ.update(proxy_environ(req))\n    return resp, environ"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "class Response:\n\n    def __init__(self, req, sock, cfg):\n        self.req = req\n        self.sock = sock\n        self.version = SERVER\n        self.status = None\n        self.chunked = False\n        self.must_close = False\n        self.headers = []\n        self.headers_sent = False\n        self.response_length = None\n        self.sent = 0\n        self.upgrade = False\n        self.cfg = cfg"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def force_close(self):\n        self.must_close = True"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def should_close(self):\n        if self.must_close or self.req.should_close():\n            return True\n        if self.response_length is not None or self.chunked:\n            return False\n        if self.req.method == 'HEAD':\n            return False\n        if self.status_code < 200 or self.status_code in (204, 304):\n            return False\n        return True"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def start_response(self, status, headers, exc_info=None):\n        if exc_info:\n            try:\n                if self.status and self.headers_sent:\n                    util.reraise(exc_info[0], exc_info[1], exc_info[2])\n            finally:\n                exc_info = None\n        elif self.status is not None:\n            raise AssertionError(\"Response headers already set!\")\n\n        self.status = status\n\n        try:\n            self.status_code = int(self.status.split()[0])\n        except ValueError:\n            self.status_code = None\n\n        self.process_headers(headers)\n        self.chunked = self.is_chunked()\n        return self.write"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def process_headers(self, headers):\n        for name, value in headers:\n            if not isinstance(name, str):\n                raise TypeError('%r is not a string' % name)\n\n            if not TOKEN_RE.fullmatch(name):\n                raise InvalidHeaderName('%r' % name)\n\n            if not isinstance(value, str):\n                raise TypeError('%r is not a string' % value)\n\n            if not HEADER_VALUE_RE.fullmatch(value):\n                raise InvalidHeader('%r' % value)\n\n            value = value.strip(\" \\t\")\n            lname = name.lower()\n            if lname == \"content-length\":\n                self.response_length = int(value)\n            elif util.is_hoppish(name):\n                if lname == \"connection\":\n                    if value.lower() == \"upgrade\":\n                        self.upgrade = True\n                elif lname == \"upgrade\":\n                    if value.lower() == \"websocket\":\n                        self.headers.append((name, value))\n\n                continue\n            self.headers.append((name, value))"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def is_chunked(self):\n        if self.response_length is not None:\n            return False\n        elif self.req.version <= (1, 0):\n            return False\n        elif self.req.method == 'HEAD':\n            return False\n        elif self.status_code in (204, 304):\n            return False\n        return True"
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def default_headers(self):\n        if self.upgrade:\n            connection = \"upgrade\"\n        elif self.should_close():\n            connection = \"close\"\n        else:\n            connection = \"keep-alive\"\n\n        headers = [\n            \"HTTP/%s.%s %s\\r\\n\" % (self.req.version[0],\n                                   self.req.version[1], self.status),\n            \"Server: %s\\r\\n\" % self.version,\n            \"Date: %s\\r\\n\" % util.http_date(),\n            \"Connection: %s\\r\\n\" % connection\n        ]\n        if self.chunked:\n            headers.append(\"Transfer-Encoding: chunked\\r\\n\")\n        return headers"
    },
    {
      "chunk_id": 295,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def send_headers(self):\n        if self.headers_sent:\n            return\n        tosend = self.default_headers()\n        tosend.extend([\"%s: %s\\r\\n\" % (k, v) for k, v in self.headers])\n\n        header_str = \"%s\\r\\n\" % \"\".join(tosend)\n        util.write(self.sock, util.to_bytestring(header_str, \"latin-1\"))\n        self.headers_sent = True"
    },
    {
      "chunk_id": 296,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def write(self, arg):\n        self.send_headers()\n        if not isinstance(arg, bytes):\n            raise TypeError('%r is not a byte' % arg)\n        arglen = len(arg)\n        tosend = arglen\n        if self.response_length is not None:\n            if self.sent >= self.response_length:\n                return\n\n            tosend = min(self.response_length - self.sent, tosend)\n            if tosend < arglen:\n                arg = arg[:tosend]\n\n        if self.chunked and tosend == 0:\n            return\n\n        self.sent += tosend\n        util.write(self.sock, arg, self.chunked)"
    },
    {
      "chunk_id": 297,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def can_sendfile(self):\n        return self.cfg.sendfile is not False"
    },
    {
      "chunk_id": 298,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def sendfile(self, respiter):\n        if self.cfg.is_ssl or not self.can_sendfile():\n            return False\n\n        if not util.has_fileno(respiter.filelike):\n            return False\n\n        fileno = respiter.filelike.fileno()\n        try:\n            offset = os.lseek(fileno, 0, os.SEEK_CUR)\n            if self.response_length is None:\n                filesize = os.fstat(fileno).st_size\n                nbytes = filesize - offset\n            else:\n                nbytes = self.response_length\n        except (OSError, io.UnsupportedOperation):\n            return False\n\n        self.send_headers()\n\n        if self.is_chunked():\n            chunk_size = \"%X\\r\\n\" % nbytes\n            self.sock.sendall(chunk_size.encode('utf-8'))\n        if nbytes > 0:\n            self.sock.sendfile(respiter.filelike, offset=offset, count=nbytes)\n\n        if self.is_chunked():\n            self.sock.sendall(b\"\\r\\n\")\n\n        os.lseek(fileno, offset, os.SEEK_SET)\n\n        return True"
    },
    {
      "chunk_id": 299,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def write_file(self, respiter):\n        if not self.sendfile(respiter):\n            for item in respiter:\n                self.write(item)"
    },
    {
      "chunk_id": 300,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/wsgi.py",
      "content": "def close(self):\n        if not self.headers_sent:\n            self.send_headers()\n        if self.chunked:\n            util.write_chunk(self.sock, b\"\")"
    },
    {
      "chunk_id": 301,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/unreader.py",
      "content": "import io\nimport os"
    },
    {
      "chunk_id": 302,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/unreader.py",
      "content": "class Unreader:\n    def __init__(self):\n        self.buf = io.BytesIO()\n\n    def chunk(self):\n        raise NotImplementedError()\n\n    def read(self, size=None):\n        if size is not None and not isinstance(size, int):\n            raise TypeError(\"size parameter must be an int or long.\")\n\n        if size is not None:\n            if size == 0:\n                return b\"\"\n            if size < 0:\n                size = None\n\n        self.buf.seek(0, os.SEEK_END)\n\n        if size is None and self.buf.tell():\n            ret = self.buf.getvalue()\n            self.buf = io.BytesIO()\n            return ret\n        if size is None:\n            d = self.chunk()\n            return d\n\n        while self.buf.tell() < size:\n            chunk = self.chunk()\n            if not chunk:\n                ret = self.buf.getvalue()\n                self.buf = io.BytesIO()\n                return ret\n            self.buf.write(chunk)\n        data = self.buf.getvalue()\n        self.buf = io.BytesIO()\n        self.buf.write(data[size:])\n        return data[:size]\n\n    def unread(self, data):\n        self.buf.seek(0, os.SEEK_END)\n        self.buf.write(data)"
    },
    {
      "chunk_id": 303,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/unreader.py",
      "content": "class SocketUnreader(Unreader):\n    def __init__(self, sock, max_chunk=8192):\n        super().__init__()\n        self.sock = sock\n        self.mxchunk = max_chunk\n\n    def chunk(self):\n        return self.sock.recv(self.mxchunk)"
    },
    {
      "chunk_id": 304,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/unreader.py",
      "content": "class IterUnreader(Unreader):\n    def __init__(self, iterable):\n        super().__init__()\n        self.iter = iter(iterable)\n\n    def chunk(self):\n        if not self.iter:\n            return b\"\"\n        try:\n            return next(self.iter)\n        except StopIteration:\n            self.iter = None\n            return b\"\""
    },
    {
      "chunk_id": 305,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 306,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "import io\nimport re\nimport socket\n\nfrom gunicorn.http.body import ChunkedReader, LengthReader, EOFReader, Body\nfrom gunicorn.http.errors import (\n    InvalidHeader, InvalidHeaderName, NoMoreData,\n    InvalidRequestLine, InvalidRequestMethod, InvalidHTTPVersion,\n    LimitRequestLine, LimitRequestHeaders,\n    UnsupportedTransferCoding, ObsoleteFolding,\n)\nfrom gunicorn.http.errors import InvalidProxyLine, ForbiddenProxyRequest\nfrom gunicorn.http.errors import InvalidSchemeHeaders\nfrom gunicorn.util import bytes_to_str, split_request_uri"
    },
    {
      "chunk_id": 307,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "MAX_REQUEST_LINE = 8190\nMAX_HEADERS = 32768\nDEFAULT_MAX_HEADERFIELD_SIZE = 8190\n\n# verbosely on purpose, avoid backslash ambiguity\nRFC9110_5_6_2_TOKEN_SPECIALS = r\"!#$%&'*+-.^_`|~\"\nTOKEN_RE = re.compile(r\"[%s0-9a-zA-Z]+\" % (re.escape(RFC9110_5_6_2_TOKEN_SPECIALS)))\nMETHOD_BADCHAR_RE = re.compile(\"[a-z#]\")\n# usually 1.0 or 1.1 - RFC9112 permits restricting to single-digit versions\nVERSION_RE = re.compile(r\"HTTP/(\\d)\\.(\\d)\")\nRFC9110_5_5_INVALID_AND_DANGEROUS = re.compile(r\"[\\0\\r\\n]\")"
    },
    {
      "chunk_id": 308,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "class Message:\n    def __init__(self, cfg, unreader, peer_addr):\n        self.cfg = cfg\n        self.unreader = unreader\n        self.peer_addr = peer_addr\n        self.remote_addr = peer_addr\n        self.version = None\n        self.headers = []\n        self.trailers = []\n        self.body = None\n        self.scheme = \"https\" if cfg.is_ssl else \"http\"\n        self.must_close = False\n\n        # set headers limits\n        self.limit_request_fields = cfg.limit_request_fields\n        if (self.limit_request_fields <= 0\n                or self.limit_request_fields > MAX_HEADERS):\n            self.limit_request_fields = MAX_HEADERS\n        self.limit_request_field_size = cfg.limit_request_field_size\n        if self.limit_request_field_size < 0:\n            self.limit_request_field_size = DEFAULT_MAX_HEADERFIELD_SIZE\n\n        # set max header buffer size\n        max_header_field_size = self.limit_request_field_size or DEFAULT_MAX_HEADERFIELD_SIZE\n        self.max_buffer_headers = self.limit_request_fields * \\\n            (max_header_field_size + 2) + 4\n\n        unused = self.parse(self.unreader)\n        self.unreader.unread(unused)\n        self.set_body_reader()"
    },
    {
      "chunk_id": 309,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def force_close(self):\n        self.must_close = True"
    },
    {
      "chunk_id": 310,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def parse(self, unreader):\n        raise NotImplementedError()"
    },
    {
      "chunk_id": 311,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def parse_headers(self, data, from_trailer=False):\n        cfg = self.cfg\n        headers = []\n\n        # Split lines on \\r\\n\n        lines = [bytes_to_str(line) for line in data.split(b\"\\r\\n\")]\n\n        # handle scheme headers\n        scheme_header = False\n        secure_scheme_headers = {}\n        forwarder_headers = []\n        if from_trailer:\n            # nonsense. either a request is https from the beginning\n            #  .. or we are just behind a proxy who does not remove conflicting trailers\n            pass\n        elif ('*' in cfg.forwarded_allow_ips or\n              not isinstance(self.peer_addr, tuple)\n              or self.peer_addr[0] in cfg.forwarded_allow_ips):\n            secure_scheme_headers = cfg.secure_scheme_headers\n            forwarder_headers = cfg.forwarder_headers\n\n        # Parse headers into key/value pairs paying attention\n        # to continuation lines.\n        while lines:\n            if len(headers) >= self.limit_request_fields:\n                raise LimitRequestHeaders(\"limit request headers fields\")\n\n            # Parse initial header name: value pair.\n            curr = lines.pop(0)\n            header_length = len(curr) + len(\"\\r\\n\")\n            if curr.find(\":\") <= 0:\n                raise InvalidHeader(curr)\n            name, value = curr.split(\":\", 1)\n            if self.cfg.strip_header_spaces:\n                name = name.rstrip(\" \\t\")\n            if not TOKEN_RE.fullmatch(name):\n                raise InvalidHeaderName(name)\n\n            # this is still a dangerous place to do this\n            #  but it is more correct than doing it before the pattern match:\n            # after we entered Unicode wonderland, 8bits could case-shift into ASCII:\n            # b\"\\xDF\".decode(\"latin-1\").upper().encode(\"ascii\") == b\"SS\"\n            name = name.upper()\n\n            value = [value.strip(\" \\t\")]\n\n            # Consume value continuation lines..\n            while lines and lines[0].startswith((\" \", \"\\t\")):\n                # .. which is obsolete here, and no longer done by default\n                if not self.cfg.permit_obsolete_folding:\n                    raise ObsoleteFolding(name)\n                curr = lines.pop(0)\n                header_length += len(curr) + len(\"\\r\\n\")\n                if header_length > self.limit_request_field_size > 0:\n                    raise LimitRequestHeaders(\"limit request headers \"\n                                              \"fields size\")\n                value.append(curr.strip(\"\\t \"))\n            value = \" \".join(value)\n\n            if RFC9110_5_5_INVALID_AND_DANGEROUS.search(value):\n                raise InvalidHeader(name)\n\n            if header_length > self.limit_request_field_size > 0:\n                raise LimitRequestHeaders(\"limit request headers fields size\")\n\n            if name in secure_scheme_headers:\n                secure = value == secure_scheme_headers[name]\n                scheme = \"https\" if secure else \"http\"\n                if scheme_header:\n                    if scheme != self.scheme:\n                        raise InvalidSchemeHeaders()\n                else:\n                    scheme_header = True\n                    self.scheme = scheme\n\n            # ambiguous mapping allows fooling downstream, e.g. merging non-identical headers:\n            # X-Forwarded-For: 2001:db8::ha:cc:ed\n            # X_Forwarded_For: 127.0.0.1,::1\n            # HTTP_X_FORWARDED_FOR = 2001:db8::ha:cc:ed,127.0.0.1,::1\n            # Only modify after fixing *ALL* header transformations; network to wsgi env\n            if \"_\" in name:\n                if name in forwarder_headers or \"*\" in forwarder_headers:\n                    # This forwarder may override our environment\n                    pass\n                elif self.cfg.header_map == \"dangerous\":\n                    # as if we did not know we cannot safely map this\n                    pass\n                elif self.cfg.header_map == \"drop\":\n                    # almost as if it never had been there\n                    # but still counts against resource limits\n                    continue\n                else:\n                    # fail-safe fallthrough: refuse\n                    raise InvalidHeaderName(name)\n\n            headers.append((name, value))\n\n        return headers"
    },
    {
      "chunk_id": 312,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def set_body_reader(self):\n        chunked = False\n        content_length = None\n\n        for (name, value) in self.headers:\n            if name == \"CONTENT-LENGTH\":\n                if content_length is not None:\n                    raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n                content_length = value\n            elif name == \"TRANSFER-ENCODING\":\n                # T-E can be a list\n                # https://datatracker.ietf.org/doc/html/rfc9112#name-transfer-encoding\n                vals = [v.strip() for v in value.split(',')]\n                for val in vals:\n                    if val.lower() == \"chunked\":\n                        # DANGER: transfer codings stack, and stacked chunking is never intended\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                        chunked = True\n                    elif val.lower() == \"identity\":\n                        # does not do much, could still plausibly desync from what the proxy does\n                        # safe option: nuke it, its never needed\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                    elif val.lower() in ('compress', 'deflate', 'gzip'):\n                        # chunked should be the last one\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                        self.force_close()\n                    else:\n                        raise UnsupportedTransferCoding(value)\n\n        if chunked:\n            # two potentially dangerous cases:\n            #  a) CL + TE (TE overrides CL.. only safe if the recipient sees it that way too)\n            #  b) chunked HTTP/1.0 (always faulty)\n            if self.version < (1, 1):\n                # framing wonky, see RFC 9112 Section 6.1\n                raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n            if content_length is not None:\n                # we cannot be certain the message framing we understood matches proxy intent\n                #  -> whatever happens next, remaining input must not be trusted\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n            self.body = Body(ChunkedReader(self, self.unreader))\n        elif content_length is not None:\n            try:\n                if str(content_length).isnumeric():\n                    content_length = int(content_length)\n                else:\n                    raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n            except ValueError:\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n\n            if content_length < 0:\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n\n            self.body = Body(LengthReader(self.unreader, content_length))\n        else:\n            self.body = Body(EOFReader(self.unreader))"
    },
    {
      "chunk_id": 313,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def should_close(self):\n        if self.must_close:\n            return True\n        for (h, v) in self.headers:\n            if h == \"CONNECTION\":\n                v = v.lower().strip(\" \\t\")\n                if v == \"close\":\n                    return True\n                elif v == \"keep-alive\":\n                    return False\n                break\n        return self.version <= (1, 0)"
    },
    {
      "chunk_id": 314,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "class Request(Message):\n    def __init__(self, cfg, unreader, peer_addr, req_number=1):\n        self.method = None\n        self.uri = None\n        self.path = None\n        self.query = None\n        self.fragment = None\n\n        # get max request line size\n        self.limit_request_line = cfg.limit_request_line\n        if (self.limit_request_line < 0\n                or self.limit_request_line >= MAX_REQUEST_LINE):\n            self.limit_request_line = MAX_REQUEST_LINE\n\n        self.req_number = req_number\n        self.proxy_protocol_info = None\n        super().__init__(cfg, unreader, peer_addr)"
    },
    {
      "chunk_id": 315,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def get_data(self, unreader, buf, stop=False):\n        data = unreader.read()\n        if not data:\n            if stop:\n                raise StopIteration()\n            raise NoMoreData(buf.getvalue())\n        buf.write(data)"
    },
    {
      "chunk_id": 316,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def parse(self, unreader):\n        buf = io.BytesIO()\n        self.get_data(unreader, buf, stop=True)\n\n        # get request line\n        line, rbuf = self.read_line(unreader, buf, self.limit_request_line)\n\n        # proxy protocol\n        if self.proxy_protocol(bytes_to_str(line)):\n            # get next request line\n            buf = io.BytesIO()\n            buf.write(rbuf)\n            line, rbuf = self.read_line(unreader, buf, self.limit_request_line)\n\n        self.parse_request_line(line)\n        buf = io.BytesIO()\n        buf.write(rbuf)\n\n        # Headers\n        data = buf.getvalue()\n        idx = data.find(b\"\\r\\n\\r\\n\")\n\n        done = data[:2] == b\"\\r\\n\"\n        while True:\n            idx = data.find(b\"\\r\\n\\r\\n\")\n            done = data[:2] == b\"\\r\\n\"\n\n            if idx < 0 and not done:\n                self.get_data(unreader, buf)\n                data = buf.getvalue()\n                if len(data) > self.max_buffer_headers:\n                    raise LimitRequestHeaders(\"max buffer headers\")\n            else:\n                break\n\n        if done:\n            self.unreader.unread(data[2:])\n            return b\"\"\n\n        self.headers = self.parse_headers(data[:idx], from_trailer=False)\n\n        ret = data[idx + 4:]\n        buf = None\n        return ret"
    },
    {
      "chunk_id": 317,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def read_line(self, unreader, buf, limit=0):\n        data = buf.getvalue()\n\n        while True:\n            idx = data.find(b\"\\r\\n\")\n            if idx >= 0:\n                # check if the request line is too large\n                if idx > limit > 0:\n                    raise LimitRequestLine(idx, limit)\n                break\n            if len(data) - 2 > limit > 0:\n                raise LimitRequestLine(len(data), limit)\n            self.get_data(unreader, buf)\n            data = buf.getvalue()\n\n        return (data[:idx],  # request line,\n                data[idx + 2:])  # residue in the buffer, skip \\r\\n"
    },
    {
      "chunk_id": 318,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def proxy_protocol(self, line):\n        \"\"\"\\\n        Detect, check and parse proxy protocol.\n\n        :raises: ForbiddenProxyRequest, InvalidProxyLine.\n        :return: True for proxy protocol line else False\n        \"\"\"\n        if not self.cfg.proxy_protocol:\n            return False\n\n        if self.req_number != 1:\n            return False\n\n        if not line.startswith(\"PROXY\"):\n            return False\n\n        self.proxy_protocol_access_check()\n        self.parse_proxy_protocol(line)\n\n        return True"
    },
    {
      "chunk_id": 319,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def proxy_protocol_access_check(self):\n        # check in allow list\n        if (\"*\" not in self.cfg.proxy_allow_ips and\n            isinstance(self.peer_addr, tuple) and\n                self.peer_addr[0] not in self.cfg.proxy_allow_ips):\n            raise ForbiddenProxyRequest(self.peer_addr[0])"
    },
    {
      "chunk_id": 320,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def parse_proxy_protocol(self, line):\n        bits = line.split(\" \")\n\n        if len(bits) != 6:\n            raise InvalidProxyLine(line)\n\n        # Extract data\n        proto = bits[1]\n        s_addr = bits[2]\n        d_addr = bits[3]\n\n        # Validation\n        if proto not in [\"TCP4\", \"TCP6\"]:\n            raise InvalidProxyLine(\"protocol '%s' not supported\" % proto)\n        if proto == \"TCP4\":\n            try:\n                socket.inet_pton(socket.AF_INET, s_addr)\n                socket.inet_pton(socket.AF_INET, d_addr)\n            except OSError:\n                raise InvalidProxyLine(line)\n        elif proto == \"TCP6\":\n            try:\n                socket.inet_pton(socket.AF_INET6, s_addr)\n                socket.inet_pton(socket.AF_INET6, d_addr)\n            except OSError:\n                raise InvalidProxyLine(line)\n\n        try:\n            s_port = int(bits[4])\n            d_port = int(bits[5])\n        except ValueError:\n            raise InvalidProxyLine(\"invalid port %s\" % line)\n\n        if not ((0 <= s_port <= 65535) and (0 <= d_port <= 65535)):\n            raise InvalidProxyLine(\"invalid port %s\" % line)\n\n        # Set data\n        self.proxy_protocol_info = {\n            \"proxy_protocol\": proto,\n            \"client_addr\": s_addr,\n            \"client_port\": s_port,\n            \"proxy_addr\": d_addr,\n            \"proxy_port\": d_port\n        }"
    },
    {
      "chunk_id": 321,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def parse_request_line(self, line_bytes):\n        bits = [bytes_to_str(bit) for bit in line_bytes.split(b\" \", 2)]\n        if len(bits) != 3:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n\n        # Method: RFC9110 Section 9\n        self.method = bits[0]\n\n        # nonstandard restriction, suitable for all IANA registered methods\n        # partially enforced in previous gunicorn versions\n        if not self.cfg.permit_unconventional_http_method:\n            if METHOD_BADCHAR_RE.search(self.method):\n                raise InvalidRequestMethod(self.method)\n            if not 3 <= len(bits[0]) <= 20:\n                raise InvalidRequestMethod(self.method)\n        # standard restriction: RFC9110 token\n        if not TOKEN_RE.fullmatch(self.method):\n            raise InvalidRequestMethod(self.method)\n        # nonstandard and dangerous\n        # methods are merely uppercase by convention, no case-insensitive treatment is intended\n        if self.cfg.casefold_http_method:\n            self.method = self.method.upper()\n\n        # URI\n        self.uri = bits[1]\n\n        # Python stdlib explicitly tells us it will not perform validation.\n        # https://docs.python.org/3/library/urllib.parse.html#url-parsing-security\n        # There are *four* `request-target` forms in rfc9112, none of them can be empty:\n        # 1. origin-form, which starts with a slash\n        # 2. absolute-form, which starts with a non-empty scheme\n        # 3. authority-form, (for CONNECT) which contains a colon after the host\n        # 4. asterisk-form, which is an asterisk (`\\x2A`)\n        # => manually reject one always invalid URI: empty\n        if len(self.uri) == 0:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n\n        try:\n            parts = split_request_uri(self.uri)\n        except ValueError:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n        self.path = parts.path or \"\"\n        self.query = parts.query or \"\"\n        self.fragment = parts.fragment or \"\"\n\n        # Version\n        match = VERSION_RE.fullmatch(bits[2])\n        if match is None:\n            raise InvalidHTTPVersion(bits[2])\n        self.version = (int(match.group(1)), int(match.group(2)))\n        if not (1, 0) <= self.version < (2, 0):\n            # if ever relaxing this, carefully review Content-Encoding processing\n            if not self.cfg.permit_unconventional_http_version:\n                raise InvalidHTTPVersion(self.version)"
    },
    {
      "chunk_id": 322,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/message.py",
      "content": "def set_body_reader(self):\n        super().set_body_reader()\n        if isinstance(self.body.reader, EOFReader):\n            self.body = Body(LengthReader(self.unreader, 0))"
    },
    {
      "chunk_id": 323,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "import io\nimport sys\n\nfrom gunicorn.http.errors import (NoMoreData, ChunkMissingTerminator,\n                                  InvalidChunkSize)"
    },
    {
      "chunk_id": 324,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "class ChunkedReader:\n    def __init__(self, req, unreader):\n        self.req = req\n        self.parser = self.parse_chunked(unreader)\n        self.buf = io.BytesIO()"
    },
    {
      "chunk_id": 325,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integer type\")\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        if self.parser:\n            while self.buf.tell() < size:\n                try:\n                    self.buf.write(next(self.parser))\n                except StopIteration:\n                    self.parser = None\n                    break\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret"
    },
    {
      "chunk_id": 326,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def parse_trailers(self, unreader, data):\n        buf = io.BytesIO()\n        buf.write(data)\n\n        idx = buf.getvalue().find(b\"\\r\\n\\r\\n\")\n        done = buf.getvalue()[:2] == b\"\\r\\n\"\n        while idx < 0 and not done:\n            self.get_data(unreader, buf)\n            idx = buf.getvalue().find(b\"\\r\\n\\r\\n\")\n            done = buf.getvalue()[:2] == b\"\\r\\n\"\n        if done:\n            unreader.unread(buf.getvalue()[2:])\n            return b\"\"\n        self.req.trailers = self.req.parse_headers(buf.getvalue()[:idx], from_trailer=True)\n        unreader.unread(buf.getvalue()[idx + 4:])"
    },
    {
      "chunk_id": 327,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def parse_chunked(self, unreader):\n        (size, rest) = self.parse_chunk_size(unreader)\n        while size > 0:\n            while size > len(rest):\n                size -= len(rest)\n                yield rest\n                rest = unreader.read()\n                if not rest:\n                    raise NoMoreData()\n            yield rest[:size]\n            # Remove \\r\\n after chunk\n            rest = rest[size:]\n            while len(rest) < 2:\n                new_data = unreader.read()\n                if not new_data:\n                    break\n                rest += new_data\n            if rest[:2] != b'\\r\\n':\n                raise ChunkMissingTerminator(rest[:2])\n            (size, rest) = self.parse_chunk_size(unreader, data=rest[2:])"
    },
    {
      "chunk_id": 328,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def parse_chunk_size(self, unreader, data=None):\n        buf = io.BytesIO()\n        if data is not None:\n            buf.write(data)\n\n        idx = buf.getvalue().find(b\"\\r\\n\")\n        while idx < 0:\n            self.get_data(unreader, buf)\n            idx = buf.getvalue().find(b\"\\r\\n\")\n\n        data = buf.getvalue()\n        line, rest_chunk = data[:idx], data[idx + 2:]\n\n        # RFC9112 7.1.1: BWS before chunk-ext - but ONLY then\n        chunk_size, *chunk_ext = line.split(b\";\", 1)\n        if chunk_ext:\n            chunk_size = chunk_size.rstrip(b\" \\t\")\n        if any(n not in b\"0123456789abcdefABCDEF\" for n in chunk_size):\n            raise InvalidChunkSize(chunk_size)\n        if len(chunk_size) == 0:\n            raise InvalidChunkSize(chunk_size)\n        chunk_size = int(chunk_size, 16)\n\n        if chunk_size == 0:\n            try:\n                self.parse_trailers(unreader, rest_chunk)\n            except NoMoreData:\n                pass\n            return (0, None)\n        return (chunk_size, rest_chunk)"
    },
    {
      "chunk_id": 329,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def get_data(self, unreader, buf):\n        data = unreader.read()\n        if not data:\n            raise NoMoreData()\n        buf.write(data)"
    },
    {
      "chunk_id": 330,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "class LengthReader:\n    def __init__(self, unreader, length):\n        self.unreader = unreader\n        self.length = length"
    },
    {
      "chunk_id": 331,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n\n        size = min(self.length, size)\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        buf = io.BytesIO()\n        data = self.unreader.read()\n        while data:\n            buf.write(data)\n            if buf.tell() >= size:\n                break\n            data = self.unreader.read()\n\n        buf = buf.getvalue()\n        ret, rest = buf[:size], buf[size:]\n        self.unreader.unread(rest)\n        self.length -= size\n        return ret"
    },
    {
      "chunk_id": 332,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "class EOFReader:\n    def __init__(self, unreader):\n        self.unreader = unreader\n        self.buf = io.BytesIO()\n        self.finished = False"
    },
    {
      "chunk_id": 333,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        if self.finished:\n            data = self.buf.getvalue()\n            ret, rest = data[:size], data[size:]\n            self.buf = io.BytesIO()\n            self.buf.write(rest)\n            return ret\n\n        data = self.unreader.read()\n        while data:\n            self.buf.write(data)\n            if self.buf.tell() > size:\n                break\n            data = self.unreader.read()\n\n        if not data:\n            self.finished = True\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret"
    },
    {
      "chunk_id": 334,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "class Body:\n    def __init__(self, reader):\n        self.reader = reader\n        self.buf = io.BytesIO()"
    },
    {
      "chunk_id": 335,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def __iter__(self):\n        return self"
    },
    {
      "chunk_id": 336,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def __next__(self):\n        ret = self.readline()\n        if not ret:\n            raise StopIteration()\n        return ret"
    },
    {
      "chunk_id": 337,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "next = __next__"
    },
    {
      "chunk_id": 338,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def getsize(self, size):\n        if size is None:\n            return sys.maxsize\n        elif not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n        elif size < 0:\n            return sys.maxsize\n        return size"
    },
    {
      "chunk_id": 339,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def read(self, size=None):\n        size = self.getsize(size)\n        if size == 0:\n            return b\"\"\n\n        if size < self.buf.tell():\n            data = self.buf.getvalue()\n            ret, rest = data[:size], data[size:]\n            self.buf = io.BytesIO()\n            self.buf.write(rest)\n            return ret\n\n        while size > self.buf.tell():\n            data = self.reader.read(1024)\n            if not data:\n                break\n            self.buf.write(data)\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret"
    },
    {
      "chunk_id": 340,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def readline(self, size=None):\n        size = self.getsize(size)\n        if size == 0:\n            return b\"\"\n\n        data = self.buf.getvalue()\n        self.buf = io.BytesIO()\n\n        ret = []\n        while 1:\n            idx = data.find(b\"\\n\", 0, size)\n            idx = idx + 1 if idx >= 0 else size if len(data) >= size else 0\n            if idx:\n                ret.append(data[:idx])\n                self.buf.write(data[idx:])\n                break\n\n            ret.append(data)\n            size -= len(data)\n            data = self.reader.read(min(1024, size))\n            if not data:\n                break\n\n        return b\"\".join(ret)"
    },
    {
      "chunk_id": 341,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/body.py",
      "content": "def readlines(self, size=None):\n        ret = []\n        data = self.read()\n        while data:\n            pos = data.find(b\"\\n\")\n            if pos < 0:\n                ret.append(data)\n                data = b\"\"\n            else:\n                line, data = data[:pos + 1], data[pos + 1:]\n                ret.append(line)\n        return ret"
    },
    {
      "chunk_id": 342,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom gunicorn.http.message import Request\nfrom gunicorn.http.unreader import SocketUnreader, IterUnreader"
    },
    {
      "chunk_id": 343,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "class Parser:\n\n    mesg_class = None\n\n    def __init__(self, cfg, source, source_addr):\n        self.cfg = cfg\n        if hasattr(source, \"recv\"):\n            self.unreader = SocketUnreader(source)\n        else:\n            self.unreader = IterUnreader(source)\n        self.mesg = None\n        self.source_addr = source_addr\n\n        # request counter (for keepalive connetions)\n        self.req_count = 0"
    },
    {
      "chunk_id": 344,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "def __iter__(self):\n        return self"
    },
    {
      "chunk_id": 345,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "def __next__(self):\n        # Stop if HTTP dictates a stop.\n        if self.mesg and self.mesg.should_close():\n            raise StopIteration()\n\n        # Discard any unread body of the previous message\n        if self.mesg:\n            data = self.mesg.body.read(8192)\n            while data:\n                data = self.mesg.body.read(8192)\n\n        # Parse the next request\n        self.req_count += 1\n        self.mesg = self.mesg_class(self.cfg, self.unreader, self.source_addr, self.req_count)\n        if not self.mesg:\n            raise StopIteration()\n        return self.mesg"
    },
    {
      "chunk_id": 346,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "next = __next__"
    },
    {
      "chunk_id": 347,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/parser.py",
      "content": "class RequestParser(Parser):\n\n    mesg_class = Request"
    },
    {
      "chunk_id": 348,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# We don't need to call super() in __init__ methods of our\n# BaseException and Exception classes because we also define\n# our own __str__ methods so there is no need to pass 'message'\n# to the base class to get a meaningful output from 'str(exc)'.\n# pylint: disable=super-init-not-called"
    },
    {
      "chunk_id": 349,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class ParseException(Exception):\n    pass"
    },
    {
      "chunk_id": 350,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class NoMoreData(IOError):\n    def __init__(self, buf=None):\n        self.buf = buf\n\n    def __str__(self):\n        return \"No more data after: %r\" % self.buf"
    },
    {
      "chunk_id": 351,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class ConfigurationProblem(ParseException):\n    def __init__(self, info):\n        self.info = info\n        self.code = 500\n\n    def __str__(self):\n        return \"Configuration problem: %s\" % self.info"
    },
    {
      "chunk_id": 352,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidRequestLine(ParseException):\n    def __init__(self, req):\n        self.req = req\n        self.code = 400\n\n    def __str__(self):\n        return \"Invalid HTTP request line: %r\" % self.req"
    },
    {
      "chunk_id": 353,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidRequestMethod(ParseException):\n    def __init__(self, method):\n        self.method = method\n\n    def __str__(self):\n        return \"Invalid HTTP method: %r\" % self.method"
    },
    {
      "chunk_id": 354,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidHTTPVersion(ParseException):\n    def __init__(self, version):\n        self.version = version\n\n    def __str__(self):\n        return \"Invalid HTTP Version: %r\" % (self.version,)"
    },
    {
      "chunk_id": 355,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidHeader(ParseException):\n    def __init__(self, hdr, req=None):\n        self.hdr = hdr\n        self.req = req\n\n    def __str__(self):\n        return \"Invalid HTTP Header: %r\" % self.hdr"
    },
    {
      "chunk_id": 356,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class ObsoleteFolding(ParseException):\n    def __init__(self, hdr):\n        self.hdr = hdr\n\n    def __str__(self):\n        return \"Obsolete line folding is unacceptable: %r\" % (self.hdr, )"
    },
    {
      "chunk_id": 357,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidHeaderName(ParseException):\n    def __init__(self, hdr):\n        self.hdr = hdr\n\n    def __str__(self):\n        return \"Invalid HTTP header name: %r\" % self.hdr"
    },
    {
      "chunk_id": 358,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class UnsupportedTransferCoding(ParseException):\n    def __init__(self, hdr):\n        self.hdr = hdr\n        self.code = 501\n\n    def __str__(self):\n        return \"Unsupported transfer coding: %r\" % self.hdr"
    },
    {
      "chunk_id": 359,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidChunkSize(IOError):\n    def __init__(self, data):\n        self.data = data\n\n    def __str__(self):\n        return \"Invalid chunk size: %r\" % self.data"
    },
    {
      "chunk_id": 360,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class ChunkMissingTerminator(IOError):\n    def __init__(self, term):\n        self.term = term\n\n    def __str__(self):\n        return \"Invalid chunk terminator is not '\\\\r\\\\n': %r\" % self.term"
    },
    {
      "chunk_id": 361,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class LimitRequestLine(ParseException):\n    def __init__(self, size, max_size):\n        self.size = size\n        self.max_size = max_size\n\n    def __str__(self):\n        return \"Request Line is too large (%s > %s)\" % (self.size, self.max_size)"
    },
    {
      "chunk_id": 362,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class LimitRequestHeaders(ParseException):\n    def __init__(self, msg):\n        self.msg = msg\n\n    def __str__(self):\n        return self.msg"
    },
    {
      "chunk_id": 363,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidProxyLine(ParseException):\n    def __init__(self, line):\n        self.line = line\n        self.code = 400\n\n    def __str__(self):\n        return \"Invalid PROXY line: %r\" % self.line"
    },
    {
      "chunk_id": 364,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class ForbiddenProxyRequest(ParseException):\n    def __init__(self, host):\n        self.host = host\n        self.code = 403\n\n    def __str__(self):\n        return \"Proxy request from %r not allowed\" % self.host"
    },
    {
      "chunk_id": 365,
      "source": "__internal__/data_repo/gunicorn/gunicorn/http/errors.py",
      "content": "class InvalidSchemeHeaders(ParseException):\n    def __str__(self):\n        return \"Contradictory scheme headers\""
    },
    {
      "chunk_id": 366,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/__init__.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 367,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/__init__.py",
      "content": "# (No additional code provided to chunk)"
    },
    {
      "chunk_id": 368,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "import importlib.util\nimport importlib.machinery\nimport os\nimport sys\nimport traceback\n\nfrom gunicorn import util\nfrom gunicorn.arbiter import Arbiter\nfrom gunicorn.config import Config, get_default_config_file\nfrom gunicorn import debug"
    },
    {
      "chunk_id": 369,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "class BaseApplication:\n    \"\"\"\n    An application interface for configuring and loading\n    the various necessities for any given web framework.\n    \"\"\"\n    def __init__(self, usage=None, prog=None):\n        self.usage = usage\n        self.cfg = None\n        self.callable = None\n        self.prog = prog\n        self.logger = None\n        self.do_load_config()"
    },
    {
      "chunk_id": 370,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def do_load_config(self):\n        \"\"\"\n        Loads the configuration\n        \"\"\"\n        try:\n            self.load_default_config()\n            self.load_config()\n        except Exception as e:\n            print(\"\\nError: %s\" % str(e), file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(1)"
    },
    {
      "chunk_id": 371,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load_default_config(self):\n        # init configuration\n        self.cfg = Config(self.usage, prog=self.prog)"
    },
    {
      "chunk_id": 372,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def init(self, parser, opts, args):\n        raise NotImplementedError"
    },
    {
      "chunk_id": 373,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load(self):\n        raise NotImplementedError"
    },
    {
      "chunk_id": 374,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load_config(self):\n        \"\"\"\n        This method is used to load the configuration from one or several input(s).\n        Custom Command line, configuration file.\n        You have to override this method in your class.\n        \"\"\"\n        raise NotImplementedError"
    },
    {
      "chunk_id": 375,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def reload(self):\n        self.do_load_config()\n        if self.cfg.spew:\n            debug.spew()"
    },
    {
      "chunk_id": 376,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def wsgi(self):\n        if self.callable is None:\n            self.callable = self.load()\n        return self.callable"
    },
    {
      "chunk_id": 377,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def run(self):\n        try:\n            Arbiter(self).run()\n        except RuntimeError as e:\n            print(\"\\nError: %s\\n\" % e, file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(1)"
    },
    {
      "chunk_id": 378,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "class Application(BaseApplication):\n\n    # 'init' and 'load' methods are implemented by WSGIApplication.\n    # pylint: disable=abstract-method"
    },
    {
      "chunk_id": 379,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def chdir(self):\n        # chdir to the configured path before loading,\n        # default is the current dir\n        os.chdir(self.cfg.chdir)\n\n        # add the path to sys.path\n        if self.cfg.chdir not in sys.path:\n            sys.path.insert(0, self.cfg.chdir)"
    },
    {
      "chunk_id": 380,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def get_config_from_filename(self, filename):\n\n        if not os.path.exists(filename):\n            raise RuntimeError(\"%r doesn't exist\" % filename)\n\n        ext = os.path.splitext(filename)[1]\n\n        try:\n            module_name = '__config__'\n            if ext in [\".py\", \".pyc\"]:\n                spec = importlib.util.spec_from_file_location(module_name, filename)\n            else:\n                msg = \"configuration file should have a valid Python extension.\\n\"\n                util.warn(msg)\n                loader_ = importlib.machinery.SourceFileLoader(module_name, filename)\n                spec = importlib.util.spec_from_file_location(module_name, filename, loader=loader_)\n            mod = importlib.util.module_from_spec(spec)\n            sys.modules[module_name] = mod\n            spec.loader.exec_module(mod)\n        except Exception:\n            print(\"Failed to read config file: %s\" % filename, file=sys.stderr)\n            traceback.print_exc()\n            sys.stderr.flush()\n            sys.exit(1)\n\n        return vars(mod)"
    },
    {
      "chunk_id": 381,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def get_config_from_module_name(self, module_name):\n        return vars(importlib.import_module(module_name))"
    },
    {
      "chunk_id": 382,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load_config_from_module_name_or_filename(self, location):\n        \"\"\"\n        Loads the configuration file: the file is a python file, otherwise raise an RuntimeError\n        Exception or stop the process if the configuration file contains a syntax error.\n        \"\"\"\n\n        if location.startswith(\"python:\"):\n            module_name = location[len(\"python:\"):]\n            cfg = self.get_config_from_module_name(module_name)\n        else:\n            if location.startswith(\"file:\"):\n                filename = location[len(\"file:\"):]\n            else:\n                filename = location\n            cfg = self.get_config_from_filename(filename)\n\n        for k, v in cfg.items():\n            # Ignore unknown names\n            if k not in self.cfg.settings:\n                continue\n            try:\n                self.cfg.set(k.lower(), v)\n            except Exception:\n                print(\"Invalid value for %s: %s\\n\" % (k, v), file=sys.stderr)\n                sys.stderr.flush()\n                raise\n\n        return cfg"
    },
    {
      "chunk_id": 383,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load_config_from_file(self, filename):\n        return self.load_config_from_module_name_or_filename(location=filename)"
    },
    {
      "chunk_id": 384,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def load_config(self):\n        # parse console args\n        parser = self.cfg.parser()\n        args = parser.parse_args()\n\n        # optional settings from apps\n        cfg = self.init(parser, args, args.args)\n\n        # set up import paths and follow symlinks\n        self.chdir()\n\n        # Load up the any app specific configuration\n        if cfg:\n            for k, v in cfg.items():\n                self.cfg.set(k.lower(), v)\n\n        env_args = parser.parse_args(self.cfg.get_cmd_args_from_env())\n\n        if args.config:\n            self.load_config_from_file(args.config)\n        elif env_args.config:\n            self.load_config_from_file(env_args.config)\n        else:\n            default_config = get_default_config_file()\n            if default_config is not None:\n                self.load_config_from_file(default_config)\n\n        # Load up environment configuration\n        for k, v in vars(env_args).items():\n            if v is None:\n                continue\n            if k == \"args\":\n                continue\n            self.cfg.set(k.lower(), v)\n\n        # Lastly, update the configuration with any command line settings.\n        for k, v in vars(args).items():\n            if v is None:\n                continue\n            if k == \"args\":\n                continue\n            self.cfg.set(k.lower(), v)\n\n        # current directory might be changed by the config now\n        # set up import paths and follow symlinks\n        self.chdir()"
    },
    {
      "chunk_id": 385,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/base.py",
      "content": "def run(self):\n        if self.cfg.print_config:\n            print(self.cfg)\n\n        if self.cfg.print_config or self.cfg.check_config:\n            try:\n                self.load()\n            except Exception:\n                msg = \"\\nError while loading the application:\\n\"\n                print(msg, file=sys.stderr)\n                traceback.print_exc()\n                sys.stderr.flush()\n                sys.exit(1)\n            sys.exit(0)\n\n        if self.cfg.spew:\n            debug.spew()\n\n        if self.cfg.daemon:\n            if os.environ.get('NOTIFY_SOCKET'):\n                msg = \"Warning: you shouldn't specify `daemon = True`\" \\\n                      \" when launching by systemd with `Type = notify`\"\n                print(msg, file=sys.stderr, flush=True)\n\n            util.daemonize(self.cfg.enable_stdio_inheritance)\n\n        # set python paths\n        if self.cfg.pythonpath:\n            paths = self.cfg.pythonpath.split(\",\")\n            for path in paths:\n                pythonpath = os.path.abspath(path)\n                if pythonpath not in sys.path:\n                    sys.path.insert(0, pythonpath)\n\n        super().run()"
    },
    {
      "chunk_id": 386,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 387,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "import configparser\nimport os\n\nfrom paste.deploy import loadapp\n\nfrom gunicorn.app.wsgiapp import WSGIApplication\nfrom gunicorn.config import get_default_config_file"
    },
    {
      "chunk_id": 388,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "def get_wsgi_app(config_uri, name=None, defaults=None):\n    if ':' not in config_uri:\n        config_uri = \"config:%s\" % config_uri\n\n    return loadapp(\n        config_uri,\n        name=name,\n        relative_to=os.getcwd(),\n        global_conf=defaults,\n    )"
    },
    {
      "chunk_id": 389,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "def has_logging_config(config_file):\n    parser = configparser.ConfigParser()\n    parser.read([config_file])\n    return parser.has_section('loggers')"
    },
    {
      "chunk_id": 390,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "def serve(app, global_conf, **local_conf):\n    \"\"\"\\\n    A Paste Deployment server runner.\n\n    Example configuration:\n\n        [server:main]\n        use = egg:gunicorn#main\n        host = 127.0.0.1\n        port = 5000\n    \"\"\"\n    config_file = global_conf['__file__']\n    gunicorn_config_file = local_conf.pop('config', None)\n\n    host = local_conf.pop('host', '')\n    port = local_conf.pop('port', '')\n    if host and port:\n        local_conf['bind'] = '%s:%s' % (host, port)\n    elif host:\n        local_conf['bind'] = host.split(',')"
    },
    {
      "chunk_id": 391,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "class PasterServerApplication(WSGIApplication):\n        def load_config(self):\n            self.cfg.set(\"default_proc_name\", config_file)\n\n            if has_logging_config(config_file):\n                self.cfg.set(\"logconfig\", config_file)\n\n            if gunicorn_config_file:\n                self.load_config_from_file(gunicorn_config_file)\n            else:\n                default_gunicorn_config_file = get_default_config_file()\n                if default_gunicorn_config_file is not None:\n                    self.load_config_from_file(default_gunicorn_config_file)\n\n            for k, v in local_conf.items():\n                if v is not None:\n                    self.cfg.set(k.lower(), v)"
    },
    {
      "chunk_id": 392,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "def load(self):\n            return app"
    },
    {
      "chunk_id": 393,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/pasterapp.py",
      "content": "PasterServerApplication().run()"
    },
    {
      "chunk_id": 394,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 395,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "import os\n\nfrom gunicorn.errors import ConfigError\nfrom gunicorn.app.base import Application\nfrom gunicorn import util"
    },
    {
      "chunk_id": 396,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "class WSGIApplication(Application):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.app_uri = None\n\n    def init(self, parser, opts, args):\n        if opts.paste:\n            from .pasterapp import has_logging_config\n\n            config_uri = os.path.abspath(opts.paste)\n            config_file = config_uri.split('#')[0]\n\n            if not os.path.exists(config_file):\n                raise ConfigError(\"%r not found\" % config_file)\n\n            self.cfg.set(\"default_proc_name\", config_file)\n            self.app_uri = config_uri\n\n            if has_logging_config(config_file):\n                self.cfg.set(\"logconfig\", config_file)\n\n            return\n\n        if len(args) > 0:\n            self.cfg.set(\"default_proc_name\", args[0])\n            self.app_uri = args[0]"
    },
    {
      "chunk_id": 397,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "def load_config(self):\n        super().load_config()\n\n        if self.app_uri is None:\n            if self.cfg.wsgi_app is not None:\n                self.app_uri = self.cfg.wsgi_app\n            else:\n                raise ConfigError(\"No application module specified.\")"
    },
    {
      "chunk_id": 398,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "def load_wsgiapp(self):\n        return util.import_app(self.app_uri)"
    },
    {
      "chunk_id": 399,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "def load_pasteapp(self):\n        from .pasterapp import get_wsgi_app\n        return get_wsgi_app(self.app_uri, defaults=self.cfg.paste_global_conf)"
    },
    {
      "chunk_id": 400,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "def load(self):\n        if self.cfg.paste is not None:\n            return self.load_pasteapp()\n        else:\n            return self.load_wsgiapp()"
    },
    {
      "chunk_id": 401,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "def run(prog=None):\n    \"\"\"\\\n    The ``gunicorn`` command line runner for launching Gunicorn with\n    generic WSGI applications.\n    \"\"\"\n    from gunicorn.app.wsgiapp import WSGIApplication\n    WSGIApplication(\"%(prog)s [OPTIONS] [APP_MODULE]\", prog=prog).run()"
    },
    {
      "chunk_id": 402,
      "source": "__internal__/data_repo/gunicorn/gunicorn/app/wsgiapp.py",
      "content": "if __name__ == '__main__':\n    run()"
    },
    {
      "chunk_id": 403,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/__init__.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 404,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/__init__.py",
      "content": "# supported gunicorn workers.\nSUPPORTED_WORKERS = {\n    \"sync\": \"gunicorn.workers.sync.SyncWorker\",\n    \"eventlet\": \"gunicorn.workers.geventlet.EventletWorker\",\n    \"gevent\": \"gunicorn.workers.ggevent.GeventWorker\",\n    \"gevent_wsgi\": \"gunicorn.workers.ggevent.GeventPyWSGIWorker\",\n    \"gevent_pywsgi\": \"gunicorn.workers.ggevent.GeventPyWSGIWorker\",\n    \"tornado\": \"gunicorn.workers.gtornado.TornadoWorker\",\n    \"gthread\": \"gunicorn.workers.gthread.ThreadWorker\",\n}"
    },
    {
      "chunk_id": 405,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\nimport sys\nfrom datetime import datetime\nfrom functools import partial\nimport time\n\ntry:\n    import gevent\nexcept ImportError:\n    raise RuntimeError(\"gevent worker requires gevent 1.4 or higher\")\nelse:\n    from packaging.version import parse as parse_version\n    if parse_version(gevent.__version__) < parse_version('1.4'):\n        raise RuntimeError(\"gevent worker requires gevent 1.4 or higher\")\n\nfrom gevent.pool import Pool\nfrom gevent.server import StreamServer\nfrom gevent import hub, monkey, socket, pywsgi\n\nimport gunicorn\nfrom gunicorn.http.wsgi import base_environ\nfrom gunicorn.sock import ssl_context\nfrom gunicorn.workers.base_async import AsyncWorker\n\nVERSION = \"gevent/%s gunicorn/%s\" % (gevent.__version__, gunicorn.__version__)"
    },
    {
      "chunk_id": 406,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "class GeventWorker(AsyncWorker):\n\n    server_class = None\n    wsgi_handler = None\n\n    def patch(self):\n        monkey.patch_all()\n\n        # patch sockets\n        sockets = []\n        for s in self.sockets:\n            sockets.append(socket.socket(s.FAMILY, socket.SOCK_STREAM,\n                                         fileno=s.sock.detach()))\n        self.sockets = sockets\n\n    def notify(self):\n        super().notify()\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            sys.exit(0)\n\n    def timeout_ctx(self):\n        return gevent.Timeout(self.cfg.keepalive, False)\n\n    def run(self):\n        servers = []\n        ssl_args = {}\n\n        if self.cfg.is_ssl:\n            ssl_args = {\"ssl_context\": ssl_context(self.cfg)}\n\n        for s in self.sockets:\n            s.setblocking(1)\n            pool = Pool(self.worker_connections)\n            if self.server_class is not None:\n                environ = base_environ(self.cfg)\n                environ.update({\n                    \"wsgi.multithread\": True,\n                    \"SERVER_SOFTWARE\": VERSION,\n                })\n                server = self.server_class(\n                    s, application=self.wsgi, spawn=pool, log=self.log,\n                    handler_class=self.wsgi_handler, environ=environ,\n                    **ssl_args)\n            else:\n                hfun = partial(self.handle, s)\n                server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)\n                if self.cfg.workers > 1:\n                    server.max_accept = 1\n\n            server.start()\n            servers.append(server)\n\n        while self.alive:\n            self.notify()\n            gevent.sleep(1.0)\n\n        try:\n            # Stop accepting requests\n            for server in servers:\n                if hasattr(server, 'close'):  # gevent 1.0\n                    server.close()\n                if hasattr(server, 'kill'):  # gevent < 1.0\n                    server.kill()\n\n            # Handle current requests until graceful_timeout\n            ts = time.time()\n            while time.time() - ts <= self.cfg.graceful_timeout:\n                accepting = 0\n                for server in servers:\n                    if server.pool.free_count() != server.pool.size:\n                        accepting += 1\n\n                # if no server is accepting a connection, we can exit\n                if not accepting:\n                    return\n\n                self.notify()\n                gevent.sleep(1.0)\n\n            # Force kill all active the handlers\n            self.log.warning(\"Worker graceful timeout (pid:%s)\", self.pid)\n            for server in servers:\n                server.stop(timeout=1)\n        except Exception:\n            pass\n\n    def handle(self, listener, client, addr):\n        # Connected socket timeout defaults to socket.getdefaulttimeout().\n        # This forces to blocking mode.\n        client.setblocking(1)\n        super().handle(listener, client, addr)\n\n    def handle_request(self, listener_name, req, sock, addr):\n        try:\n            super().handle_request(listener_name, req, sock, addr)\n        except gevent.GreenletExit:\n            pass\n        except SystemExit:\n            pass\n\n    def handle_quit(self, sig, frame):\n        # Move this out of the signal handler so we can use\n        # blocking calls. See #1126\n        gevent.spawn(super().handle_quit, sig, frame)\n\n    def handle_usr1(self, sig, frame):\n        # Make the gevent workers handle the usr1 signal\n        # by deferring to a new greenlet. See #1645\n        gevent.spawn(super().handle_usr1, sig, frame)\n\n    def init_process(self):\n        self.patch()\n        hub.reinit()\n        super().init_process()"
    },
    {
      "chunk_id": 407,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "class GeventResponse:\n\n    status = None\n    headers = None\n    sent = None\n\n    def __init__(self, status, headers, clength):\n        self.status = status\n        self.headers = headers\n        self.sent = clength"
    },
    {
      "chunk_id": 408,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "class PyWSGIHandler(pywsgi.WSGIHandler):\n\n    def log_request(self):\n        start = datetime.fromtimestamp(self.time_start)\n        finish = datetime.fromtimestamp(self.time_finish)\n        response_time = finish - start\n        resp_headers = getattr(self, 'response_headers', {})\n\n        # Status is expected to be a string but is encoded to bytes in gevent for PY3\n        # Except when it isn't because gevent uses hardcoded strings for network errors.\n        status = self.status.decode() if isinstance(self.status, bytes) else self.status\n        resp = GeventResponse(status, resp_headers, self.response_length)\n        if hasattr(self, 'headers'):\n            req_headers = self.headers.items()\n        else:\n            req_headers = []\n        self.server.log.access(resp, req_headers, self.environ, response_time)\n\n    def get_environ(self):\n        env = super().get_environ()\n        env['gunicorn.sock'] = self.socket\n        env['RAW_URI'] = self.path\n        return env"
    },
    {
      "chunk_id": 409,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "class PyWSGIServer(pywsgi.WSGIServer):\n    pass"
    },
    {
      "chunk_id": 410,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/ggevent.py",
      "content": "class GeventPyWSGIWorker(GeventWorker):\n    \"The Gevent StreamServer based workers.\"\n    server_class = PyWSGIServer\n    wsgi_handler = PyWSGIHandler"
    },
    {
      "chunk_id": 411,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 412,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "import io\nimport os\nimport signal\nimport sys\nimport time\nimport traceback\nfrom datetime import datetime\nfrom random import randint\nfrom ssl import SSLError\n\nfrom gunicorn import util\nfrom gunicorn.http.errors import (\n    ForbiddenProxyRequest, InvalidHeader,\n    InvalidHeaderName, InvalidHTTPVersion,\n    InvalidProxyLine, InvalidRequestLine,\n    InvalidRequestMethod, InvalidSchemeHeaders,\n    LimitRequestHeaders, LimitRequestLine,\n    UnsupportedTransferCoding,\n    ConfigurationProblem, ObsoleteFolding,\n)\nfrom gunicorn.http.wsgi import Response, default_environ\nfrom gunicorn.reloader import reloader_engines\nfrom gunicorn.workers.workertmp import WorkerTmp"
    },
    {
      "chunk_id": 413,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "class Worker:\n\n    SIGNALS = [getattr(signal, \"SIG%s\" % x) for x in (\n        \"ABRT HUP QUIT INT TERM USR1 USR2 WINCH CHLD\".split()\n    )]\n\n    PIPE = []\n\n    def __init__(self, age, ppid, sockets, app, timeout, cfg, log):\n        \"\"\"\\\n        This is called pre-fork so it shouldn't do anything to the\n        current process. If there's a need to make process wide\n        changes you'll want to do that in ``self.init_process()``.\n        \"\"\"\n        self.age = age\n        self.pid = \"[booting]\"\n        self.ppid = ppid\n        self.sockets = sockets\n        self.app = app\n        self.timeout = timeout\n        self.cfg = cfg\n        self.booted = False\n        self.aborted = False\n        self.reloader = None\n\n        self.nr = 0\n\n        if cfg.max_requests > 0:\n            jitter = randint(0, cfg.max_requests_jitter)\n            self.max_requests = cfg.max_requests + jitter\n        else:\n            self.max_requests = sys.maxsize\n\n        self.alive = True\n        self.log = log\n        self.tmp = WorkerTmp(cfg)\n\n    def __str__(self):\n        return \"<Worker %s>\" % self.pid"
    },
    {
      "chunk_id": 414,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def notify(self):\n        \"\"\"\\\n        Your worker subclass must arrange to have this method called\n        once every ``self.timeout`` seconds. If you fail in accomplishing\n        this task, the master process will murder your workers.\n        \"\"\"\n        self.tmp.notify()"
    },
    {
      "chunk_id": 415,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def run(self):\n        \"\"\"\\\n        This is the mainloop of a worker process. You should override\n        this method in a subclass to provide the intended behaviour\n        for your particular evil schemes.\n        \"\"\"\n        raise NotImplementedError()"
    },
    {
      "chunk_id": 416,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def init_process(self):\n        \"\"\"\\\n        If you override this method in a subclass, the last statement\n        in the function should be to call this method with\n        super().init_process() so that the ``run()`` loop is initiated.\n        \"\"\"\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        util.set_owner_process(self.cfg.uid, self.cfg.gid,\n                               initgroups=self.cfg.initgroups)\n\n        # Reseed the random number generator\n        util.seed()\n\n        # For waking ourselves up\n        self.PIPE = os.pipe()\n        for p in self.PIPE:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        # Prevent fd inheritance\n        for s in self.sockets:\n            util.close_on_exec(s)\n        util.close_on_exec(self.tmp.fileno())\n\n        self.wait_fds = self.sockets + [self.PIPE[0]]\n\n        self.log.close_on_exec()\n\n        self.init_signals()\n\n        # start the reloader\n        if self.cfg.reload:\n            def changed(fname):\n                self.log.info(\"Worker reloading: %s modified\", fname)\n                self.alive = False\n                os.write(self.PIPE[1], b\"1\")\n                self.cfg.worker_int(self)\n                time.sleep(0.1)\n                sys.exit(0)\n\n            reloader_cls = reloader_engines[self.cfg.reload_engine]\n            self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,\n                                         callback=changed)\n\n        self.load_wsgi()\n        if self.reloader:\n            self.reloader.start()\n\n        self.cfg.post_worker_init(self)\n\n        # Enter main run loop\n        self.booted = True\n        self.run()"
    },
    {
      "chunk_id": 417,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def load_wsgi(self):\n        try:\n            self.wsgi = self.app.wsgi()\n        except SyntaxError as e:\n            if not self.cfg.reload:\n                raise\n\n            self.log.exception(e)\n\n            # fix from PR #1228\n            # storing the traceback into exc_tb will create a circular reference.\n            # per https://docs.python.org/2/library/sys.html#sys.exc_info warning,\n            # delete the traceback after use.\n            try:\n                _, exc_val, exc_tb = sys.exc_info()\n                self.reloader.add_extra_file(exc_val.filename)\n\n                tb_string = io.StringIO()\n                traceback.print_tb(exc_tb, file=tb_string)\n                self.wsgi = util.make_fail_app(tb_string.getvalue())\n            finally:\n                del exc_tb"
    },
    {
      "chunk_id": 418,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def init_signals(self):\n        # reset signaling\n        for s in self.SIGNALS:\n            signal.signal(s, signal.SIG_DFL)\n        # init new signaling\n        signal.signal(signal.SIGQUIT, self.handle_quit)\n        signal.signal(signal.SIGTERM, self.handle_exit)\n        signal.signal(signal.SIGINT, self.handle_quit)\n        signal.signal(signal.SIGWINCH, self.handle_winch)\n        signal.signal(signal.SIGUSR1, self.handle_usr1)\n        signal.signal(signal.SIGABRT, self.handle_abort)\n\n        # Don't let SIGTERM and SIGUSR1 disturb active requests\n        # by interrupting system calls\n        signal.siginterrupt(signal.SIGTERM, False)\n        signal.siginterrupt(signal.SIGUSR1, False)\n\n        if hasattr(signal, 'set_wakeup_fd'):\n            signal.set_wakeup_fd(self.PIPE[1])"
    },
    {
      "chunk_id": 419,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_usr1(self, sig, frame):\n        self.log.reopen_files()"
    },
    {
      "chunk_id": 420,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_exit(self, sig, frame):\n        self.alive = False"
    },
    {
      "chunk_id": 421,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_quit(self, sig, frame):\n        self.alive = False\n        # worker_int callback\n        self.cfg.worker_int(self)\n        time.sleep(0.1)\n        sys.exit(0)"
    },
    {
      "chunk_id": 422,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_abort(self, sig, frame):\n        self.alive = False\n        self.cfg.worker_abort(self)\n        sys.exit(1)"
    },
    {
      "chunk_id": 423,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_error(self, req, client, addr, exc):\n        request_start = datetime.now()\n        addr = addr or ('', -1)  # unix socket case\n        if isinstance(exc, (\n            InvalidRequestLine, InvalidRequestMethod,\n            InvalidHTTPVersion, InvalidHeader, InvalidHeaderName,\n            LimitRequestLine, LimitRequestHeaders,\n            InvalidProxyLine, ForbiddenProxyRequest,\n            InvalidSchemeHeaders, UnsupportedTransferCoding,\n            ConfigurationProblem, ObsoleteFolding,\n            SSLError,\n        )):\n\n            status_int = 400\n            reason = \"Bad Request\"\n\n            if isinstance(exc, InvalidRequestLine):\n                mesg = \"Invalid Request Line '%s'\" % str(exc)\n            elif isinstance(exc, InvalidRequestMethod):\n                mesg = \"Invalid Method '%s'\" % str(exc)\n            elif isinstance(exc, InvalidHTTPVersion):\n                mesg = \"Invalid HTTP Version '%s'\" % str(exc)\n            elif isinstance(exc, UnsupportedTransferCoding):\n                mesg = \"%s\" % str(exc)\n                status_int = 501\n            elif isinstance(exc, ConfigurationProblem):\n                mesg = \"%s\" % str(exc)\n                status_int = 500\n            elif isinstance(exc, ObsoleteFolding):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, (InvalidHeaderName, InvalidHeader,)):\n                mesg = \"%s\" % str(exc)\n                if not req and hasattr(exc, \"req\"):\n                    req = exc.req  # for access log\n            elif isinstance(exc, LimitRequestLine):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, LimitRequestHeaders):\n                reason = \"Request Header Fields Too Large\"\n                mesg = \"Error parsing headers: '%s'\" % str(exc)\n                status_int = 431\n            elif isinstance(exc, InvalidProxyLine):\n                mesg = \"'%s'\" % str(exc)\n            elif isinstance(exc, ForbiddenProxyRequest):\n                reason = \"Forbidden\"\n                mesg = \"Request forbidden\"\n                status_int = 403\n            elif isinstance(exc, InvalidSchemeHeaders):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, SSLError):\n                reason = \"Forbidden\"\n                mesg = \"'%s'\" % str(exc)\n                status_int = 403\n\n            msg = \"Invalid request from ip={ip}: {error}\"\n            self.log.warning(msg.format(ip=addr[0], error=str(exc)))\n        else:\n            if hasattr(req, \"uri\"):\n                self.log.exception(\"Error handling request %s\", req.uri)\n            else:\n                self.log.exception(\"Error handling request (no URI read)\")\n            status_int = 500\n            reason = \"Internal Server Error\"\n            mesg = \"\"\n\n        if req is not None:\n            request_time = datetime.now() - request_start\n            environ = default_environ(req, client, self.cfg)\n            environ['REMOTE_ADDR'] = addr[0]\n            environ['REMOTE_PORT'] = str(addr[1])\n            resp = Response(req, client, self.cfg)\n            resp.status = \"%s %s\" % (status_int, reason)\n            resp.response_length = len(mesg)\n            self.log.access(resp, req, environ, request_time)\n\n        try:\n            util.write_error(client, status_int, reason, mesg)\n        except Exception:\n            self.log.debug(\"Failed to send error message.\")"
    },
    {
      "chunk_id": 424,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base.py",
      "content": "def handle_winch(self, sig, fname):\n        # Ignore SIGWINCH in worker. Fixes a crash on OpenBSD.\n        self.log.debug(\"worker: SIGWINCH ignored.\")"
    },
    {
      "chunk_id": 425,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 426,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "from functools import partial\nimport sys\n\ntry:\n    import eventlet\nexcept ImportError:\n    raise RuntimeError(\"eventlet worker requires eventlet 0.24.1 or higher\")\nelse:\n    from packaging.version import parse as parse_version\n    if parse_version(eventlet.__version__) < parse_version('0.24.1'):\n        raise RuntimeError(\"eventlet worker requires eventlet 0.24.1 or higher\")\n\nfrom eventlet import hubs, greenthread\nfrom eventlet.greenio import GreenSocket\nimport eventlet.wsgi\nimport greenlet\n\nfrom gunicorn.workers.base_async import AsyncWorker\nfrom gunicorn.sock import ssl_wrap_socket\n\n# ALREADY_HANDLED is removed in 0.30.3+ now it's `WSGI_LOCAL.already_handled: bool`\n# https://github.com/eventlet/eventlet/pull/544\nEVENTLET_WSGI_LOCAL = getattr(eventlet.wsgi, \"WSGI_LOCAL\", None)\nEVENTLET_ALREADY_HANDLED = getattr(eventlet.wsgi, \"ALREADY_HANDLED\", None)"
    },
    {
      "chunk_id": 427,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "def _eventlet_socket_sendfile(self, file, offset=0, count=None):\n    # Based on the implementation in gevent which in turn is slightly\n    # modified from the standard library implementation.\n    if self.gettimeout() == 0:\n        raise ValueError(\"non-blocking sockets are not supported\")\n    if offset:\n        file.seek(offset)\n    blocksize = min(count, 8192) if count else 8192\n    total_sent = 0\n    # localize variable access to minimize overhead\n    file_read = file.read\n    sock_send = self.send\n    try:\n        while True:\n            if count:\n                blocksize = min(count - total_sent, blocksize)\n                if blocksize <= 0:\n                    break\n            data = memoryview(file_read(blocksize))\n            if not data:\n                break  # EOF\n            while True:\n                try:\n                    sent = sock_send(data)\n                except BlockingIOError:\n                    continue\n                else:\n                    total_sent += sent\n                    if sent < len(data):\n                        data = data[sent:]\n                    else:\n                        break\n        return total_sent\n    finally:\n        if total_sent > 0 and hasattr(file, 'seek'):\n            file.seek(offset + total_sent)"
    },
    {
      "chunk_id": 428,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "def _eventlet_serve(sock, handle, concurrency):\n    \"\"\"\n    Serve requests forever.\n\n    This code is nearly identical to ``eventlet.convenience.serve`` except\n    that it attempts to join the pool at the end, which allows for gunicorn\n    graceful shutdowns.\n    \"\"\"\n    pool = eventlet.greenpool.GreenPool(concurrency)\n    server_gt = eventlet.greenthread.getcurrent()\n\n    while True:\n        try:\n            conn, addr = sock.accept()\n            gt = pool.spawn(handle, conn, addr)\n            gt.link(_eventlet_stop, server_gt, conn)\n            conn, addr, gt = None, None, None\n        except eventlet.StopServe:\n            sock.close()\n            pool.waitall()\n            return"
    },
    {
      "chunk_id": 429,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "def _eventlet_stop(client, server, conn):\n    \"\"\"\n    Stop a greenlet handling a request and close its connection.\n\n    This code is lifted from eventlet so as not to depend on undocumented\n    functions in the library.\n    \"\"\"\n    try:\n        try:\n            client.wait()\n        finally:\n            conn.close()\n    except greenlet.GreenletExit:\n        pass\n    except Exception:\n        greenthread.kill(server, *sys.exc_info())"
    },
    {
      "chunk_id": 430,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "def patch_sendfile():\n    # As of eventlet 0.25.1, GreenSocket.sendfile doesn't exist,\n    # meaning the native implementations of socket.sendfile will be used.\n    # If os.sendfile exists, it will attempt to use that, failing explicitly\n    # if the socket is in non-blocking mode, which the underlying\n    # socket object /is/. Even the regular _sendfile_use_send will\n    # fail in that way; plus, it would use the underlying socket.send which isn't\n    # properly cooperative. So we have to monkey-patch a working socket.sendfile()\n    # into GreenSocket; in this method, `self.send` will be the GreenSocket's\n    # send method which is properly cooperative.\n    if not hasattr(GreenSocket, 'sendfile'):\n        GreenSocket.sendfile = _eventlet_socket_sendfile"
    },
    {
      "chunk_id": 431,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/geventlet.py",
      "content": "class EventletWorker(AsyncWorker):\n\n    def patch(self):\n        hubs.use_hub()\n        eventlet.monkey_patch()\n        patch_sendfile()\n\n    def is_already_handled(self, respiter):\n        # eventlet >= 0.30.3\n        if getattr(EVENTLET_WSGI_LOCAL, \"already_handled\", None):\n            raise StopIteration()\n        # eventlet < 0.30.3\n        if respiter == EVENTLET_ALREADY_HANDLED:\n            raise StopIteration()\n        return super().is_already_handled(respiter)\n\n    def init_process(self):\n        self.patch()\n        super().init_process()\n\n    def handle_quit(self, sig, frame):\n        eventlet.spawn(super().handle_quit, sig, frame)\n\n    def handle_usr1(self, sig, frame):\n        eventlet.spawn(super().handle_usr1, sig, frame)\n\n    def timeout_ctx(self):\n        return eventlet.Timeout(self.cfg.keepalive or None, False)\n\n    def handle(self, listener, client, addr):\n        if self.cfg.is_ssl:\n            client = ssl_wrap_socket(client, self.cfg)\n        super().handle(listener, client, addr)\n\n    def run(self):\n        acceptors = []\n        for sock in self.sockets:\n            gsock = GreenSocket(sock)\n            gsock.setblocking(1)\n            hfun = partial(self.handle, gsock)\n            acceptor = eventlet.spawn(_eventlet_serve, gsock, hfun,\n                                      self.worker_connections)\n\n            acceptors.append(acceptor)\n            eventlet.sleep(0.0)\n\n        while self.alive:\n            self.notify()\n            eventlet.sleep(1.0)\n\n        self.notify()\n        t = None\n        try:\n            with eventlet.Timeout(self.cfg.graceful_timeout) as t:\n                for a in acceptors:\n                    a.kill(eventlet.StopServe())\n                for a in acceptors:\n                    a.wait()\n        except eventlet.Timeout as te:\n            if te != t:\n                raise\n            for a in acceptors:\n                a.kill()"
    },
    {
      "chunk_id": 432,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "import os\nimport time\nimport platform\nimport tempfile\n\nfrom gunicorn import util\n\nPLATFORM = platform.system()\nIS_CYGWIN = PLATFORM.startswith('CYGWIN')"
    },
    {
      "chunk_id": 433,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "class WorkerTmp:\n\n    def __init__(self, cfg):\n        old_umask = os.umask(cfg.umask)\n        fdir = cfg.worker_tmp_dir\n        if fdir and not os.path.isdir(fdir):\n            raise RuntimeError(\"%s doesn't exist. Can't create workertmp.\" % fdir)\n        fd, name = tempfile.mkstemp(prefix=\"wgunicorn-\", dir=fdir)\n        os.umask(old_umask)\n\n        # change the owner and group of the file if the worker will run as\n        # a different user or group, so that the worker can modify the file\n        if cfg.uid != os.geteuid() or cfg.gid != os.getegid():\n            util.chown(name, cfg.uid, cfg.gid)\n\n        # unlink the file so we don't leak temporary files\n        try:\n            if not IS_CYGWIN:\n                util.unlink(name)\n            # In Python 3.8, open() emits RuntimeWarning if buffering=1 for binary mode.\n            # Because we never write to this file, pass 0 to switch buffering off.\n            self._tmp = os.fdopen(fd, 'w+b', 0)\n        except Exception:\n            os.close(fd)\n            raise"
    },
    {
      "chunk_id": 434,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "def notify(self):\n        new_time = time.monotonic()\n        os.utime(self._tmp.fileno(), (new_time, new_time))"
    },
    {
      "chunk_id": 435,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "def last_update(self):\n        return os.fstat(self._tmp.fileno()).st_mtime"
    },
    {
      "chunk_id": 436,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "def fileno(self):\n        return self._tmp.fileno()"
    },
    {
      "chunk_id": 437,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/workertmp.py",
      "content": "def close(self):\n        return self._tmp.close()"
    },
    {
      "chunk_id": 438,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "from datetime import datetime\nimport errno\nimport os\nimport select\nimport socket\nimport ssl\nimport sys\n\nfrom gunicorn import http\nfrom gunicorn.http import wsgi\nfrom gunicorn import sock\nfrom gunicorn import util\nfrom gunicorn.workers import base"
    },
    {
      "chunk_id": 439,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "class StopWaiting(Exception):\n    \"\"\" exception raised to stop waiting for a connection \"\"\""
    },
    {
      "chunk_id": 440,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "class SyncWorker(base.Worker):\n\n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 441,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def accept(self, listener):\n        client, addr = listener.accept()\n        client.setblocking(1)\n        util.close_on_exec(client)\n        self.handle(listener, client, addr)"
    },
    {
      "chunk_id": 442,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def wait(self, timeout):\n        try:\n            self.notify()\n            ret = select.select(self.wait_fds, [], [], timeout)\n            if ret[0]:\n                if self.PIPE[0] in ret[0]:\n                    os.read(self.PIPE[0], 1)\n                return ret[0]\n\n        except OSError as e:\n            if e.args[0] == errno.EINTR:\n                return self.sockets\n            if e.args[0] == errno.EBADF:\n                if self.nr < 0:\n                    return self.sockets\n                else:\n                    raise StopWaiting\n            raise"
    },
    {
      "chunk_id": 443,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def is_parent_alive(self):\n        # If our parent changed then we shut down.\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            return False\n        return True"
    },
    {
      "chunk_id": 444,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def run_for_one(self, timeout):\n        listener = self.sockets[0]\n        while self.alive:\n            self.notify()\n\n            # Accept a connection. If we get an error telling us\n            # that no connection is waiting we fall down to the\n            # select which is where we'll wait for a bit for new\n            # workers to come give us some love.\n            try:\n                self.accept(listener)\n                # Keep processing clients until no one is waiting. This\n                # prevents the need to select() for every client that we\n                # process.\n                continue\n\n            except OSError as e:\n                if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                   errno.EWOULDBLOCK):\n                    raise\n\n            if not self.is_parent_alive():\n                return\n\n            try:\n                self.wait(timeout)\n            except StopWaiting:\n                return"
    },
    {
      "chunk_id": 445,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def run_for_multiple(self, timeout):\n        while self.alive:\n            self.notify()\n\n            try:\n                ready = self.wait(timeout)\n            except StopWaiting:\n                return\n\n            if ready is not None:\n                for listener in ready:\n                    if listener == self.PIPE[0]:\n                        continue\n\n                    try:\n                        self.accept(listener)\n                    except OSError as e:\n                        if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                           errno.EWOULDBLOCK):\n                            raise\n\n            if not self.is_parent_alive():\n                return"
    },
    {
      "chunk_id": 446,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def run(self):\n        # if no timeout is given the worker will never wait and will\n        # use the CPU for nothing. This minimal timeout prevent it.\n        timeout = self.timeout or 0.5\n\n        # self.socket appears to lose its blocking status after\n        # we fork in the arbiter. Reset it here.\n        for s in self.sockets:\n            s.setblocking(0)\n\n        if len(self.sockets) > 1:\n            self.run_for_multiple(timeout)\n        else:\n            self.run_for_one(timeout)"
    },
    {
      "chunk_id": 447,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def handle(self, listener, client, addr):\n        req = None\n        try:\n            if self.cfg.is_ssl:\n                client = sock.ssl_wrap_socket(client, self.cfg)\n            parser = http.RequestParser(self.cfg, client, addr)\n            req = next(parser)\n            self.handle_request(listener, req, client, addr)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except BaseException as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)"
    },
    {
      "chunk_id": 448,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/sync.py",
      "content": "def handle_request(self, listener, req, client, addr):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, client, addr,\n                                        listener.getsockname(), self.cfg)\n            # Force the connection closed until someone shows\n            # a buffering proxy that supports Keep-Alive to\n            # the backend.\n            resp.force_close()\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                self.log.info(\"Autorestarting worker after current request.\")\n                self.alive = False\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n        except OSError:\n            # pass to next try-except level\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    client.shutdown(socket.SHUT_RDWR)\n                    client.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")"
    },
    {
      "chunk_id": 449,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom datetime import datetime\nimport errno\nimport socket\nimport ssl\nimport sys\n\nfrom gunicorn import http\nfrom gunicorn.http import wsgi\nfrom gunicorn import util\nfrom gunicorn.workers import base\n\nALREADY_HANDLED = object()"
    },
    {
      "chunk_id": 450,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "class AsyncWorker(base.Worker):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.worker_connections = self.cfg.worker_connections"
    },
    {
      "chunk_id": 451,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "def timeout_ctx(self):\n        raise NotImplementedError()"
    },
    {
      "chunk_id": 452,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "def is_already_handled(self, respiter):\n        # some workers will need to overload this function to raise a StopIteration\n        return respiter == ALREADY_HANDLED"
    },
    {
      "chunk_id": 453,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "def handle(self, listener, client, addr):\n        req = None\n        try:\n            parser = http.RequestParser(self.cfg, client, addr)\n            try:\n                listener_name = listener.getsockname()\n                if not self.cfg.keepalive:\n                    req = next(parser)\n                    self.handle_request(listener_name, req, client, addr)\n                else:\n                    # keepalive loop\n                    proxy_protocol_info = {}\n                    while True:\n                        req = None\n                        with self.timeout_ctx():\n                            req = next(parser)\n                        if not req:\n                            break\n                        if req.proxy_protocol_info:\n                            proxy_protocol_info = req.proxy_protocol_info\n                        else:\n                            req.proxy_protocol_info = proxy_protocol_info\n                        self.handle_request(listener_name, req, client, addr)\n            except http.errors.NoMoreData as e:\n                self.log.debug(\"Ignored premature client disconnection. %s\", e)\n            except StopIteration as e:\n                self.log.debug(\"Closing connection. %s\", e)\n            except ssl.SSLError:\n                # pass to next try-except level\n                util.reraise(*sys.exc_info())\n            except OSError:\n                # pass to next try-except level\n                util.reraise(*sys.exc_info())\n            except Exception as e:\n                self.handle_error(req, client, addr, e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except BaseException as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)"
    },
    {
      "chunk_id": 454,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/base_async.py",
      "content": "def handle_request(self, listener_name, req, sock, addr):\n        request_start = datetime.now()\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            resp, environ = wsgi.create(req, sock, addr,\n                                        listener_name, self.cfg)\n            environ[\"wsgi.multithread\"] = True\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                if self.alive:\n                    self.log.info(\"Autorestarting worker after current request.\")\n                    self.alive = False\n\n            if not self.alive or not self.cfg.keepalive:\n                resp.force_close()\n\n            respiter = self.wsgi(environ, resp.start_response)\n            if self.is_already_handled(respiter):\n                return False\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n            if resp.should_close():\n                raise StopIteration()\n        except StopIteration:\n            raise\n        except OSError:\n            # If the original exception was a socket.error we delegate\n            # handling it to the caller (where handle() might ignore it)\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    sock.shutdown(socket.SHUT_RDWR)\n                    sock.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n        return True"
    },
    {
      "chunk_id": 455,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "import os\nimport sys\n\ntry:\n    import tornado\nexcept ImportError:\n    raise RuntimeError(\"You need tornado installed to use this worker.\")\nimport tornado.web\nimport tornado.httpserver\nfrom tornado.ioloop import IOLoop, PeriodicCallback\nfrom tornado.wsgi import WSGIContainer\nfrom gunicorn.workers.base import Worker\nfrom gunicorn import __version__ as gversion\nfrom gunicorn.sock import ssl_context\n\nTORNADO5 = tornado.version_info >= (5, 0, 0)"
    },
    {
      "chunk_id": 456,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "class TornadoWorker(Worker):\n    \"\"\"A worker that uses Tornado as the web server.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    @classmethod\n    def setup(cls):\n        web = sys.modules.pop(\"tornado.web\")\n        old_clear = web.RequestHandler.clear\n\n        def clear(self):\n            old_clear(self)\n            if \"Gunicorn\" not in self._headers[\"Server\"]:\n                self._headers[\"Server\"] += \" (Gunicorn/%s)\" % gversion\n        web.RequestHandler.clear = clear\n        sys.modules[\"tornado.web\"] = web"
    },
    {
      "chunk_id": 457,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def handle_exit(self, sig, frame):\n        if self.alive:\n            super().handle_exit(sig, frame)"
    },
    {
      "chunk_id": 458,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def handle_request(self):\n        self.nr += 1\n        if self.alive and self.nr >= self.max_requests:\n            self.log.info(\"Autorestarting worker after current request.\")\n            self.alive = False"
    },
    {
      "chunk_id": 459,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def watchdog(self):\n        if self.alive:\n            self.notify()\n\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            self.alive = False"
    },
    {
      "chunk_id": 460,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def heartbeat(self):\n        if not self.alive:\n            if self.server_alive:\n                if hasattr(self, 'server'):\n                    try:\n                        self.server.stop()\n                    except Exception:\n                        pass\n                self.server_alive = False\n            else:\n                if TORNADO5:\n                    for callback in self.callbacks:\n                        callback.stop()\n                    self.ioloop.stop()\n                else:\n                    if not self.ioloop._callbacks:\n                        self.ioloop.stop()"
    },
    {
      "chunk_id": 461,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def init_process(self):\n        IOLoop.clear_current()\n        super().init_process()"
    },
    {
      "chunk_id": 462,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gtornado.py",
      "content": "def run(self):\n        self.ioloop = IOLoop.instance()\n        self.alive = True\n        self.server_alive = False\n\n        if TORNADO5:\n            self.callbacks = []\n            self.callbacks.append(PeriodicCallback(self.watchdog, 1000))\n            self.callbacks.append(PeriodicCallback(self.heartbeat, 1000))\n            for callback in self.callbacks:\n                callback.start()\n        else:\n            PeriodicCallback(self.watchdog, 1000, io_loop=self.ioloop).start()\n            PeriodicCallback(self.heartbeat, 1000, io_loop=self.ioloop).start()\n\n        app = self.wsgi\n\n        if tornado.version_info[0] < 6:\n            if not isinstance(app, tornado.web.Application) or \\\n                    isinstance(app, tornado.wsgi.WSGIApplication):\n                app = WSGIContainer(app)\n        elif not isinstance(app, WSGIContainer) and \\\n                not isinstance(app, tornado.web.Application):\n            app = WSGIContainer(app)\n\n        httpserver = sys.modules[\"tornado.httpserver\"]\n        if hasattr(httpserver, 'HTTPConnection'):\n            old_connection_finish = httpserver.HTTPConnection.finish\n\n            def finish(other):\n                self.handle_request()\n                old_connection_finish(other)\n            httpserver.HTTPConnection.finish = finish\n            sys.modules[\"tornado.httpserver\"] = httpserver\n\n            server_class = tornado.httpserver.HTTPServer\n        else:\n\n            class _HTTPServer(tornado.httpserver.HTTPServer):\n\n                def on_close(instance, server_conn):\n                    self.handle_request()\n                    super().on_close(server_conn)\n\n            server_class = _HTTPServer\n\n        if self.cfg.is_ssl:\n            if TORNADO5:\n                server = server_class(app, ssl_options=ssl_context(self.cfg))\n            else:\n                server = server_class(app, io_loop=self.ioloop,\n                                      ssl_options=ssl_context(self.cfg))\n        else:\n            if TORNADO5:\n                server = server_class(app)\n            else:\n                server = server_class(app, io_loop=self.ioloop)\n\n        self.server = server\n        self.server_alive = True\n\n        for s in self.sockets:\n            s.setblocking(0)\n            if hasattr(server, \"add_socket\"):  # tornado > 2.0\n                server.add_socket(s)\n            elif hasattr(server, \"_sockets\"):  # tornado 2.0\n                server._sockets[s.fileno()] = s\n\n        server.no_keep_alive = self.cfg.keepalive <= 0\n        server.start(num_processes=1)\n\n        self.ioloop.start()"
    },
    {
      "chunk_id": 463,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "from concurrent import futures\nimport errno\nimport os\nimport selectors\nimport socket\nimport ssl\nimport sys\nimport time\nfrom collections import deque\nfrom datetime import datetime\nfrom functools import partial\nfrom threading import RLock\n\nfrom . import base\nfrom .. import http\nfrom .. import util\nfrom .. import sock\nfrom ..http import wsgi"
    },
    {
      "chunk_id": 464,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "class TConn:\n\n    def __init__(self, cfg, sock, client, server):\n        self.cfg = cfg\n        self.sock = sock\n        self.client = client\n        self.server = server\n\n        self.timeout = None\n        self.parser = None\n        self.initialized = False\n\n        # set the socket to non blocking\n        self.sock.setblocking(False)\n\n    def init(self):\n        self.initialized = True\n        self.sock.setblocking(True)\n\n        if self.parser is None:\n            # wrap the socket if needed\n            if self.cfg.is_ssl:\n                self.sock = sock.ssl_wrap_socket(self.sock, self.cfg)\n\n            # initialize the parser\n            self.parser = http.RequestParser(self.cfg, self.sock, self.client)\n\n    def set_timeout(self):\n        # set the timeout\n        self.timeout = time.time() + self.cfg.keepalive\n\n    def close(self):\n        util.close(self.sock)"
    },
    {
      "chunk_id": 465,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "class ThreadWorker(base.Worker):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.worker_connections = self.cfg.worker_connections\n        self.max_keepalived = self.cfg.worker_connections - self.cfg.threads\n        # initialise the pool\n        self.tpool = None\n        self.poller = None\n        self._lock = None\n        self.futures = deque()\n        self._keep = deque()\n        self.nr_conns = 0\n\n    @classmethod\n    def check_config(cls, cfg, log):\n        max_keepalived = cfg.worker_connections - cfg.threads\n\n        if max_keepalived <= 0 and cfg.keepalive:\n            log.warning(\"No keepalived connections can be handled. \" +\n                        \"Check the number of worker connections and threads.\")"
    },
    {
      "chunk_id": 466,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def init_process(self):\n        self.tpool = self.get_thread_pool()\n        self.poller = selectors.DefaultSelector()\n        self._lock = RLock()\n        super().init_process()\n\n    def get_thread_pool(self):\n        \"\"\"Override this method to customize how the thread pool is created\"\"\"\n        return futures.ThreadPoolExecutor(max_workers=self.cfg.threads)"
    },
    {
      "chunk_id": 467,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def handle_quit(self, sig, frame):\n        self.alive = False\n        # worker_int callback\n        self.cfg.worker_int(self)\n        self.tpool.shutdown(False)\n        time.sleep(0.1)\n        sys.exit(0)\n\n    def _wrap_future(self, fs, conn):\n        fs.conn = conn\n        self.futures.append(fs)\n        fs.add_done_callback(self.finish_request)"
    },
    {
      "chunk_id": 468,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def enqueue_req(self, conn):\n        conn.init()\n        # submit the connection to a worker\n        fs = self.tpool.submit(self.handle, conn)\n        self._wrap_future(fs, conn)\n\n    def accept(self, server, listener):\n        try:\n            sock, client = listener.accept()\n            # initialize the connection object\n            conn = TConn(self.cfg, sock, client, server)\n\n            self.nr_conns += 1\n            # wait until socket is readable\n            with self._lock:\n                self.poller.register(conn.sock, selectors.EVENT_READ,\n                                     partial(self.on_client_socket_readable, conn))\n        except OSError as e:\n            if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                               errno.EWOULDBLOCK):\n                raise"
    },
    {
      "chunk_id": 469,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def on_client_socket_readable(self, conn, client):\n        with self._lock:\n            # unregister the client from the poller\n            self.poller.unregister(client)\n\n            if conn.initialized:\n                # remove the connection from keepalive\n                try:\n                    self._keep.remove(conn)\n                except ValueError:\n                    # race condition\n                    return\n\n        # submit the connection to a worker\n        self.enqueue_req(conn)"
    },
    {
      "chunk_id": 470,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def murder_keepalived(self):\n        now = time.time()\n        while True:\n            with self._lock:\n                try:\n                    # remove the connection from the queue\n                    conn = self._keep.popleft()\n                except IndexError:\n                    break\n\n            delta = conn.timeout - now\n            if delta > 0:\n                # add the connection back to the queue\n                with self._lock:\n                    self._keep.appendleft(conn)\n                break\n            else:\n                self.nr_conns -= 1\n                # remove the socket from the poller\n                with self._lock:\n                    try:\n                        self.poller.unregister(conn.sock)\n                    except OSError as e:\n                        if e.errno != errno.EBADF:\n                            raise\n                    except KeyError:\n                        # already removed by the system, continue\n                        pass\n                    except ValueError:\n                        # already removed by the system continue\n                        pass\n\n                # close the socket\n                conn.close()"
    },
    {
      "chunk_id": 471,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def is_parent_alive(self):\n        # If our parent changed then we shut down.\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            return False\n        return True\n\n    def run(self):\n        # init listeners, add them to the event loop\n        for sock in self.sockets:\n            sock.setblocking(False)\n            # a race condition during graceful shutdown may make the listener\n            # name unavailable in the request handler so capture it once here\n            server = sock.getsockname()\n            acceptor = partial(self.accept, server)\n            self.poller.register(sock, selectors.EVENT_READ, acceptor)\n\n        while self.alive:\n            # notify the arbiter we are alive\n            self.notify()\n\n            # can we accept more connections?\n            if self.nr_conns < self.worker_connections:\n                # wait for an event\n                events = self.poller.select(1.0)\n                for key, _ in events:\n                    callback = key.data\n                    callback(key.fileobj)\n\n                # check (but do not wait) for finished requests\n                result = futures.wait(self.futures, timeout=0,\n                                      return_when=futures.FIRST_COMPLETED)\n            else:\n                # wait for a request to finish\n                result = futures.wait(self.futures, timeout=1.0,\n                                      return_when=futures.FIRST_COMPLETED)\n\n            # clean up finished requests\n            for fut in result.done:\n                self.futures.remove(fut)\n\n            if not self.is_parent_alive():\n                break\n\n            # handle keepalive timeouts\n            self.murder_keepalived()\n\n        self.tpool.shutdown(False)\n        self.poller.close()\n\n        for s in self.sockets:\n            s.close()\n\n        futures.wait(self.futures, timeout=self.cfg.graceful_timeout)"
    },
    {
      "chunk_id": 472,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def finish_request(self, fs):\n        if fs.cancelled():\n            self.nr_conns -= 1\n            fs.conn.close()\n            return\n\n        try:\n            (keepalive, conn) = fs.result()\n            # if the connection should be kept alived add it\n            # to the eventloop and record it\n            if keepalive and self.alive:\n                # flag the socket as non blocked\n                conn.sock.setblocking(False)\n\n                # register the connection\n                conn.set_timeout()\n                with self._lock:\n                    self._keep.append(conn)\n\n                    # add the socket to the event loop\n                    self.poller.register(conn.sock, selectors.EVENT_READ,\n                                         partial(self.on_client_socket_readable, conn))\n            else:\n                self.nr_conns -= 1\n                conn.close()\n        except Exception:\n            # an exception happened, make sure to close the\n            # socket.\n            self.nr_conns -= 1\n            fs.conn.close()"
    },
    {
      "chunk_id": 473,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def handle(self, conn):\n        keepalive = False\n        req = None\n        try:\n            req = next(conn.parser)\n            if not req:\n                return (False, conn)\n\n            # handle the request\n            keepalive = self.handle_request(req, conn)\n            if keepalive:\n                return (keepalive, conn)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                conn.sock.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, conn.sock, conn.client, e)\n\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring connection epipe\")\n        except Exception as e:\n            self.handle_error(req, conn.sock, conn.client, e)\n\n        return (False, conn)"
    },
    {
      "chunk_id": 474,
      "source": "__internal__/data_repo/gunicorn/gunicorn/workers/gthread.py",
      "content": "def handle_request(self, req, conn):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, conn.sock, conn.client,\n                                        conn.server, self.cfg)\n            environ[\"wsgi.multithread\"] = True\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                if self.alive:\n                    self.log.info(\"Autorestarting worker after current request.\")\n                    self.alive = False\n                resp.force_close()\n\n            if not self.alive or not self.cfg.keepalive:\n                resp.force_close()\n            elif len(self._keep) >= self.max_keepalived:\n                resp.force_close()\n\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n\n            if resp.should_close():\n                self.log.debug(\"Closing connection.\")\n                return False\n        except OSError:\n            # pass to next try-except level\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    conn.sock.shutdown(socket.SHUT_RDWR)\n                    conn.sock.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n\n        return True"
    },
    {
      "chunk_id": 475,
      "source": "__internal__/data_repo/gunicorn/examples/boot_fail.py",
      "content": "raise RuntimeError(\"Bad app!\")"
    },
    {
      "chunk_id": 476,
      "source": "__internal__/data_repo/gunicorn/examples/boot_fail.py",
      "content": "def app(environ, start_response):\n    assert 1 == 2, \"Shouldn't get here.\""
    },
    {
      "chunk_id": 477,
      "source": "__internal__/data_repo/gunicorn/examples/echo.py",
      "content": "from gunicorn import __version__"
    },
    {
      "chunk_id": 478,
      "source": "__internal__/data_repo/gunicorn/examples/echo.py",
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n\n    if environ['REQUEST_METHOD'].upper() != 'POST':\n        data = b'Hello, World!\\n'\n    else:\n        data = environ['wsgi.input'].read()\n\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n        ('X-Gunicorn-Version', __version__)\n    ]\n    start_response(status, response_headers)\n    return iter([data])"
    },
    {
      "chunk_id": 479,
      "source": "__internal__/data_repo/gunicorn/examples/when_ready.conf.py",
      "content": "import signal\nimport commands\nimport threading\nimport time\n\nmax_mem = 100000"
    },
    {
      "chunk_id": 480,
      "source": "__internal__/data_repo/gunicorn/examples/when_ready.conf.py",
      "content": "class MemoryWatch(threading.Thread):\n    \"\"\"Monitor memory usage of server workers.\"\"\"\n\n    def __init__(self, server, max_mem):\n        super().__init__()\n        self.daemon = True\n        self.server = server\n        self.max_mem = max_mem\n        self.timeout = server.timeout / 2"
    },
    {
      "chunk_id": 481,
      "source": "__internal__/data_repo/gunicorn/examples/when_ready.conf.py",
      "content": "def memory_usage(self, pid):\n        try:\n            out = commands.getoutput(\"ps -o rss -p %s\" % pid)\n        except OSError:\n            return -1\n        used_mem = sum(int(x) for x in out.split('\\n')[1:])\n        return used_mem"
    },
    {
      "chunk_id": 482,
      "source": "__internal__/data_repo/gunicorn/examples/when_ready.conf.py",
      "content": "def run(self):\n        while True:\n            for (pid, worker) in list(self.server.WORKERS.items()):\n                if self.memory_usage(pid) > self.max_mem:\n                    self.server.log.info(\"Pid %s killed (memory usage > %s)\",\n                        pid, self.max_mem)\n                    self.server.kill_worker(pid, signal.SIGTERM)\n            time.sleep(self.timeout)"
    },
    {
      "chunk_id": 483,
      "source": "__internal__/data_repo/gunicorn/examples/when_ready.conf.py",
      "content": "def when_ready(server):\n    mw = MemoryWatch(server, max_mem)\n    mw.start()"
    },
    {
      "chunk_id": 484,
      "source": "__internal__/data_repo/gunicorn/examples/read_django_settings.py",
      "content": "```python\n\"\"\"\nUse this config file in your script like this:\n\n    $ gunicorn project_name.wsgi:application -c read_django_settings.py\n\"\"\"\n```"
    },
    {
      "chunk_id": 485,
      "source": "__internal__/data_repo/gunicorn/examples/read_django_settings.py",
      "content": "```python\nsettings_dict = {}\n```"
    },
    {
      "chunk_id": 486,
      "source": "__internal__/data_repo/gunicorn/examples/read_django_settings.py",
      "content": "```python\nwith open('frameworks/django/testing/testing/settings.py') as f:\n    exec(f.read(), settings_dict)\n```"
    },
    {
      "chunk_id": 487,
      "source": "__internal__/data_repo/gunicorn/examples/read_django_settings.py",
      "content": "```python\nloglevel = 'warning'\nproc_name = 'web-project'\nworkers = 1\n```"
    },
    {
      "chunk_id": 488,
      "source": "__internal__/data_repo/gunicorn/examples/read_django_settings.py",
      "content": "```python\nif settings_dict['DEBUG']:\n    loglevel = 'debug'\n    reload = True\n    proc_name += '_debug'\n```"
    },
    {
      "chunk_id": 489,
      "source": "__internal__/data_repo/gunicorn/examples/bad.py",
      "content": "import tempfile"
    },
    {
      "chunk_id": 490,
      "source": "__internal__/data_repo/gunicorn/examples/bad.py",
      "content": "files = []"
    },
    {
      "chunk_id": 491,
      "source": "__internal__/data_repo/gunicorn/examples/bad.py",
      "content": "def app(environ, start_response):\n    files.append(tempfile.mkstemp())\n    start_response('200 OK', [('Content-type', 'text/plain'), ('Content-length', '2')])\n    return ['ok']"
    },
    {
      "chunk_id": 492,
      "source": "__internal__/data_repo/gunicorn/examples/log_app.py",
      "content": "import logging"
    },
    {
      "chunk_id": 493,
      "source": "__internal__/data_repo/gunicorn/examples/log_app.py",
      "content": "log = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 494,
      "source": "__internal__/data_repo/gunicorn/examples/log_app.py",
      "content": "log.addHandler(logging.StreamHandler())"
    },
    {
      "chunk_id": 495,
      "source": "__internal__/data_repo/gunicorn/examples/log_app.py",
      "content": "def app_factory(global_options, **local_options):\n    return app"
    },
    {
      "chunk_id": 496,
      "source": "__internal__/data_repo/gunicorn/examples/log_app.py",
      "content": "def app(environ, start_response):\n    start_response(\"200 OK\", [])\n    log.debug(\"Hello Debug!\")\n    log.info(\"Hello Info!\")\n    log.warn(\"Hello Warn!\")\n    log.error(\"Hello Error!\")\n    return [b\"Hello World!\\n\"]"
    },
    {
      "chunk_id": 497,
      "source": "__internal__/data_repo/gunicorn/examples/sendfile.py",
      "content": "import os\nfrom wsgiref.validate import validator"
    },
    {
      "chunk_id": 498,
      "source": "__internal__/data_repo/gunicorn/examples/sendfile.py",
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    status = '200 OK'\n    fname = os.path.join(os.path.dirname(__file__), \"hello.txt\")\n    f = open(fname, 'rb')\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n    ]\n    start_response(status, response_headers)\n\n    return environ['wsgi.file_wrapper'](f)"
    },
    {
      "chunk_id": 499,
      "source": "__internal__/data_repo/gunicorn/examples/test.py",
      "content": "from wsgiref.validate import validator\n\nfrom gunicorn import __version__"
    },
    {
      "chunk_id": 500,
      "source": "__internal__/data_repo/gunicorn/examples/test.py",
      "content": "@validator\ndef app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n        ('X-Gunicorn-Version', __version__),\n        ('Foo', 'B\\u00e5r'),  # Foo: B\u00e5r\n    ]\n    start_response(status, response_headers)\n    return iter([data])"
    },
    {
      "chunk_id": 501,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "try:\n    from routes import Mapper\nexcept ImportError:\n    print(\"This example requires Routes to be installed\")"
    },
    {
      "chunk_id": 502,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "from test import app as app1\nfrom test import app as app2"
    },
    {
      "chunk_id": 503,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "class Application:\n    def __init__(self):\n        self.map = Mapper()\n        self.map.connect('app1', '/app1url', app=app1)\n        self.map.connect('app2', '/app2url', app=app2)"
    },
    {
      "chunk_id": 504,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "def __call__(self, environ, start_response):\n        match = self.map.routematch(environ=environ)\n        if not match:\n            return self.error404(environ, start_response)\n        return match[0]['app'](environ, start_response)"
    },
    {
      "chunk_id": 505,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "def error404(self, environ, start_response):\n        html = b\"\"\"\\\n        <html>\n          <head>\n            <title>404 - Not Found</title>\n          </head>\n          <body>\n            <h1>404 - Not Found</h1>\n          </body>\n        </html>\n        \"\"\"\n        headers = [\n            ('Content-Type', 'text/html'),\n            ('Content-Length', str(len(html)))\n        ]\n        start_response('404 Not Found', headers)\n        return [html]"
    },
    {
      "chunk_id": 506,
      "source": "__internal__/data_repo/gunicorn/examples/multiapp.py",
      "content": "app = Application()"
    },
    {
      "chunk_id": 507,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "#!/usr/bin/env python\n#\n# An example of a standalone application using the internal API of Gunicorn.\n#\n#   $ python standalone_app.py\n#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport multiprocessing\n\nimport gunicorn.app.base"
    },
    {
      "chunk_id": 508,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "def number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1"
    },
    {
      "chunk_id": 509,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "def handler_app(environ, start_response):\n    response_body = b'Works fine'\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-Type', 'text/plain'),\n    ]\n\n    start_response(status, response_headers)\n\n    return [response_body]"
    },
    {
      "chunk_id": 510,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "class StandaloneApplication(gunicorn.app.base.BaseApplication):\n\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()"
    },
    {
      "chunk_id": 511,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                  if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)"
    },
    {
      "chunk_id": 512,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "def load(self):\n        return self.application"
    },
    {
      "chunk_id": 513,
      "source": "__internal__/data_repo/gunicorn/examples/standalone_app.py",
      "content": "if __name__ == '__main__':\n    options = {\n        'bind': '%s:%s' % ('127.0.0.1', '8080'),\n        'workers': number_of_workers(),\n    }\n    StandaloneApplication(handler_app, options).run()"
    },
    {
      "chunk_id": 514,
      "source": "__internal__/data_repo/gunicorn/examples/slowclient.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport sys\nimport time"
    },
    {
      "chunk_id": 515,
      "source": "__internal__/data_repo/gunicorn/examples/slowclient.py",
      "content": "def app(environ, start_response):\n    \"\"\"Application which cooperatively pauses 10 seconds before responding\"\"\"\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n    ]\n    sys.stdout.write('request received, pausing 10 seconds')\n    sys.stdout.flush()\n    time.sleep(10)\n    start_response(status, response_headers)\n    return iter([data])"
    },
    {
      "chunk_id": 516,
      "source": "__internal__/data_repo/gunicorn/examples/timeout.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 517,
      "source": "__internal__/data_repo/gunicorn/examples/timeout.py",
      "content": "import sys\nimport time"
    },
    {
      "chunk_id": 518,
      "source": "__internal__/data_repo/gunicorn/examples/timeout.py",
      "content": "def app(environ, start_response):\n    \"\"\"Application which pauses 35 seconds before responding. the worker\n    will timeout in default case.\"\"\"\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n    ]\n    sys.stdout.write('request will timeout')\n    sys.stdout.flush()\n    time.sleep(35)\n    start_response(status, response_headers)\n    return iter([data])"
    },
    {
      "chunk_id": 519,
      "source": "__internal__/data_repo/gunicorn/examples/longpoll.py",
      "content": "import sys\nimport time"
    },
    {
      "chunk_id": 520,
      "source": "__internal__/data_repo/gunicorn/examples/longpoll.py",
      "content": "class TestIter:\n    \"\"\"Class to iterate over lines with a delay.\"\"\"\n\n    def __iter__(self):\n        lines = [b'line 1\\n', b'line 2\\n']\n        for line in lines:\n            yield line\n            time.sleep(20)"
    },
    {
      "chunk_id": 521,
      "source": "__internal__/data_repo/gunicorn/examples/longpoll.py",
      "content": "def app(environ, start_response):\n    \"\"\"Application which cooperatively pauses 20 seconds (needed to surpass normal timeouts) before responding\"\"\"\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Transfer-Encoding', \"chunked\"),\n    ]\n    sys.stdout.write('request received')\n    sys.stdout.flush()\n    start_response(status, response_headers)\n    return TestIter()"
    },
    {
      "chunk_id": 522,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "bind = '127.0.0.1:8000'\nbacklog = 2048"
    },
    {
      "chunk_id": 523,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "workers = 1\nworker_class = 'sync'\nworker_connections = 1000\ntimeout = 30\nkeepalive = 2"
    },
    {
      "chunk_id": 524,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "spew = False"
    },
    {
      "chunk_id": 525,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "daemon = False\nraw_env = [\n    'DJANGO_SECRET_KEY=something',\n    'SPAM=eggs',\n]\npidfile = None\numask = 0\nuser = None\ngroup = None\ntmp_upload_dir = None"
    },
    {
      "chunk_id": 526,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "errorlog = '-'\nloglevel = 'info'\naccesslog = '-'\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'"
    },
    {
      "chunk_id": 527,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "proc_name = None"
    },
    {
      "chunk_id": 528,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def post_fork(server, worker):\n    server.log.info(\"Worker spawned (pid: %s)\", worker.pid)"
    },
    {
      "chunk_id": 529,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def pre_fork(server, worker):\n    pass"
    },
    {
      "chunk_id": 530,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def pre_exec(server):\n    server.log.info(\"Forked child, re-executing.\")"
    },
    {
      "chunk_id": 531,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def when_ready(server):\n    server.log.info(\"Server is ready. Spawning workers\")"
    },
    {
      "chunk_id": 532,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def worker_int(worker):\n    worker.log.info(\"worker received INT or QUIT signal\")\n\n    ## get traceback info\n    import threading, sys, traceback\n    id2name = {th.ident: th.name for th in threading.enumerate()}\n    code = []\n    for threadId, stack in sys._current_frames().items():\n        code.append(\"\\n# Thread: %s(%d)\" % (id2name.get(threadId,\"\"),\n            threadId))\n        for filename, lineno, name, line in traceback.extract_stack(stack):\n            code.append('File: \"%s\", line %d, in %s' % (filename,\n                lineno, name))\n            if line:\n                code.append(\"  %s\" % (line.strip()))\n    worker.log.debug(\"\\n\".join(code))"
    },
    {
      "chunk_id": 533,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def worker_abort(worker):\n    worker.log.info(\"worker received SIGABRT signal\")"
    },
    {
      "chunk_id": 534,
      "source": "__internal__/data_repo/gunicorn/examples/example_config.py",
      "content": "def ssl_context(conf, default_ssl_context_factory):\n    import ssl\n\n    # The default SSLContext returned by the factory function is initialized\n    # with the TLS parameters from config, including TLS certificates and other\n    # parameters.\n    context = default_ssl_context_factory()\n\n    # The SSLContext can be further customized, for example by enforcing\n    # minimum TLS version.\n    context.minimum_version = ssl.TLSVersion.TLSv1_3\n\n    # Server can also return different server certificate depending which\n    # hostname the client uses. Requires Python 3.7 or later.\n    def sni_callback(socket, server_hostname, context):\n        if server_hostname == \"foo.127.0.0.1.nip.io\":\n            new_context = default_ssl_context_factory()\n            new_context.load_cert_chain(certfile=\"foo.pem\", keyfile=\"foo-key.pem\")\n            socket.context = new_context\n\n    context.sni_callback = sni_callback\n\n    return context"
    },
    {
      "chunk_id": 535,
      "source": "__internal__/data_repo/gunicorn/examples/alt_spec.py",
      "content": "#\n# An example of how to pass information from the command line to\n# a WSGI app. Only applies to the native WSGI workers used by\n# Gunicorn sync (default) workers.\n#\n#   $ gunicorn 'alt_spec:load(arg)'\n#\n# Single quoting is generally necessary for shell escape semantics.\n#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information."
    },
    {
      "chunk_id": 536,
      "source": "__internal__/data_repo/gunicorn/examples/alt_spec.py",
      "content": "def load(arg):\n    def app(environ, start_response):\n        data = b'Hello, %s!\\n' % arg\n        status = '200 OK'\n        response_headers = [\n            ('Content-type', 'text/plain'),\n            ('Content-Length', str(len(data)))\n        ]\n        start_response(status, response_headers)\n        return iter([data])\n    return app"
    },
    {
      "chunk_id": 537,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport re"
    },
    {
      "chunk_id": 538,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "class SubDomainApp:\n    \"\"\"WSGI application to delegate requests based on domain name.\n\"\"\"\n    def __init__(self, mapping):\n        self.mapping = mapping"
    },
    {
      "chunk_id": 539,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "def __call__(self, environ, start_response):\n        host = environ.get(\"HTTP_HOST\", \"\")\n        host = host.split(\":\")[0]  # strip port\n\n        for pattern, app in self.mapping:\n            if re.match(\"^\" + pattern + \"$\", host):\n                return app(environ, start_response)\n        else:\n            start_response(\"404 Not Found\", [])\n            return [b\"\"]"
    },
    {
      "chunk_id": 540,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "def hello(environ, start_response):\n    start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])\n    return [b\"Hello, world\\n\"]"
    },
    {
      "chunk_id": 541,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "def bye(environ, start_response):\n    start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])\n    return [b\"Goodbye!\\n\"]"
    },
    {
      "chunk_id": 542,
      "source": "__internal__/data_repo/gunicorn/examples/multidomainapp.py",
      "content": "app = SubDomainApp([\n    (\"localhost\", hello),\n    (\".*\", bye)\n])"
    },
    {
      "chunk_id": 543,
      "source": "__internal__/data_repo/gunicorn/examples/readline_app.py",
      "content": "# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Simple example of readline, reading from a stream then echoing the response\n#\n# Usage:\n#\n# Launch a server with the app in a terminal\n#\n#     $ gunicorn -w3 readline_app:app\n#\n# Then in another terminal launch the following command:\n#\n#     $ curl -XPOST -d'test\\r\\ntest2\\r\\n' -H\"Transfer-Encoding: Chunked\" http://localhost:8000"
    },
    {
      "chunk_id": 544,
      "source": "__internal__/data_repo/gunicorn/examples/readline_app.py",
      "content": "from gunicorn import __version__"
    },
    {
      "chunk_id": 545,
      "source": "__internal__/data_repo/gunicorn/examples/readline_app.py",
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Transfer-Encoding', \"chunked\"),\n        ('X-Gunicorn-Version', __version__)\n    ]\n    start_response(status, response_headers)\n\n    body = environ['wsgi.input']\n\n    lines = []\n    while True:\n        line = body.readline()\n        if line == b\"\":\n            break\n        print(line)\n        lines.append(line)\n\n    return iter(lines)"
    },
    {
      "chunk_id": 546,
      "source": "__internal__/data_repo/gunicorn/examples/deep/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 547,
      "source": "__internal__/data_repo/gunicorn/examples/deep/test.py",
      "content": "from wsgiref.validate import validator\n\nfrom gunicorn import __version__"
    },
    {
      "chunk_id": 548,
      "source": "__internal__/data_repo/gunicorn/examples/deep/test.py",
      "content": "@validator\ndef app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n        ('X-Gunicorn-Version', __version__),\n        ('Foo', 'B\\u00e5r'),  # Foo: B\u00e5r\n    ]\n    start_response(status, response_headers)\n    return iter([data])"
    },
    {
      "chunk_id": 549,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "import collections\nimport errno\nimport re\nfrom hashlib import md5, sha1\nimport base64\nfrom base64 import b64encode, b64decode\nimport socket\nimport struct\nimport logging\nfrom socket import error as SocketError\n\nimport eventlet\nfrom gunicorn.workers.base_async import ALREADY_HANDLED\nfrom eventlet import pools\n\nlogger = logging.getLogger(__name__)\n\nWS_KEY = b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\""
    },
    {
      "chunk_id": 550,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "class WebSocketWSGI:\n    def __init__(self, handler):\n        self.handler = handler\n\n    def verify_client(self, ws):\n        pass\n\n    def _get_key_value(self, key_value):\n        if not key_value:\n            return\n        key_number = int(re.sub(\"\\\\D\", \"\", key_value))\n        spaces = re.subn(\" \", \"\", key_value)[1]\n        if key_number % spaces != 0:\n            return\n        part = key_number / spaces\n        return part\n\n    def __call__(self, environ, start_response):\n        if not (environ.get('HTTP_CONNECTION').find('Upgrade') != -1 and\n            environ['HTTP_UPGRADE'].lower() == 'websocket'):\n            start_response('400 Bad Request', [('Connection','close')])\n            return []\n\n        sock = environ['gunicorn.socket']\n\n        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')\n\n        ws = WebSocket(sock, environ, version)\n\n        handshake_reply = (\"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                   \"Upgrade: websocket\\r\\n\"\n                   \"Connection: Upgrade\\r\\n\")\n\n        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')\n        if key:\n            ws_key = base64.b64decode(key)\n            if len(ws_key) != 16:\n                start_response('400 Bad Request', [('Connection','close')])\n                return []\n\n            protocols = []\n            subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')\n            ws_protocols = []\n            if subprotocols:\n                for s in subprotocols.split(','):\n                    s = s.strip()\n                    if s in protocols:\n                        ws_protocols.append(s)\n            if ws_protocols:\n                handshake_reply += 'Sec-WebSocket-Protocol: %s\\r\\n' % ', '.join(ws_protocols)\n\n            exts = []\n            extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')\n            ws_extensions = []\n            if extensions:\n                for ext in extensions.split(','):\n                    ext = ext.strip()\n                    if ext in exts:\n                        ws_extensions.append(ext)\n            if ws_extensions:\n                handshake_reply += 'Sec-WebSocket-Extensions: %s\\r\\n' % ', '.join(ws_extensions)\n\n            key_hash = sha1()\n            key_hash.update(key.encode())\n            key_hash.update(WS_KEY)\n\n            handshake_reply +=  (\n                \"Sec-WebSocket-Origin: %s\\r\\n\"\n                \"Sec-WebSocket-Location: ws://%s%s\\r\\n\"\n                \"Sec-WebSocket-Version: %s\\r\\n\"\n                \"Sec-WebSocket-Accept: %s\\r\\n\\r\\n\"\n                 % (\n                    environ.get('HTTP_ORIGIN'),\n                    environ.get('HTTP_HOST'),\n                    ws.path,\n                    version,\n                    base64.b64encode(key_hash.digest()).decode()\n                ))\n\n        else:\n\n            handshake_reply += (\n                       \"WebSocket-Origin: %s\\r\\n\"\n                       \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\" % (\n                            environ.get('HTTP_ORIGIN'),\n                            environ.get('HTTP_HOST'),\n                            ws.path))\n\n        sock.sendall(handshake_reply.encode())\n\n        try:\n            self.handler(ws)\n        except BrokenPipeError:\n            pass\n        else:\n            raise\n        return ALREADY_HANDLED"
    },
    {
      "chunk_id": 551,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "class WebSocket:\n    \"\"\"A websocket object that handles the details of\n    serialization/deserialization to the socket.\n\n    The primary way to interact with a :class:`WebSocket` object is to\n    call :meth:`send` and :meth:`wait` in order to pass messages back\n    and forth with the browser.  Also available are the following\n    properties:\n\n    path\n        The path value of the request.  This is the same as the WSGI PATH_INFO variable, but more convenient.\n    protocol\n        The value of the Websocket-Protocol header.\n    origin\n        The value of the 'Origin' header.\n    environ\n        The full WSGI environment for this request.\n\n    \"\"\"\n    def __init__(self, sock, environ, version=76):\n        \"\"\"\n        :param socket: The eventlet socket\n        :type socket: :class:`eventlet.greenio.GreenSocket`\n        :param environ: The wsgi environment\n        :param version: The WebSocket spec version to follow (default is 76)\n        \"\"\"\n        self.socket = sock\n        self.origin = environ.get('HTTP_ORIGIN')\n        self.protocol = environ.get('HTTP_WEBSOCKET_PROTOCOL')\n        self.path = environ.get('PATH_INFO')\n        self.environ = environ\n        self.version = version\n        self.websocket_closed = False\n        self._buf = \"\"\n        self._msgs = collections.deque()\n        self._sendlock = pools.TokenPool(1)"
    },
    {
      "chunk_id": 552,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "@staticmethod\n    def encode_hybi(buf, opcode, base64=False):\n        \"\"\" Encode a HyBi style WebSocket frame.\n        Optional opcode:\n            0x0 - continuation\n            0x1 - text frame (base64 encode buf)\n            0x2 - binary frame (use raw buf)\n            0x8 - connection close\n            0x9 - ping\n            0xA - pong\n        \"\"\"\n        if base64:\n            buf = b64encode(buf)\n        else:\n            buf = buf.encode()\n\n        b1 = 0x80 | (opcode & 0x0f) # FIN + opcode\n        payload_len = len(buf)\n        if payload_len <= 125:\n            header = struct.pack('>BB', b1, payload_len)\n        elif payload_len > 125 and payload_len < 65536:\n            header = struct.pack('>BBH', b1, 126, payload_len)\n        elif payload_len >= 65536:\n            header = struct.pack('>BBQ', b1, 127, payload_len)\n\n        return header + buf, len(header), 0"
    },
    {
      "chunk_id": 553,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "@staticmethod\n    def decode_hybi(buf, base64=False):\n        \"\"\" Decode HyBi style WebSocket packets.\n        Returns:\n            {'fin'          : 0_or_1,\n             'opcode'       : number,\n             'mask'         : 32_bit_number,\n             'hlen'         : header_bytes_number,\n             'length'       : payload_bytes_number,\n             'payload'      : decoded_buffer,\n             'left'         : bytes_left_number,\n             'close_code'   : number,\n             'close_reason' : string}\n        \"\"\"\n\n        f = {'fin'          : 0,\n             'opcode'       : 0,\n             'mask'         : 0,\n             'hlen'         : 2,\n             'length'       : 0,\n             'payload'      : None,\n             'left'         : 0,\n             'close_code'   : None,\n             'close_reason' : None}\n\n        blen = len(buf)\n        f['left'] = blen\n\n        if blen < f['hlen']:\n            return f # Incomplete frame header\n\n        b1, b2 = struct.unpack_from(\">BB\", buf)\n        f['opcode'] = b1 & 0x0f\n        f['fin'] = (b1 & 0x80) >> 7\n        has_mask = (b2 & 0x80) >> 7\n\n        f['length'] = b2 & 0x7f\n\n        if f['length'] == 126:\n            f['hlen'] = 4\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxH', buf)\n        elif f['length'] == 127:\n            f['hlen'] = 10\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxQ', buf)\n\n        full_len = f['hlen'] + has_mask * 4 + f['length']\n\n        if blen < full_len: # Incomplete frame\n            return f # Incomplete frame header\n\n        f['left'] = blen - full_len\n\n        if has_mask:\n            f['mask'] = buf[f['hlen']:f['hlen']+4]\n            b = c = ''\n            if f['length'] >= 4:\n                data = struct.unpack('<I', buf[f['hlen']:f['hlen']+4])[0]\n                of1 = f['hlen']+4\n                b = ''\n                for i in range(0, int(f['length']/4)):\n                    mask = struct.unpack('<I', buf[of1+4*i:of1+4*(i+1)])[0]\n                    b += struct.pack('I', data ^ mask)\n\n            if f['length'] % 4:\n                l = f['length'] % 4\n                of1 = f['hlen']\n                of2 = full_len - l\n                c = ''\n                for i in range(0, l):\n                    mask = struct.unpack('B', buf[of1 + i])[0]\n                    data = struct.unpack('B', buf[of2 + i])[0]\n                    c += chr(data ^ mask)\n\n            f['payload'] = b + c\n        else:\n            f['payload'] = buf[(f['hlen'] + has_mask * 4):full_len]\n\n        if base64 and f['opcode'] in [1, 2]:\n            try:\n                f['payload'] = b64decode(f['payload'])\n            except:\n                raise\n\n        if f['opcode'] == 0x08:\n            if f['length'] >= 2:\n                f['close_code'] = struct.unpack_from(\">H\", f['payload'])\n            if f['length'] > 3:\n                f['close_reason'] = f['payload'][2:]\n\n        return f"
    },
    {
      "chunk_id": 554,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "@staticmethod\n    def _pack_message(message):\n        \"\"\"Pack the message inside ``00`` and ``FF``\n\n        As per the dataframing section (5.3) for the websocket spec\n        \"\"\"\n        if isinstance(message, str):\n            message = message.encode('utf-8')\n        packed = \"\\x00%s\\xFF\" % message\n        return packed"
    },
    {
      "chunk_id": 555,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def _parse_messages(self):\n        \"\"\" Parses for messages in the buffer *buf*.  It is assumed that\n        the buffer contains the start character for a message, but that it\n        may contain only part of the rest of the message.\n\n        Returns an array of messages, and the buffer remainder that\n        didn't contain any full messages.\"\"\"\n        msgs = []\n        end_idx = 0\n        buf = self._buf\n        while buf:\n            if self.version in ['7', '8', '13']:\n                frame = self.decode_hybi(buf, base64=False)\n\n                if frame['payload'] == None:\n                    break\n                else:\n                    if frame['opcode'] == 0x8: # connection close\n                        self.websocket_closed = True\n                        break\n                    else:\n                        msgs.append(frame['payload']);\n                        if frame['left']:\n                            buf = buf[-frame['left']:]\n                        else:\n                            buf = ''\n\n            else:\n                frame_type = ord(buf[0])\n                if frame_type == 0:\n                    end_idx = buf.find(\"\\xFF\")\n                    if end_idx == -1: #pragma NO COVER\n                        break\n                    msgs.append(buf[1:end_idx].decode('utf-8', 'replace'))\n                    buf = buf[end_idx+1:]\n                elif frame_type == 255:\n                    assert ord(buf[1]) == 0, \"Unexpected closing handshake: %r\" % buf\n                    self.websocket_closed = True\n                    break\n                else:\n                    raise ValueError(\"Don't understand how to parse this type of message: %r\" % buf)\n        self._buf = buf\n        return msgs"
    },
    {
      "chunk_id": 556,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def send(self, message):\n        \"\"\"Send a message to the browser.\n\n        *message* should be convertible to a string; unicode objects should be\n        encodable as utf-8.  Raises socket.error with errno of 32\n        (broken pipe) if the socket has already been closed by the client.\"\"\"\n        if self.version in ['7', '8', '13']:\n            packed, lenhead, lentail = self.encode_hybi(message, opcode=0x01, base64=False)\n        else:\n            packed = self._pack_message(message)\n        t = self._sendlock.get()\n        try:\n            self.socket.sendall(packed)\n        finally:\n            self._sendlock.put(t)"
    },
    {
      "chunk_id": 557,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def wait(self):\n        \"\"\"Waits for and deserializes messages.\n\n        Returns a single message; the oldest not yet processed. If the client\n        has already closed the connection, returns None.  This is different\n        from normal socket behavior because the empty string is a valid\n        websocket message.\"\"\"\n        while not self._msgs:\n            if self.websocket_closed:\n                return None\n            delta = self.socket.recv(8096)\n            if delta == b'':\n                return None\n            self._buf += delta\n            msgs = self._parse_messages()\n            self._msgs.extend(msgs)\n        return self._msgs.popleft()"
    },
    {
      "chunk_id": 558,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def _send_closing_frame(self, ignore_send_errors=False):\n        \"\"\"Sends the closing frame to the client, if required.\"\"\"\n        if self.version in ['7', '8', '13'] and not self.websocket_closed:\n            msg = ''\n            buf, h, t = self.encode_hybi(msg, opcode=0x08, base64=False)\n            self.socket.sendall(buf)\n            self.websocket_closed = True\n\n        elif self.version == 76 and not self.websocket_closed:\n            try:\n                self.socket.sendall(b\"\\xff\\x00\")\n            except SocketError:\n                if not ignore_send_errors: #pragma NO COVER\n                    raise\n            self.websocket_closed = True"
    },
    {
      "chunk_id": 559,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def close(self):\n        \"\"\"Forcibly close the websocket; generally it is preferable to\n        return from the handler method.\"\"\"\n        self._send_closing_frame()\n        self.socket.shutdown(True)\n        self.socket.close()"
    },
    {
      "chunk_id": 560,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "import os\nimport random\ndef handle(ws):\n    \"\"\"  This is the websocket handler function.  Note that we\n    can dispatch based on path in here, too.\"\"\"\n    if ws.path == '/echo':\n        while True:\n            m = ws.wait()\n            if m is None:\n                break\n            ws.send(m)\n\n    elif ws.path == '/data':\n        for i in range(10000):\n            ws.send(\"0 %s %s\\n\" % (i, random.random()))\n            eventlet.sleep(0.1)"
    },
    {
      "chunk_id": 561,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "wsapp = WebSocketWSGI(handle)"
    },
    {
      "chunk_id": 562,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/websocket.py",
      "content": "def app(environ, start_response):\n    \"\"\" This resolves to the web page or the websocket depending on\n    the path.\"\"\"\n    if environ['PATH_INFO'] == '/' or environ['PATH_INFO'] == \"\":\n        data = open(os.path.join(\n                     os.path.dirname(__file__),\n                     'websocket.html')).read()\n        data = data % environ\n        start_response('200 OK', [('Content-Type', 'text/html'),\n                                 ('Content-Length', str(len(data)))])\n        return [data.encode()]\n    else:\n        return wsapp(environ, start_response)"
    },
    {
      "chunk_id": 563,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/gevent_websocket.py",
      "content": "import collections\nimport errno\nimport re\nimport hashlib\nimport base64\nfrom base64 import b64encode, b64decode\nimport socket\nimport struct\nimport logging\nfrom socket import error as SocketError\n\nimport gevent\nfrom gunicorn.workers.base_async import ALREADY_HANDLED\n\nlogger = logging.getLogger(__name__)\n\nWS_KEY = b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\""
    },
    {
      "chunk_id": 564,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/gevent_websocket.py",
      "content": "class WebSocketWSGI:\n    def __init__(self, handler):\n        self.handler = handler\n\n    def verify_client(self, ws):\n        pass\n\n    def _get_key_value(self, key_value):\n        if not key_value:\n            return\n        key_number = int(re.sub(\"\\\\D\", \"\", key_value))\n        spaces = re.subn(\" \", \"\", key_value)[1]\n        if key_number % spaces != 0:\n            return\n        part = key_number / spaces\n        return part\n\n    def __call__(self, environ, start_response):\n        if not (environ.get('HTTP_CONNECTION').find('Upgrade') != -1 and\n            environ['HTTP_UPGRADE'].lower() == 'websocket'):\n            start_response('400 Bad Request', [('Connection','close')])\n            return []\n\n        sock = environ['gunicorn.socket']\n\n        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')\n\n        ws = WebSocket(sock, environ, version)\n\n        handshake_reply = (\"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                   \"Upgrade: websocket\\r\\n\"\n                   \"Connection: Upgrade\\r\\n\")\n\n        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')\n        if key:\n            ws_key = base64.b64decode(key)\n            if len(ws_key) != 16:\n                start_response('400 Bad Request', [('Connection','close')])\n                return []\n\n            protocols = []\n            subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')\n            ws_protocols = []\n            if subprotocols:\n                for s in subprotocols.split(','):\n                    s = s.strip()\n                    if s in protocols:\n                        ws_protocols.append(s)\n            if ws_protocols:\n                handshake_reply += 'Sec-WebSocket-Protocol: %s\\r\\n' % ', '.join(ws_protocols)\n\n            exts = []\n            extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')\n            ws_extensions = []\n            if extensions:\n                for ext in extensions.split(','):\n                    ext = ext.strip()\n                    if ext in exts:\n                        ws_extensions.append(ext)\n            if ws_extensions:\n                handshake_reply += 'Sec-WebSocket-Extensions: %s\\r\\n' % ', '.join(ws_extensions)\n\n            key_hash = hashlib.sha1()\n            key_hash.update(key.encode())\n            key_hash.update(WS_KEY)\n\n            handshake_reply +=  (\n                \"Sec-WebSocket-Origin: %s\\r\\n\"\n                \"Sec-WebSocket-Location: ws://%s%s\\r\\n\"\n                \"Sec-WebSocket-Version: %s\\r\\n\"\n                \"Sec-WebSocket-Accept: %s\\r\\n\\r\\n\"\n                 % (\n                    environ.get('HTTP_ORIGIN'),\n                    environ.get('HTTP_HOST'),\n                    ws.path,\n                    version,\n                    base64.b64encode(key_hash.digest()).decode()\n                ))\n\n        else:\n            handshake_reply += (\n                       \"WebSocket-Origin: %s\\r\\n\"\n                       \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\" % (\n                            environ.get('HTTP_ORIGIN'),\n                            environ.get('HTTP_HOST'),\n                            ws.path))\n\n        sock.sendall(handshake_reply.encode())\n\n        try:\n            self.handler(ws)\n        except BrokenPipeError:\n            pass\n        else:\n            raise\n        return ALREADY_HANDLED"
    },
    {
      "chunk_id": 565,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/gevent_websocket.py",
      "content": "class WebSocket:\n    \"\"\"A websocket object that handles the details of\n    serialization/deserialization to the socket.\n\n    The primary way to interact with a :class:`WebSocket` object is to\n    call :meth:`send` and :meth:`wait` in order to pass messages back\n    and forth with the browser.  Also available are the following\n    properties:\n\n    path\n        The path value of the request.  This is the same as the WSGI PATH_INFO variable, but more convenient.\n    protocol\n        The value of the Websocket-Protocol header.\n    origin\n        The value of the 'Origin' header.\n    environ\n        The full WSGI environment for this request.\n\n    \"\"\"\n    def __init__(self, sock, environ, version=76):\n        \"\"\"\n        :param socket: The eventlet socket\n        :type socket: :class:`eventlet.greenio.GreenSocket`\n        :param environ: The wsgi environment\n        :param version: The WebSocket spec version to follow (default is 76)\n        \"\"\"\n        self.socket = sock\n        self.origin = environ.get('HTTP_ORIGIN')\n        self.protocol = environ.get('HTTP_WEBSOCKET_PROTOCOL')\n        self.path = environ.get('PATH_INFO')\n        self.environ = environ\n        self.version = version\n        self.websocket_closed = False\n        self._buf = \"\"\n        self._msgs = collections.deque()\n\n    @staticmethod\n    def encode_hybi(buf, opcode, base64=False):\n        \"\"\" Encode a HyBi style WebSocket frame.\n        Optional opcode:\n            0x0 - continuation\n            0x1 - text frame (base64 encode buf)\n            0x2 - binary frame (use raw buf)\n            0x8 - connection close\n            0x9 - ping\n            0xA - pong\n        \"\"\"\n        if base64:\n            buf = b64encode(buf)\n        else:\n            buf = buf.encode()\n\n        b1 = 0x80 | (opcode & 0x0f) # FIN + opcode\n        payload_len = len(buf)\n        if payload_len <= 125:\n            header = struct.pack('>BB', b1, payload_len)\n        elif payload_len > 125 and payload_len < 65536:\n            header = struct.pack('>BBH', b1, 126, payload_len)\n        elif payload_len >= 65536:\n            header = struct.pack('>BBQ', b1, 127, payload_len)\n\n        return header + buf, len(header), 0\n\n    @staticmethod\n    def decode_hybi(buf, base64=False):\n        \"\"\" Decode HyBi style WebSocket packets.\n        Returns:\n            {'fin'          : 0_or_1,\n             'opcode'       : number,\n             'mask'         : 32_bit_number,\n             'hlen'         : header_bytes_number,\n             'length'       : payload_bytes_number,\n             'payload'      : decoded_buffer,\n             'left'         : bytes_left_number,\n             'close_code'   : number,\n             'close_reason' : string}\n        \"\"\"\n\n        f = {'fin'          : 0,\n             'opcode'       : 0,\n             'mask'         : 0,\n             'hlen'         : 2,\n             'length'       : 0,\n             'payload'      : None,\n             'left'         : 0,\n             'close_code'   : None,\n             'close_reason' : None}\n\n        blen = len(buf)\n        f['left'] = blen\n\n        if blen < f['hlen']:\n            return f # Incomplete frame header\n\n        b1, b2 = struct.unpack_from(\">BB\", buf)\n        f['opcode'] = b1 & 0x0f\n        f['fin'] = (b1 & 0x80) >> 7\n        has_mask = (b2 & 0x80) >> 7\n\n        f['length'] = b2 & 0x7f\n\n        if f['length'] == 126:\n            f['hlen'] = 4\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxH', buf)\n        elif f['length'] == 127:\n            f['hlen'] = 10\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxQ', buf)\n\n        full_len = f['hlen'] + has_mask * 4 + f['length']\n\n        if blen < full_len: # Incomplete frame\n            return f # Incomplete frame header\n\n        f['left'] = blen - full_len\n\n        if has_mask:\n            f['mask'] = buf[f['hlen']:f['hlen']+4]\n            b = c = ''\n            if f['length'] >= 4:\n                data = struct.unpack('<I', buf[f['hlen']:f['hlen']+4])[0]\n                of1 = f['hlen']+4\n                b = ''\n                for i in range(0, int(f['length']/4)):\n                    mask = struct.unpack('<I', buf[of1+4*i:of1+4*(i+1)])[0]\n                    b += struct.pack('I', data ^ mask)\n\n            if f['length'] % 4:\n                l = f['length'] % 4\n                of1 = f['hlen']\n                of2 = full_len - l\n                c = ''\n                for i in range(0, l):\n                    mask = struct.unpack('B', buf[of1 + i])[0]\n                    data = struct.unpack('B', buf[of2 + i])[0]\n                    c += chr(data ^ mask)\n\n            f['payload'] = b + c\n        else:\n            f['payload'] = buf[(f['hlen'] + has_mask * 4):full_len]\n\n        if base64 and f['opcode'] in [1, 2]:\n            try:\n                f['payload'] = b64decode(f['payload'])\n            except:\n                raise\n\n        if f['opcode'] == 0x08:\n            if f['length'] >= 2:\n                f['close_code'] = struct.unpack_from(\">H\", f['payload'])\n            if f['length'] > 3:\n                f['close_reason'] = f['payload'][2:]\n\n        return f\n\n    @staticmethod\n    def _pack_message(message):\n        \"\"\"Pack the message inside ``00`` and ``FF``\n\n        As per the dataframing section (5.3) for the websocket spec\n        \"\"\"\n        if isinstance(message, str):\n            message = message.encode('utf-8')\n        packed = \"\\x00%s\\xFF\" % message\n        return packed\n\n    def _parse_messages(self):\n        \"\"\" Parses for messages in the buffer *buf*.  It is assumed that\n        the buffer contains the start character for a message, but that it\n        may contain only part of the rest of the message.\n\n        Returns an array of messages, and the buffer remainder that\n        didn't contain any full messages.\"\"\"\n        msgs = []\n        end_idx = 0\n        buf = self._buf\n        while buf:\n            if self.version in ['7', '8', '13']:\n                frame = self.decode_hybi(buf, base64=False)\n\n                if frame['payload'] == None:\n                    break\n                else:\n                    if frame['opcode'] == 0x8: # connection close\n                        self.websocket_closed = True\n                        break\n                    else:\n                        msgs.append(frame['payload']);\n                        if frame['left']:\n                            buf = buf[-frame['left']:]\n                        else:\n                            buf = ''\n\n            else:\n                frame_type = ord(buf[0])\n                if frame_type == 0:\n                    end_idx = buf.find(\"\\xFF\")\n                    if end_idx == -1: #pragma NO COVER\n                        break\n                    msgs.append(buf[1:end_idx].decode('utf-8', 'replace'))\n                    buf = buf[end_idx+1:]\n                elif frame_type == 255:\n                    assert ord(buf[1]) == 0, \"Unexpected closing handshake: %r\" % buf\n                    self.websocket_closed = True\n                    break\n                else:\n                    raise ValueError(\"Don't understand how to parse this type of message: %r\" % buf)\n        self._buf = buf\n        return msgs\n\n    def send(self, message):\n        \"\"\"Send a message to the browser.\n\n        *message* should be convertible to a string; unicode objects should be\n        encodable as utf-8.  Raises socket.error with errno of 32\n        (broken pipe) if the socket has already been closed by the client.\"\"\"\n        if self.version in ['7', '8', '13']:\n            packed, lenhead, lentail = self.encode_hybi(message, opcode=0x01, base64=False)\n        else:\n            packed = self._pack_message(message)\n        try:\n            self.socket.sendall(packed)\n        finally:\n            pass\n\n    def wait(self):\n        \"\"\"Waits for and deserializes messages.\n\n        Returns a single message; the oldest not yet processed. If the client\n        has already closed the connection, returns None.  This is different\n        from normal socket behavior because the empty string is a valid\n        websocket message.\"\"\"\n        while not self._msgs:\n            if self.websocket_closed:\n                return None\n            delta = self.socket.recv(8096)\n            if delta == b'':\n                return None\n            self._buf += delta\n            msgs = self._parse_messages()\n            self._msgs.extend(msgs)\n        return self._msgs.popleft()\n\n    def _send_closing_frame(self, ignore_send_errors=False):\n        \"\"\"Sends the closing frame to the client, if required.\"\"\"\n        if self.version in ['7', '8', '13'] and not self.websocket_closed:\n            msg = ''\n            buf, h, t = self.encode_hybi(msg, opcode=0x08, base64=False)\n            self.socket.sendall(buf)\n            self.websocket_closed = True\n\n        elif self.version == 76 and not self.websocket_closed:\n            try:\n                self.socket.sendall(b\"\\xff\\x00\")\n            except SocketError:\n                if not ignore_send_errors: #pragma NO COVER\n                    raise\n            self.websocket_closed = True\n\n    def close(self):\n        \"\"\"Forcibly close the websocket; generally it is preferable to\n        return from the handler method.\"\"\"\n        self._send_closing_frame()\n        self.socket.shutdown(True)\n        self.socket.close()"
    },
    {
      "chunk_id": 566,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/gevent_websocket.py",
      "content": "import os\nimport random\ndef handle(ws):\n    \"\"\"  This is the websocket handler function.  Note that we\n    can dispatch based on path in here, too.\"\"\"\n    if ws.path == '/echo':\n        while True:\n            m = ws.wait()\n            if m is None:\n                break\n            ws.send(m)\n\n    elif ws.path == '/data':\n        for i in range(10000):\n            ws.send(\"0 %s %s\\n\" % (i, random.random()))\n            gevent.sleep(0.1)\n\nwsapp = WebSocketWSGI(handle)"
    },
    {
      "chunk_id": 567,
      "source": "__internal__/data_repo/gunicorn/examples/websocket/gevent_websocket.py",
      "content": "def app(environ, start_response):\n    \"\"\" This resolves to the web page or the websocket depending on\n    the path.\"\"\"\n    if environ['PATH_INFO'] == '/' or environ['PATH_INFO'] == \"\":\n        data = open(os.path.join(\n                     os.path.dirname(__file__),\n                     'websocket.html')).read()\n        data = data % environ\n        start_response('200 OK', [('Content-Type', 'text/html'),\n                                 ('Content-Length', str(len(data)))])\n        return [data.encode()]\n    else:\n        return wsapp(environ, start_response)"
    },
    {
      "chunk_id": 568,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flask_sendfile.py",
      "content": "import io"
    },
    {
      "chunk_id": 569,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flask_sendfile.py",
      "content": "from flask import Flask, send_file"
    },
    {
      "chunk_id": 570,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flask_sendfile.py",
      "content": "app = Flask(__name__)"
    },
    {
      "chunk_id": 571,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flask_sendfile.py",
      "content": "@app.route('/')\ndef index():\n    buf = io.BytesIO()\n    buf.write(b'hello world')\n    buf.seek(0)\n    return send_file(buf,\n                     attachment_filename=\"testing.txt\",\n                     as_attachment=True)"
    },
    {
      "chunk_id": 572,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/pyramidapp.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 573,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/pyramidapp.py",
      "content": "def hello_world(request):\n    return Response('Hello world!')"
    },
    {
      "chunk_id": 574,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/pyramidapp.py",
      "content": "def goodbye_world(request):\n    return Response('Goodbye world!')"
    },
    {
      "chunk_id": 575,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/pyramidapp.py",
      "content": "config = Configurator()\nconfig.add_view(hello_world)\nconfig.add_view(goodbye_world, name='goodbye')\napp = config.make_wsgi_app()"
    },
    {
      "chunk_id": 576,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "content": "from aiohttp import web\nfrom aiohttp_wsgi import WSGIHandler\nfrom flask import Flask"
    },
    {
      "chunk_id": 577,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "content": "app = Flask(__name__)"
    },
    {
      "chunk_id": 578,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "content": "@app.route('/')\ndef hello():\n    return 'Hello, world!'"
    },
    {
      "chunk_id": 579,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "content": "def make_aiohttp_app(app):\n    wsgi_handler = WSGIHandler(app)\n    aioapp = web.Application()\n    aioapp.router.add_route('*', '/{path_info:.*}', wsgi_handler)\n    return aioapp"
    },
    {
      "chunk_id": 580,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "content": "aioapp = make_aiohttp_app(app)"
    },
    {
      "chunk_id": 581,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/tornadoapp.py",
      "content": "import tornado.ioloop\nimport tornado.web\nfrom tornado import gen"
    },
    {
      "chunk_id": 582,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/tornadoapp.py",
      "content": "class MainHandler(tornado.web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        # Your asynchronous code here\n        yield gen.sleep(1)  # Example of an asynchronous operation\n        self.write(\"Hello, World!\")"
    },
    {
      "chunk_id": 583,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/tornadoapp.py",
      "content": "def make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])"
    },
    {
      "chunk_id": 584,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/tornadoapp.py",
      "content": "if __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()"
    },
    {
      "chunk_id": 585,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/cherryapp.py",
      "content": "import cherrypy"
    },
    {
      "chunk_id": 586,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/cherryapp.py",
      "content": "class Root:\n    @cherrypy.expose\n    def index(self):\n        return 'Hello World!'"
    },
    {
      "chunk_id": 587,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/cherryapp.py",
      "content": "cherrypy.config.update({'environment': 'embedded'})"
    },
    {
      "chunk_id": 588,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/cherryapp.py",
      "content": "app = cherrypy.tree.mount(Root())"
    },
    {
      "chunk_id": 589,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp.py",
      "content": "from flask import Flask"
    },
    {
      "chunk_id": 590,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp.py",
      "content": "app = Flask(__name__)"
    },
    {
      "chunk_id": 591,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/flaskapp.py",
      "content": "@app.route(\"/\")\ndef hello():\n    return \"Hello World!\""
    },
    {
      "chunk_id": 592,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/webpyapp.py",
      "content": "import web"
    },
    {
      "chunk_id": 593,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/webpyapp.py",
      "content": "urls = (\n    '/', 'index'\n)"
    },
    {
      "chunk_id": 594,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/webpyapp.py",
      "content": "class index:\n    def GET(self):\n        return \"Hello, world!\""
    },
    {
      "chunk_id": 595,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/webpyapp.py",
      "content": "app = web.application(urls, globals()).wsgifunc()"
    },
    {
      "chunk_id": 596,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/manage.py",
      "content": "#!/usr/bin/env python"
    },
    {
      "chunk_id": 597,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/manage.py",
      "content": "import os, sys"
    },
    {
      "chunk_id": 598,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/manage.py",
      "content": "if __name__ == \"__main__\":\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"testing.settings\")"
    },
    {
      "chunk_id": 599,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/manage.py",
      "content": "from django.core.management import execute_from_command_line"
    },
    {
      "chunk_id": 600,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/manage.py",
      "content": "execute_from_command_line(sys.argv)"
    },
    {
      "chunk_id": 601,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 602,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/urls.py",
      "content": "from django.conf.urls import include, url"
    },
    {
      "chunk_id": 603,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/urls.py",
      "content": "from django.contrib import admin\nadmin.autodiscover()"
    },
    {
      "chunk_id": 604,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/urls.py",
      "content": "urlpatterns = [\n    # Examples:\n    # url(r'^$', 'testing.views.home', name='home'),\n    # url(r'^testing/', include('testing.foo.urls')),\n\n    # Uncomment the admin/doc line below to enable admin documentation:\n    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),\n\n    # Uncomment the next line to enable the admin:\n    url(r'^admin/', admin.site.urls),\n\n    url(r'^', include(\"testing.apps.someapp.urls\")),\n]"
    },
    {
      "chunk_id": 605,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "\"\"\"\nWSGI config for testing project.\n\nThis module contains the WSGI application used by Django's development server\nand any production WSGI deployments. It should expose a module-level variable\nnamed ``application``. Django's ``runserver`` and ``runfcgi`` commands discover\nthis application via the ``WSGI_APPLICATION`` setting.\n\nUsually you will have the standard Django WSGI application here, but it also\nmight make sense to replace the whole Django WSGI application with a custom one\nthat later delegates to the Django one. For example, you could introduce WSGI\nmiddleware here, or combine a Django application with an application of another\nframework.\n\n\"\"\""
    },
    {
      "chunk_id": 606,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 607,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "# make sure the current project is in PYTHONPATH\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__),\n                                                \"..\")))"
    },
    {
      "chunk_id": 608,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "# set the environment settings\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"testing.settings\")"
    },
    {
      "chunk_id": 609,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "# This application object is used by any WSGI server configured to use this\n# file. This includes Django's development server, if the WSGI_APPLICATION\n# setting points here.\nfrom django.core.wsgi import get_wsgi_application"
    },
    {
      "chunk_id": 610,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "application = get_wsgi_application()"
    },
    {
      "chunk_id": 611,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/wsgi.py",
      "content": "# Apply WSGI middleware here.\n# from helloworld.wsgi import HelloWorldApplication\n# application = HelloWorldApplication(application)"
    },
    {
      "chunk_id": 612,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "# Django settings for testing project."
    },
    {
      "chunk_id": 613,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "DEBUG = True\nTEMPLATE_DEBUG = DEBUG"
    },
    {
      "chunk_id": 614,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "ADMINS = (\n    # ('Your Name', 'your_email@example.com'),\n)"
    },
    {
      "chunk_id": 615,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "MANAGERS = ADMINS"
    },
    {
      "chunk_id": 616,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.\n        'NAME': 'testdb.sql',                      # Or path to database file if using sqlite3.\n        'USER': '',                      # Not used with sqlite3.\n        'PASSWORD': '',                  # Not used with sqlite3.\n        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.\n        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.\n    }\n}"
    },
    {
      "chunk_id": 617,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "TIME_ZONE = 'America/Chicago'"
    },
    {
      "chunk_id": 618,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "LANGUAGE_CODE = 'en-us'"
    },
    {
      "chunk_id": 619,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "SITE_ID = 1"
    },
    {
      "chunk_id": 620,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "USE_I18N = True"
    },
    {
      "chunk_id": 621,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "USE_L10N = True"
    },
    {
      "chunk_id": 622,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "USE_TZ = True"
    },
    {
      "chunk_id": 623,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "MEDIA_ROOT = ''"
    },
    {
      "chunk_id": 624,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "MEDIA_URL = ''"
    },
    {
      "chunk_id": 625,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "STATIC_ROOT = ''"
    },
    {
      "chunk_id": 626,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "STATIC_URL = '/static/'"
    },
    {
      "chunk_id": 627,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "STATICFILES_DIRS = (\n    # Put strings here, like \"/home/html/static\" or \"C:/www/django/static\".\n    # Always use forward slashes, even on Windows.\n    # Don't forget to use absolute paths, not relative paths.\n)"
    },
    {
      "chunk_id": 628,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "STATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n#    'django.contrib.staticfiles.finders.DefaultStorageFinder',\n)"
    },
    {
      "chunk_id": 629,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "SECRET_KEY = 'what'"
    },
    {
      "chunk_id": 630,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "TEMPLATE_LOADERS = (\n    'django.template.loaders.filesystem.Loader',\n    'django.template.loaders.app_directories.Loader',\n#     'django.template.loaders.eggs.Loader',\n)"
    },
    {
      "chunk_id": 631,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "MIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    # Uncomment the next line for simple clickjacking protection:\n    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',\n    # uncomment the next line to test multiprocessing\n    #'testing.apps.someapp.middleware.GunicornSubProcessTestMiddleware',\n)"
    },
    {
      "chunk_id": 632,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "ROOT_URLCONF = 'testing.urls'"
    },
    {
      "chunk_id": 633,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "WSGI_APPLICATION = 'testing.wsgi.application'"
    },
    {
      "chunk_id": 634,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            # ... some options here ...\n        },\n    },\n]"
    },
    {
      "chunk_id": 635,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "TEMPLATE_DIRS = (\n    # Put strings here, like \"/home/html/django_templates\" or \"C:/www/django/templates\".\n    # Always use forward slashes, even on Windows.\n    # Don't forget to use absolute paths, not relative paths.\n)"
    },
    {
      "chunk_id": 636,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "INSTALLED_APPS = (\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # Uncomment the next line to enable the admin:\n    'django.contrib.admin',\n    # Uncomment the next line to enable admin documentation:\n    # 'django.contrib.admindocs',\n    'testing.apps.someapp',\n    'gunicorn'\n)"
    },
    {
      "chunk_id": 637,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "LOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'filters': {\n        'require_debug_false': {\n            '()': 'django.utils.log.RequireDebugFalse'\n        }\n    },\n    'handlers': {\n        'mail_admins': {\n            'level': 'ERROR',\n            'filters': ['require_debug_false'],\n            'class': 'django.utils.log.AdminEmailHandler'\n        }\n    },\n    'loggers': {\n        'django.request': {\n            'handlers': ['mail_admins'],\n            'level': 'ERROR',\n            'propagate': True,\n        },\n    }\n}"
    },
    {
      "chunk_id": 638,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/settings.py",
      "content": "SOME_VALUE = \"test on reload\""
    },
    {
      "chunk_id": 639,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 640,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 641,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 642,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One:\", self.value)"
    },
    {
      "chunk_id": 643,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two:\", self.value)"
    },
    {
      "chunk_id": 644,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 645,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 646,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 647,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 648,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One:\", self.value)"
    },
    {
      "chunk_id": 649,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two:\", self.value)"
    },
    {
      "chunk_id": 650,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 651,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/urls.py",
      "content": "from django.conf.urls import url"
    },
    {
      "chunk_id": 652,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/urls.py",
      "content": "from . import views"
    },
    {
      "chunk_id": 653,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/urls.py",
      "content": "urlpatterns = [\n    url(r'^acsv$', views.acsv),\n    url(r'^$', views.home),\n]"
    },
    {
      "chunk_id": 654,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/middleware.py",
      "content": "from multiprocessing import Process, Queue\nimport requests"
    },
    {
      "chunk_id": 655,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/middleware.py",
      "content": "def child_process(queue):\n    while True:\n        print(queue.get())\n        requests.get('http://requestb.in/15s95oz1')"
    },
    {
      "chunk_id": 656,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/middleware.py",
      "content": "class GunicornSubProcessTestMiddleware:\n    def __init__(self):\n        super().__init__()\n        self.queue = Queue()\n        self.process = Process(target=child_process, args=(self.queue,))\n        self.process.start()"
    },
    {
      "chunk_id": 657,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/middleware.py",
      "content": "def process_request(self, request):\n        self.queue.put(('REQUEST',))"
    },
    {
      "chunk_id": 658,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/middleware.py",
      "content": "def process_response(self, request, response):\n        self.queue.put(('RESPONSE', response.status_code))\n        return response"
    },
    {
      "chunk_id": 659,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/tests.py",
      "content": "\"\"\"\nThis file demonstrates two different styles of tests (one doctest and one\nunittest). These will both pass when you run \"manage.py test\".\n\nReplace these with more appropriate tests for your application.\n\"\"\""
    },
    {
      "chunk_id": 660,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/tests.py",
      "content": "from django.test import TestCase"
    },
    {
      "chunk_id": 661,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/tests.py",
      "content": "class SimpleTest(TestCase):\n    def test_basic_addition(self):\n        \"\"\"\n        Tests that 1 + 1 always equals 2.\n        \"\"\"\n        self.assertEqual(1 + 1, 2)"
    },
    {
      "chunk_id": 662,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/tests.py",
      "content": "__test__ = {\"doctest\": \"\"\"\nAnother way to test that 1 + 1 is equal to 2.\n\n>>> 1 + 1 == 2\nTrue\n\"\"\"}"
    },
    {
      "chunk_id": 663,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/models.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 664,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/views.py",
      "content": "import csv\nimport io\nimport os\nfrom django import forms\nfrom django.http import HttpResponse\nfrom django.shortcuts import render\nfrom django.template import RequestContext"
    },
    {
      "chunk_id": 665,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/views.py",
      "content": "class MsgForm(forms.Form):\n    \"\"\"Form for sending messages.\"\"\"\n    subject = forms.CharField(max_length=100)\n    message = forms.CharField()\n    f = forms.FileField()"
    },
    {
      "chunk_id": 666,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/views.py",
      "content": "def home(request):\n    from django.conf import settings\n    print(settings.SOME_VALUE)\n    subject = None\n    message = None\n    size = 0\n    print(request.META)\n    if request.POST:\n        form = MsgForm(request.POST, request.FILES)\n        print(request.FILES)\n        if form.is_valid():\n            subject = form.cleaned_data['subject']\n            message = form.cleaned_data['message']\n            f = request.FILES['f']\n\n            if not hasattr(f, \"fileno\"):\n                size = len(f.read())\n            else:\n                try:\n                    size = int(os.fstat(f.fileno())[6])\n                except io.UnsupportedOperation:\n                    size = len(f.read())\n    else:\n        form = MsgForm()\n\n    return render(request, 'home.html', {\n        'form': form,\n        'subject': subject,\n        'message': message,\n        'size': size\n    })"
    },
    {
      "chunk_id": 667,
      "source": "__internal__/data_repo/gunicorn/examples/frameworks/django/testing/testing/apps/someapp/views.py",
      "content": "def acsv(request):\n    rows = [\n        {'a': 1, 'b': 2},\n        {'a': 3, 'b': 3}\n    ]\n\n    response = HttpResponse(mimetype='text/csv')\n    response['Content-Disposition'] = 'attachment; filename=report.csv'\n\n    writer = csv.writer(response)\n    writer.writerow(['a', 'b'])\n\n    for r in rows:\n        writer.writerow([r['a'], r['b']])\n\n    return response"
    },
    {
      "chunk_id": 668,
      "source": "__internal__/data_repo/gunicorn/scripts/update_thanks.py",
      "content": "#!/usr/bin/env python\n# Usage: git log --format=\"%an <%ae>\" | python update_thanks.py\n# You will get a result.txt file, you can work with the file (update, remove, ...)\n#\n# Install\n# =======\n# pip install validate_email pyDNS\n#\nimport sys\n\nfrom validate_email import validate_email\nfrom email.utils import parseaddr\nimport DNS.Base"
    },
    {
      "chunk_id": 669,
      "source": "__internal__/data_repo/gunicorn/scripts/update_thanks.py",
      "content": "addresses = set()\nbad_addresses = set()\ncollection = []"
    },
    {
      "chunk_id": 670,
      "source": "__internal__/data_repo/gunicorn/scripts/update_thanks.py",
      "content": "lines = list(reversed(sys.stdin.readlines()))"
    },
    {
      "chunk_id": 671,
      "source": "__internal__/data_repo/gunicorn/scripts/update_thanks.py",
      "content": "for author in map(str.strip, lines):\n    realname, email_address = parseaddr(author)\n\n    if email_address not in addresses:\n        if email_address in bad_addresses:\n            continue\n        else:\n            try:\n                value = validate_email(email_address)\n                if value:\n                    addresses.add(email_address)\n                    collection.append(author)\n                else:\n                    bad_addresses.add(email_address)\n            except DNS.Base.TimeoutError:\n                bad_addresses.add(email_address)"
    },
    {
      "chunk_id": 672,
      "source": "__internal__/data_repo/gunicorn/scripts/update_thanks.py",
      "content": "with open('result.txt', 'w') as output:\n    output.write('\\n'.join(collection))"
    },
    {
      "chunk_id": 673,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "import os\nimport inspect\n\nfrom docutils import nodes, utils\n\nimport gunicorn.config as guncfg"
    },
    {
      "chunk_id": 674,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "HEAD = \"\"\"\\\n.. Please update gunicorn/config.py instead.\n\n.. _settings:\n\nSettings\n========\n\nThis is an exhaustive list of settings for Gunicorn. Some settings are only\nable to be set from a configuration file. The setting name is what should be\nused in the configuration file. The command line arguments are listed as well\nfor reference on setting at the command line.\n\n.. note::\n\n    Settings can be specified by using environment variable\n    ``GUNICORN_CMD_ARGS``. All available command line arguments can be used.\n    For example, to specify the bind address and number of workers::\n\n        $ GUNICORN_CMD_ARGS=\"--bind=127.0.0.1 --workers=3\" gunicorn app:app\n\n    .. versionadded:: 19.7\n\n\"\"\"\nISSUE_URI = 'https://github.com/benoitc/gunicorn/issues/%s'\nPULL_REQUEST_URI = 'https://github.com/benoitc/gunicorn/pull/%s'"
    },
    {
      "chunk_id": 675,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "def format_settings(app):\n    settings_file = os.path.join(app.srcdir, \"settings.rst\")\n    ret = []\n    known_settings = sorted(guncfg.KNOWN_SETTINGS, key=lambda s: s.section)\n    for i, s in enumerate(known_settings):\n        if i == 0 or s.section != known_settings[i - 1].section:\n            ret.append(\"%s\\n%s\\n\\n\" % (s.section, \"-\" * len(s.section)))\n        ret.append(fmt_setting(s))\n\n    with open(settings_file, 'w') as settings:\n        settings.write(HEAD)\n        settings.write(''.join(ret))"
    },
    {
      "chunk_id": 676,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "def fmt_setting(s):\n    if hasattr(s, \"default_doc\"):\n        val = s.default_doc\n    elif callable(s.default):\n        val = inspect.getsource(s.default)\n        val = \"\\n\".join(\"    %s\" % line for line in val.splitlines())\n        val = \"\\n\\n.. code-block:: python\\n\\n\" + val\n    elif s.default == '':\n        val = \"``''``\"\n    else:\n        val = \"``%r``\" % s.default\n\n    if s.cli and s.meta:\n        cli = \" or \".join(\"``%s %s``\" % (arg, s.meta) for arg in s.cli)\n    elif s.cli:\n        cli = \" or \".join(\"``%s``\" % arg for arg in s.cli)\n    else:\n        cli = \"\"\n\n    out = []\n    out.append(\".. _%s:\\n\" % s.name.replace(\"_\", \"-\"))\n    out.append(\"``%s``\" % s.name)\n    out.append(\"~\" * (len(s.name) + 4))\n    out.append(\"\")\n    if s.cli:\n        out.append(\"**Command line:** %s\" % cli)\n        out.append(\"\")\n    out.append(\"**Default:** %s\" % val)\n    out.append(\"\")\n    out.append(s.desc)\n    out.append(\"\")\n    out.append(\"\")\n    return \"\\n\".join(out)"
    },
    {
      "chunk_id": 677,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "def issue_role(typ, rawtext, text, lineno, inliner, options={}, content=[]):\n    issue = utils.unescape(text)\n    text = 'issue ' + issue\n    refnode = nodes.reference(text, text, refuri=ISSUE_URI % issue)\n    return [refnode], []"
    },
    {
      "chunk_id": 678,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "def pull_request_role(typ, rawtext, text, lineno, inliner, options={}, content=[]):\n    issue = utils.unescape(text)\n    text = 'pull request ' + issue\n    refnode = nodes.reference(text, text, refuri=PULL_REQUEST_URI % issue)\n    return [refnode], []"
    },
    {
      "chunk_id": 679,
      "source": "__internal__/data_repo/gunicorn/docs/gunicorn_ext.py",
      "content": "def setup(app):\n    app.connect('builder-inited', format_settings)\n    app.add_role('issue', issue_role)\n    app.add_role('pr', pull_request_role)"
    },
    {
      "chunk_id": 680,
      "source": "__internal__/data_repo/gunicorn/docs/sitemap_gen.py",
      "content": "import os\nimport subprocess\nfrom xml.etree import ElementTree"
    },
    {
      "chunk_id": 681,
      "source": "__internal__/data_repo/gunicorn/docs/sitemap_gen.py",
      "content": "def main():\n    generate(\n        site_path=os.path.join(os.path.dirname(__file__), 'site'),\n        special_priorities={'index.html': 1.0})"
    },
    {
      "chunk_id": 682,
      "source": "__internal__/data_repo/gunicorn/docs/sitemap_gen.py",
      "content": "def generate(site_path, special_priorities, directory_index='index.html'):\n    urlset = ElementTree.Element('urlset', xmlns='http://www.sitemaps.org/schemas/sitemap/0.9')\n    urlset.text = '\\n '\n    for root, dirs, filenames in os.walk(site_path):\n        for filename in filenames:\n            if filename.endswith('.html'):\n                absolute_filepath = os.path.join(root, filename)\n                relative_path = os.path.relpath(absolute_filepath, site_path)\n                relative_url = os.path.dirname(relative_path) if filename == directory_index else relative_path\n                last_modification = subprocess.check_output(\n                    ['git', 'log', '-1', '--pretty=\"%cI\"', absolute_filepath]).decode('ascii').strip('\\n\"')\n                url_element = ElementTree.SubElement(urlset, 'url')\n                loc_element = ElementTree.SubElement(url_element, 'loc')\n                loc_element.text = 'http://gunicorn.org/' + relative_url\n                lastmod_element = ElementTree.SubElement(url_element, 'lastmod')\n                lastmod_element.text = last_modification\n                priority_element = ElementTree.SubElement(url_element, 'priority')\n                priority_element.text = str(special_priorities.get(relative_path, 0.5))\n                url_element.tail = priority_element.tail = '\\n '\n                url_element.text = loc_element.tail = lastmod_element.tail = '\\n  '\n    urlset[:] = sorted([url for url in urlset], key=lambda url: url[0].text)\n    urlset.tail = urlset[-1].tail = '\\n'\n    with open(os.path.join(site_path, 'sitemap.xml'), 'wb') as sitemap_file:\n        ElementTree.ElementTree(urlset).write(sitemap_file, encoding='UTF-8', xml_declaration=True)"
    },
    {
      "chunk_id": 683,
      "source": "__internal__/data_repo/gunicorn/docs/sitemap_gen.py",
      "content": "if __name__ == '__main__':\n    main()"
    },
    {
      "chunk_id": 684,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "import os\nimport sys\nimport time\n\nDOCS_DIR = os.path.abspath(os.path.dirname(__file__))\n\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\n\nsys.path.append(os.path.join(DOCS_DIR, os.pardir))\nsys.path.insert(0, os.path.join(DOCS_DIR, os.pardir, os.pardir))\n\nextensions = ['gunicorn_ext']\ntemplates_path = ['_templates']\nsource_suffix = '.rst'\nmaster_doc = 'index'\n\nproject = 'Gunicorn'\ncopyright = '2009-%s, Benoit Chesneau' % time.strftime('%Y')\nimport gunicorn\nrelease = version = gunicorn.__version__\n\nexclude_patterns = []\npygments_style = 'sphinx'"
    },
    {
      "chunk_id": 685,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "if not on_rtd:  # only import and set the theme if we're building docs locally\n    try:\n        import sphinx_rtd_theme\n    except ImportError:\n        html_theme = 'default'\n    else:\n        html_theme = 'sphinx_rtd_theme'\n        html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\nelse:\n    html_theme = 'default'\n\nhtml_static_path = ['_static']\nhtmlhelp_basename = 'Gunicorndoc'"
    },
    {
      "chunk_id": 686,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "latex_elements = {\n\n}"
    },
    {
      "chunk_id": 687,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "latex_documents = [\n  ('index', 'Gunicorn.tex', 'Gunicorn Documentation',\n   'Benoit Chesneau', 'manual'),\n]"
    },
    {
      "chunk_id": 688,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "man_pages = [\n    ('index', 'gunicorn', 'Gunicorn Documentation',\n     ['Benoit Chesneau'], 1)\n]"
    },
    {
      "chunk_id": 689,
      "source": "__internal__/data_repo/gunicorn/docs/source/conf.py",
      "content": "texinfo_documents = [\n  ('index', 'Gunicorn', 'Gunicorn Documentation',\n   'Benoit Chesneau', 'Gunicorn', 'One line description of project.',\n   'Miscellaneous'),\n]"
    }
  ]
}