{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/pyramid/setup.py",
      "content": "from setuptools import find_packages, setup"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/pyramid/setup.py",
      "content": "def readfile(name):\n    with open(name) as f:\n        return f.read()"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/pyramid/setup.py",
      "content": "README = readfile('README.rst')\nCHANGES = readfile('CHANGES.rst')\n\nVERSION = '2.1.dev0'\n\ninstall_requires = [\n    'hupper >= 1.5',  # ignore_files support\n    'plaster',\n    'plaster_pastedeploy',\n    'setuptools',\n    'translationstring >= 0.4',  # py3 compat\n    'venusian >= 1.0',  # ``ignore``\n    'webob >= 1.8.3',  # Accept.parse_offer\n    'zope.deprecation >= 3.5.0',  # py3 compat\n    'zope.interface >= 3.8.0',  # has zope.interface.registry\n]\n\ntests_require = [\n    'webtest >= 1.3.1',  # py3 compat\n    'zope.component >= 4.0',  # py3 compat\n]\n\ndocs_extras = [\n    'Sphinx >= 3.0.0',  # Force RTD to use >= 3.0.0\n    'docutils',\n    'pylons-sphinx-themes >= 1.0.8',  # Ethical Ads\n    'pylons_sphinx_latesturl',\n    'repoze.sphinx.autointerface',\n    'sphinx-copybutton',\n    'sphinxcontrib-autoprogram',\n]\n\ntesting_extras = tests_require + [\n    'coverage',\n    'pytest>=5.4.2',  # unittest.TestCase funkyness, see commit 77c1505ab\n    'pytest-cov',\n]\n\nbranch_version = \".\".join(VERSION.split(\".\")[:2])\n\n# black is refusing to make anything under 80 chars so just splitting it up\ndocs_fmt = 'https://docs.pylonsproject.org/projects/pyramid/en/{}-branch/'\ndocs_url = docs_fmt.format(branch_version)"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/pyramid/setup.py",
      "content": "setup(\n    name='pyramid',\n    version=VERSION,\n    description='The Pyramid Web Framework, a Pylons project',\n    long_description=README + '\\n\\n' + CHANGES,\n    long_description_content_type='text/x-rst',\n    classifiers=[\n        \"Development Status :: 6 - Mature\",\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Framework :: Pyramid\",\n        \"Topic :: Internet :: WWW/HTTP\",\n        \"Topic :: Internet :: WWW/HTTP :: WSGI\",\n        \"License :: Repoze Public License\",\n    ],\n    keywords=['web', 'wsgi', 'pylons', 'pyramid'],\n    author=\"Chris McDonough, Agendaless Consulting\",\n    author_email=\"pylons-discuss@googlegroups.com\",\n    url=\"https://trypyramid.com\",\n    project_urls={\n        'Documentation': docs_url,\n        'Changelog': '{}whatsnew-{}.html'.format(docs_url, branch_version),\n        'Issue Tracker': 'https://github.com/Pylons/pyramid/issues',\n    },\n    license=\"BSD-derived (Repoze)\",\n    packages=find_packages('src', exclude=['tests']),\n    package_dir={'': 'src'},\n    include_package_data=True,\n    zip_safe=False,\n    python_requires='>=3.8',\n    install_requires=install_requires,\n    extras_require={'testing': testing_extras, 'docs': docs_extras},\n    tests_require=tests_require,\n    test_suite=\"tests\",\n    entry_points={\n        'paste.server_runner': [\n            'wsgiref = pyramid.scripts.pserve:wsgiref_server_runner',\n            'cherrypy = pyramid.scripts.pserve:cherrypy_server_runner',\n        ],\n        'pyramid.pshell_runner': [\n            'python = pyramid.scripts.pshell:python_shell_runner'\n        ],\n        'console_scripts': [\n            'pserve = pyramid.scripts.pserve:main',\n            'pshell = pyramid.scripts.pshell:main',\n            'proutes = pyramid.scripts.proutes:main',\n            'pviews = pyramid.scripts.pviews:main',\n            'ptweens = pyramid.scripts.ptweens:main',\n            'prequest = pyramid.scripts.prequest:main',\n            'pdistreport = pyramid.scripts.pdistreport:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/pyramid/src/pyramid/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/pyramid/src/pyramid/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/pyramid/src/pyramid/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/pyramid/src/pyramid/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/pyramid/src/pyramid/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "\"\"\" Utility functions for dealing with URLs in pyramid \"\"\""
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "from functools import lru_cache\nimport os\n\nfrom pyramid.encode import url_quote, urlencode\nfrom pyramid.interfaces import IResourceURL, IRoutesMapper, IStaticURLInfo\nfrom pyramid.path import caller_package\nfrom pyramid.threadlocal import get_current_registry\nfrom pyramid.traversal import (\n    PATH_SAFE,\n    PATH_SEGMENT_SAFE,\n    ResourceURL,\n    quote_path_segment,\n)\nfrom pyramid.util import bytes_"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "QUERY_SAFE = \"/?:@!$&'()*+,;=\"  # RFC 3986\nANCHOR_SAFE = QUERY_SAFE"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def parse_url_overrides(request, kw):\n    \"\"\"\n    Parse special arguments passed when generating urls.\n\n    The supplied dictionary is mutated when we pop arguments.\n    Returns a 3-tuple of the format:\n\n      ``(app_url, qs, anchor)``.\n\n    \"\"\"\n    app_url = kw.pop('_app_url', None)\n    scheme = kw.pop('_scheme', None)\n    host = kw.pop('_host', None)\n    port = kw.pop('_port', None)\n    query = kw.pop('_query', '')\n    anchor = kw.pop('_anchor', '')\n\n    if app_url is None:\n        if scheme is not None or host is not None or port is not None:\n            app_url = request._partial_application_url(scheme, host, port)\n        else:\n            app_url = request.application_url\n\n    qs = ''\n    if query:\n        if isinstance(query, str):\n            qs = '?' + url_quote(query, QUERY_SAFE)\n        else:\n            qs = '?' + urlencode(query, doseq=True)\n\n    frag = ''\n    if anchor:\n        frag = '#' + url_quote(anchor, ANCHOR_SAFE)\n\n    return app_url, qs, frag"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "class URLMethodsMixin:\n    \"\"\"Request methods mixin for BaseRequest having to do with URL\n    generation\"\"\"\n\n    def _partial_application_url(self, scheme=None, host=None, port=None):\n        \"\"\"\n        Construct the URL defined by request.application_url, replacing any\n        of the default scheme, host, or port portions with user-supplied\n        variants.\n\n        If ``scheme`` is passed as ``https``, and the ``port`` is *not*\n        passed, the ``port`` value is assumed to ``443``.  Likewise, if\n        ``scheme`` is passed as ``http`` and ``port`` is not passed, the\n        ``port`` value is assumed to be ``80``.\n\n        \"\"\"\n        e = self.environ\n        if scheme is None:\n            scheme = e['wsgi.url_scheme']\n        else:\n            if scheme == 'https':\n                if port is None:\n                    port = '443'\n            if scheme == 'http':\n                if port is None:\n                    port = '80'\n        if host is None:\n            host = e.get('HTTP_HOST')\n            if host is None:\n                host = e['SERVER_NAME']\n        if port is None:\n            if ':' in host:\n                host, port = host.split(':', 1)\n            else:\n                port = e['SERVER_PORT']\n        else:\n            port = str(port)\n            if ':' in host:\n                host, _ = host.split(':', 1)\n        if scheme == 'https':\n            if port == '443':\n                port = None\n        elif scheme == 'http':\n            if port == '80':\n                port = None\n        url = scheme + '://' + host\n        if port:\n            url += ':%s' % port\n\n        url_encoding = getattr(self, 'url_encoding', 'utf-8')  # webob 1.2b3+\n        bscript_name = bytes_(self.script_name, url_encoding)\n        return url + url_quote(bscript_name, PATH_SAFE)"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def route_url(self, route_name, *elements, **kw):\n        \"\"\"Generates a fully qualified URL for a named :app:`Pyramid`\n        :term:`route configuration`.\n\n        Use the route's ``name`` as the first positional argument.\n        Additional positional arguments (``*elements``) are appended to the\n        URL as path segments after it is generated.\n\n        Use keyword arguments to supply values which match any dynamic\n        path elements in the route definition.  Raises a :exc:`KeyError`\n        exception if the URL cannot be generated for any reason (not\n        enough arguments, for example).\n\n        For example, if you've defined a route named \"foobar\" with the path\n        ``{foo}/{bar}/*traverse``::\n\n            request.route_url('foobar',\n                               foo='1')             => <KeyError exception>\n            request.route_url('foobar',\n                               foo='1',\n                               bar='2')             => <KeyError exception>\n            request.route_url('foobar',\n                               foo='1',\n                               bar='2',\n                               traverse=('a','b'))  => http://e.com/1/2/a/b\n            request.route_url('foobar',\n                               foo='1',\n                               bar='2',\n                               traverse='/a/b')     => http://e.com/1/2/a/b\n\n        Values replacing ``:segment`` arguments can be passed as strings\n        or Unicode objects.  They will be encoded to UTF-8 and URL-quoted\n        before being placed into the generated URL.\n\n        Values replacing ``*remainder`` arguments can be passed as strings\n        *or* tuples of Unicode/string values.  If a tuple is passed as a\n        ``*remainder`` replacement value, its values are URL-quoted and\n        encoded to UTF-8.  The resulting strings are joined with slashes\n        and rendered into the URL.  If a string is passed as a\n        ``*remainder`` replacement value, it is tacked on to the URL\n        after being URL-quoted-except-for-embedded-slashes.\n\n        If ``_query`` is provided, it will be used to compose a query string\n        that will be tacked on to the end of the URL.  The value of ``_query``\n        may be a sequence of two-tuples *or* a data structure with an\n        ``.items()`` method that returns a sequence of two-tuples\n        (presumably a dictionary). This data structure will be turned into\n        a query string per the documentation of the\n        :func:`pyramid.url.urlencode` function.  This will produce a query\n        string in the ``x-www-form-urlencoded`` format.  A\n        non-``x-www-form-urlencoded`` query string may be used by passing a\n        *string* value as ``_query`` in which case it will be URL-quoted\n        (e.g. query=\"foo bar\" will become \"foo%20bar\").  However, the result\n        will not need to be in ``k=v`` form as required by\n        ``x-www-form-urlencoded``.  After the query data is turned into a query\n        string, a leading ``?`` is prepended, and the resulting string is\n        appended to the generated URL.\n\n        .. note::\n\n           Python data structures that are passed as ``_query`` which are\n           sequences or dictionaries are turned into a string under the same\n           rules as when run through :func:`urllib.urlencode` with the\n           ``doseq`` argument equal to ``True``.  This means that sequences can\n           be passed as values, and a k=v pair will be placed into the query\n           string for each value.\n\n        If a keyword argument ``_anchor`` is present, its string\n        representation will be quoted per :rfc:`3986#section-3.5` and used as\n        a named anchor in the generated URL\n        (e.g. if ``_anchor`` is passed as ``foo`` and the route URL is\n        ``http://example.com/route/url``, the resulting generated URL will\n        be ``http://example.com/route/url#foo``.\n\n        .. note::\n\n           If ``_anchor`` is passed as a string, it should be UTF-8 encoded. If\n           ``_anchor`` is passed as a Unicode object, it will be converted to\n           UTF-8 before being appended to the URL.\n\n        If both ``_anchor`` and ``_query`` are specified, the anchor\n        element will always follow the query element,\n        e.g. ``http://example.com?foo=1#bar``.\n\n        If any of the keyword arguments ``_scheme``, ``_host``, or ``_port``\n        is passed and is non-``None``, the provided value will replace the\n        named portion in the generated URL.  For example, if you pass\n        ``_host='foo.com'``, and the URL that would have been generated\n        without the host replacement is ``http://example.com/a``, the result\n        will be ``http://foo.com/a``.\n\n        Note that if ``_scheme`` is passed as ``https``, and ``_port`` is not\n        passed, the ``_port`` value is assumed to have been passed as\n        ``443``.  Likewise, if ``_scheme`` is passed as ``http`` and\n        ``_port`` is not passed, the ``_port`` value is assumed to have been\n        passed as ``80``. To avoid this behavior, always explicitly pass\n        ``_port`` whenever you pass ``_scheme``.\n\n        If a keyword ``_app_url`` is present, it will be used as the\n        protocol/hostname/port/leading path prefix of the generated URL.\n        For example, using an ``_app_url`` of\n        ``http://example.com:8080/foo`` would cause the URL\n        ``http://example.com:8080/foo/fleeb/flub`` to be returned from\n        this function if the expansion of the route pattern associated\n        with the ``route_name`` expanded to ``/fleeb/flub``.  If\n        ``_app_url`` is not specified, the result of\n        ``request.application_url`` will be used as the prefix (the\n        default).\n\n        If both ``_app_url`` and any of ``_scheme``, ``_host``, or ``_port``\n        are passed, ``_app_url`` takes precedence and any values passed for\n        ``_scheme``, ``_host``, and ``_port`` will be ignored.\n\n        This function raises a :exc:`KeyError` if the URL cannot be\n        generated due to missing replacement names.  Extra replacement\n        names are ignored.\n\n        If the route object which matches the ``route_name`` argument has\n        a :term:`pregenerator`, the ``*elements`` and ``**kw``\n        arguments passed to this function might be augmented or changed.\n\n        .. versionchanged:: 1.5\n           Allow the ``_query`` option to be a string to enable alternative\n           encodings.\n\n           The ``_anchor`` option will be escaped instead of using\n           its raw string representation.\n\n        .. versionchanged:: 1.9\n           If ``_query`` or ``_anchor`` are falsey (such as ``None`` or an\n           empty string) they will not be included in the generated url.\n\n        \"\"\"\n        try:\n            reg = self.registry\n        except AttributeError:\n            reg = get_current_registry()  # b/c\n        mapper = reg.getUtility(IRoutesMapper)\n        route = mapper.get_route(route_name)\n\n        if route is None:\n            raise KeyError('No such route named %s' % route_name)\n\n        if route.pregenerator is not None:\n            elements, kw = route.pregenerator(self, elements, kw)\n\n        app_url, qs, anchor = parse_url_overrides(self, kw)\n\n        path = route.generate(kw)  # raises KeyError if generate fails\n\n        if elements:\n            suffix = _join_elements(elements)\n            if not path.endswith('/'):\n                suffix = '/' + suffix\n        else:\n            suffix = ''\n\n        return app_url + path + suffix + qs + anchor"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def route_path(self, route_name, *elements, **kw):\n        \"\"\"\n        Generates a path (aka a 'relative URL', a URL minus the host, scheme,\n        and port) for a named :app:`Pyramid` :term:`route configuration`.\n\n        This function accepts the same argument as\n        :meth:`pyramid.request.Request.route_url` and performs the same duty.\n        It just omits the host, port, and scheme information in the return\n        value; only the script_name, path, query parameters, and anchor data\n        are present in the returned string.\n\n        For example, if you've defined a route named 'foobar' with the path\n        ``/{foo}/{bar}``, this call to ``route_path``::\n\n            request.route_path('foobar', foo='1', bar='2')\n\n        Will return the string ``/1/2``.\n\n        .. note::\n\n           Calling ``request.route_path('route')`` is the same as calling\n           ``request.route_url('route', _app_url=request.script_name)``.\n           :meth:`pyramid.request.Request.route_path` is, in fact,\n           implemented in terms of :meth:`pyramid.request.Request.route_url`\n           in just this way. As a result, any ``_app_url`` passed within the\n           ``**kw`` values to ``route_path`` will be ignored.\n\n        \"\"\"\n        kw['_app_url'] = self.script_name\n        return self.route_url(route_name, *elements, **kw)"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def resource_url(self, resource, *elements, **kw):\n        \"\"\"\n        Generate a string representing the absolute URL of the\n        :term:`resource` object based on the ``wsgi.url_scheme``,\n        ``HTTP_HOST`` or ``SERVER_NAME`` in the request, plus any\n        ``SCRIPT_NAME``.  The overall result of this method is always a\n        UTF-8 encoded string.\n\n        Examples::\n\n            request.resource_url(resource) =>\n\n                                       http://example.com/\n\n            request.resource_url(resource, 'a.html') =>\n\n                                       http://example.com/a.html\n\n            request.resource_url(resource, 'a.html', query={'q':'1'}) =>\n\n                                       http://example.com/a.html?q=1\n\n            request.resource_url(resource, 'a.html', anchor='abc') =>\n\n                                       http://example.com/a.html#abc\n\n            request.resource_url(resource, app_url='') =>\n\n                                       /\n\n        Any positional arguments passed in as ``elements`` must be strings\n        Unicode objects, or integer objects.  These will be joined by slashes\n        and appended to the generated resource URL.  Each of the elements\n        passed in is URL-quoted before being appended; if any element is\n        Unicode, it will converted to a UTF-8 bytestring before being\n        URL-quoted. If any element is an integer, it will be converted to its\n        string representation before being URL-quoted.\n\n        .. warning:: if no ``elements`` arguments are specified, the resource\n                     URL will end with a trailing slash.  If any\n                     ``elements`` are used, the generated URL will *not*\n                     end in a trailing slash.\n\n        If ``query`` is provided, it will be used to compose a query string\n        that will be tacked on to the end of the URL.  The value of ``query``\n        may be a sequence of two-tuples *or* a data structure with an\n        ``.items()`` method that returns a sequence of two-tuples\n        (presumably a dictionary). This data structure will be turned into\n        a query string per the documentation of the\n        :func:`pyramid.url.urlencode` function.  This will produce a query\n        string in the ``x-www-form-urlencoded`` format.  A\n        non-``x-www-form-urlencoded`` query string may be used by passing a\n        *string* value as ``query`` in which case it will be URL-quoted\n        (e.g. query=\"foo bar\" will become \"foo%20bar\").  However, the result\n        will not need to be in ``k=v`` form as required by\n        ``x-www-form-urlencoded``.  After the query data is turned into a query\n        string, a leading ``?`` is prepended, and the resulting string is\n        appended to the generated URL.\n\n        .. note::\n\n           Python data structures that are passed as ``query`` which are\n           sequences or dictionaries are turned into a string under the same\n           rules as when run through :func:`urllib.urlencode` with the\n           ``doseq`` argument equal to ``True``.  This means that sequences can\n           be passed as values, and a k=v pair will be placed into the query\n           string for each value.\n\n        If a keyword argument ``anchor`` is present, its string\n        representation will be used as a named anchor in the generated URL\n        (e.g. if ``anchor`` is passed as ``foo`` and the resource URL is\n        ``http://example.com/resource/url``, the resulting generated URL will\n        be ``http://example.com/resource/url#foo``.\n\n        .. note::\n\n           If ``anchor`` is passed as a string, it should be UTF-8 encoded. If\n           ``anchor`` is passed as a Unicode object, it will be converted to\n           UTF-8 before being appended to the URL.\n\n        If both ``anchor`` and ``query`` are specified, the anchor element\n        will always follow the query element,\n        e.g. ``http://example.com?foo=1#bar``.\n\n        If any of the keyword arguments ``scheme``, ``host``, or ``port`` is\n        passed and is non-``None``, the provided value will replace the named\n        portion in the generated URL.  For example, if you pass\n        ``host='foo.com'``, and the URL that would have been generated\n        without the host replacement is ``http://example.com/a``, the result\n        will be ``http://foo.com/a``.\n\n        If ``scheme`` is passed as ``https``, and an explicit ``port`` is not\n        passed, the ``port`` value is assumed to have been passed as ``443``.\n        Likewise, if ``scheme`` is passed as ``http`` and ``port`` is not\n        passed, the ``port`` value is assumed to have been passed as\n        ``80``. To avoid this behavior, always explicitly pass ``port``\n        whenever you pass ``scheme``.\n\n        If a keyword argument ``app_url`` is passed and is not ``None``, it\n        should be a string that will be used as the port/hostname/initial\n        path portion of the generated URL instead of the default request\n        application URL.  For example, if ``app_url='http://foo'``, then the\n        resulting url of a resource that has a path of ``/baz/bar`` will be\n        ``http://foo/baz/bar``.  If you want to generate completely relative\n        URLs with no leading scheme, host, port, or initial path, you can\n        pass ``app_url=''``.  Passing ``app_url=''`` when the resource path is\n        ``/baz/bar`` will return ``/baz/bar``.\n\n        If ``app_url`` is passed and any of ``scheme``, ``port``, or ``host``\n        are also passed, ``app_url`` will take precedence and the values\n        passed for ``scheme``, ``host``, and/or ``port`` will be ignored.\n\n        If the ``resource`` passed in has a ``__resource_url__`` method, it\n        will be used to generate the URL (scheme, host, port, path) for the\n        base resource which is operated upon by this function.\n\n        .. seealso::\n\n            See also :ref:`overriding_resource_url_generation`.\n\n        If ``route_name`` is passed, this function will delegate its URL\n        production to the ``route_url`` function.  Calling\n        ``resource_url(someresource, 'element1', 'element2', query={'a':1},\n        route_name='blogentry')`` is roughly equivalent to doing::\n\n           traversal_path = request.resource_path(someobject)\n           url = request.route_url(\n                     'blogentry',\n                     'element1',\n                     'element2',\n                     _query={'a':'1'},\n                     traverse=traversal_path,\n                     )\n\n        It is only sensible to pass ``route_name`` if the route being named has\n        a ``*remainder`` stararg value such as ``*traverse``.  The remainder\n        value will be ignored in the output otherwise.\n\n        By default, the resource path value will be passed as the name\n        ``traverse`` when ``route_url`` is called.  You can influence this by\n        passing a different ``route_remainder_name`` value if the route has a\n        different ``*stararg`` value at its end.  For example if the route\n        pattern you want to replace has a ``*subpath`` stararg ala\n        ``/foo*subpath``::\n\n           request.resource_url(\n                          resource,\n                          route_name='myroute',\n                          route_remainder_name='subpath'\n                          )\n\n        If ``route_name`` is passed, it is also permissible to pass\n        ``route_kw``, which will passed as additional keyword arguments to\n        ``route_url``.  Saying ``resource_url(someresource, 'element1',\n        'element2', route_name='blogentry', route_kw={'id':'4'},\n        _query={'a':'1'})`` is roughly equivalent to::\n\n           traversal_path = request.resource_path_tuple(someobject)\n           kw = {'id':'4', '_query':{'a':'1'}, 'traverse':traversal_path}\n           url = request.route_url(\n                     'blogentry',\n                     'element1',\n                     'element2',\n                     **kw,\n                     )\n\n        If ``route_kw`` or ``route_remainder_name`` is passed, but\n        ``route_name`` is not passed, both ``route_kw`` and\n        ``route_remainder_name`` will be ignored.  If ``route_name``\n        is passed, the ``__resource_url__`` method of the resource passed is\n        ignored unconditionally.  This feature is incompatible with\n        resources which generate their own URLs.\n\n        .. note::\n\n           If the :term:`resource` used is the result of a :term:`traversal`,\n           it must be :term:`location`-aware.  The resource can also be the\n           context of a :term:`URL dispatch`; contexts found this way do not\n           need to be location-aware.\n\n        .. note::\n\n           If a 'virtual root path' is present in the request environment (the\n           value of the WSGI environ key ``HTTP_X_VHM_ROOT``), and the resource\n           was obtained via :term:`traversal`, the URL path will not include\n           the virtual root prefix (it will be stripped off the left hand side\n           of the generated URL).\n\n        .. note::\n\n           For backwards compatibility purposes, this method is also\n           aliased as the ``model_url`` method of request.\n\n        .. versionchanged:: 1.3\n           Added the ``app_url`` keyword argument.\n\n        .. versionchanged:: 1.5\n           Allow the ``query`` option to be a string to enable alternative\n           encodings.\n\n           The ``anchor`` option will be escaped instead of using\n           its raw string representation.\n\n           Added the ``route_name``, ``route_kw``, and\n           ``route_remainder_name`` keyword arguments.\n\n        .. versionchanged:: 1.9\n           If ``query`` or ``anchor`` are falsey (such as ``None`` or an\n           empty string) they will not be included in the generated url.\n        \"\"\"\n        try:\n            reg = self.registry\n        except AttributeError:\n            reg = get_current_registry()  # b/c\n\n        url_adapter = reg.queryMultiAdapter((resource, self), IResourceURL)\n        if url_adapter is None:\n            url_adapter = ResourceURL(resource, self)\n\n        virtual_path = getattr(url_adapter, 'virtual_path', None)\n\n        urlkw = {}\n        for name in ('app_url', 'scheme', 'host', 'port', 'query', 'anchor'):\n            val = kw.get(name, None)\n            if val is not None:\n                urlkw['_' + name] = val\n\n        if 'route_name' in kw:\n            route_name = kw['route_name']\n            remainder = getattr(url_adapter, 'virtual_path_tuple', None)\n            if remainder is None:\n                # older user-supplied IResourceURL adapter without 1.5\n                # virtual_path_tuple\n                remainder = tuple(url_adapter.virtual_path.split('/'))\n            remainder_name = kw.get('route_remainder_name', 'traverse')\n            urlkw[remainder_name] = remainder\n\n            if 'route_kw' in kw:\n                route_kw = kw.get('route_kw')\n                if route_kw is not None:\n                    urlkw.update(route_kw)\n\n            return self.route_url(route_name, *elements, **urlkw)\n\n        app_url, qs, anchor = parse_url_overrides(self, urlkw)\n\n        resource_url = None\n        local_url = getattr(resource, '__resource_url__', None)\n\n        if local_url is not None:\n            # the resource handles its own url generation\n            d = dict(\n                virtual_path=virtual_path,\n                physical_path=url_adapter.physical_path,\n                app_url=app_url,\n            )\n\n            # allow __resource_url__ to punt by returning None\n            resource_url = local_url(self, d)\n\n        if resource_url is None:\n            # the resource did not handle its own url generation or the\n            # __resource_url__ function returned None\n            resource_url = app_url + virtual_path\n\n        if elements:\n            suffix = _join_elements(elements)\n        else:\n            suffix = ''\n\n        return resource_url + suffix + qs + anchor"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "model_url = resource_url  # b/w compat forever"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def resource_path(self, resource, *elements, **kw):\n        \"\"\"\n        Generates a path (aka a 'relative URL', a URL minus the host, scheme,\n        and port) for a :term:`resource`.\n\n        This function accepts the same argument as\n        :meth:`pyramid.request.Request.resource_url` and performs the same\n        duty.  It just omits the host, port, and scheme information in the\n        return value; only the script_name, path, query parameters, and\n        anchor data are present in the returned string.\n\n        .. note::\n\n           Calling ``request.resource_path(resource)`` is the same as calling\n           ``request.resource_path(resource, app_url=request.script_name)``.\n           :meth:`pyramid.request.Request.resource_path` is, in fact,\n           implemented in terms of\n           :meth:`pyramid.request.Request.resource_url` in just this way. As\n           a result, any ``app_url`` passed within the ``**kw`` values to\n           ``route_path`` will be ignored.  ``scheme``, ``host``, and\n           ``port`` are also ignored.\n        \"\"\"\n        kw['app_url'] = self.script_name\n        return self.resource_url(resource, *elements, **kw)"
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def static_url(self, path, **kw):\n        \"\"\"\n        Generates a fully qualified URL for a static :term:`asset`.\n        The asset must live within a location defined via the\n        :meth:`pyramid.config.Configurator.add_static_view`\n        :term:`configuration declaration` (see :ref:`static_assets_section`).\n\n        Example::\n\n            request.static_url('mypackage:static/foo.css') =>\n\n                                    http://example.com/static/foo.css\n\n\n        The ``path`` argument points at a file or directory on disk which\n        a URL should be generated for.  The ``path`` may be either a\n        relative path (e.g. ``static/foo.css``) or an absolute path (e.g.\n        ``/abspath/to/static/foo.css``) or a :term:`asset specification`\n        (e.g. ``mypackage:static/foo.css``).\n\n        The purpose of the ``**kw`` argument is the same as the purpose of\n        the :meth:`pyramid.request.Request.route_url` ``**kw`` argument.  See\n        the documentation for that function to understand the arguments which\n        you can provide to it.  However, typically, you don't need to pass\n        anything as ``*kw`` when generating a static asset URL.\n\n        This function raises a :exc:`ValueError` if a static view\n        definition cannot be found which matches the path specification.\n\n        \"\"\"\n        if not os.path.isabs(path):\n            if ':' not in path:\n                # if it's not a package:relative/name and it's not an\n                # /absolute/path it's a relative/path; this means its relative\n                # to the package in which the caller's module is defined.\n                package = caller_package()\n                path = f'{package.__name__}:{path}'\n\n        try:\n            reg = self.registry\n        except AttributeError:\n            reg = get_current_registry()  # b/c\n\n        info = reg.queryUtility(IStaticURLInfo)\n        if info is None:\n            raise ValueError('No static URL definition matching %s' % path)\n\n        return info.generate(path, self, **kw)"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def static_path(self, path, **kw):\n        \"\"\"\n        Generates a path (aka a 'relative URL', a URL minus the host, scheme,\n        and port) for a static resource.\n\n        This function accepts the same argument as\n        :meth:`pyramid.request.Request.static_url` and performs the\n        same duty.  It just omits the host, port, and scheme information in\n        the return value; only the script_name, path, query parameters, and\n        anchor data are present in the returned string.\n\n        Example::\n\n            request.static_path('mypackage:static/foo.css') =>\n\n                                    /static/foo.css\n\n        .. note::\n\n           Calling ``request.static_path(apath)`` is the same as calling\n           ``request.static_url(apath, _app_url=request.script_name)``.\n           :meth:`pyramid.request.Request.static_path` is, in fact, implemented\n           in terms of :meth:`pyramid.request.Request.static_url` in just this\n           way. As a result, any ``_app_url`` passed within the ``**kw`` values\n           to ``static_path`` will be ignored.\n        \"\"\"\n        if not os.path.isabs(path):\n            if ':' not in path:\n                # if it's not a package:relative/name and it's not an\n                # /absolute/path it's a relative/path; this means its relative\n                # to the package in which the caller's module is defined.\n                package = caller_package()\n                path = f'{package.__name__}:{path}'\n\n        kw['_app_url'] = self.script_name\n        return self.static_url(path, **kw)"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def current_route_url(self, *elements, **kw):\n        \"\"\"\n        Generates a fully qualified URL for a named :app:`Pyramid`\n        :term:`route configuration` based on the 'current route'.\n\n        This function supplements\n        :meth:`pyramid.request.Request.route_url`. It presents an easy way to\n        generate a URL for the 'current route' (defined as the route which\n        matched when the request was generated).\n\n        The arguments to this method have the same meaning as those with the\n        same names passed to :meth:`pyramid.request.Request.route_url`.  It\n        also understands an extra argument which ``route_url`` does not named\n        ``_route_name``.\n\n        The route name used to generate a URL is taken from either the\n        ``_route_name`` keyword argument or the name of the route which is\n        currently associated with the request if ``_route_name`` was not\n        passed.  Keys and values from the current request :term:`matchdict`\n        are combined with the ``kw`` arguments to form a set of defaults\n        named ``newkw``.  Then ``request.route_url(route_name, *elements,\n        **newkw)`` is called, returning a URL.\n\n        Examples follow.\n\n        If the 'current route' has the route pattern ``/foo/{page}`` and the\n        current url path is ``/foo/1`` , the matchdict will be\n        ``{'page':'1'}``.  The result of ``request.current_route_url()`` in\n        this situation will be ``/foo/1``.\n\n        If the 'current route' has the route pattern ``/foo/{page}`` and the\n        current url path is ``/foo/1``, the matchdict will be\n        ``{'page':'1'}``.  The result of ``request.current_route_url(page='2')`` in\n        this situation will be ``/foo/2``.\n\n        Usage of the ``_route_name`` keyword argument: if our routing table\n        defines routes ``/foo/{action}`` named 'foo' and\n        ``/foo/{action}/{page}`` named ``fooaction``, and the current url\n        pattern is ``/foo/view`` (which has matched the ``/foo/{action}``\n        route), we may want to use the matchdict args to generate a URL to\n        the ``fooaction`` route.  In this scenario,\n        ``request.current_route_url(_route_name='fooaction', page='5')``\n        Will return string like: ``/foo/view/5``.\n\n        \"\"\"\n        if '_route_name' in kw:\n            route_name = kw.pop('_route_name')\n        else:\n            route = getattr(self, 'matched_route', None)\n            route_name = getattr(route, 'name', None)\n            if route_name is None:\n                raise ValueError('Current request matches no route')\n\n        if '_query' not in kw:\n            kw['_query'] = self.GET\n\n        newkw = {}\n        newkw.update(self.matchdict)\n        newkw.update(kw)\n        return self.route_url(route_name, *elements, **newkw)"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def current_route_path(self, *elements, **kw):\n        \"\"\"\n        Generates a path (aka a 'relative URL', a URL minus the host, scheme,\n        and port) for the :app:`Pyramid` :term:`route configuration` matched\n        by the current request.\n\n        This function accepts the same argument as\n        :meth:`pyramid.request.Request.current_route_url` and performs the\n        same duty.  It just omits the host, port, and scheme information in the\n        return value; only the script_name, path, query parameters, and\n        anchor data are present in the returned string.\n\n        For example, if the route matched by the current request has the\n        pattern ``/{foo}/{bar}``, this call to ``current_route_path``::\n\n            request.current_route_path(foo='1', bar='2')\n\n        Will return the string ``/1/2``.\n\n        .. note::\n\n           Calling ``request.current_route_path('route')`` is the same\n           as calling ``request.current_route_url('route',\n           _app_url=request.script_name)``.\n           :meth:`pyramid.request.Request.current_route_path` is, in fact,\n           implemented in terms of\n           :meth:`pyramid.request.Request.current_route_url` in just this\n           way. As a result, any ``_app_url`` passed within the ``**kw``\n           values to ``current_route_path`` will be ignored.\n        \"\"\"\n        kw['_app_url'] = self.script_name\n        return self.current_route_url(*elements, **kw)"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def route_url(route_name, request, *elements, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.route_url(route_name, *elements, **kw)\n\n    See :meth:`pyramid.request.Request.route_url` for more information.\n    \"\"\"\n    return request.route_url(route_name, *elements, **kw)"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def route_path(route_name, request, *elements, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.route_path(route_name, *elements, **kw)\n\n    See :meth:`pyramid.request.Request.route_path` for more information.\n    \"\"\"\n    return request.route_path(route_name, *elements, **kw)"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def resource_url(resource, request, *elements, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.resource_url(resource, *elements, **kw)\n\n    See :meth:`pyramid.request.Request.resource_url` for more information.\n    \"\"\"\n    return request.resource_url(resource, *elements, **kw)"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "model_url = resource_url  # b/w compat (forever)"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def static_url(path, request, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.static_url(path, **kw)\n\n    See :meth:`pyramid.request.Request.static_url` for more information.\n    \"\"\"\n    if not os.path.isabs(path):\n        if ':' not in path:\n            # if it's not a package:relative/name and it's not an\n            # /absolute/path it's a relative/path; this means its relative\n            # to the package in which the caller's module is defined.\n            package = caller_package()\n            path = f'{package.__name__}:{path}'\n    return request.static_url(path, **kw)"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def static_path(path, request, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.static_path(path, **kw)\n\n    See :meth:`pyramid.request.Request.static_path` for more information.\n    \"\"\"\n    if not os.path.isabs(path):\n        if ':' not in path:\n            # if it's not a package:relative/name and it's not an\n            # /absolute/path it's a relative/path; this means its relative\n            # to the package in which the caller's module is defined.\n            package = caller_package()\n            path = f'{package.__name__}:{path}'\n    return request.static_path(path, **kw)"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def current_route_url(request, *elements, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.current_route_url(*elements, **kw)\n\n    See :meth:`pyramid.request.Request.current_route_url` for more\n    information.\n    \"\"\"\n    return request.current_route_url(*elements, **kw)"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "def current_route_path(request, *elements, **kw):\n    \"\"\"\n    This is a backwards compatibility function.  Its result is the same as\n    calling::\n\n        request.current_route_path(*elements, **kw)\n\n    See :meth:`pyramid.request.Request.current_route_path` for more\n    information.\n    \"\"\"\n    return request.current_route_path(*elements, **kw)"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/pyramid/src/pyramid/url.py",
      "content": "@lru_cache(1000)\ndef _join_elements(elements):\n    return '/'.join(\n        [quote_path_segment(s, safe=PATH_SEGMENT_SAFE) for s in elements]\n    )"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "import re\nfrom zope.interface import implementer\n\nfrom pyramid.exceptions import URLDecodeError\nfrom pyramid.interfaces import IRoute, IRoutesMapper\nfrom pyramid.traversal import PATH_SAFE, quote_path_segment, split_path_info\nfrom pyramid.util import is_nonstr_iter, text_\n\n_marker = object()"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "@implementer(IRoute)\nclass Route:\n    def __init__(\n        self, name, pattern, factory=None, predicates=(), pregenerator=None\n    ):\n        self.pattern = pattern\n        self.path = pattern  # indefinite b/w compat, not in interface\n        self.match, self.generate = _compile_route(pattern)\n        self.name = name\n        self.factory = factory\n        self.predicates = predicates\n        self.pregenerator = pregenerator"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "@implementer(IRoutesMapper)\nclass RoutesMapper:\n    def __init__(self):\n        self.routelist = []\n        self.static_routes = []\n        self.routes = {}"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def has_routes(self):\n        return bool(self.routelist)"
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def get_routes(self, include_static=False):\n        if include_static is True:\n            return self.routelist + self.static_routes\n        return self.routelist"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def get_route(self, name):\n        return self.routes.get(name)"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def connect(\n        self,\n        name,\n        pattern,\n        factory=None,\n        predicates=(),\n        pregenerator=None,\n        static=False,\n    ):\n        if name in self.routes:\n            oldroute = self.routes[name]\n            if oldroute in self.routelist:\n                self.routelist.remove(oldroute)\n\n        route = Route(name, pattern, factory, predicates, pregenerator)\n        if not static:\n            self.routelist.append(route)\n        else:\n            self.static_routes.append(route)\n\n        self.routes[name] = route\n        return route"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def generate(self, name, kw):\n        return self.routes[name].generate(kw)"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def __call__(self, request):\n        try:\n            path = request.path_info or '/'\n        except KeyError:\n            path = '/'\n        except UnicodeDecodeError as e:\n            raise URLDecodeError(\n                e.encoding, e.object, e.start, e.end, e.reason\n            )\n\n        for route in self.routelist:\n            match = route.match(path)\n            if match is not None:\n                preds = route.predicates\n                info = {'match': match, 'route': route}\n                if preds and not all(p(info, request) for p in preds):\n                    continue\n                return info\n\n        return {'route': None, 'match': None}"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "old_route_re = re.compile(r'(\\:[_a-zA-Z]\\w*)')\nstar_at_end = re.compile(r'\\*(\\w*)$')\n\nroute_re = re.compile(r'(\\{[_a-zA-Z][^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\})')"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def update_pattern(matchobj):\n    name = matchobj.group(0)\n    return '{%s}' % name[1:]"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/pyramid/src/pyramid/urldispatch.py",
      "content": "def _compile_route(route):\n    if route.__class__ is not str:\n        try:\n            route = text_(route, 'ascii')\n        except UnicodeDecodeError:\n            raise ValueError(\n                'The pattern value passed to add_route must be '\n                'either a Unicode string or a plain string without '\n                'any non-ASCII characters (you provided %r).' % route\n            )\n\n    if old_route_re.search(route) and not route_re.search(route):\n        route = old_route_re.sub(update_pattern, route)\n\n    if not route.startswith('/'):\n        route = '/' + route\n\n    remainder = None\n    if star_at_end.search(route):\n        route, remainder = route.rsplit('*', 1)\n\n    pat = route_re.split(route)\n\n    pat.reverse()\n    rpat = []\n    gen = []\n    prefix = pat.pop()\n\n    gen.append(\n        quote_path_segment(prefix, safe='/').replace('%', '%%')\n    )\n    rpat.append(re.escape(prefix))\n\n    while pat:\n        name = pat.pop()\n        name = name[1:-1]\n        if ':' in name:\n            name, reg = name.split(':', 1)\n        else:\n            reg = '[^/]+'\n        gen.append('%%(%s)s' % name)\n        name = f'(?P<{name}>{reg})'\n        rpat.append(name)\n        s = pat.pop()\n        if s:\n            rpat.append(re.escape(s))\n            gen.append(quote_path_segment(s, safe='/').replace('%', '%%'))\n\n    if remainder:\n        rpat.append('(?P<%s>.*?)' % remainder)\n        gen.append('%%(%s)s' % remainder)\n\n    pattern = ''.join(rpat) + '$'\n\n    match = re.compile(pattern).match\n\n    def matcher(path):\n        m = match(path)\n        if m is None:\n            return None\n        d = {}\n        for k, v in m.groupdict().items():\n            if k == remainder:\n                d[k] = split_path_info(v)\n            else:\n                d[k] = v\n        return d\n\n    gen = ''.join(gen)\n\n    def q(v):\n        return quote_path_segment(v, safe=PATH_SAFE)\n\n    def generator(dict):\n        newdict = {}\n        for k, v in dict.items():\n            if v.__class__ is bytes:\n                v = v.decode('utf-8')\n\n            if k == remainder:\n                if is_nonstr_iter(v):\n                    v = '/'.join([q(x) for x in v])\n                else:\n                    if v.__class__ is not str:\n                        v = str(v)\n                    v = q(v)\n            else:\n                if v.__class__ is not str:\n                    v = str(v)\n                v = q(v)\n\n            newdict[k] = v\n\n        result = gen % newdict\n        return result\n\n    return matcher, generator"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/pyramid/src/pyramid/location.py",
      "content": "def inside(resource1, resource2):\n    \"\"\"Is ``resource1`` 'inside' ``resource2``?  Return ``True`` if so, else\n    ``False``.\n\n    ``resource1`` is 'inside' ``resource2`` if ``resource2`` is a\n    :term:`lineage` ancestor of ``resource1``.  It is a lineage ancestor\n    if its parent (or one of its parent's parents, etc.) is an\n    ancestor.\n    \"\"\"\n    while resource1 is not None:\n        if resource1 is resource2:\n            return True\n        resource1 = resource1.__parent__\n\n    return False"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/pyramid/src/pyramid/location.py",
      "content": "def lineage(resource):\n    \"\"\"\n    Return a generator representing the :term:`lineage` of the\n    :term:`resource` object implied by the ``resource`` argument.  The\n    generator first returns ``resource`` unconditionally.  Then, if\n    ``resource`` supplies a ``__parent__`` attribute, return the resource\n    represented by ``resource.__parent__``.  If *that* resource has a\n    ``__parent__`` attribute, return that resource's parent, and so on,\n    until the resource being inspected either has no ``__parent__``\n    attribute or which has a ``__parent__`` attribute of ``None``.\n    For example, if the resource tree is::\n\n      thing1 = Thing()\n      thing2 = Thing()\n      thing2.__parent__ = thing1\n\n    Calling ``lineage(thing2)`` will return a generator.  When we turn\n    it into a list, we will get::\n\n      list(lineage(thing2))\n      [ <Thing object at thing2>, <Thing object at thing1> ]\n    \"\"\"\n    while resource is not None:\n        yield resource\n        # The common case is that the AttributeError exception below\n        # is exceptional as long as the developer is a \"good citizen\"\n        # who has a root object with a __parent__ of None.  Using an\n        # exception here instead of a getattr with a default is an\n        # important micro-optimization, because this function is\n        # called in any non-trivial application over and over again to\n        # generate URLs and paths.\n        try:\n            resource = resource.__parent__\n        except AttributeError:\n            resource = None"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "import mimetypes\nfrom os.path import getmtime, getsize\nimport venusian\nfrom webob import Response as _Response\nfrom zope.interface import implementer\n\nfrom pyramid.interfaces import IResponse, IResponseFactory\n\n_BLOCK_SIZE = 4096 * 64  # 256K"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "@implementer(IResponse)\nclass Response(_Response):\n    pass"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "class FileResponse(Response):\n    \"\"\"\n    A Response object that can be used to serve a static file from disk\n    simply.\n\n    ``path`` is a file path on disk.\n\n    ``request`` must be a Pyramid :term:`request` object.  Note\n    that a request *must* be passed if the response is meant to attempt to\n    use the ``wsgi.file_wrapper`` feature of the web server that you're using\n    to serve your Pyramid application.\n\n    ``cache_max_age`` is the number of seconds that should be used\n    to HTTP cache this response.\n\n    ``content_type`` is the content_type of the response.\n\n    ``content_encoding`` is the content_encoding of the response.\n    It's generally safe to leave this set to ``None`` if you're serving a\n    binary file.  This argument will be ignored if you also leave\n    ``content-type`` as ``None``.\n    \"\"\"\n\n    def __init__(\n        self,\n        path,\n        request=None,\n        cache_max_age=None,\n        content_type=None,\n        content_encoding=None,\n    ):\n        if content_type is None:\n            content_type, content_encoding = _guess_type(path)\n        super().__init__(\n            conditional_response=True,\n            content_type=content_type,\n            content_encoding=content_encoding,\n        )\n        self.last_modified = getmtime(path)\n        content_length = getsize(path)\n        f = open(path, 'rb')\n        app_iter = None\n        if request is not None:\n            environ = request.environ\n            if 'wsgi.file_wrapper' in environ:\n                app_iter = environ['wsgi.file_wrapper'](f, _BLOCK_SIZE)\n        if app_iter is None:\n            app_iter = FileIter(f, _BLOCK_SIZE)\n        self.app_iter = app_iter\n        # assignment of content_length must come after assignment of app_iter\n        self.content_length = content_length\n        if cache_max_age is not None:\n            self.cache_expires = cache_max_age"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "class FileIter:\n    \"\"\"A fixed-block-size iterator for use as a WSGI app_iter.\n\n    ``file`` is a Python file pointer (or at least an object with a ``read``\n    method that takes a size hint).\n\n    ``block_size`` is an optional block size for iteration.\n    \"\"\"\n\n    def __init__(self, file, block_size=_BLOCK_SIZE):\n        self.file = file\n        self.block_size = block_size\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        val = self.file.read(self.block_size)\n        if not val:\n            raise StopIteration\n        return val\n\n    def close(self):\n        self.file.close()"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "class response_adapter:\n    \"\"\"Decorator activated via a :term:`scan` which treats the function\n    being decorated as a :term:`response adapter` for the set of types or\n    interfaces passed as ``*types_or_ifaces`` to the decorator constructor.\n\n    For example, if you scan the following response adapter:\n\n    .. code-block:: python\n\n        from pyramid.response import Response\n        from pyramid.response import response_adapter\n\n        @response_adapter(int)\n        def myadapter(i):\n            return Response(status=i)\n\n    You can then return an integer from your view callables, and it will be\n    converted into a response with the integer as the status code.\n\n    More than one type or interface can be passed as a constructor argument.\n    The decorated response adapter will be called for each type or interface.\n\n    .. code-block:: python\n\n        import json\n\n        from pyramid.response import Response\n        from pyramid.response import response_adapter\n\n        @response_adapter(dict, list)\n        def myadapter(ob):\n            return Response(json.dumps(ob))\n\n    This method will have no effect until a :term:`scan` is performed\n    agains the package or module which contains it, ala:\n\n    .. code-block:: python\n\n        from pyramid.config import Configurator\n        config = Configurator()\n        config.scan('somepackage_containing_adapters')\n\n    Two additional keyword arguments which will be passed to the\n    :term:`venusian` ``attach`` function are ``_depth`` and ``_category``.\n\n    ``_depth`` is provided for people who wish to reuse this class from another\n    decorator. The default value is ``0`` and should be specified relative to\n    the ``response_adapter`` invocation. It will be passed in to the\n    :term:`venusian` ``attach`` function as the depth of the callstack when\n    Venusian checks if the decorator is being used in a class or module\n    context. It's not often used, but it can be useful in this circumstance.\n\n    ``_category`` sets the decorator category name. It can be useful in\n    combination with the ``category`` argument of ``scan`` to control which\n    views should be processed.\n\n    See the :py:func:`venusian.attach` function in Venusian for more\n    information about the ``_depth`` and ``_category`` arguments.\n\n    .. versionchanged:: 1.9.1\n       Added the ``_depth`` and ``_category`` arguments.\n\n    \"\"\"\n\n    venusian = venusian  # for unit testing\n\n    def __init__(self, *types_or_ifaces, **kwargs):\n        self.types_or_ifaces = types_or_ifaces\n        self.depth = kwargs.pop('_depth', 0)\n        self.category = kwargs.pop('_category', 'pyramid')\n        self.kwargs = kwargs\n\n    def register(self, scanner, name, wrapped):\n        config = scanner.config\n        for type_or_iface in self.types_or_ifaces:\n            config.add_response_adapter(wrapped, type_or_iface, **self.kwargs)\n\n    def __call__(self, wrapped):\n        self.venusian.attach(\n            wrapped,\n            self.register,\n            category=self.category,\n            depth=self.depth + 1,\n        )\n        return wrapped"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "def _get_response_factory(registry):\n    \"\"\"Obtain a :class: `pyramid.response.Response` using the\n    `pyramid.interfaces.IResponseFactory`.\n    \"\"\"\n    response_factory = registry.queryUtility(\n        IResponseFactory, default=lambda r: Response()\n    )\n\n    return response_factory"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/pyramid/src/pyramid/response.py",
      "content": "def _guess_type(path):\n    content_type, content_encoding = mimetypes.guess_type(path, strict=False)\n    if content_type is None:\n        content_type = 'application/octet-stream'\n    return content_type, content_encoding"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "import venusian\nfrom zope.interface import Interface, implementer\n\nfrom pyramid.interfaces import (\n    IApplicationCreated,\n    IBeforeRender,\n    IBeforeTraversal,\n    IContextFound,\n    INewRequest,\n    INewResponse,\n)"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "class subscriber:\n    \"\"\"Decorator activated via a :term:`scan` which treats the function\n    being decorated as an event subscriber for the set of interfaces passed\n    as ``*ifaces`` and the set of predicate terms passed as ``**predicates``\n    to the decorator constructor.\n\n    For example:\n\n    .. code-block:: python\n\n       from pyramid.events import NewRequest\n       from pyramid.events import subscriber\n\n       @subscriber(NewRequest)\n       def mysubscriber(event):\n           event.request.foo = 1\n\n    More than one event type can be passed as a constructor argument.  The\n    decorated subscriber will be called for each event type.\n\n    .. code-block:: python\n\n       from pyramid.events import NewRequest, NewResponse\n       from pyramid.events import subscriber\n\n       @subscriber(NewRequest, NewResponse)\n       def mysubscriber(event):\n           print(event)\n\n    When the ``subscriber`` decorator is used without passing an arguments,\n    the function it decorates is called for every event sent:\n\n    .. code-block:: python\n\n       from pyramid.events import subscriber\n\n       @subscriber()\n       def mysubscriber(event):\n           print(event)\n\n    This method will have no effect until a :term:`scan` is performed\n    against the package or module which contains it, ala:\n\n    .. code-block:: python\n\n       from pyramid.config import Configurator\n       config = Configurator()\n       config.scan('somepackage_containing_subscribers')\n\n    Any ``**predicate`` arguments will be passed along to\n    :meth:`pyramid.config.Configurator.add_subscriber`.  See\n    :ref:`subscriber_predicates` for a description of how predicates can\n    narrow the set of circumstances in which a subscriber will be called.\n\n    Two additional keyword arguments which will be passed to the\n    :term:`venusian` ``attach`` function are ``_depth`` and ``_category``.\n\n    ``_depth`` is provided for people who wish to reuse this class from another\n    decorator. The default value is ``0`` and should be specified relative to\n    the ``subscriber`` invocation. It will be passed in to the\n    :term:`venusian` ``attach`` function as the depth of the callstack when\n    Venusian checks if the decorator is being used in a class or module\n    context. It's not often used, but it can be useful in this circumstance.\n\n    ``_category`` sets the decorator category name. It can be useful in\n    combination with the ``category`` argument of ``scan`` to control which\n    views should be processed.\n\n    See the :py:func:`venusian.attach` function in Venusian for more\n    information about the ``_depth`` and ``_category`` arguments.\n\n    .. versionchanged:: 1.9.1\n       Added the ``_depth`` and ``_category`` arguments.\n\n    \"\"\"\n\n    venusian = venusian  # for unit testing\n\n    def __init__(self, *ifaces, **predicates):\n        self.ifaces = ifaces\n        self.predicates = predicates\n        self.depth = predicates.pop('_depth', 0)\n        self.category = predicates.pop('_category', 'pyramid')\n\n    def register(self, scanner, name, wrapped):\n        config = scanner.config\n        for iface in self.ifaces or (Interface,):\n            config.add_subscriber(wrapped, iface, **self.predicates)\n\n    def __call__(self, wrapped):\n        self.venusian.attach(\n            wrapped,\n            self.register,\n            category=self.category,\n            depth=self.depth + 1,\n        )\n        return wrapped"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(INewRequest)\nclass NewRequest:\n    \"\"\"An instance of this class is emitted as an :term:`event`\n    whenever :app:`Pyramid` begins to process a new request.  The\n    event instance has an attribute, ``request``, which is a\n    :term:`request` object.  This event class implements the\n    :class:`pyramid.interfaces.INewRequest` interface.\"\"\"\n\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(INewResponse)\nclass NewResponse:\n    \"\"\"An instance of this class is emitted as an :term:`event`\n    whenever any :app:`Pyramid` :term:`view` or :term:`exception\n    view` returns a :term:`response`.\n\n    The instance has two attributes:``request``, which is the request\n    which caused the response, and ``response``, which is the response\n    object returned by a view or renderer.\n\n    If the ``response`` was generated by an :term:`exception view`, the\n    request will have an attribute named ``exception``, which is the\n    exception object which caused the exception view to be executed.  If the\n    response was generated by a 'normal' view, this attribute of the request\n    will be ``None``.\n\n    This event will not be generated if a response cannot be created due to\n    an exception that is not caught by an exception view (no response is\n    created under this circumstace).\n\n    This class implements the\n    :class:`pyramid.interfaces.INewResponse` interface.\n\n    .. note::\n\n       Postprocessing a response is usually better handled in a WSGI\n       :term:`middleware` component than in subscriber code that is\n       called by a :class:`pyramid.interfaces.INewResponse` event.\n       The :class:`pyramid.interfaces.INewResponse` event exists\n       almost purely for symmetry with the\n       :class:`pyramid.interfaces.INewRequest` event.\n    \"\"\"\n\n    def __init__(self, request, response):\n        self.request = request\n        self.response = response"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(IBeforeTraversal)\nclass BeforeTraversal:\n    \"\"\"\n    An instance of this class is emitted as an :term:`event` after the\n    :app:`Pyramid` :term:`router` has attempted to find a :term:`route` object\n    but before any traversal or view code is executed. The instance has an\n    attribute, ``request``, which is the request object generated by\n    :app:`Pyramid`.\n\n    Notably, the request object **may** have an attribute named\n    ``matched_route``, which is the matched route if found. If no route\n    matched, this attribute is not available.\n\n    This class implements the :class:`pyramid.interfaces.IBeforeTraversal`\n    interface.\n    \"\"\"\n\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(IContextFound)\nclass ContextFound:\n    \"\"\"An instance of this class is emitted as an :term:`event` after\n    the :app:`Pyramid` :term:`router` finds a :term:`context`\n    object (after it performs traversal) but before any view code is\n    executed.  The instance has an attribute, ``request``, which is\n    the request object generated by :app:`Pyramid`.\n\n    Notably, the request object will have an attribute named\n    ``context``, which is the context that will be provided to the\n    view which will eventually be called, as well as other attributes\n    attached by context-finding code.\n\n    This class implements the\n    :class:`pyramid.interfaces.IContextFound` interface.\n\n    .. note::\n\n       As of :app:`Pyramid` 1.0, for backwards compatibility purposes, this\n       event may also be imported as :class:`pyramid.events.AfterTraversal`.\n    \"\"\"\n\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "AfterTraversal = ContextFound  # b/c as of 1.0"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(IApplicationCreated)\nclass ApplicationCreated:\n    \"\"\"An instance of this class is emitted as an :term:`event` when\n    the :meth:`pyramid.config.Configurator.make_wsgi_app` is\n    called.  The instance has an attribute, ``app``, which is an\n    instance of the :term:`router` that will handle WSGI requests.\n    This class implements the\n    :class:`pyramid.interfaces.IApplicationCreated` interface.\n\n    .. note::\n\n       For backwards compatibility purposes, this class can also be imported as\n       :class:`pyramid.events.WSGIApplicationCreatedEvent`.  This was the name\n       of the event class before :app:`Pyramid` 1.0.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n        self.object = app"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "WSGIApplicationCreatedEvent = ApplicationCreated  # b/c (as of 1.0)"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/pyramid/src/pyramid/events.py",
      "content": "@implementer(IBeforeRender)\nclass BeforeRender(dict):\n    \"\"\"\n    Subscribers to this event may introspect and modify the set of\n    :term:`renderer globals` before they are passed to a :term:`renderer`.\n    This event object itself has a dictionary-like interface that can be used\n    for this purpose.  For example::\n\n      from pyramid.events import subscriber\n      from pyramid.events import BeforeRender\n\n      @subscriber(BeforeRender)\n      def add_global(event):\n          event['mykey'] = 'foo'\n\n    An object of this type is sent as an event just before a :term:`renderer`\n    is invoked.\n\n    If a subscriber adds a key via ``__setitem__`` that already exists in\n    the renderer globals dictionary, it will overwrite the older value there.\n    This can be problematic because event subscribers to the BeforeRender\n    event do not possess any relative ordering.  For maximum interoperability\n    with other third-party subscribers, if you write an event subscriber meant\n    to be used as a BeforeRender subscriber, your subscriber code will need\n    to ensure no value already exists in the renderer globals dictionary before\n    setting an overriding value (which can be done using ``.get`` or\n    ``__contains__`` of the event object).\n\n    The dictionary returned from the view is accessible through the\n    :attr:`rendering_val` attribute of a :class:`~pyramid.events.BeforeRender`\n    event.\n\n    Suppose you return ``{'mykey': 'somevalue', 'mykey2': 'somevalue2'}`` from\n    your view callable, like so::\n\n      from pyramid.view import view_config\n\n      @view_config(renderer='some_renderer')\n      def myview(request):\n          return {'mykey': 'somevalue', 'mykey2': 'somevalue2'}\n\n    :attr:`rendering_val` can be used to access these values from the\n    :class:`~pyramid.events.BeforeRender` object::\n\n      from pyramid.events import subscriber\n      from pyramid.events import BeforeRender\n\n      @subscriber(BeforeRender)\n      def read_return(event):\n          # {'mykey': 'somevalue'} is returned from the view\n          print(event.rendering_val['mykey'])\n\n    In other words, :attr:`rendering_val` is the (non-system) value returned\n    by a view or passed to ``render*`` as ``value``.  This feature is new in\n    Pyramid 1.2.\n\n    For a description of the values present in the renderer globals dictionary,\n    see :ref:`renderer_system_values`.\n\n    .. seealso::\n\n        See also :class:`pyramid.interfaces.IBeforeRender`.\n    \"\"\"\n\n    def __init__(self, system, rendering_val=None):\n        dict.__init__(self, system)\n        self.rendering_val = rendering_val"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripting.py",
      "content": "from pyramid.config import global_registries\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import IRequestFactory, IRootFactory\nfrom pyramid.request import Request, apply_request_extensions\nfrom pyramid.threadlocal import RequestContext\nfrom pyramid.traversal import DefaultRootFactory"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripting.py",
      "content": "def get_root(app, request=None):\n    \"\"\"Return a tuple composed of ``(root, closer)`` when provided a\n    :term:`router` instance as the ``app`` argument.  The ``root``\n    returned is the application root object.  The ``closer`` returned\n    is a callable (accepting no arguments) that should be called when\n    your scripting application is finished using the root.\n\n    ``request`` is passed to the :app:`Pyramid` application root\n    factory to compute the root. If ``request`` is None, a default\n    will be constructed using the registry's :term:`Request Factory`\n    via the :meth:`pyramid.interfaces.IRequestFactory.blank` method.\n    \"\"\"\n    registry = app.registry\n    if request is None:\n        request = _make_request('/', registry)\n    request.registry = registry\n    ctx = RequestContext(request)\n    ctx.begin()\n\n    def closer():\n        ctx.end()\n\n    root = app.root_factory(request)\n    return root, closer"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripting.py",
      "content": "def prepare(request=None, registry=None):\n    \"\"\"This function pushes data onto the Pyramid threadlocal stack\n    (request and registry), making those objects 'current'.  It\n    returns a dictionary useful for bootstrapping a Pyramid\n    application in a scripting environment.\n\n    ``request`` is passed to the :app:`Pyramid` application root\n    factory to compute the root. If ``request`` is None, a default\n    will be constructed using the registry's :term:`Request Factory`\n    via the :meth:`pyramid.interfaces.IRequestFactory.blank` method.\n\n    If ``registry`` is not supplied, the last registry loaded from\n    :attr:`pyramid.config.global_registries` will be used. If you\n    have loaded more than one :app:`Pyramid` application in the\n    current process, you may not want to use the last registry\n    loaded, thus you can search the ``global_registries`` and supply\n    the appropriate one based on your own criteria.\n\n    The function returns a dictionary composed of ``root``,\n    ``closer``, ``registry``, ``request`` and ``root_factory``.  The\n    ``root`` returned is the application's root resource object.  The\n    ``closer`` returned is a callable (accepting no arguments) that\n    should be called when your scripting application is finished\n    using the root.  ``registry`` is the resolved registry object.\n    ``request`` is the request object passed or the constructed request\n    if no request is passed.  ``root_factory`` is the root factory used\n    to construct the root.\n\n    This function may be used as a context manager to call the ``closer``\n    automatically:\n\n    .. code-block:: python\n\n       registry = config.registry\n       with prepare(registry) as env:\n           request = env['request']\n           # ...\n\n    .. versionchanged:: 1.8\n\n       Added the ability to use the return value as a context manager.\n\n    .. versionchanged:: 2.0\n\n       Request finished callbacks added via\n       :meth:`pyramid.request.Request.add_finished_callback` will be invoked\n       by the ``closer``.\n\n    \"\"\"\n    if registry is None:\n        registry = getattr(request, 'registry', global_registries.last)\n    if registry is None:\n        raise ConfigurationError(\n            'No valid Pyramid applications could be '\n            'found, make sure one has been created '\n            'before trying to activate it.'\n        )\n    if request is None:\n        request = _make_request('/', registry)\n    request.registry = registry\n    ctx = RequestContext(request)\n    ctx.begin()\n    apply_request_extensions(request)\n\n    def closer():\n        if request.finished_callbacks:\n            request._process_finished_callbacks()\n        ctx.end()\n\n    root_factory = registry.queryUtility(\n        IRootFactory, default=DefaultRootFactory\n    )\n    root = root_factory(request)\n    if getattr(request, 'context', None) is None:\n        request.context = root\n    return AppEnvironment(\n        root=root,\n        closer=closer,\n        registry=registry,\n        request=request,\n        root_factory=root_factory,\n    )"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripting.py",
      "content": "class AppEnvironment(dict):\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self['closer']()"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripting.py",
      "content": "def _make_request(path, registry=None):\n    \"\"\"Return a :meth:`pyramid.request.Request` object anchored at a\n    given path. The object returned will be generated from the supplied\n    registry's :term:`Request Factory` using the\n    :meth:`pyramid.interfaces.IRequestFactory.blank` method.\n\n    This request object can be passed to :meth:`pyramid.scripting.get_root`\n    or :meth:`pyramid.scripting.prepare` to initialize an application in\n    preparation for executing a script with a proper environment setup.\n    URLs can then be generated with the object, as well as rendering\n    templates.\n\n    If ``registry`` is not supplied, the last registry loaded from\n    :attr:`pyramid.config.global_registries` will be used. If you have\n    loaded more than one :app:`Pyramid` application in the current\n    process, you may not want to use the last registry loaded, thus\n    you can search the ``global_registries`` and supply the appropriate\n    one based on your own criteria.\n    \"\"\"\n    if registry is None:\n        registry = global_registries.last\n    request_factory = registry.queryUtility(IRequestFactory, default=Request)\n    request = request_factory.blank(path)\n    request.registry = registry\n    return request"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "import operator\nimport threading\nfrom zope.interface import implementer\nfrom zope.interface.registry import Components\n\nfrom pyramid.decorator import reify\nfrom pyramid.interfaces import IIntrospectable, IIntrospector, ISettings\nfrom pyramid.path import CALLER_PACKAGE, caller_package"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "class Registry(Components, dict):\n    \"\"\"A registry object is an :term:`application registry`.\n\n    It is used by the framework itself to perform mappings of URLs to view\n    callables, as well as servicing other various framework duties. A registry\n    has its own internal API, but this API is rarely used by Pyramid\n    application developers (it's usually only used by developers of the\n    Pyramid framework and Pyramid addons).  But it has a number of attributes\n    that may be useful to application developers within application code,\n    such as ``settings``, which is a dictionary containing application\n    deployment settings.\n\n    For information about the purpose and usage of the application registry,\n    see :ref:`zca_chapter`.\n\n    The registry may be used both as an :class:`pyramid.interfaces.IDict` and\n    as a Zope component registry.\n    These two ways of storing configuration are independent.\n    Applications will tend to prefer to store information as key-values\n    whereas addons may prefer to use the component registry to avoid naming\n    conflicts and to provide more complex lookup mechanisms.\n\n    The application registry is usually accessed as ``request.registry`` in\n    application code. By the time a registry is used to handle requests it\n    should be considered frozen and read-only. Any changes to its internal\n    state should be done with caution and concern for thread-safety.\n\n    \"\"\"\n\n    # for optimization purposes, if no listeners are listening, don't try\n    # to notify them\n    has_listeners = False\n\n    _settings = None\n\n    def __init__(self, package_name=CALLER_PACKAGE, *args, **kw):\n        # add a registry-instance-specific lock, which is used when the lookup\n        # cache is mutated\n        self._lock = threading.Lock()\n        # add a view lookup cache\n        self._clear_view_lookup_cache()\n        if package_name is CALLER_PACKAGE:\n            package_name = caller_package().__name__\n        Components.__init__(self, package_name, *args, **kw)\n        dict.__init__(self)"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def _clear_view_lookup_cache(self):\n        self._view_lookup_cache = {}"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def __bool__(self):\n        # defeat bool determination via dict.__len__\n        return True"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "@reify\n    def package_name(self):\n        return self.__name__"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def registerSubscriptionAdapter(self, *arg, **kw):\n        result = Components.registerSubscriptionAdapter(self, *arg, **kw)\n        self.has_listeners = True\n        return result"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def registerSelfAdapter(\n        self, required=None, provided=None, name='', info='', event=True\n    ):\n        # registerAdapter analogue which always returns the object itself\n        # when required is matched\n        return self.registerAdapter(\n            lambda x: x,\n            required=required,\n            provided=provided,\n            name=name,\n            info=info,\n            event=event,\n        )"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def queryAdapterOrSelf(self, object, interface, default=None):\n        # queryAdapter analogue which returns the object if it implements\n        # the interface, otherwise it will return an adaptation to the\n        # interface\n        if not interface.providedBy(object):\n            return self.queryAdapter(object, interface, default=default)\n        return object"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def registerHandler(self, *arg, **kw):\n        result = Components.registerHandler(self, *arg, **kw)\n        self.has_listeners = True\n        return result"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def notify(self, *events):\n        if self.has_listeners:\n            # iterating over subscribers assures they get executed\n            [_ for _ in self.subscribers(events, None)]"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "# backwards compatibility for code that wants to look up a settings\n    # object via ``registry.getUtility(ISettings)``\n    def _get_settings(self):\n        return self._settings"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def _set_settings(self, settings):\n        self.registerUtility(settings, ISettings)\n        self._settings = settings"
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "settings = property(_get_settings, _set_settings)"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "@implementer(IIntrospector)\nclass Introspector:\n    def __init__(self):\n        self._refs = {}\n        self._categories = {}\n        self._counter = 0"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def add(self, intr):\n        category = self._categories.setdefault(intr.category_name, {})\n        category[intr.discriminator] = intr\n        category[intr.discriminator_hash] = intr\n        intr.order = self._counter\n        self._counter += 1"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def get(self, category_name, discriminator, default=None):\n        category = self._categories.setdefault(category_name, {})\n        intr = category.get(discriminator, default)\n        return intr"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def get_category(self, category_name, default=None, sort_key=None):\n        if sort_key is None:\n            sort_key = operator.attrgetter('order')\n        category = self._categories.get(category_name)\n        if category is None:\n            return default\n        values = category.values()\n        values = sorted(set(values), key=sort_key)\n        return [\n            {'introspectable': intr, 'related': self.related(intr)}\n            for intr in values\n        ]"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def categorized(self, sort_key=None):\n        L = []\n        for category_name in self.categories():\n            L.append(\n                (\n                    category_name,\n                    self.get_category(category_name, sort_key=sort_key),\n                )\n            )\n        return L"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def categories(self):\n        return sorted(self._categories.keys())"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def remove(self, category_name, discriminator):\n        intr = self.get(category_name, discriminator)\n        if intr is None:\n            return\n        L = self._refs.pop(intr, [])\n        for d in L:\n            L2 = self._refs[d]\n            L2.remove(intr)\n        category = self._categories[intr.category_name]\n        del category[intr.discriminator]\n        del category[intr.discriminator_hash]"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def _get_intrs_by_pairs(self, pairs):\n        introspectables = []\n        for pair in pairs:\n            category_name, discriminator = pair\n            intr = self._categories.get(category_name, {}).get(discriminator)\n            if intr is None:\n                raise KeyError((category_name, discriminator))\n            introspectables.append(intr)\n        return introspectables"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def relate(self, *pairs):\n        introspectables = self._get_intrs_by_pairs(pairs)\n        relatable = ((x, y) for x in introspectables for y in introspectables)\n        for x, y in relatable:\n            L = self._refs.setdefault(x, [])\n            if x is not y and y not in L:\n                L.append(y)"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def unrelate(self, *pairs):\n        introspectables = self._get_intrs_by_pairs(pairs)\n        relatable = ((x, y) for x in introspectables for y in introspectables)\n        for x, y in relatable:\n            L = self._refs.get(x, [])\n            if y in L:\n                L.remove(y)"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def related(self, intr):\n        category_name, discriminator = intr.category_name, intr.discriminator\n        intr = self._categories.get(category_name, {}).get(discriminator)\n        if intr is None:\n            raise KeyError((category_name, discriminator))\n        return self._refs.get(intr, [])"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "@implementer(IIntrospectable)\nclass Introspectable(dict):\n    order = 0  # mutated by introspector.add\n    action_info = None  # mutated by self.register\n\n    def __init__(self, category_name, discriminator, title, type_name):\n        self.category_name = category_name\n        self.discriminator = discriminator\n        self.title = title\n        self.type_name = type_name\n        self._relations = []"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def relate(self, category_name, discriminator):\n        self._relations.append((True, category_name, discriminator))"
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def unrelate(self, category_name, discriminator):\n        self._relations.append((False, category_name, discriminator))"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def _assert_resolved(self):\n        assert undefer(self.discriminator) is self.discriminator"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "@property\n    def discriminator_hash(self):\n        self._assert_resolved()\n        return hash(self.discriminator)"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def __hash__(self):\n        self._assert_resolved()\n        return hash((self.category_name,) + (self.discriminator,))"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def __repr__(self):\n        self._assert_resolved()\n        return '<{} category {!r}, discriminator {!r}>'.format(\n            self.__class__.__name__,\n            self.category_name,\n            self.discriminator,\n        )"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def __bool__(self):\n        return True"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def register(self, introspector, action_info):\n        self.discriminator = undefer(self.discriminator)\n        self.action_info = action_info\n        introspector.add(self)\n        for relate, category_name, discriminator in self._relations:\n            discriminator = undefer(discriminator)\n            if relate:\n                method = introspector.relate\n            else:\n                method = introspector.unrelate\n            method(\n                (self.category_name, self.discriminator),\n                (category_name, discriminator),\n            )"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "class Deferred:\n    \"\"\"Can be used by a third-party configuration extender to wrap a\n    :term:`discriminator` during configuration if an immediately hashable\n    discriminator cannot be computed because it relies on unresolved values.\n    The function should accept no arguments and should return a hashable\n    discriminator.\"\"\"\n\n    def __init__(self, func):\n        self.func = func"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "@reify\n    def value(self):\n        result = self.func()\n        del self.func\n        return result"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def resolve(self):\n        return self.value"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "def undefer(v):\n    \"\"\"Function which accepts an object and returns it unless it is a\n    :class:`pyramid.registry.Deferred` instance.  If it is an instance of\n    that class, its ``resolve`` method is called, and the result of the\n    method is returned.\"\"\"\n    if isinstance(v, Deferred):\n        v = v.resolve()\n    return v"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "class predvalseq(tuple):\n    \"\"\"A subtype of tuple used to represent a sequence of predicate values\"\"\""
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/pyramid/src/pyramid/registry.py",
      "content": "global_registry = Registry('global')"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "import functools\nfrom importlib import import_module\nfrom importlib.machinery import SOURCE_SUFFIXES\nimport os\nimport pkg_resources\nimport sys\nfrom zope.interface import implementer\n\nfrom pyramid.interfaces import IAssetDescriptor\n\ninit_names = ['__init__%s' % x for x in SOURCE_SUFFIXES]"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def caller_path(path, level=2):\n    if not os.path.isabs(path):\n        module = caller_module(level + 1)\n        prefix = package_path(module)\n        path = os.path.join(prefix, path)\n    return path"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def caller_module(level=2, sys=sys):\n    module_globals = sys._getframe(level).f_globals\n    module_name = module_globals.get('__name__') or '__main__'\n    module = sys.modules[module_name]\n    return module"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def package_name(pkg_or_module):\n    \"\"\"If this function is passed a module, return the dotted Python\n    package name of the package in which the module lives.  If this\n    function is passed a package, return the dotted Python package\n    name of the package itself.\"\"\"\n    if pkg_or_module is None or pkg_or_module.__name__ == '__main__':\n        return '__main__'\n    pkg_name = pkg_or_module.__name__\n    pkg_filename = getattr(pkg_or_module, '__file__', None)\n    if pkg_filename is None:\n        # Namespace packages do not have __init__.py* files,\n        # and so have no __file__ attribute\n        return pkg_name\n    splitted = os.path.split(pkg_filename)\n    if splitted[-1] in init_names:\n        # it's a package\n        return pkg_name\n    return pkg_name.rsplit('.', 1)[0]"
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def package_of(pkg_or_module):\n    \"\"\"Return the package of a module or return the package itself\"\"\"\n    pkg_name = package_name(pkg_or_module)\n    __import__(pkg_name)\n    return sys.modules[pkg_name]"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def caller_package(level=2, caller_module=caller_module):\n    # caller_module in arglist for tests\n    module = caller_module(level + 1)\n    f = getattr(module, '__file__', '')\n    if ('__init__.py' in f) or ('__init__$py' in f):  # empty at >>>\n        # Module is a package\n        return module\n    # Go up one level to get package\n    package_name = module.__name__.rsplit('.', 1)[0]\n    return sys.modules[package_name]"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def package_path(package):\n    # computing the abspath is actually kinda expensive so we memoize\n    # the result\n    prefix = getattr(package, '__abspath__', None)\n    if prefix is None:\n        prefix = pkg_resources.resource_filename(package.__name__, '')\n        # pkg_resources doesn't care whether we feed it a package\n        # name or a module name within the package, the result\n        # will be the same: a directory name to the package itself\n        try:\n            package.__abspath__ = prefix\n        except Exception:\n            # this is only an optimization, ignore any error\n            pass\n    return prefix"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "class _CALLER_PACKAGE:\n    def __repr__(self):  # pragma: no cover (for docs)\n        return 'pyramid.path.CALLER_PACKAGE'"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "CALLER_PACKAGE = _CALLER_PACKAGE()"
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "class Resolver:\n    def __init__(self, package=CALLER_PACKAGE):\n        if package in (None, CALLER_PACKAGE):\n            self.package = package\n        else:\n            if isinstance(package, str):\n                try:\n                    __import__(package)\n                except ImportError:\n                    raise ValueError(\n                        f'The dotted name {package!r} cannot be imported'\n                    )\n                package = sys.modules[package]\n            self.package = package_of(package)"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def get_package_name(self):\n        if self.package is CALLER_PACKAGE:\n            package_name = caller_package().__name__\n        else:\n            package_name = self.package.__name__\n        return package_name"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def get_package(self):\n        if self.package is CALLER_PACKAGE:\n            package = caller_package()\n        else:\n            package = self.package\n        return package"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "class AssetResolver(Resolver):\n    \"\"\"A class used to resolve an :term:`asset specification` to an\n    :term:`asset descriptor`.\n\n    .. versionadded:: 1.3\n\n    The constructor accepts a single argument named ``package`` which may be\n    any of:\n\n    - A fully qualified (not relative) dotted name to a module or package\n\n    - a Python module or package object\n\n    - The value ``None``\n\n    - The constant value :attr:`pyramid.path.CALLER_PACKAGE`.\n\n    The default value is :attr:`pyramid.path.CALLER_PACKAGE`.\n\n    The ``package`` is used when a relative asset specification is supplied\n    to the :meth:`~pyramid.path.AssetResolver.resolve` method.  An asset\n    specification without a colon in it is treated as relative.\n\n    If ``package`` is ``None``, the resolver will\n    only be able to resolve fully qualified (not relative) asset\n    specifications.  Any attempt to resolve a relative asset specification\n    will result in an :exc:`ValueError` exception.\n\n    If ``package`` is :attr:`pyramid.path.CALLER_PACKAGE`,\n    the resolver will treat relative asset specifications as\n    relative to the caller of the :meth:`~pyramid.path.AssetResolver.resolve`\n    method.\n\n    If ``package`` is a *module* or *module name* (as opposed to a package or\n    package name), its containing package is computed and this\n    package is used to derive the package name (all names are resolved relative\n    to packages, never to modules).  For example, if the ``package`` argument\n    to this type was passed the string ``xml.dom.expatbuilder``, and\n    ``template.pt`` is supplied to the\n    :meth:`~pyramid.path.AssetResolver.resolve` method, the resulting absolute\n    asset spec would be ``xml.minidom:template.pt``, because\n    ``xml.dom.expatbuilder`` is a module object, not a package object.\n\n    If ``package`` is a *package* or *package name* (as opposed to a module or\n    module name), this package will be used to compute relative\n    asset specifications.  For example, if the ``package`` argument to this\n    type was passed the string ``xml.dom``, and ``template.pt`` is supplied\n    to the :meth:`~pyramid.path.AssetResolver.resolve` method, the resulting\n    absolute asset spec would be ``xml.minidom:template.pt``.\n    \"\"\""
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/pyramid/src/pyramid/path.py",
      "content": "def resolve(self, spec):\n        \"\"\"\n        Resolve the asset spec named as ``spec`` to an object that has the\n        attributes and methods described in\n        :class:`pyramid.interfaces.IAssetDescriptor`.\n\n        If ``spec`` is an absolute filename\n        (e.g. ``/path/to/myproject/templates/foo.pt``) or an absolute asset\n        spec (e.g. ``myproject:templates.foo.pt``), an asset descriptor is\n        returned without taking into account the ``package`` passed to this\n        class' constructor.\n\n        If ``spec`` is a *relative* asset specification (an asset\n        specification without a ``:`` in it, e.g. ``templates/foo.pt``), the\n        ``package`` argument of the constructor is used as the package\n        portion of the asset spec.  For example:\n\n        .. code-block:: python\n\n           a = AssetResolver('"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/pyramid/src/pyramid/resource.py",
      "content": "\"\"\" Backwards compatibility shim module (forever). \"\"\""
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/pyramid/src/pyramid/resource.py",
      "content": "from pyramid.asset import *  # noqa b/w compat"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/pyramid/src/pyramid/resource.py",
      "content": "resolve_resource_spec = resolve_asset_spec  # noqa\nresource_spec_from_abspath = asset_spec_from_abspath  # noqa\nabspath_from_resource_spec = abspath_from_asset_spec  # noqa"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "from zope.interface import implementer, providedBy\n\nfrom pyramid.events import (\n    BeforeTraversal,\n    ContextFound,\n    NewRequest,\n    NewResponse,\n)\nfrom pyramid.httpexceptions import HTTPNotFound\nfrom pyramid.interfaces import (\n    IDebugLogger,\n    IExecutionPolicy,\n    IRequest,\n    IRequestExtensions,\n    IRequestFactory,\n    IRootFactory,\n    IRouter,\n    IRouteRequest,\n    IRoutesMapper,\n    ITraverser,\n    ITweens,\n)\nfrom pyramid.request import Request, apply_request_extensions\nfrom pyramid.threadlocal import RequestContext\nfrom pyramid.traversal import DefaultRootFactory, ResourceTreeTraverser\nfrom pyramid.view import _call_view"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "@implementer(IRouter)\nclass Router:\n    debug_notfound = False\n    debug_routematch = False\n\n    def __init__(self, registry):\n        q = registry.queryUtility\n        self.logger = q(IDebugLogger)\n        self.root_factory = q(IRootFactory, default=DefaultRootFactory)\n        self.routes_mapper = q(IRoutesMapper)\n        self.request_factory = q(IRequestFactory, default=Request)\n        self.request_extensions = q(IRequestExtensions)\n        self.execution_policy = q(\n            IExecutionPolicy, default=default_execution_policy\n        )\n        self.orig_handle_request = self.handle_request\n        tweens = q(ITweens)\n        if tweens is not None:\n            self.handle_request = tweens(self.handle_request, registry)\n        self.root_policy = self.root_factory  # b/w compat\n        self.registry = registry\n        settings = registry.settings\n        if settings is not None:\n            self.debug_notfound = settings['debug_notfound']\n            self.debug_routematch = settings['debug_routematch']"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def handle_request(self, request):\n        attrs = request.__dict__\n        registry = attrs['registry']\n\n        request.request_iface = IRequest\n        context = None\n        routes_mapper = self.routes_mapper\n        debug_routematch = self.debug_routematch\n        adapters = registry.adapters\n        has_listeners = registry.has_listeners\n        notify = registry.notify\n        logger = self.logger\n\n        has_listeners and notify(NewRequest(request))\n        # find the root object\n        root_factory = self.root_factory\n        if routes_mapper is not None:\n            info = routes_mapper(request)\n            match, route = info['match'], info['route']\n            if route is None:\n                if debug_routematch:\n                    msg = 'no route matched for url %s' % request.url\n                    logger and logger.debug(msg)\n            else:\n                attrs['matchdict'] = match\n                attrs['matched_route'] = route\n\n                if debug_routematch:\n                    msg = (\n                        'route matched for url %s; '\n                        'route_name: %r, '\n                        'path_info: %r, '\n                        'pattern: %r, '\n                        'matchdict: %r, '\n                        'predicates: %r'\n                        % (\n                            request.url,\n                            route.name,\n                            request.path_info,\n                            route.pattern,\n                            match,\n                            ', '.join([p.text() for p in route.predicates]),\n                        )\n                    )\n                    logger and logger.debug(msg)\n\n                request.request_iface = registry.queryUtility(\n                    IRouteRequest, name=route.name, default=IRequest\n                )\n\n                root_factory = route.factory or self.root_factory\n\n        # Notify anyone listening that we are about to start traversal\n        #\n        # Notify before creating root_factory in case we want to do something\n        # special on a route we may have matched. See\n        # https://github.com/Pylons/pyramid/pull/1876 for ideas of what is\n        # possible.\n        has_listeners and notify(BeforeTraversal(request))\n\n        # Create the root factory\n        root = root_factory(request)\n        attrs['root'] = root\n\n        # We are about to traverse and find a context\n        traverser = adapters.queryAdapter(root, ITraverser)\n        if traverser is None:\n            traverser = ResourceTreeTraverser(root)\n        tdict = traverser(request)\n\n        context, view_name, subpath, traversed, vroot, vroot_path = (\n            tdict['context'],\n            tdict['view_name'],\n            tdict['subpath'],\n            tdict['traversed'],\n            tdict['virtual_root'],\n            tdict['virtual_root_path'],\n        )\n\n        attrs.update(tdict)\n\n        # Notify anyone listening that we have a context and traversal is\n        # complete\n        has_listeners and notify(ContextFound(request))\n\n        # find a view callable\n        context_iface = providedBy(context)\n        response = _call_view(\n            registry, request, context, context_iface, view_name\n        )\n\n        if response is None:\n            if self.debug_notfound:\n                msg = (\n                    'debug_notfound of url %s; path_info: %r, '\n                    'context: %r, view_name: %r, subpath: %r, '\n                    'traversed: %r, root: %r, vroot: %r, '\n                    'vroot_path: %r'\n                    % (\n                        request.url,\n                        request.path_info,\n                        context,\n                        view_name,\n                        subpath,\n                        traversed,\n                        root,\n                        vroot,\n                        vroot_path,\n                    )\n                )\n                logger and logger.debug(msg)\n            else:\n                msg = request.path_info\n            raise HTTPNotFound(msg)\n\n        return response"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def invoke_subrequest(self, request, use_tweens=False):\n        \"\"\"Obtain a response object from the Pyramid application based on\n        information in the ``request`` object provided.  The ``request``\n        object must be an object that implements the Pyramid request\n        interface (such as a :class:`pyramid.request.Request` instance).  If\n        ``use_tweens`` is ``True``, the request will be sent to the\n        :term:`tween` in the tween stack closest to the request ingress.  If\n        ``use_tweens`` is ``False``, the request will be sent to the main\n        router handler, and no tweens will be invoked.\n\n        See the API for pyramid.request for complete documentation.\n        \"\"\"\n        request.registry = self.registry\n        request.invoke_subrequest = self.invoke_subrequest\n        extensions = self.request_extensions\n        if extensions is not None:\n            apply_request_extensions(request, extensions=extensions)\n        with RequestContext(request):\n            return self.invoke_request(request, _use_tweens=use_tweens)"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def request_context(self, environ):\n        \"\"\"\n        Create a new request context from a WSGI environ.\n\n        The request context is used to push/pop the threadlocals required\n        when processing the request. It also contains an initialized\n        :class:`pyramid.interfaces.IRequest` instance using the registered\n        :class:`pyramid.interfaces.IRequestFactory`. The context may be\n        used as a context manager to control the threadlocal lifecycle:\n\n        .. code-block:: python\n\n            with router.request_context(environ) as request:\n                ...\n\n        Alternatively, the context may be used without the ``with`` statement\n        by manually invoking its ``begin()`` and ``end()`` methods.\n\n        .. code-block:: python\n\n            ctx = router.request_context(environ)\n            request = ctx.begin()\n            try:\n                ...\n            finally:\n                ctx.end()\n\n        \"\"\"\n        request = self.request_factory(environ)\n        request.registry = self.registry\n        request.invoke_subrequest = self.invoke_subrequest\n        extensions = self.request_extensions\n        if extensions is not None:\n            apply_request_extensions(request, extensions=extensions)\n        return RequestContext(request)"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def invoke_request(self, request, _use_tweens=True):\n        \"\"\"\n        Execute a request through the request processing pipeline and\n        return the generated response.\n\n        \"\"\"\n        registry = self.registry\n        has_listeners = registry.has_listeners\n        notify = registry.notify\n\n        if _use_tweens:\n            handle_request = self.handle_request\n        else:\n            handle_request = self.orig_handle_request\n\n        try:\n            response = handle_request(request)\n\n            if request.response_callbacks:\n                request._process_response_callbacks(response)\n\n            has_listeners and notify(NewResponse(request, response))\n\n            return response\n\n        finally:\n            self.finish_request(request)"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def finish_request(self, request):\n        if request.finished_callbacks:\n            request._process_finished_callbacks()\n        request.__dict__.pop('context', None)  # Break potential ref cycle"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def __call__(self, environ, start_response):\n        \"\"\"\n        Accept ``environ`` and ``start_response``; create a\n        :term:`request` and route the request to a :app:`Pyramid`\n        view based on introspection of :term:`view configuration`\n        within the application registry; call ``start_response`` and\n        return an iterable.\n        \"\"\"\n        response = self.execution_policy(environ, self)\n        return response(environ, start_response)"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/pyramid/src/pyramid/router.py",
      "content": "def default_execution_policy(environ, router):\n    with router.request_context(environ) as request:\n        return router.invoke_request(request)"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "import inspect\nfrom zope.interface import implementer, provider\n\nfrom pyramid import renderers\nfrom pyramid.csrf import check_csrf_origin, check_csrf_token\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.httpexceptions import HTTPForbidden\nfrom pyramid.interfaces import (\n    IDebugLogger,\n    IDefaultCSRFOptions,\n    IDefaultPermission,\n    IResponse,\n    ISecurityPolicy,\n    IViewMapper,\n    IViewMapperFactory,\n)\nfrom pyramid.response import Response\nfrom pyramid.security import NO_PERMISSION_REQUIRED\nfrom pyramid.util import (\n    is_bound_method,\n    is_unbound_method,\n    object_description,\n    takes_one_arg,\n)\nfrom pyramid.view import render_view_to_response"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def view_description(view):\n    try:\n        return view.__text__\n    except AttributeError:\n        return object_description(view)"
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def requestonly(view, attr=None):\n    return takes_one_arg(view, attr=attr, argname='request')"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "@implementer(IViewMapper)\n@provider(IViewMapperFactory)\nclass DefaultViewMapper:\n    def __init__(self, **kw):\n        self.attr = kw.get('attr')\n\n    def __call__(self, view):\n        if is_unbound_method(view) and self.attr is None:\n            raise ConfigurationError(\n                'Unbound method calls are not supported, please set the '\n                'class as your `view` and the method as your `attr`'\n            )\n\n        if inspect.isclass(view):\n            view = self.map_class(view)\n        else:\n            view = self.map_nonclass(view)\n        return view"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_class(self, view):\n        ronly = requestonly(view, self.attr)\n        if ronly:\n            mapped_view = self.map_class_requestonly(view)\n        else:\n            mapped_view = self.map_class_native(view)\n        mapped_view.__text__ = 'method {} of {}'.format(\n            self.attr or '__call__',\n            object_description(view),\n        )\n        return mapped_view"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_nonclass(self, view):\n        mapped_view = view\n        ronly = requestonly(view, self.attr)\n        if ronly:\n            mapped_view = self.map_nonclass_requestonly(view)\n        elif self.attr:\n            mapped_view = self.map_nonclass_attr(view)\n        if inspect.isroutine(mapped_view):\n            if is_bound_method(view):\n                _mapped_view = mapped_view\n\n                def mapped_view(context, request):\n                    return _mapped_view(context, request)\n\n            if self.attr is not None:\n                mapped_view.__text__ = 'attr {} of {}'.format(\n                    self.attr,\n                    object_description(view),\n                )\n            else:\n                mapped_view.__text__ = object_description(view)\n        return mapped_view"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_class_requestonly(self, view):\n        attr = self.attr\n\n        def _class_requestonly_view(context, request):\n            inst = view(request)\n            request.__view__ = inst\n            if attr is None:\n                response = inst()\n            else:\n                response = getattr(inst, attr)()\n            return response\n\n        return _class_requestonly_view"
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_class_native(self, view):\n        attr = self.attr\n\n        def _class_view(context, request):\n            inst = view(context, request)\n            request.__view__ = inst\n            if attr is None:\n                response = inst()\n            else:\n                response = getattr(inst, attr)()\n            return response\n\n        return _class_view"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_nonclass_requestonly(self, view):\n        attr = self.attr\n\n        def _requestonly_view(context, request):\n            if attr is None:\n                response = view(request)\n            else:\n                response = getattr(view, attr)(request)\n            return response\n\n        return _requestonly_view"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def map_nonclass_attr(self, view):\n        def _attr_view(context, request):\n            response = getattr(view, self.attr)(context, request)\n            return response\n\n        return _attr_view"
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def wraps_view(wrapper):\n    def inner(view, info):\n        wrapper_view = wrapper(view, info)\n        return preserve_view_attrs(view, wrapper_view)\n\n    return inner"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def preserve_view_attrs(view, wrapper):\n    if view is None:\n        return wrapper\n\n    if wrapper is view:\n        return view\n\n    original_view = getattr(view, '__original_view__', None)\n\n    if original_view is None:\n        original_view = view\n\n    wrapper.__wraps__ = view\n    wrapper.__original_view__ = original_view\n    wrapper.__module__ = view.__module__\n    wrapper.__doc__ = view.__doc__\n\n    try:\n        wrapper.__name__ = view.__name__\n    except AttributeError:\n        wrapper.__name__ = repr(view)\n\n    for attr in (\n        '__permitted__',\n        '__call_permissive__',\n        '__permission__',\n        '__predicated__',\n        '__predicates__',\n        '__accept__',\n        '__order__',\n        '__text__',\n    ):\n        try:\n            setattr(wrapper, attr, getattr(view, attr))\n        except AttributeError:\n            pass\n\n    return wrapper"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def mapped_view(view, info):\n    mapper = info.options.get('mapper')\n    if mapper is None:\n        mapper = getattr(view, '__view_mapper__', None)\n        if mapper is None:\n            mapper = info.registry.queryUtility(IViewMapperFactory)\n            if mapper is None:\n                mapper = DefaultViewMapper\n\n    mapped_view = mapper(**info.options)(view)\n    return mapped_view\n\n\nmapped_view.options = ('mapper', 'attr')"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def owrapped_view(view, info):\n    wrapper_viewname = info.options.get('wrapper')\n    viewname = info.options.get('name')\n    if not wrapper_viewname:\n        return view\n\n    def _owrapped_view(context, request):\n        response = view(context, request)\n        request.wrapped_response = response\n        request.wrapped_body = response.body\n        request.wrapped_view = view\n        wrapped_response = render_view_to_response(\n            context, request, wrapper_viewname\n        )\n        if wrapped_response is None:\n            raise ValueError(\n                'No wrapper view named %r found when executing view '\n                'named %r' % (wrapper_viewname, viewname)\n            )\n        return wrapped_response\n\n    return _owrapped_view\n\n\nowrapped_view.options = ('name', 'wrapper')"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def http_cached_view(view, info):\n    if info.settings.get('prevent_http_cache', False):\n        return view\n\n    seconds = info.options.get('http_cache')\n\n    if seconds is None:\n        return view\n\n    options = {}\n\n    if isinstance(seconds, (tuple, list)):\n        try:\n            seconds, options = seconds\n        except ValueError:\n            raise ConfigurationError(\n                'If http_cache parameter is a tuple or list, it must be '\n                'in the form (seconds, options); not %s' % (seconds,)\n            )\n\n    def wrapper(context, request):\n        response = view(context, request)\n        prevent_caching = getattr(\n            response.cache_control, 'prevent_auto', False\n        )\n        if not prevent_caching:\n            response.cache_expires(seconds, **options)\n        return response\n\n    return wrapper\n\n\nhttp_cached_view.options = ('http_cache',)"
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def secured_view(view, info):\n    for wrapper in (_secured_view, _authdebug_view):\n        view = wraps_view(wrapper)(view, info)\n    return view\n\n\nsecured_view.options = ('permission',)"
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def _secured_view(view, info):\n    permission = info.options.get('permission')\n\n    if not info.exception_only and permission is None:\n        permission = info.registry.queryUtility(IDefaultPermission)\n\n    if permission == NO_PERMISSION_REQUIRED:\n        permission = None\n\n    policy = info.registry.queryUtility(ISecurityPolicy)\n    if policy is None or permission is None:\n        return view\n\n    def permitted(context, request):\n        return policy.permits(request, context, permission)\n\n    def secured_view(context, request):\n        result = permitted(context, request)\n        if result:\n            return view(context, request)\n        view_name = getattr(view, '__name__', view)\n        msg = getattr(\n            request,\n            'authdebug_message',\n            'Unauthorized: %s failed permission check' % view_name,\n        )\n        raise HTTPForbidden(msg, result=result)\n\n    secured_view.__call_permissive__ = view\n    secured_view.__permitted__ = permitted\n    secured_view.__permission__ = permission\n    return secured_view"
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def _authdebug_view(view, info):\n    settings = info.settings\n    if not settings or not settings.get('debug_authorization', False):\n        return view\n\n    permission = info.options.get('permission')\n\n    if info.exception_only and (\n        permission is None or permission == NO_PERMISSION_REQUIRED\n    ):\n        return view\n\n    if permission is None:\n        permission = info.registry.queryUtility(IDefaultPermission)\n\n    policy = info.registry.queryUtility(ISecurityPolicy)\n    logger = info.registry.queryUtility(IDebugLogger)\n\n    def authdebug_view(context, request):\n        if policy:\n            if permission is NO_PERMISSION_REQUIRED:\n                msg = 'Allowed (NO_PERMISSION_REQUIRED)'\n            elif permission is None:\n                msg = 'Allowed (no permission registered)'\n            else:\n                result = policy.permits(request, context, permission)\n                msg = str(result)\n        else:\n            msg = 'Allowed (no security policy in use)'\n\n        view_name = getattr(request, 'view_name', None)\n        url = getattr(request, 'url', None)\n        msg = (\n            'debug_authorization of url %s (view name %r against '\n            'context %r): %s' % (url, view_name, context, msg)\n        )\n        if logger:\n            logger.debug(msg)\n        if request is not None:\n            request.authdebug_message = msg\n        return view(context, request)\n\n    return authdebug_view"
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def rendered_view(view, info):\n    renderer = info.options.get('renderer')\n    if renderer is None:\n        def viewresult_to_response(context, request):\n            result = view(context, request)\n            if result.__class__ is Response:\n                response = result\n            else:\n                response = info.registry.queryAdapterOrSelf(result, IResponse)\n                if response is None:\n                    if result is None:\n                        append = (\n                            ' You may have forgotten to return a value '\n                            'from the view callable.'\n                        )\n                    elif isinstance(result, dict):\n                        append = (\n                            ' You may have forgotten to define a '\n                            'renderer in the view configuration.'\n                        )\n                    else:\n                        append = ''\n\n                    msg = (\n                        'Could not convert return value of the view '\n                        'callable %s into a response object. '\n                        'The value returned was %r.' + append\n                    )\n\n                    raise ValueError(msg % (view_description(view), result))\n\n            return response\n\n        return viewresult_to_response\n\n    if renderer is renderers.null_renderer:\n        return view\n\n    def rendered_view(context, request):\n        result = view(context, request)\n        if result.__class__ is Response:\n            response = result\n        else:\n            response = info.registry.queryAdapterOrSelf(result, IResponse)\n            if response is None:\n                attrs = getattr(request, '__dict__', {})\n                if 'override_renderer' in attrs:\n                    renderer_name = attrs.pop('override_renderer')\n                    view_renderer = renderers.RendererHelper(\n                        name=renderer_name,\n                        package=info.package,\n                        registry=info.registry,\n                    )\n                else:\n                    view_renderer = renderer.clone()\n                if '__view__' in attrs:\n                    view_inst = attrs.pop('__view__')\n                else:\n                    view_inst = getattr(view, '__original_view__', view)\n                response = view_renderer.render_view(\n                    request, result, view_inst, context\n                )\n        return response\n\n    return rendered_view\n\n\nrendered_view.options = ('renderer',)"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def decorated_view(view, info):\n    decorator = info.options.get('decorator')\n    if decorator is None:\n        return view\n    return decorator(view)\n\n\ndecorated_view.options = ('decorator',)"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "def csrf_view(view, info):\n    explicit_val = info.options.get('require_csrf')\n    defaults = info.registry.queryUtility(IDefaultCSRFOptions)\n    if defaults is None:\n        default_val = False\n        token = 'csrf_token'\n        header = 'X-CSRF-Token'\n        safe_methods = frozenset([\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"])\n        check_origin = True\n        allow_no_origin = False\n        callback = None\n    else:\n        default_val = defaults.require_csrf\n        token = defaults.token\n        header = defaults.header\n        safe_methods = defaults.safe_methods\n        check_origin = defaults.check_origin\n        allow_no_origin = defaults.allow_no_origin\n        callback = defaults.callback\n\n    enabled = (\n        explicit_val is True\n        or\n        (explicit_val is not False and default_val and not info.exception_only)\n    )\n    enabled = enabled and (token or header)\n    wrapped_view = view\n    if enabled:\n\n        def csrf_view(context, request):\n            if request.method not in safe_methods and (\n                callback is None or callback(request)\n            ):\n                if check_origin:\n                    check_csrf_origin(\n                        request, raises=True, allow_no_origin=allow_no_origin\n                    )\n                check_csrf_token(request, token, header, raises=True)\n            return view(context, request)\n\n        wrapped_view = csrf_view\n    return wrapped_view\n\n\ncsrf_view.options = ('require_csrf',)"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/pyramid/src/pyramid/viewderivers.py",
      "content": "VIEW = 'VIEW'\nINGRESS = 'INGRESS'"
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "from functools import partial\nimport json\nimport os\nimport re\nfrom zope.interface import implementer, providedBy\nfrom zope.interface.registry import Components\n\nfrom pyramid.csrf import get_csrf_token\nfrom pyramid.decorator import reify\nfrom pyramid.events import BeforeRender\nfrom pyramid.httpexceptions import HTTPBadRequest\nfrom pyramid.interfaces import IJSONAdapter, IRendererFactory, IRendererInfo\nfrom pyramid.path import caller_package\nfrom pyramid.response import _get_response_factory\nfrom pyramid.threadlocal import get_current_registry\nfrom pyramid.util import hide_attrs"
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render(renderer_name, value, request=None, package=None):\n    \"\"\"Using the renderer ``renderer_name`` (a template\n    or a static renderer), render the value (or set of values) present\n    in ``value``. Return the result of the renderer's ``__call__``\n    method (usually a string or Unicode).\n    ...\n    \"\"\"\n    try:\n        registry = request.registry\n    except AttributeError:\n        registry = None\n    if package is None:\n        package = caller_package()\n    helper = RendererHelper(\n        name=renderer_name, package=package, registry=registry\n    )\n\n    with hide_attrs(request, 'response'):\n        result = helper.render(value, None, request=request)\n\n    return result"
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render_to_response(\n    renderer_name, value, request=None, package=None, response=None\n):\n    \"\"\"Using the renderer ``renderer_name`` (a template\n    or a static renderer), render the value (or set of values) using\n    the result of the renderer's ``__call__`` method (usually a string\n    or Unicode) as the response body.\n    ...\n    \"\"\"\n    try:\n        registry = request.registry\n    except AttributeError:\n        registry = None\n    if package is None:\n        package = caller_package()\n    helper = RendererHelper(\n        name=renderer_name, package=package, registry=registry\n    )\n\n    with hide_attrs(request, 'response'):\n        if response is not None:\n            request.response = response\n        result = helper.render_to_response(value, None, request=request)\n\n    return result"
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def get_renderer(renderer_name, package=None, registry=None):\n    \"\"\"Return the renderer object for the renderer ``renderer_name``.\n    ...\n    \"\"\"\n    if package is None:\n        package = caller_package()\n    helper = RendererHelper(\n        name=renderer_name, package=package, registry=registry\n    )\n    return helper.renderer"
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def string_renderer_factory(info):\n    def _render(value, system):\n        if not isinstance(value, str):\n            value = str(value)\n        request = system.get('request')\n        if request is not None:\n            response = request.response\n            ct = response.content_type\n            if ct == response.default_content_type:\n                response.content_type = 'text/plain'\n        return value\n\n    return _render"
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "class JSON:\n    \"\"\"Renderer that returns a JSON-encoded string.\n    ...\n    \"\"\"\n\n    def __init__(self, serializer=json.dumps, adapters=(), **kw):\n        \"\"\"Any keyword arguments will be passed to the ``serializer``\n        function.\"\"\"\n        self.serializer = serializer\n        self.kw = kw\n        self.components = Components()\n        for type, adapter in adapters:\n            self.add_adapter(type, adapter)"
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def add_adapter(self, type_or_iface, adapter):\n        \"\"\"When an object of the type (or interface) ``type_or_iface`` fails\n        to automatically encode using the serializer, the renderer will use\n        the adapter ``adapter`` to convert it into a JSON-serializable\n        object.\n        ...\n        \"\"\"\n        self.components.registerAdapter(\n            adapter, (type_or_iface,), IJSONAdapter\n        )"
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def __call__(self, info):\n        \"\"\"Returns a plain JSON-encoded string with content-type\n        ``application/json``. The content-type may be overridden by\n        setting ``request.response.content_type``.\"\"\"\n        def _render(value, system):\n            request = system.get('request')\n            if request is not None:\n                response = request.response\n                ct = response.content_type\n                if ct == response.default_content_type:\n                    response.content_type = 'application/json'\n            default = self._make_default(request)\n            return self.serializer(value, default=default, **self.kw)\n\n        return _render"
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def _make_default(self, request):\n        def default(obj):\n            if hasattr(obj, '__json__'):\n                return obj.__json__(request)\n            obj_iface = providedBy(obj)\n            adapters = self.components.adapters\n            result = adapters.lookup(\n                (obj_iface,), IJSONAdapter, default=_marker\n            )\n            if result is _marker:\n                raise TypeError(f'{obj!r} is not JSON serializable')\n            return result(obj, request)\n\n        return default"
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "json_renderer_factory = JSON()  # bw compat"
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "JSONP_VALID_CALLBACK = re.compile(r\"^[$a-z_][$0-9a-z_\\.\\[\\]]+[^.]$\", re.I)"
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "class JSONP(JSON):\n    \"\"\"`JSONP <https://en.wikipedia.org/wiki/JSONP>`_ renderer factory helper\n    which implements a hybrid json/jsonp renderer.\n    ...\n    \"\"\"\n\n    def __init__(self, param_name='callback', **kw):\n        self.param_name = param_name\n        JSON.__init__(self, **kw)"
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def __call__(self, info):\n        \"\"\"Returns JSONP-encoded string with content-type\n        ``application/javascript`` if query parameter matching\n        ``self.param_name`` is present in request.GET; otherwise returns\n        plain-JSON encoded string with content-type ``application/json``\"\"\"\n        def _render(value, system):\n            request = system.get('request')\n            default = self._make_default(request)\n            val = self.serializer(value, default=default, **self.kw)\n            ct = 'application/json'\n            body = val\n            if request is not None:\n                callback = request.GET.get(self.param_name)\n\n                if callback is not None:\n                    if not JSONP_VALID_CALLBACK.match(callback):\n                        raise HTTPBadRequest(\n                            'Invalid JSONP callback function name.'\n                        )\n\n                    ct = 'application/javascript'\n                    body = f'/**/{callback}({val});'\n                response = request.response\n                if response.content_type == response.default_content_type:\n                    response.content_type = ct\n            return body\n\n        return _render"
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "@implementer(IRendererInfo)\nclass RendererHelper:\n    def __init__(self, name=None, package=None, registry=None):\n        if name and '.' in name:\n            rtype = os.path.splitext(name)[1]\n        else:\n            rtype = name or ''\n\n        if registry is None:\n            registry = get_current_registry()\n\n        self.name = name\n        self.package = package\n        self.type = rtype\n        self.registry = registry"
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "@reify\n    def settings(self):\n        settings = self.registry.settings\n        if settings is None:\n            settings = {}\n        return settings"
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "@reify\n    def renderer(self):\n        factory = self.registry.queryUtility(IRendererFactory, name=self.type)\n        if factory is None:\n            raise ValueError('No such renderer factory %s' % str(self.type))\n        return factory(self)"
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def get_renderer(self):\n        return self.renderer"
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render_view(self, request, response, view, context):\n        system = {\n            'view': view,\n            'renderer_name': self.name,\n            'renderer_info': self,\n            'context': context,\n            'request': request,\n            'req': request,\n            'get_csrf_token': partial(get_csrf_token, request),\n        }\n        return self.render_to_response(response, system, request=request)"
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render(self, value, system_values, request=None):\n        renderer = self.renderer\n        if system_values is None:\n            system_values = {\n                'view': None,\n                'renderer_name': self.name,\n                'renderer_info': self,\n                'context': getattr(request, 'context', None),\n                'request': request,\n                'req': request,\n                'get_csrf_token': partial(get_csrf_token, request),\n            }\n\n        system_values = BeforeRender(system_values, value)\n\n        registry = self.registry\n        registry.notify(system_values)\n        result = renderer(value, system_values)\n        return result"
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render_to_response(self, value, system_values, request=None):\n        result = self.render(value, system_values, request=request)\n        return self._make_response(result, request)"
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def _make_response(self, result, request):\n        response = getattr(request, 'response', None)\n        if response is None:\n            registry = self.registry\n            response_factory = _get_response_factory(registry)\n            response = response_factory(request)\n\n        if result is not None:\n            if isinstance(result, str):\n                response.text = result\n            elif isinstance(result, bytes):\n                response.body = result\n            elif hasattr(result, '__iter__'):\n                response.app_iter = result\n            else:\n                response.body = result\n\n        return response"
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def clone(self, name=None, package=None, registry=None):\n        if name is None:\n            name = self.name\n        if package is None:\n            package = self.package\n        if registry is None:\n            registry = self.registry\n        return self.__class__(name=name, package=package, registry=registry)"
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "class NullRendererHelper(RendererHelper):\n    \"\"\"Special renderer helper that has render_* methods which simply return\n    the value they are fed rather than converting them to response objects;\n    useful for testing purposes and special case view configuration\n    registrations that want to use the view configuration machinery but do\n    not want actual rendering to happen .\"\"\"\n\n    def __init__(self, name=None, package=None, registry=None):\n        self.name = None\n        self.package = None\n        self.type = ''\n        self.registry = None"
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "@property\n    def settings(self):\n        return {}"
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render_view(self, request, value, view, context):\n        return value"
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render(self, value, system_values, request=None):\n        return value"
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def render_to_response(self, value, system_values, request=None):\n        return value"
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "def clone(self, name=None, package=None, registry=None):\n        return self"
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/pyramid/src/pyramid/renderers.py",
      "content": "null_renderer = NullRendererHelper()"
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "```python"
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "from zope.interface import Attribute, Interface"
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IContextFound(Interface):\n    \"\"\"An event type that is emitted after :app:`Pyramid` finds a\n    :term:`context` object but before it calls any view code.  See the\n    documentation attached to :class:`pyramid.events.ContextFound`\n    for more information.\n\n    .. note::\n\n       For backwards compatibility with versions of\n       :app:`Pyramid` before 1.0, this event interface can also be\n       imported as :class:`pyramid.interfaces.IAfterTraversal`.\n    \"\"\"\n\n    request = Attribute('The request object')"
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "IAfterTraversal = IContextFound"
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IBeforeTraversal(Interface):\n    \"\"\"\n    An event type that is emitted after :app:`Pyramid` attempted to find a\n    route but before it calls any traversal or view code. See the documentation\n    attached to :class:`pyramid.events.Routefound` for more information.\n    \"\"\"\n\n    request = Attribute('The request object')"
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class INewRequest(Interface):\n    \"\"\"An event type that is emitted whenever :app:`Pyramid`\n    begins to process a new request.  See the documentation attached\n    to :class:`pyramid.events.NewRequest` for more information.\"\"\"\n\n    request = Attribute('The request object')"
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class INewResponse(Interface):\n    \"\"\"An event type that is emitted whenever any :app:`Pyramid`\n    view returns a response. See the\n    documentation attached to :class:`pyramid.events.NewResponse`\n    for more information.\"\"\"\n\n    request = Attribute('The request object')\n    response = Attribute('The response object')"
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IApplicationCreated(Interface):\n    \"\"\"Event issued when the\n    :meth:`pyramid.config.Configurator.make_wsgi_app` method\n    is called.  See the documentation attached to\n    :class:`pyramid.events.ApplicationCreated` for more\n    information.\n\n    .. note::\n\n       For backwards compatibility with :app:`Pyramid`\n       versions before 1.0, this interface can also be imported as\n       :class:`pyramid.interfaces.IWSGIApplicationCreatedEvent`.\n    \"\"\"\n\n    app = Attribute(\"Created application\")"
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "IWSGIApplicationCreatedEvent = IApplicationCreated  # b /c"
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IResponse(Interface):\n    \"\"\"Represents a WSGI response using the WebOb response interface.\n    Some attribute and method documentation of this interface references\n    :rfc:`2616`.\n\n    This interface is most famously implemented by\n    :class:`pyramid.response.Response` and the HTTP exception classes in\n    :mod:`pyramid.httpexceptions`.\"\"\"\n\n    RequestClass = Attribute(\"\"\"Alias for :class:`pyramid.request.Request`\"\"\")\n\n    def __call__(environ, start_response):\n        \"\"\":term:`WSGI` call interface, should call the start_response\n        callback and should return an iterable\"\"\"\n\n    accept_ranges = Attribute(\n        \"\"\"Gets and sets and deletes the Accept-Ranges header. For more\n        information on Accept-Ranges see RFC 2616, section 14.5\"\"\"\n    )\n\n    age = Attribute(\n        \"\"\"Gets and sets and deletes the Age header. Converts using int.\n        For more information on Age see RFC 2616, section 14.6.\"\"\"\n    )\n\n    allow = Attribute(\n        \"\"\"Gets and sets and deletes the Allow header. Converts using\n        list. For more information on Allow see RFC 2616, Section 14.7.\"\"\"\n    )\n\n    app_iter = Attribute(\n        \"\"\"Returns the app_iter of the response.\n\n        If body was set, this will create an app_iter from that body\n        (a single-item list)\"\"\"\n    )\n\n    def app_iter_range(start, stop):\n        \"\"\"Return a new app_iter built from the response app_iter that\n        serves up only the given start:stop range.\"\"\"\n\n    identity = Attribute(\n        \"\"\"An object containing authentication information related to the\n        current request. The object's type and meaning is defined by the\n        configured :term:`security policy`.\"\"\"\n    )\n\n    authenticated_userid = Attribute(\n        \"\"\"A string to identify the authenticated user or ``None``.\"\"\"\n    )\n\n    body = Attribute(\n        \"\"\"The body of the response, as a str. This will read in the entire\n        app_iter if necessary.\"\"\"\n    )\n\n    body_file = Attribute(\n        \"\"\"A file-like object that can be used to write to the body. If you\n        passed in a list app_iter, that app_iter will be modified by writes.\"\"\"\n    )\n\n    cache_control = Attribute(\n        \"\"\"Get/set/modify the Cache-Control header (RFC 2616 section 14.9)\"\"\"\n    )\n\n    cache_expires = Attribute(\n        \"\"\"Get/set the Cache-Control and Expires headers. This sets the\n            response to expire in the number of seconds passed when set.\"\"\"\n    )\n\n    charset = Attribute(\"\"\"Get/set the charset (in the Content-Type)\"\"\")\n\n    def conditional_response_app(environ, start_response):\n        \"\"\"Like the normal __call__ interface, but checks conditional\n        headers:\n\n        - If-Modified-Since (304 Not Modified; only on GET, HEAD)\n\n        - If-None-Match (304 Not Modified; only on GET, HEAD)\n\n        - Range (406 Partial Content; only on GET, HEAD)\"\"\"\n\n    content_disposition = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Disposition header.\n        For more information on Content-Disposition see RFC 2616 section\n        19.5.1.\"\"\"\n    )\n\n    content_encoding = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Encoding header.  For more\n        information about Content-Encoding see RFC 2616 section 14.11.\"\"\"\n    )\n\n    content_language = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Language header. Converts\n        using list.  For more information about Content-Language see RFC 2616\n        section 14.12.\"\"\"\n    )\n\n    content_length = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Length header. For more\n        information on Content-Length see RFC 2616 section 14.17.\n        Converts using int.\"\"\"\n    )\n\n    content_location = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Location header. For more\n        information on Content-Location see RFC 2616 section 14.14.\"\"\"\n    )\n\n    content_md5 = Attribute(\n        \"\"\"Gets and sets and deletes the Content-MD5 header. For more\n        information on Content-MD5 see RFC 2616 section 14.14.\"\"\"\n    )\n\n    content_range = Attribute(\n        \"\"\"Gets and sets and deletes the Content-Range header. For more\n        information on Content-Range see section 14.16. Converts using\n        ContentRange object.\"\"\"\n    )\n\n    content_type = Attribute(\n        \"\"\"Get/set the Content-Type header (or None), without the charset\n        or any parameters. If you include parameters (or ; at all) when\n        setting the content_type, any existing parameters will be deleted;\n        otherwise they will be preserved.\"\"\"\n    )\n\n    content_type_params = Attribute(\n        \"\"\"A dictionary of all the parameters in the content type.  This is\n        not a view, set to change, modifications of the dict would not\n        be applied otherwise.\"\"\"\n    )\n\n    def copy():\n        \"\"\"Makes a copy of the response and returns the copy.\"\"\"\n\n    date = Attribute(\n        \"\"\"Gets and sets and deletes the Date header. For more information on\n        Date see RFC 2616 section 14.18. Converts using HTTP date.\"\"\"\n    )\n\n    def delete_cookie(name, path='/', domain=None):\n        \"\"\"Delete a cookie from the client. Note that path and domain must\n        match how the cookie was originally set.  This sets the cookie to the\n        empty string, and max_age=0 so that it should expire immediately.\"\"\"\n\n    def encode_content(encoding='gzip', lazy=False):\n        \"\"\"Encode the content with the given encoding (only gzip and\n        identity are supported).\"\"\"\n\n    environ = Attribute(\n        \"\"\"Get/set the request environ associated with this response,\n        if any.\"\"\"\n    )\n\n    etag = Attribute(\n        \"\"\"Gets and sets and deletes the ETag header. For more information\n        on ETag see RFC 2616 section 14.19. Converts using Entity tag.\"\"\"\n    )\n\n    expires = Attribute(\n        \"\"\"Gets and sets and deletes the Expires header. For more\n        information on Expires see RFC 2616 section 14.21. Converts using\n        HTTP date.\"\"\"\n    )\n\n    headerlist = Attribute(\"\"\"The list of response headers.\"\"\")\n\n    headers = Attribute(\"\"\"The headers in a dictionary-like object\"\"\")\n\n    is_authenticated = Attribute(\n        \"\"\"A boolean indicating whether the request has an authenticated\n        user, as determined by the security policy in use.\n\n        The value is determined by the result of\n        :attr:`pyramid.request.Request.authenticated_userid`.\n        \"\"\"\n    )\n\n    last_modified = Attribute(\n        \"\"\"Gets and sets and deletes the Last-Modified header. For more\n        information on Last-Modified see RFC 2616 section 14.29. Converts\n        using HTTP date.\"\"\"\n    )\n\n    location = Attribute(\n        \"\"\"Gets and sets and deletes the Location header. For more\n        information on Location see RFC 2616 section 14.30.\"\"\"\n    )\n\n    def md5_etag(body=None, set_content_md5=False):\n        \"\"\"Generate an etag for the response object using an MD5 hash of the\n        body (the body parameter, or self.body if not given).  Sets self.etag.\n        If set_content_md5 is True sets self.content_md5 as well\"\"\"\n\n    def merge_cookies(resp):\n        \"\"\"Merge the cookies that were set on this response with the given\n        resp object (which can be any WSGI application).  If the resp is a\n        webob.Response object, then the other object will be modified\n        in-place.\"\"\"\n\n    pragma = Attribute(\n        \"\"\"Gets and sets and deletes the Pragma header. For more information\n        on Pragma see RFC 2616 section 14.32.\"\"\"\n    )\n\n    request = Attribute(\n        \"\"\"Return the request associated with this response if any.\"\"\"\n    )\n\n    retry_after = Attribute(\n        \"\"\"Gets and sets and deletes the Retry-After header. For more\n        information on Retry-After see RFC 2616 section 14.37. Converts\n        using HTTP date or delta seconds.\"\"\"\n    )\n\n    server = Attribute(\n        \"\"\"Gets and sets and deletes the Server header. For more information\n        on Server see RFC216 section 14.38.\"\"\"\n    )\n\n    def set_cookie(\n        name,\n        value='',\n        max_age=None,\n        path='/',\n        domain=None,\n        secure=False,\n        httponly=False,\n        comment=None,\n        expires=None,\n        overwrite=False,\n    ):\n        \"\"\"Set (add) a cookie for the response\"\"\"\n\n    status = Attribute(\"\"\"The status string.\"\"\")\n\n    status_int = Attribute(\"\"\"The status as an integer\"\"\")\n\n    unicode_body = Attribute(\n        \"\"\"Get/set the unicode value of the body (using the charset of\n        the Content-Type)\"\"\"\n    )\n\n    def unset_cookie(name, strict=True):\n        \"\"\"Unset a cookie with the given name (remove it from the\n        response).\"\"\"\n\n    vary = Attribute(\n        \"\"\"Gets and sets and deletes the Vary header. For more information\n        on Vary see section 14.44. Converts using list.\"\"\"\n    )\n\n    www_authenticate = Attribute(\n        \"\"\"Gets and sets and deletes the WWW-Authenticate header. For more\n        information on WWW-Authenticate see RFC 2616 section 14.47. Converts\n        using 'parse_auth' and 'serialize_auth'.\"\"\"\n    )"
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IException(Interface):  # not an API\n    \"\"\"An interface representing a generic exception\"\"\""
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IExceptionResponse(IException, IResponse):\n    \"\"\"An interface representing a WSGI response which is also an exception\n    object.  Register an exception view using this interface as a ``context``\n    to apply the registered view for all exception types raised by\n    :app:`Pyramid` internally (any exception that inherits from\n    :class:`pyramid.response.Response`, including\n    :class:`pyramid.httpexceptions.HTTPNotFound` and\n    :class:`pyramid.httpexceptions.HTTPForbidden`).\"\"\"\n\n    def prepare(environ):\n        \"\"\"Prepares the response for being called as a WSGI application\"\"\""
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IDict(Interface):\n    # Documentation-only interface\n\n    def __contains__(k):\n        \"\"\"Return ``True`` if key ``k`` exists in the dictionary.\"\"\"\n\n    def __setitem__(k, value):\n        \"\"\"Set a key/value pair into the dictionary\"\"\"\n\n    def __delitem__(k):\n        \"\"\"Delete an item from the dictionary which is passed to the\n        renderer as the renderer globals dictionary.\"\"\"\n\n    def __getitem__(k):\n        \"\"\"Return the value for key ``k`` from the dictionary or raise a\n        KeyError if the key doesn't exist\"\"\"\n\n    def __iter__():\n        \"\"\"Return an iterator over the keys of this dictionary\"\"\"\n\n    def get(k, default=None):\n        \"\"\"Return the value for key ``k`` from the renderer dictionary, or\n        the default if no such value exists.\"\"\"\n\n    def items():\n        \"\"\"Return a list of [(k,v)] pairs from the dictionary\"\"\"\n\n    def keys():\n        \"\"\"Return a list of keys from the dictionary\"\"\"\n\n    def values():\n        \"\"\"Return a list of values from the dictionary\"\"\"\n\n    def pop(k, default=None):\n        \"\"\"Pop the key k from the dictionary and return its value.  If k\n        doesn't exist, and default is provided, return the default.  If k\n        doesn't exist and default is not provided, raise a KeyError.\"\"\"\n\n    def popitem():\n        \"\"\"Pop the item with key k from the dictionary and return it as a\n        two-tuple (k, v).  If k doesn't exist, raise a KeyError.\"\"\"\n\n    def setdefault(k, default=None):\n        \"\"\"Return the existing value for key ``k`` in the dictionary.  If no\n        value with ``k`` exists in the dictionary, set the ``default``\n        value into the dictionary under the k name passed.  If a value already\n        existed in the dictionary, return it.  If a value did not exist in\n        the dictionary, return the default\"\"\"\n\n    def update(d):\n        \"\"\"Update the renderer dictionary with another dictionary ``d``.\"\"\"\n\n    def clear():\n        \"\"\"Clear all values from the dictionary\"\"\""
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IBeforeRender(IDict):\n    \"\"\"\n    Subscribers to this event may introspect and modify the set of\n    :term:`renderer globals` before they are passed to a :term:`renderer`.\n    The event object itself provides a dictionary-like interface for adding\n    and removing :term:`renderer globals`.  The keys and values of the\n    dictionary are those globals.  For example::\n\n      from repoze.events import subscriber\n      from pyramid.interfaces import IBeforeRender\n\n      @subscriber(IBeforeRender)\n      def add_global(event):\n          event['mykey'] = 'foo'\n\n    .. seealso::\n\n        See also :ref:`beforerender_event`.\n    \"\"\"\n\n    rendering_val = Attribute(\n        'The value returned by a view or passed to a '\n        '``render`` method for this rendering. '\n        'This feature is new in Pyramid 1.2.'\n    )"
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRendererInfo(Interface):\n    \"\"\"An object implementing this interface is passed to every\n    :term:`renderer factory` constructor as its only argument (conventionally\n    named ``info``)\"\"\"\n\n    name = Attribute('The value passed by the user as the renderer name')\n    package = Attribute(\n        'The \"current package\" when the renderer '\n        'configuration statement was found'\n    )\n    type = Attribute('The renderer type name')\n    registry = Attribute(\n        'The \"current\" application registry when the renderer was created'\n    )\n    settings = Attribute(\n        'The deployment settings dictionary related '\n        'to the current application'\n    )\n\n    def clone():\n        \"\"\"Return a shallow copy that does not share any mutable state.\"\"\""
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRendererFactory(Interface):\n    def __call__(info):\n        \"\"\"Return an object that implements\n        :class:`pyramid.interfaces.IRenderer`. ``info`` is an\n        object that implements :class:`pyramid.interfaces.IRendererInfo`.\n        \"\"\""
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRenderer(Interface):\n    def __call__(value, system):\n        \"\"\"Call the renderer with the result of the\n        view (``value``) passed in and return a result (a string or\n        unicode object useful as a response body).  Values computed by\n        the system are passed by the system in the ``system``\n        parameter, which is a dictionary.  Keys in the dictionary\n        include: ``view`` (the view callable that returned the value),\n        ``renderer_name`` (the template name or simple name of the\n        renderer), ``context`` (the context object passed to the\n        view), and ``request`` (the request object passed to the\n        view).\"\"\""
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewMapper(Interface):\n    def __call__(self, object):\n        \"\"\"Provided with an arbitrary object (a function, class, or\n        instance), returns a callable with the call signature ``(context,\n        request)``.  The callable returned should itself return a Response\n        object.  An IViewMapper is returned by\n        :class:`pyramid.interfaces.IViewMapperFactory`.\"\"\""
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewMapperFactory(Interface):\n    def __call__(self, **kw):\n        \"\"\"\n        Return an object which implements\n        :class:`pyramid.interfaces.IViewMapper`.  ``kw`` will be a dictionary\n        containing view-specific arguments, such as ``permission``,\n        ``predicates``, ``attr``, ``renderer``, and other items.  An\n        IViewMapperFactory is used by\n        :meth:`pyramid.config.Configurator.add_view` to provide a plugpoint\n        to extension developers who want to modify potential view callable\n        invocation signatures and response values.\n        \"\"\""
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISecurityPolicy(Interface):\n    def identity(request):\n        \"\"\"Return the :term:`identity` of the current user.  The object can be\n        of any shape, such as a simple ID string or an ORM object.\n        \"\"\"\n\n    def authenticated_userid(request):\n        \"\"\"Return a :term:`userid` string identifying the trusted and\n        verified user, or ``None`` if unauthenticated.\n\n        If the result is ``None``, then\n        :attr:`pyramid.request.Request.is_authenticated` will return ``False``.\n        \"\"\"\n\n    def permits(request, context, permission):\n        \"\"\"Return an instance of :class:`pyramid.security.Allowed` if a user\n        of the given identity is allowed the ``permission`` in the current\n        ``context``, else return an instance of\n        :class:`pyramid.security.Denied`.\n        \"\"\"\n\n    def remember(request, userid, **kw):\n        \"\"\"Return a set of headers suitable for 'remembering' the\n        :term:`userid` named ``userid`` when set in a response.  An individual\n        security policy and its consumers can decide on the composition and\n        meaning of ``**kw``.\n        \"\"\"\n\n    def forget(request, **kw):\n        \"\"\"Return a set of headers suitable for 'forgetting' the\n        current user on subsequent requests.  An individual security policy and\n        its consumers can decide on the composition and meaning of ``**kw``.\n        \"\"\""
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IAuthenticationPolicy(Interface):\n    \"\"\"An object representing a Pyramid authentication policy.\n\n    .. deprecated:: 2.0\n\n        Authentication policies have been removed in favor of security\n        policies.  See :ref:`upgrading_auth_20` for more information.\n\n    \"\"\"\n\n    def authenticated_userid(request):\n        \"\"\"Return the authenticated :term:`userid` or ``None`` if\n        no authenticated userid can be found. This method of the\n        policy should ensure that a record exists in whatever\n        persistent store is used related to the user (the user\n        should not have been deleted); if a record associated with\n        the current id does not exist in a persistent store, it\n        should return ``None``.\n\n        \"\"\"\n\n    def unauthenticated_userid(request):\n        \"\"\"Return the *unauthenticated* userid.  This method\n        performs the same duty as ``authenticated_userid`` but is\n        permitted to return the userid based only on data present\n        in the request; it needn't (and shouldn't) check any\n        persistent store to ensure that the user record related to\n        the request userid exists.\n\n        This method is intended primarily a helper to assist the\n        ``authenticated_userid`` method in pulling credentials out\n        of the request data, abstracting away the specific headers,\n        query strings, etc that are used to authenticate the request.\n\n        \"\"\"\n\n    def effective_principals(request):\n        \"\"\"Return a sequence representing the effective principals\n        typically including the :term:`userid` and any groups belonged\n        to by the current user, always including 'system' groups such\n        as ``pyramid.authorization.Everyone`` and\n        ``pyramid.authorization.Authenticated``.\n\n        \"\"\"\n\n    def remember(request, userid, **kw):\n        \"\"\"Return a set of headers suitable for 'remembering' the\n        :term:`userid` named ``userid`` when set in a response. An\n        individual authentication policy and its consumers can\n        decide on the composition and meaning of ``**kw``.\n\n        \"\"\"\n\n    def forget(request):\n        \"\"\"Return a set of headers suitable for 'forgetting' the\n        current user on subsequent requests.\n\n        \"\"\""
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IAuthorizationPolicy(Interface):\n    \"\"\"An object representing a Pyramid authorization policy.\n\n    .. deprecated:: 2.0\n\n        Authentication policies have been removed in favor of security\n        policies.  See :ref:`upgrading_auth_20` for more information.\n\n    \"\"\"\n\n    def permits(context, principals, permission):\n        \"\"\"Return an instance of :class:`pyramid.security.Allowed` if any\n        of the ``principals`` is allowed the ``permission`` in the current\n        ``context``, else return an instance of\n        :class:`pyramid.security.Denied`.\n        \"\"\"\n\n    def principals_allowed_by_permission(context, permission):\n        \"\"\"Return a set of principal identifiers allowed by the\n        ``permission`` in ``context``.  This behavior is optional; if you\n        choose to not implement it you should define this method as\n        something which raises a ``NotImplementedError``.  This method\n        will only be called when the\n        ``pyramid.security.principals_allowed_by_permission`` API is\n        used.\"\"\""
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IMultiDict(IDict):  # docs-only interface\n    \"\"\"\n    An ordered dictionary that can have multiple values for each key. A\n    multidict adds the methods ``getall``, ``getone``, ``mixed``, ``extend``,\n    ``add``, and ``dict_of_lists`` to the normal dictionary interface.  A\n    multidict data structure is used as ``request.POST``, ``request.GET``,\n    and ``request.params`` within an :app:`Pyramid` application.\n    \"\"\"\n\n    def add(key, value):\n        \"\"\"Add the key and value, not overwriting any previous value.\"\"\"\n\n    def dict_of_lists():\n        \"\"\"\n        Returns a dictionary where each key is associated with a list of\n        values.\n        \"\"\"\n\n    def extend(other=None, **kwargs):\n        \"\"\"Add a set of keys and values, not overwriting any previous\n        values.  The ``other`` structure may be a list of two-tuples or a\n        dictionary.  If ``**kwargs`` is passed, its value *will* overwrite\n        existing values.\"\"\"\n\n    def getall(key):\n        \"\"\"Return a list of all values matching the key (may be an empty\n        list)\"\"\"\n\n    def getone(key):\n        \"\"\"Get one value matching the key, raising a KeyError if multiple\n        values were found.\"\"\"\n\n    def mixed():\n        \"\"\"Returns a dictionary where the values are either single values,\n        or a list of values when a key/value appears more than once in this\n        dictionary. This is similar to the kind of dictionary often used to\n        represent the variables in a web request.\"\"\""
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRequest(Interface):\n    \"\"\"Request type interface attached to all request objects\"\"\""
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ITweens(Interface):\n    \"\"\"Marker interface for utility registration representing the ordered\n    set of a configuration's tween factories\"\"\""
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRequestHandler(Interface):\n    \"\"\" \"\"\"\n\n    def __call__(self, request):\n        \"\"\"Must return a tuple of IReqest, IResponse or raise an exception.\n        The ``request`` argument will be an instance of an object that\n        provides IRequest.\"\"\""
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "IRequest.combined = IRequest  # for exception view lookups"
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRequestExtensions(Interface):\n    \"\"\"Marker interface for storing request extensions (properties and\n    methods) which will be added to the request object.\"\"\"\n\n    descriptors = Attribute(\n        \"\"\"A list of descriptors that will be added to each request.\"\"\"\n    )\n    methods = Attribute(\"\"\"A list of methods to be added to each request.\"\"\")"
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRouteRequest(Interface):\n    \"\"\"*internal only* interface used as in a utility lookup to find\n    route-specific interfaces.  Not an API.\"\"\""
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IAcceptOrder(Interface):\n    \"\"\"\n    Marker interface for a list of accept headers with the most important\n    first.\n\n    \"\"\""
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IStaticURLInfo(Interface):\n    \"\"\"A policy for generating URLs to static assets\"\"\"\n\n    def add(config, name, spec, **extra):\n        \"\"\"Add a new static info registration\"\"\"\n\n    def generate(path, request, **kw):\n        \"\"\"Generate a URL for the given path\"\"\"\n\n    def add_cache_buster(config, spec, cache_buster):\n        \"\"\"Add a new cache buster to a particular set of assets\"\"\""
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IResponseFactory(Interface):\n    \"\"\"A utility which generates a response\"\"\"\n\n    def __call__(request):\n        \"\"\"Return a response object implementing IResponse,\n        e.g. :class:`pyramid.response.Response`). It should handle the\n        case when ``request`` is ``None``.\"\"\""
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRequestFactory(Interface):\n    \"\"\"A utility which generates a request\"\"\"\n\n    def __call__(environ):\n        \"\"\"Return an instance of ``pyramid.request.Request``\"\"\"\n\n    def blank(path):\n        \"\"\"Return an empty request object (see\n        :meth:`pyramid.request.Request.blank`)\"\"\""
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewClassifier(Interface):\n    \"\"\"*Internal only* marker interface for views.\"\"\""
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IExceptionViewClassifier(Interface):\n    \"\"\"*Internal only* marker interface for exception views.\"\"\""
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IView(Interface):\n    def __call__(context, request):\n        \"\"\"Must return an object that implements IResponse.\"\"\""
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISecuredView(IView):\n    \"\"\"*Internal only* interface.  Not an API.\"\"\"\n\n    def __call_permissive__(context, request):\n        \"\"\"Guaranteed-permissive version of __call__\"\"\"\n\n    def __permitted__(context, request):\n        \"\"\"Return True if view execution will be permitted using the\n        context and request, False otherwise\"\"\""
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IMultiView(ISecuredView):\n    \"\"\"*internal only*.  A multiview is a secured view that is a\n    collection of other views.  Each of the views is associated with\n    zero or more predicates.  Not an API.\"\"\"\n\n    def add(view, predicates, order, accept=None, phash=None):\n        \"\"\"Add a view to the multiview.\"\"\""
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRootFactory(Interface):\n    def __call__(request):\n        \"\"\"Return a root object based on the request\"\"\""
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IDefaultRootFactory(Interface):\n    def __call__(request):\n        \"\"\"Return the *default* root object for an application\"\"\""
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ITraverser(Interface):\n    def __call__(request):\n        \"\"\"Return a dictionary with (at least) the keys ``root``,\n        ``context``, ``view_name``, ``subpath``, ``traversed``,\n        ``virtual_root``, and ``virtual_root_path``.  These values are\n        typically the result of an object graph traversal.  ``root`` is the\n        physical root object, ``context`` will be a model object,\n        ``view_name`` will be the view name used (a Unicode name),\n        ``subpath`` will be a sequence of Unicode names that followed the\n        view name but were not traversed, ``traversed`` will be a sequence of\n        Unicode names that were traversed (including the virtual root path,\n        if any) ``virtual_root`` will be a model object representing the\n        virtual root (or the physical root if traversal was not performed),\n        and ``virtual_root_path`` will be a sequence representing the virtual\n        root path (a sequence of Unicode names) or ``None`` if traversal was\n        not performed.\n\n        Extra keys for special purpose functionality can be returned as\n        necessary.\n\n        All values returned in the dictionary will be made available\n        as attributes of the ``request`` object by the :term:`router`.\n        \"\"\""
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "ITraverserFactory = ITraverser  # b / c for 1.0 code"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewPermission(Interface):\n    def __call__(context, request):\n        \"\"\"Return True if the permission allows, return False if it denies.\"\"\""
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRouter(Interface):\n    \"\"\"\n    WSGI application which routes requests to 'view' code based on\n    a view registry.\n\n    \"\"\"\n\n    registry = Attribute(\n        \"\"\"Component architecture registry local to this application.\"\"\"\n    )\n\n    def request_context(environ):\n        \"\"\"\n        Create a new request context from a WSGI environ.\n\n        The request context is used to push/pop the threadlocals required\n        when processing the request. It also contains an initialized\n        :class:`pyramid.interfaces.IRequest` instance using the registered\n        :class:`pyramid.interfaces.IRequestFactory`. The context may be\n        used as a context manager to control the threadlocal lifecycle:\n\n        .. code-block:: python\n\n            with router.request_context(environ) as request:\n                ...\n\n        Alternatively, the context may be used without the ``with`` statement\n        by manually invoking its ``begin()`` and ``end()`` methods.\n\n        .. code-block:: python\n\n            ctx = router.request_context(environ)\n            request = ctx.begin()\n            try:\n                ...\n            finally:\n                ctx.end()\n\n        \"\"\"\n\n    def invoke_request(request):\n        \"\"\"\n        Invoke the :app:`Pyramid` request pipeline.\n\n        See :ref:`router_chapter` for information on the request pipeline.\n\n        The output should be a :class:`pyramid.interfaces.IResponse` object\n        or a raised exception.\n\n        \"\"\""
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IExecutionPolicy(Interface):\n    def __call__(environ, router):\n        \"\"\"\n        This callable triggers the router to process a raw WSGI environ dict\n        into a response and controls the :app:`Pyramid` request pipeline.\n\n        The ``environ`` is the raw WSGI environ.\n\n        The ``router`` is an :class:`pyramid.interfaces.IRouter` object which\n        should be used to create a request object and send it into the\n        processing pipeline.\n\n        The return value should be a :class:`pyramid.interfaces.IResponse`\n        object or an exception that will be handled by WSGI middleware.\n\n        The default execution policy simply creates a request and sends it\n        through the pipeline, attempting to render any exception that escapes:\n\n        .. code-block:: python\n\n            def simple_execution_policy(environ, router):\n                with router.request_context(environ) as request:\n                    try:\n                        return router.invoke_request(request)\n                    except Exception:\n                        return request.invoke_exception_view(reraise=True)\n        \"\"\""
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISettings(IDict):\n    \"\"\"Runtime settings utility for pyramid; represents the\n    deployment settings for the application.  Implements a mapping\n    interface.\"\"\""
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ILocation(Interface):\n    \"\"\"Objects that have a structural location\"\"\"\n\n    __parent__ = Attribute(\"The parent in the location hierarchy\")\n    __name__ = Attribute(\"The name within the parent\")"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IDebugLogger(Interface):\n    \"\"\"Interface representing a PEP 282 logger\"\"\""
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "ILogger = IDebugLogger  # b/c"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRoutePregenerator(Interface):\n    def __call__(request, elements, kw):\n        \"\"\"A pregenerator is a function associated by a developer with a\n        :term:`route`. The pregenerator for a route is called by\n        :meth:`pyramid.request.Request.route_url` in order to adjust the set\n        of arguments passed to it by the user for special purposes, such as\n        Pylons 'subdomain' support.  It will influence the URL returned by\n        ``route_url``.\n\n        A pregenerator should return a two-tuple of ``(elements, kw)``\n        after examining the originals passed to this function, which\n        are the arguments ``(request, elements, kw)``.  The simplest\n        pregenerator is::\n\n            def pregenerator(request, elements, kw):\n                return elements, kw\n\n        You can employ a pregenerator by passing a ``pregenerator``\n        argument to the\n        :meth:`pyramid.config.Configurator.add_route`\n        function.\n\n        \"\"\""
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRoute(Interface):\n    \"\"\"Interface representing the type of object returned from\n    ``IRoutesMapper.get_route``\"\"\"\n\n    name = Attribute('The route name')\n    pattern = Attribute('The route pattern')\n    factory = Attribute(\n        'The :term:`root factory` used by the :app:`Pyramid` router '\n        'when this route matches (or ``None``)'\n    )\n    predicates = Attribute(\n        'A sequence of :term:`route predicate` objects used to '\n        'determine if a request matches this route or not after '\n        'basic pattern matching has been completed.'\n    )\n    pregenerator = Attribute(\n        'This attribute should either be ``None`` or '\n        'a callable object implementing the '\n        '``IRoutePregenerator`` interface'\n    )\n\n    def match(path):\n        \"\"\"\n        If the ``path`` passed to this function can be matched by the\n        ``pattern`` of this route, return a dictionary (the\n        'matchdict'), which will contain keys representing the dynamic\n        segment markers in the pattern mapped to values extracted from\n        the provided ``path``.\n\n        If the ``path`` passed to this function cannot be matched by\n        the ``pattern`` of this route, return ``None``.\n        \"\"\"\n\n    def generate(kw):\n        \"\"\"\n        Generate a URL based on filling in the dynamic segment markers\n        in the pattern using the ``kw`` dictionary provided.\n        \"\"\""
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRoutesMapper(Interface):\n    \"\"\"Interface representing a Routes ``Mapper`` object\"\"\"\n\n    def get_routes():\n        \"\"\"Return a sequence of Route objects registered in the mapper.\n        Static routes will not be returned in this sequence.\"\"\"\n\n    def has_routes():\n        \"\"\"Returns ``True`` if any route has been registered.\"\"\"\n\n    def get_route(name):\n        \"\"\"Returns an ``IRoute`` object if a route with the name ``name``\n        was registered, otherwise return ``None``.\"\"\"\n\n    def connect(\n        name,\n        pattern,\n        factory=None,\n        predicates=(),\n        pregenerator=None,\n        static=True,\n    ):\n        \"\"\"Add a new route.\"\"\"\n\n    def generate(name, kw):\n        \"\"\"Generate a URL using the route named ``name`` with the\n        keywords implied by kw\"\"\"\n\n    def __call__(request):\n        \"\"\"Return a dictionary containing matching information for\n        the request; the ``route`` key of this dictionary will either\n        be a Route object or ``None`` if no route matched; the\n        ``match`` key will be the matchdict or ``None`` if no route\n        matched.  Static routes will not be considered for matching.\"\"\""
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IResourceURL(Interface):\n    virtual_path = Attribute(\n        'The virtual url path of the resource as a string.'\n    )\n    physical_path = Attribute(\n        'The physical url path of the resource as a string.'\n    )\n    virtual_path_tuple = Attribute(\n        'The virtual url path of the resource as a tuple.  (New in 1.5)'\n    )\n    physical_path_tuple = Attribute(\n        'The physical url path of the resource as a tuple. (New in 1.5)'\n    )"
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPEP302Loader(Interface):\n    \"\"\"See http://www.python.org/dev/peps/pep-0302/#id30.\"\"\"\n\n    def get_data(path):\n        \"\"\"Retrieve data for and arbitrary \"files\" from storage backend.\n\n        Raise IOError for not found.\n\n        Data is returned as bytes.\n        \"\"\"\n\n    def is_package(fullname):\n        \"\"\"Return True if the module specified by 'fullname' is a package.\"\"\"\n\n    def get_code(fullname):\n        \"\"\"Return the code object for the module identified by 'fullname'.\n\n        Return 'None' if it's a built-in or extension module.\n\n        If the loader doesn't have the code object but it does have the source\n        code, return the compiled source code.\n\n        Raise ImportError if the module can't be found by the importer at all.\n        \"\"\"\n\n    def get_source(fullname):\n        \"\"\"Return the source code for the module identified by 'fullname'.\n\n        Return a string, using newline characters for line endings, or None\n        if the source is not available.\n\n        Raise ImportError if the module can't be found by the importer at all.\n        \"\"\"\n\n    def get_filename(fullname):\n        \"\"\"Return the value of '__file__' if the named module was loaded.\n\n        If the module is not found, raise ImportError.\n        \"\"\""
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPackageOverrides(IPEP302Loader):\n    \"\"\"Utility for pkg_resources overrides\"\"\""
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "VH_ROOT_KEY = 'HTTP_X_VHM_ROOT'"
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ILocalizer(Interface):\n    \"\"\"Localizer for a specific language\"\"\""
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ILocaleNegotiator(Interface):\n    def __call__(request):\n        \"\"\"Return a locale name\"\"\""
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ITranslationDirectories(Interface):\n    \"\"\"A list object representing all known translation directories\n    for an application\"\"\""
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IDefaultPermission(Interface):\n    \"\"\"A string object representing the default permission to be used\n    for all view configurations which do not explicitly declare their\n    own.\"\"\""
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IDefaultCSRFOptions(Interface):\n    \"\"\"An object representing the default CSRF settings to be used for\n    all view configurations which do not explicitly declare their own.\"\"\"\n\n    require_csrf = Attribute(\n        'Boolean attribute. If ``True``, then CSRF checks will be enabled by '\n        'default for the view unless overridden.'\n    )\n    token = Attribute('The key to be matched in the body of the request.')\n    header = Attribute('The header to be matched with the CSRF token.')\n    safe_methods = Attribute('A set of safe methods that skip CSRF checks.')\n    callback = Attribute('A callback to disable CSRF checks per-request.')\n    allow_no_origin = Attribute(\n        'Boolean.  If false, a request lacking both an ``Origin`` and '\n        '``Referer`` header will fail the CSRF check.'\n    )"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISessionFactory(Interface):\n    \"\"\"An interface representing a factory which accepts a request object and\n    returns an ISession object\"\"\"\n\n    def __call__(request):\n        \"\"\"Return an ISession object\"\"\""
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISession(IDict):\n    \"\"\"An interface representing a session (a web session object,\n    usually accessed via ``request.session``.\n\n    Keys and values of a session must be JSON-serializable.\n\n    .. warning::\n\n        In :app:`Pyramid` 2.0 the session was changed to only be required to\n        support types that can be serialized using JSON. It's recommended to\n        switch any session implementations to support only JSON and to only\n        store primitive types in sessions. See\n        :ref:`upgrading_session_20` for more information about why this\n        change was made.\n\n    .. versionchanged:: 1.9\n\n        Sessions are no longer required to implement ``get_csrf_token`` and\n        ``new_csrf_token``. CSRF token support was moved to the pluggable\n        :class:`pyramid.interfaces.ICSRFStoragePolicy` configuration hook.\n\n    .. versionchanged:: 2.0\n\n        Sessions now need to be JSON-serializable. This is more strict than\n        the previous requirement of pickleable objects.\n\n    \"\"\"\n\n    # attributes\n\n    created = Attribute('Integer representing Epoch time when created.')\n    new = Attribute('Boolean attribute.  If ``True``, the session is new.')\n\n    # special methods\n\n    def invalidate():\n        \"\"\"Invalidate the session.  The action caused by\n        ``invalidate`` is implementation-dependent, but it should have\n        the effect of completely dissociating any data stored in the\n        session with the current request.  It might set response\n        values (such as one which clears a cookie), or it might not.\n\n        An invalidated session may be used after the call to ``invalidate``\n        with the effect that a new session is created to store the data. This\n        enables workflows requiring an entirely new session, such as in the\n        case of changing privilege levels or preventing fixation attacks.\n        \"\"\"\n\n    def changed():\n        \"\"\"Mark the session as changed. A user of a session should\n        call this method after he or she mutates a mutable object that\n        is *a value of the session* (it should not be required after\n        mutating the session itself).  For example, if the user has\n        stored a dictionary in the session under the key ``foo``, and\n        he or she does ``session['foo'] = {}``, ``changed()`` needn't\n        be called.  However, if subsequently he or she does\n        ``session['foo']['a'] = 1``, ``changed()`` must be called for\n        the sessioning machinery to notice the mutation of the\n        internal dictionary.\"\"\"\n\n    def flash(msg, queue='', allow_duplicate=True):\n        \"\"\"Push a flash message onto the end of the flash queue represented\n        by ``queue``.  An alternate flash message queue can used by passing\n        an optional ``queue``, which must be a string.  If\n        ``allow_duplicate`` is false, if the ``msg`` already exists in the\n        queue, it will not be re-added.\"\"\"\n\n    def pop_flash(queue=''):\n        \"\"\"Pop a queue from the flash storage.  The queue is removed from\n        flash storage after this message is called.  The queue is returned;\n        it is a list of flash messages added by\n        :meth:`pyramid.interfaces.ISession.flash`\"\"\"\n\n    def peek_flash(queue=''):\n        \"\"\"Peek at a queue in the flash storage.  The queue remains in\n        flash storage after this message is called.  The queue is returned;\n        it is a list of flash messages added by\n        :meth:`pyramid.interfaces.ISession.flash`\n        \"\"\""
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ICSRFStoragePolicy(Interface):\n    \"\"\"An object that offers the ability to verify CSRF tokens and generate\n    new ones.\"\"\"\n\n    def new_csrf_token(request):\n        \"\"\"Create and return a new, random cross-site request forgery\n        protection token. The token will be an ascii-compatible unicode\n        string.\n\n        \"\"\"\n\n    def get_csrf_token(request):\n        \"\"\"Return a cross-site request forgery protection token.  It\n        will be an ascii-compatible unicode string.  If a token was previously\n        set for this user via ``new_csrf_token``, that token will be returned.\n        If no CSRF token was previously set, ``new_csrf_token`` will be\n        called, which will create and set a token, and this token will be\n        returned.\n\n        \"\"\"\n\n    def check_csrf_token(request, token):\n        \"\"\"Determine if the supplied ``token`` is valid. Most implementations\n        should simply compare the ``token`` to the current value of\n        ``get_csrf_token`` but it is possible to verify the token using\n        any mechanism necessary using this method.\n\n        Returns ``True`` if the ``token`` is valid, otherwise ``False``.\n\n        \"\"\""
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IIntrospector(Interface):\n    def get(category_name, discriminator, default=None):\n        \"\"\"Get the IIntrospectable related to the category_name and the\n        discriminator (or discriminator hash) ``discriminator``.  If it does\n        not exist in the introspector, return the value of ``default``\"\"\"\n\n    def get_category(category_name, default=None, sort_key=None):\n        \"\"\"Get a sequence of dictionaries in the form\n        ``[{'introspectable':IIntrospectable, 'related':[sequence of related\n        IIntrospectables]}, ...]`` where each introspectable is part of the\n        category associated with ``category_name`` .\n\n        If the category named ``category_name`` does not exist in the\n        introspector the value passed as ``default`` will be returned.\n\n        If ``sort_key`` is ``None``, the sequence will be returned in the\n        order the introspectables were added to the introspector.  Otherwise,\n        sort_key should be a function that accepts an IIntrospectable and\n        returns a value from it (ala the ``key`` function of Python's\n        ``sorted`` callable).\"\"\"\n\n    def categories():\n        \"\"\"Return a sorted sequence of category names known by\n        this introspector\"\"\"\n\n    def categorized(sort_key=None):\n        \"\"\"Get a sequence of tuples in the form ``[(category_name,\n        [{'introspectable':IIntrospectable, 'related':[sequence of related\n        IIntrospectables]}, ...])]`` representing all known\n        introspectables.  If ``sort_key`` is ``None``, each introspectables\n        sequence will be returned in the order the introspectables were added\n        to the introspector.  Otherwise, sort_key should be a function that\n        accepts an IIntrospectable and returns a value from it (ala the\n        ``key`` function of Python's ``sorted`` callable).\"\"\"\n\n    def remove(category_name, discriminator):\n        \"\"\"Remove the IIntrospectable related to ``category_name`` and\n        ``discriminator`` from the introspector, and fix up any relations\n        that the introspectable participates in. This method will not raise\n        an error if an introspectable related to the category name and\n        discriminator does not exist.\"\"\"\n\n    def related(intr):\n        \"\"\"Return a sequence of IIntrospectables related to the\n        IIntrospectable ``intr``. Return the empty sequence if no relations\n        for exist.\"\"\"\n\n    def add(intr):\n        \"\"\"Add the IIntrospectable ``intr`` (use instead of\n        :meth:`pyramid.interfaces.IIntrospector.add` when you have a custom\n        IIntrospectable). Replaces any existing introspectable registered\n        using the same category/discriminator.\n\n        This method is not typically called directly, instead it's called\n        indirectly by :meth:`pyramid.interfaces.IIntrospector.register`\"\"\"\n\n    def relate(*pairs):\n        \"\"\"Given any number of ``(category_name, discriminator)`` pairs\n        passed as positional arguments, relate the associated introspectables\n        to each other. The introspectable related to each pair must have\n        already been added via ``.add`` or ``.add_intr``; a :exc:`KeyError`\n        will result if this is not true.  An error will not be raised if any\n        pair has already been associated with another.\n\n        This method is not typically called directly, instead it's called\n        indirectly by :meth:`pyramid.interfaces.IIntrospector.register`\n        \"\"\"\n\n    def unrelate(*pairs):\n        \"\"\"Given any number of ``(category_name, discriminator)`` pairs\n        passed as positional arguments, unrelate the associated introspectables\n        from each other. The introspectable related to each pair must have\n        already been added via ``.add`` or ``.add_intr``; a :exc:`KeyError`\n        will result if this is not true.  An error will not be raised if any\n        pair is not already related to another.\n\n        This method is not typically called directly, instead it's called\n        indirectly by :meth:`pyramid.interfaces.IIntrospector.register`\n        \"\"\""
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IIntrospectable(Interface):\n    \"\"\"An introspectable object used for configuration introspection.  In\n    addition to the methods below, objects which implement this interface\n    must also implement all the methods of Python's\n    ``collections.MutableMapping`` (the \"dictionary interface\"), and must be\n    hashable.\"\"\"\n\n    title = Attribute('Text title describing this introspectable')\n    type_name = Attribute('Text type name describing this introspectable')\n    order = Attribute(\n        'integer order in which registered with introspector '\n        '(managed by introspector, usually)'\n    )\n    category_name = Attribute('introspection category name')\n    discriminator = Attribute(\n        'introspectable discriminator (within category) (must be hashable)'\n    )\n    discriminator_hash = Attribute('an integer hash of the discriminator')\n    action_info = Attribute(\n        'An IActionInfo object representing the caller '\n        'that invoked the creation of this introspectable '\n        '(usually a sentinel until updated during '\n        'self.register)'\n    )\n\n    def relate(category_name, discriminator):\n        \"\"\"Indicate an intent to relate this IIntrospectable with another\n        IIntrospectable (the one associated with the ``category_name`` and\n        ``discriminator``) during action execution.\n        \"\"\"\n\n    def unrelate(category_name, discriminator):\n        \"\"\"Indicate an intent to break the relationship between this\n        IIntrospectable with another IIntrospectable (the one associated with\n        the ``category_name`` and ``discriminator``) during action execution.\n        \"\"\"\n\n    def register(introspector, action_info):\n        \"\"\"Register this IIntrospectable with an introspector.  This method\n        is invoked during action execution.  Adds the introspectable and its\n        relations to the introspector.  ``introspector`` should be an object\n        implementing IIntrospector.  ``action_info`` should be a object\n        implementing the interface :class:`pyramid.interfaces.IActionInfo`\n        representing the call that registered this introspectable.\n        Pseudocode for an implementation of this method:\n\n        .. code-block:: python\n\n            def register(self, introspector, action_info):\n                self.action_info = action_info\n                introspector.add(self)\n                for methodname, category_name, discriminator in self._relations:\n                    method = getattr(introspector, methodname)\n                    method((i.category_name, i.discriminator),\n                           (category_name, discriminator))\n        \"\"\"  # noqa: E501\n\n    def __hash__():\n        \"\"\"Introspectables must be hashable.  The typical implementation of\n        an introsepectable's __hash__ is::\n\n          return hash((self.category_name,) + (self.discriminator,))\n        \"\"\""
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IActionInfo(Interface):\n    \"\"\"Class which provides code introspection capability associated with an\n    action.  The ParserInfo class used by ZCML implements the same interface.\n    \"\"\"\n\n    file = Attribute('Filename of action-invoking code as a string')\n    line = Attribute(\n        'Starting line number in file (as an integer) of action-invoking code.'\n        'This will be ``None`` if the value could not be determined.'\n    )\n\n    def __str__():\n        \"\"\"Return a representation of the action information (including\n        source code from file, if possible)\"\"\""
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IAssetDescriptor(Interface):\n    \"\"\"\n    Describes an :term:`asset`.\n    \"\"\"\n\n    def absspec():\n        \"\"\"\n        Returns the absolute asset specification for this asset\n        (e.g. ``mypackage:templates/foo.pt``).\n        \"\"\"\n\n    def abspath():\n        \"\"\"\n        Returns an absolute path in the filesystem to the asset.\n        \"\"\"\n\n    def stream():\n        \"\"\"\n        Returns an input stream for reading asset contents.  Raises an\n        exception if the asset is a directory or does not exist.\n        \"\"\"\n\n    def isdir():\n        \"\"\"\n        Returns True if the asset is a directory, otherwise returns False.\n        \"\"\"\n\n    def listdir():\n        \"\"\"\n        Returns iterable of filenames of directory contents.  Raises an\n        exception if asset is not a directory.\n        \"\"\"\n\n    def exists():\n        \"\"\"\n        Returns True if asset exists, otherwise returns False.\n        \"\"\""
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IJSONAdapter(Interface):\n    \"\"\"\n    Marker interface for objects that can convert an arbitrary object\n    into a JSON-serializable primitive.\n    \"\"\""
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPredicateList(Interface):\n    \"\"\"Interface representing a predicate list\"\"\""
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPredicateInfo(Interface):\n    package = Attribute(\n        'The \"current package\" where the predicate '\n        'configuration statement was found'\n    )\n    registry = Attribute(\n        'The \"current\" application registry where the predicate was invoked'\n    )\n    settings = Attribute(\n        'The deployment settings dictionary related '\n        'to the current application'\n    )\n\n    def maybe_dotted(value):\n        \"\"\"Resolve the :term:`dotted Python name` ``dotted`` to a\n        global Python object.  If ``dotted`` is not a string, return\n        it without attempting to do any name resolution.  If\n        ``dotted`` is a relative dotted name (e.g. ``.foo.bar``,\n        consider it relative to the ``package``.\"\"\""
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPredicateFactory(Interface):\n    def __call__(value, info):\n        \"\"\"\n        Create a a :class:`.IPredicate` instance for a specific value.\n\n        \"\"\""
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IPredicate(Interface):\n    def text():\n        \"\"\"\n        A textual description of the predicate used in the introspector.\n\n        For example, ``'content_type = application/json'`` for a\n        ``ContentTypePredicate`` with a ``value == 'application/json'``.\n\n        \"\"\"\n\n    def phash():\n        \"\"\"\n        A unique string for the predicate containing both the name and value.\n\n        Often implementations simply set ``phash = text``.\n\n        \"\"\""
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IRoutePredicate(IPredicate):\n    def __call__(info, request):\n        \"\"\"\n        The ``info`` object is a dictionary containing two keys:\n\n        - \"match\" is a dictionary of parameters that becomes\n          ``request.matchdict`` if the route is selected\n          (all route predicates match).\n\n        - \"route\" is the :class:`.IRoute` object being matched.\n\n        Return ``True`` if the route should be selected or ``False`` otherwise.\n\n        \"\"\""
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ISubscriberPredicate(IPredicate):\n    def __call__(*args):\n        \"\"\"\n        The ``args`` is usually just a single ``event`` argument sent to\n        ``registry.notify``.\n\n        Return ``True`` if the subscriber should be executed for the given\n        arguments or ``False`` otherwise.\n\n        \"\"\""
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewPredicate(IPredicate):\n    def __call__(context, request):\n        \"\"\"\n        Return ``True`` if the view should be selected for the given\n        arguments or ``False`` otherwise.\n\n        \"\"\""
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewDeriver(Interface):\n    options = Attribute(\n        'A list of supported options to be passed to '\n        ':meth:`pyramid.config.Configurator.add_view`. '\n        'This attribute is optional.'\n    )\n\n    def __call__(view, info):\n        \"\"\"\n        Derive a new view from the supplied view.\n\n        View options, package information and registry are available on\n        ``info``, an instance of :class:`pyramid.interfaces.IViewDeriverInfo`.\n\n        The ``view`` is a callable accepting ``(context, request)``.\n\n        \"\"\""
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewDeriverInfo(Interface):\n    \"\"\"An object implementing this interface is passed to every\n    :term:`view deriver` during configuration.\"\"\"\n\n    registry = Attribute(\n        'The \"current\" application registry where the view was created'\n    )\n    package = Attribute(\n        'The \"current package\" where the view '\n        'configuration statement was found'\n    )\n    settings = Attribute(\n        'The deployment settings dictionary related '\n        'to the current application'\n    )\n    options = Attribute(\n        'The view options passed to the view, including any '\n        'default values that were not overriden'\n    )\n    predicates = Attribute('The list of predicates active on the view')\n    original_view = Attribute('The original view object being wrapped')\n    exception_only = Attribute('The view will only be invoked for exceptions')"
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class IViewDerivers(Interface):\n    \"\"\"Interface for view derivers list\"\"\""
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "class ICacheBuster(Interface):\n    \"\"\"\n    A cache buster modifies the URL generation machinery for\n    :meth:`~pyramid.request.Request.static_url`. See :ref:`cache_busting`.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __call__(request, subpath, kw):\n        \"\"\"\n        Modifies a subpath and/or keyword arguments from which a static asset\n        URL will be computed during URL generation.\n\n        The ``subpath`` argument is a path of ``/``-delimited segments that\n        represent the portion of the asset URL which is used to find the asset.\n        The ``kw`` argument is a dict of keywords that are to be passed\n        eventually to :meth:`~pyramid.request.Request.static_url` for URL\n        generation.  The return value should be a two-tuple of\n        ``(subpath, kw)`` where ``subpath`` is the relative URL from where the\n        file is served and ``kw`` is the same input argument. The return value\n        should be modified to include the cache bust token in the generated\n        URL.\n\n        The ``kw`` dictionary contains extra arguments passed to\n        :meth:`~pyramid.request.Request.static_url` as well as some extra\n        items that may be usful including:\n\n          - ``pathspec`` is the path specification for the resource\n            to be cache busted.\n\n          - ``rawspec`` is the original location of the file, ignoring\n            any calls to :meth:`pyramid.config.Configurator.override_asset`.\n\n        The ``pathspec`` and ``rawspec`` values are only different in cases\n        where an asset has been mounted into a virtual location using\n        :meth:`pyramid.config.Configurator.override_asset`. For example, with\n        a call to ``request.static_url('myapp:static/foo.png'), the\n        ``pathspec`` is ``myapp:static/foo.png`` whereas the ``rawspec`` may\n        be ``themepkg:bar.png``, assuming a call to\n        ``config.override_asset('myapp:static/foo.png', 'themepkg:bar.png')``.\n        \"\"\""
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "# configuration phases: a lower phase number means the actions associated\n# with this phase will be executed earlier than those with later phase\n# numbers.  The default phase number is 0, FTR."
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/pyramid/src/pyramid/interfaces.py",
      "content": "PHASE0_CONFIG = -30\nPHASE1_CONFIG = -20\nPHASE2_CONFIG = -10\nPHASE3_CONFIG = 0\n```"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/pyramid/src/pyramid/encode.py",
      "content": "from urllib.parse import quote as _url_quote, quote_plus as _quote_plus\n\nfrom pyramid.util import is_nonstr_iter"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/pyramid/src/pyramid/encode.py",
      "content": "def url_quote(val, safe=''):  # bw compat api\n    cls = val.__class__\n    if cls is str:\n        val = val.encode('utf-8')\n    elif cls is not bytes:\n        val = str(val).encode('utf-8')\n    return _url_quote(val, safe=safe)"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/pyramid/src/pyramid/encode.py",
      "content": "# bw compat api (dnr)\ndef quote_plus(val, safe=''):\n    cls = val.__class__\n    if cls is str:\n        val = val.encode('utf-8')\n    elif cls is not bytes:\n        val = str(val).encode('utf-8')\n    return _quote_plus(val, safe=safe)"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/pyramid/src/pyramid/encode.py",
      "content": "def urlencode(query, doseq=True, quote_via=quote_plus):\n    \"\"\"\n    An alternate implementation of Python's stdlib\n    :func:`urllib.parse.urlencode` function which accepts string keys and\n    values within the ``query`` dict/sequence; all string keys and values are\n    first converted to UTF-8 before being used to compose the query string.\n\n    The value of ``query`` must be a sequence of two-tuples\n    representing key/value pairs *or* an object (often a dictionary)\n    with an ``.items()`` method that returns a sequence of two-tuples\n    representing key/value pairs.\n\n    For minimal calling convention backwards compatibility, this\n    version of urlencode accepts *but ignores* a second argument\n    conventionally named ``doseq``.  The Python stdlib version behaves\n    differently when ``doseq`` is False and when a sequence is\n    presented as one of the values.  This version always behaves in\n    the ``doseq=True`` mode, no matter what the value of the second\n    argument.\n\n    Both the key and value are encoded using the ``quote_via`` function which\n    by default is using a similar algorithm to :func:`urllib.parse.quote_plus`\n    which converts spaces into '+' characters and '/' into '%2F'.\n\n    .. versionchanged:: 1.5\n       In a key/value pair, if the value is ``None`` then it will be\n       dropped from the resulting output.\n\n    .. versionchanged:: 1.9\n       Added the ``quote_via`` argument to allow alternate quoting algorithms\n       to be used.\n\n    \"\"\"\n    try:\n        # presumed to be a dictionary\n        query = query.items()\n    except AttributeError:\n        pass\n\n    result = ''\n    prefix = ''\n\n    for k, v in query:\n        k = quote_via(k)\n\n        if is_nonstr_iter(v):\n            for x in v:\n                x = quote_via(x)\n                result += f'{prefix}{k}={x}'\n                prefix = '&'\n        elif v is None:\n            result += f'{prefix}{k}='\n        else:\n            v = quote_via(v)\n            result += f'{prefix}{k}={v}'\n\n        prefix = '&'\n\n    return result"
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "```python"
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "import base64\nimport binascii\nfrom codecs import utf_8_decode, utf_8_encode\nfrom collections import namedtuple\nimport hashlib\nimport re\nimport time as time_mod\nfrom urllib.parse import quote, unquote\nimport warnings\nfrom webob.cookies import CookieProfile\nfrom zope.interface import implementer\n\nfrom pyramid.authorization import Authenticated, Everyone\nfrom pyramid.interfaces import IAuthenticationPolicy, IDebugLogger\nfrom pyramid.util import (\n    SimpleSerializer,\n    ascii_,\n    bytes_,\n    strings_differ,\n    text_,\n)\n\nVALID_TOKEN = re.compile(r\"^[A-Za-z][A-Za-z0-9+_-]*$\")"
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "class CallbackAuthenticationPolicy:\n    \"\"\"Abstract class\"\"\"\n\n    debug = False\n    callback = None\n\n    def _log(self, msg, methodname, request):\n        logger = request.registry.queryUtility(IDebugLogger)\n        if logger:\n            cls = self.__class__\n            classname = cls.__module__ + '.' + cls.__name__\n            methodname = classname + '.' + methodname\n            logger.debug(methodname + ': ' + msg)\n\n    def _clean_principal(self, princid):\n        if princid in (Authenticated, Everyone):\n            princid = None\n        return princid\n\n    def authenticated_userid(self, request):\n        \"\"\"Return the authenticated userid or ``None``.\n\n        If no callback is registered, this will be the same as\n        ``unauthenticated_userid``.\n\n        If a ``callback`` is registered, this will return the userid if\n        and only if the callback returns a value that is not ``None``.\n\n        \"\"\"\n        debug = self.debug\n        userid = self.unauthenticated_userid(request)\n        if userid is None:\n            debug and self._log(\n                'call to unauthenticated_userid returned None; returning None',\n                'authenticated_userid',\n                request,\n            )\n            return None\n        if self._clean_principal(userid) is None:\n            debug and self._log(\n                (\n                    'use of userid %r is disallowed by any built-in Pyramid '\n                    'security policy, returning None' % userid\n                ),\n                'authenticated_userid',\n                request,\n            )\n            return None\n\n        if self.callback is None:\n            debug and self._log(\n                f'there was no groupfinder callback; returning {userid!r}',\n                'authenticated_userid',\n                request,\n            )\n            return userid\n        callback_ok = self.callback(userid, request)\n        if callback_ok is not None:  # is not None!\n            debug and self._log(\n                'groupfinder callback returned %r; returning %r'\n                % (callback_ok, userid),\n                'authenticated_userid',\n                request,\n            )\n            return userid\n        debug and self._log(\n            'groupfinder callback returned None; returning None',\n            'authenticated_userid',\n            request,\n        )\n\n    def effective_principals(self, request):\n        \"\"\"A list of effective principals derived from request.\n\n        This will return a list of principals including, at least,\n        :data:`pyramid.authorization.Everyone`. If there is no authenticated\n        userid, or the ``callback`` returns ``None``, this will be the\n        only principal:\n\n        .. code-block:: python\n\n            return [Everyone]\n\n        If the ``callback`` does not return ``None`` and an authenticated\n        userid is found, then the principals will include\n        :data:`pyramid.authorization.Authenticated`, the\n        ``authenticated_userid`` and the list of principals returned by the\n        ``callback``:\n\n        .. code-block:: python\n\n            extra_principals = callback(userid, request)\n            return [Everyone, Authenticated, userid] + extra_principals\n\n        \"\"\"\n        debug = self.debug\n        effective_principals = [Everyone]\n        userid = self.unauthenticated_userid(request)\n\n        if userid is None:\n            debug and self._log(\n                'unauthenticated_userid returned %r; returning %r'\n                % (userid, effective_principals),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        if self._clean_principal(userid) is None:\n            debug and self._log(\n                (\n                    'unauthenticated_userid returned disallowed %r; returning '\n                    '%r as if it was None' % (userid, effective_principals)\n                ),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        if self.callback is None:\n            debug and self._log(\n                'groupfinder callback is None, so groups is []',\n                'effective_principals',\n                request,\n            )\n            groups = []\n        else:\n            groups = self.callback(userid, request)\n            debug and self._log(\n                f'groupfinder callback returned {groups!r} as groups',\n                'effective_principals',\n                request,\n            )\n\n        if groups is None:  # is None!\n            debug and self._log(\n                f'returning effective principals: {effective_principals!r}',\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        effective_principals.append(Authenticated)\n        effective_principals.append(userid)\n        effective_principals.extend(groups)\n\n        debug and self._log(\n            f'returning effective principals: {effective_principals!r}',\n            'effective_principals',\n            request,\n        )\n        return effective_principals"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "@implementer(IAuthenticationPolicy)\nclass RepozeWho1AuthenticationPolicy(CallbackAuthenticationPolicy):\n    \"\"\"A :app:`Pyramid` :term:`authentication policy` which\n    obtains data from the :mod:`repoze.who` 1.X WSGI 'API' (the\n    ``repoze.who.identity`` key in the WSGI environment).\n\n    Constructor Arguments\n\n    ``identifier_name``\n\n       Default: ``auth_tkt``.  The :mod:`repoze.who` plugin name that\n       performs remember/forget.  Optional.\n\n    ``callback``\n\n        Default: ``None``.  A callback passed the :mod:`repoze.who` identity\n        and the :term:`request`, expected to return ``None`` if the user\n        represented by the identity doesn't exist or a sequence of principal\n        identifiers (possibly empty) representing groups if the user does\n        exist.  If ``callback`` is None, the userid will be assumed to exist\n        with no group principals.\n\n    Objects of this class implement the interface described by\n    :class:`pyramid.interfaces.IAuthenticationPolicy`.\n    \"\"\"\n\n    def __init__(self, identifier_name='auth_tkt', callback=None):\n        self.identifier_name = identifier_name\n        self.callback = callback\n\n    def _get_identity(self, request):\n        return request.environ.get('repoze.who.identity')\n\n    def _get_identifier(self, request):\n        plugins = request.environ.get('repoze.who.plugins')\n        if plugins is None:\n            return None\n        identifier = plugins[self.identifier_name]\n        return identifier\n\n    def authenticated_userid(self, request):\n        \"\"\"Return the authenticated userid or ``None``.\n\n        If no callback is registered, this will be the same as\n        ``unauthenticated_userid``.\n\n        If a ``callback`` is registered, this will return the userid if\n        and only if the callback returns a value that is not ``None``.\n\n        \"\"\"\n        identity = self._get_identity(request)\n\n        if identity is None:\n            self.debug and self._log(\n                'repoze.who identity is None, returning None',\n                'authenticated_userid',\n                request,\n            )\n            return None\n\n        userid = identity['repoze.who.userid']\n\n        if userid is None:\n            self.debug and self._log(\n                'repoze.who.userid is None, returning None' % userid,\n                'authenticated_userid',\n                request,\n            )\n            return None\n\n        if self._clean_principal(userid) is None:\n            self.debug and self._log(\n                (\n                    'use of userid %r is disallowed by any built-in Pyramid '\n                    'security policy, returning None' % userid\n                ),\n                'authenticated_userid',\n                request,\n            )\n            return None\n\n        if self.callback is None:\n            return userid\n\n        if self.callback(identity, request) is not None:  # is not None!\n            return userid\n\n    def unauthenticated_userid(self, request):\n        \"\"\"Return the ``repoze.who.userid`` key from the detected identity.\"\"\"\n        identity = self._get_identity(request)\n        if identity is None:\n            return None\n        return identity['repoze.who.userid']\n\n    def effective_principals(self, request):\n        \"\"\"A list of effective principals derived from the identity.\n\n        This will return a list of principals including, at least,\n        :data:`pyramid.authorization.Everyone`. If there is no identity, or\n        the ``callback`` returns ``None``, this will be the only principal.\n\n        If the ``callback`` does not return ``None`` and an identity is\n        found, then the principals will include\n        :data:`pyramid.authorization.Authenticated`, the\n        ``authenticated_userid`` and the list of principals returned by the\n        ``callback``.\n\n        \"\"\"\n        effective_principals = [Everyone]\n        identity = self._get_identity(request)\n\n        if identity is None:\n            self.debug and self._log(\n                (\n                    'repoze.who identity was None; returning %r'\n                    % effective_principals\n                ),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        if self.callback is None:\n            groups = []\n        else:\n            groups = self.callback(identity, request)\n\n        if groups is None:  # is None!\n            self.debug and self._log(\n                (\n                    'security policy groups callback returned None; returning '\n                    '%r' % effective_principals\n                ),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        userid = identity['repoze.who.userid']\n\n        if userid is None:\n            self.debug and self._log(\n                (\n                    'repoze.who.userid was None; returning %r'\n                    % effective_principals\n                ),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        if self._clean_principal(userid) is None:\n            self.debug and self._log(\n                (\n                    'unauthenticated_userid returned disallowed %r; returning '\n                    '%r as if it was None' % (userid, effective_principals)\n                ),\n                'effective_principals',\n                request,\n            )\n            return effective_principals\n\n        effective_principals.append(Authenticated)\n        effective_principals.append(userid)\n        effective_principals.extend(groups)\n        return effective_principals\n\n    def remember(self, request, userid, **kw):\n        \"\"\"Store the ``userid`` as ``repoze.who.userid``.\n\n        The identity to authenticated to :mod:`repoze.who`\n        will contain the given userid as ``userid``, and\n        provide all keyword arguments as additional identity\n        keys. Useful keys could be ``max_age`` or ``userdata``.\n        \"\"\"\n        identifier = self._get_identifier(request)\n        if identifier is None:\n            return []\n        environ = request.environ\n        identity = kw\n        identity['repoze.who.userid'] = userid\n        return identifier.remember(environ, identity)\n\n    def forget(self, request):\n        \"\"\"Forget the current authenticated user.\n\n        Return headers that, if included in a response, will delete the\n        cookie responsible for tracking the current user.\n\n        \"\"\"\n        identifier = self._get_identifier(request)\n        if identifier is None:\n            return []\n        identity = self._get_identity(request)\n        return identifier.forget(request.environ, identity)"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "@implementer(IAuthenticationPolicy)\nclass RemoteUserAuthenticationPolicy(CallbackAuthenticationPolicy):\n    \"\"\"A :app:`Pyramid` :term:`authentication policy` which\n    obtains data from the ``REMOTE_USER`` WSGI environment variable.\n\n    Constructor Arguments\n\n    ``environ_key``\n\n        Default: ``REMOTE_USER``.  The key in the WSGI environ which\n        provides the userid.\n\n    ``callback``\n\n        Default: ``None``.  A callback passed the userid and the request,\n        expected to return None if the userid doesn't exist or a sequence of\n        principal identifiers (possibly empty) representing groups if the\n        user does exist.  If ``callback`` is None, the userid will be assumed\n        to exist with no group principals.\n\n    ``debug``\n\n        Default: ``False``.  If ``debug`` is ``True``, log messages to the\n        Pyramid debug logger about the results of various authentication\n        steps.  The output from debugging is useful for reporting to maillist\n        or IRC channels when asking for support.\n\n    Objects of this class implement the interface described by\n    :class:`pyramid.interfaces.IAuthenticationPolicy`.\n    \"\"\"\n\n    def __init__(self, environ_key='REMOTE_USER', callback=None, debug=False):\n        self.environ_key = environ_key\n        self.callback = callback\n        self.debug = debug\n\n    def unauthenticated_userid(self, request):\n        \"\"\"The ``REMOTE_USER`` value found within the ``environ``.\"\"\"\n        return request.environ.get(self.environ_key)\n\n    def remember(self, request, userid, **kw):\n        \"\"\"A no-op. The ``REMOTE_USER`` does not provide a protocol for\n        remembering the user. This will be application-specific and can\n        be done somewhere else or in a subclass.\"\"\"\n        return []\n\n    def forget(self, request):\n        \"\"\"A no-op. The ``REMOTE_USER`` does not provide a protocol for\n        forgetting the user. This will be application-specific and can\n        be done somewhere else or in a subclass.\"\"\"\n        return []"
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "@implementer(IAuthenticationPolicy)\nclass AuthTktAuthenticationPolicy(CallbackAuthenticationPolicy):\n    \"\"\"A :app:`Pyramid` :term:`authentication policy` which\n    obtains data from a Pyramid \"auth ticket\" cookie.\n\n    Constructor Arguments\n\n    ``secret``\n\n       The secret (a string) used for auth_tkt cookie signing.  This value\n       should be unique across all values provided to Pyramid for various\n       subsystem secrets (see :ref:`admonishment_against_secret_sharing`).\n       Required.\n\n    ``callback``\n\n       Default: ``None``.  A callback passed the userid and the\n       request, expected to return ``None`` if the userid doesn't\n       exist or a sequence of principal identifiers (possibly empty) if\n       the user does exist.  If ``callback`` is ``None``, the userid\n       will be assumed to exist with no principals.  Optional.\n\n    ``cookie_name``\n\n       Default: ``auth_tkt``.  The cookie name used\n       (string).  Optional.\n\n    ``secure``\n\n       Default: ``False``.  Only send the cookie back over a secure\n       conn.  Optional.\n\n    ``include_ip``\n\n       Default: ``False``.  Make the requesting IP address part of\n       the authentication data in the cookie.  Optional.\n\n       For IPv6 this option is not recommended. The ``mod_auth_tkt``\n       specification does not specify how to handle IPv6 addresses, so using\n       this option in combination with IPv6 addresses may cause an\n       incompatible cookie. It ties the authentication ticket to that\n       individual's IPv6 address.\n\n    ``timeout``\n\n       Default: ``None``.  Maximum number of seconds which a newly\n       issued ticket will be considered valid.  After this amount of\n       time, the ticket will expire (effectively logging the user\n       out).  If this value is ``None``, the ticket never expires.\n       Optional.\n\n    ``reissue_time``\n\n       Default: ``None``.  If this parameter is set, it represents the number\n       of seconds that must pass before an authentication token cookie is\n       automatically reissued as the result of a request which requires\n       authentication.  The duration is measured as the number of seconds\n       since the last auth_tkt cookie was issued and 'now'.  If this value is\n       ``0``, a new ticket cookie will be reissued on every request which\n       requires authentication.\n\n       A good rule of thumb: if you want auto-expired cookies based on\n       inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n       ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n       (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n       than the ``reissue_time`` value, as the ticket will never be reissued\n       if so.  However, such a configuration is not explicitly prevented.\n\n       Optional.\n\n    ``max_age``\n\n       Default: ``None``.  The max age of the auth_tkt cookie, in\n       seconds.  This differs from ``timeout`` inasmuch as ``timeout``\n       represents the lifetime of the ticket contained in the cookie,\n       while this value represents the lifetime of the cookie itself.\n       When this value is set, the cookie's ``Max-Age`` and\n       ``Expires`` settings will be set, allowing the auth_tkt cookie\n       to last between browser sessions.  It is typically nonsensical\n       to set this to a value that is lower than ``timeout`` or\n       ``reissue_time``, although it is not explicitly prevented.\n       Optional.\n\n    ``path``\n\n       Default: ``/``. The path for which the auth_tkt cookie is valid.\n       May be desirable if the application only serves part of a domain.\n       Optional.\n\n    ``http_only``\n\n       Default: ``False``. Hide cookie from JavaScript by setting the\n       HttpOnly flag. Not honored by all browsers.\n       Optional.\n\n    ``wild_domain``\n\n       Default: ``True``. An auth_tkt cookie will be generated for the\n       wildcard domain. If your site is hosted as ``example.com`` this\n       will make the cookie available for sites underneath ``example.com``\n       such as ``www.example.com``.\n       Optional.\n\n    ``parent_domain``\n\n       Default: ``False``. An auth_tkt cookie will be generated for the\n       parent domain of the current site. For example if your site is\n       hosted under ``www.example.com`` a cookie will be generated for\n       ``.example.com``. This can be useful if you have multiple sites\n       sharing the same domain. This option supercedes the ``wild_domain``\n       option.\n       Optional.\n\n    ``domain``\n\n       Default: ``None``. If provided the auth_tkt cookie will only be\n       set for this domain. This option is not compatible with ``wild_domain``\n       and ``parent_domain``.\n       Optional.\n\n    ``hashalg``\n\n       Default: ``sha512`` (the literal string).\n\n       Any hash algorithm supported by Python's ``hashlib.new()`` function\n       can be used as the ``hashalg``.\n\n       Cookies generated by different instances of AuthTktAuthenticationPolicy\n       using different ``hashalg`` options are not compatible. Switching the\n       ``hashalg`` will imply that all existing users with a valid cookie will\n       be required to re-login.\n\n       Optional.\n\n    ``debug``\n\n        Default: ``False``.  If ``debug`` is ``True``, log messages to the\n        Pyramid debug logger about the results of various authentication\n        steps.  The output from debugging is useful for reporting to maillist\n        or IRC channels when asking for support.\n\n    ``samesite``\n\n        Default: ``'Lax'``.  The 'samesite' option of the session cookie. Set\n        the value to the string ``'None'`` to turn off the samesite option.\n\n    .. versionchanged:: 1.4\n\n       Added the ``hashalg`` option, defaulting to ``sha512``.\n\n    .. versionchanged:: 1.5\n\n       Added the ``domain`` option.\n\n       Added the ``parent_domain`` option.\n\n    .. versionchanged:: 1.10\n\n       Added the ``samesite`` option and made the default ``'Lax'``.\n\n    Objects of this class implement the interface described by\n    :class:`pyramid.interfaces.IAuthenticationPolicy`.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        secret,\n        callback=None,\n        cookie_name='auth_tkt',\n        secure=False,\n        include_ip=False,\n        timeout=None,\n        reissue_time=None,\n        max_age=None,\n        path=\"/\",\n        http_only=False,\n        wild_domain=True,\n        debug=False,\n        hashalg='sha512',\n        parent_domain=False,\n        domain=None,\n        samesite='Lax',\n    ):\n        self.cookie = AuthTktCookieHelper(\n            secret,\n            cookie_name=cookie_name,\n            secure=secure,\n            include_ip=include_ip,\n            timeout=timeout,\n            reissue_time=reissue_time,\n            max_age=max_age,\n            http_only=http_only,\n            path=path,\n            wild_domain=wild_domain,\n            hashalg=hashalg,\n            parent_domain=parent_domain,\n            domain=domain,\n            samesite=samesite,\n        )\n        self.callback = callback\n        self.debug = debug\n\n    def unauthenticated_userid(self, request):\n        \"\"\"The userid key within the auth_tkt cookie.\"\"\"\n        result = self.cookie.identify(request)\n        if result:\n            return result['userid']\n\n    def remember(self, request, userid, **kw):\n        \"\"\"Accepts the following kw args: ``max_age=<int-seconds>,\n        ``tokens=<sequence-of-ascii-strings>``.\n\n        Return a list of headers which will set appropriate cookies on\n        the response.\n\n        \"\"\"\n        return self.cookie.remember(request, userid, **kw)\n\n    def forget(self, request):\n        \"\"\"A list of headers which will delete appropriate cookies.\"\"\"\n        return self.cookie.forget(request)"
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def b64encode(v):\n    return base64.b64encode(bytes_(v)).strip().replace(b'\\n', b'')"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def b64decode(v):\n    return base64.b64decode(bytes_(v))"
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "class AuthTicket:\n    \"\"\"\n    This class represents an authentication token.  You must pass in\n    the shared secret, the userid, and the IP address.  Optionally you\n    can include tokens (a list of strings, representing role names),\n    'user_data', which is arbitrary data available for your own use in\n    later scripts.  Lastly, you can override the cookie name and\n    timestamp.\n\n    Once you provide all the arguments, use .cookie_value() to\n    generate the appropriate authentication ticket.\n\n    Usage::\n\n        token = AuthTicket('sharedsecret', 'username',\n            os.environ['REMOTE_ADDR'], tokens=['admin'])\n        val = token.cookie_value()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        secret,\n        userid,\n        ip,\n        tokens=(),\n        user_data='',\n        time=None,\n        cookie_name='auth_tkt',\n        secure=False,\n        hashalg='md5',\n    ):\n        self.secret = secret\n        self.userid = userid\n        self.ip = ip\n        self.tokens = ','.join(tokens)\n        self.user_data = user_data\n        if time is None:\n            self.time = time_mod.time()\n        else:\n            self.time = time\n        self.cookie_name = cookie_name\n        self.secure = secure\n        self.hashalg = hashalg\n\n    def digest(self):\n        return calculate_digest(\n            self.ip,\n            self.time,\n            self.secret,\n            self.userid,\n            self.tokens,\n            self.user_data,\n            self.hashalg,\n        )\n\n    def cookie_value(self):\n        v = f'{self.digest()}{int(self.time):08x}{quote(self.userid)}!'\n        if self.tokens:\n            v += self.tokens + '!'\n        v += self.user_data\n        return v"
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "class BadTicket(Exception):\n    \"\"\"\n    Exception raised when a ticket can't be parsed.  If we get far enough to\n    determine what the expected digest should have been, expected is set.\n    This should not be shown by default, but can be useful for debugging.\n    \"\"\"\n\n    def __init__(self, msg, expected=None):\n        self.expected = expected\n        Exception.__init__(self, msg)"
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def parse_ticket(secret, ticket, ip, hashalg='md5'):\n    \"\"\"\n    Parse the ticket, returning (timestamp, userid, tokens, user_data).\n\n    If the ticket cannot be parsed, a ``BadTicket`` exception will be raised\n    with an explanation.\n    \"\"\"\n    ticket = text_(ticket).strip('\"')\n    digest_size = hashlib.new(hashalg).digest_size * 2\n    digest = ticket[:digest_size]\n    try:\n        timestamp = int(ticket[digest_size : digest_size + 8], 16)\n    except ValueError as e:\n        raise BadTicket('Timestamp is not a hex integer: %s' % e)\n    try:\n        userid, data = ticket[digest_size + 8 :].split('!', 1)\n    except ValueError:\n        raise BadTicket('userid is not followed by !')\n    userid = unquote(userid)\n    if '!' in data:\n        tokens, user_data = data.split('!', 1)\n    else:  # pragma: no cover (never generated)\n        # @@: Is this the right order?\n        tokens = ''\n        user_data = data\n\n    expected = calculate_digest(\n        ip, timestamp, secret, userid, tokens, user_data, hashalg\n    )\n\n    # Avoid timing attacks (see\n    # http://seb.dbzteam.org/crypto/python-oauth-timing-hmac.pdf)\n    if strings_differ(expected, digest):\n        raise BadTicket(\n            'Digest signature is not correct', expected=(expected, digest)\n        )\n\n    tokens = tokens.split(',')\n\n    return (timestamp, userid, tokens, user_data)"
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def calculate_digest(\n    ip, timestamp, secret, userid, tokens, user_data, hashalg='md5'\n):\n    secret = bytes_(secret, 'utf-8')\n    userid = bytes_(userid, 'utf-8')\n    tokens = bytes_(tokens, 'utf-8')\n    user_data = bytes_(user_data, 'utf-8')\n    hash_obj = hashlib.new(hashalg)\n\n    # Check to see if this is an IPv6 address\n    if ':' in ip:\n        ip_timestamp = ip + str(int(timestamp))\n        ip_timestamp = bytes_(ip_timestamp)\n    else:\n        # encode_ip_timestamp not required, left in for backwards compatibility\n        ip_timestamp = encode_ip_timestamp(ip, timestamp)\n\n    hash_obj.update(\n        ip_timestamp + secret + userid + b'\\0' + tokens + b'\\0' + user_data\n    )\n    digest = hash_obj.hexdigest()\n    hash_obj2 = hashlib.new(hashalg)\n    hash_obj2.update(bytes_(digest) + secret)\n    return hash_obj2.hexdigest()"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def encode_ip_timestamp(ip, timestamp):\n    ip_chars = ''.join(map(chr, map(int, ip.split('.'))))\n    t = int(timestamp)\n    ts = (\n        (t & 0xFF000000) >> 24,\n        (t & 0xFF0000) >> 16,\n        (t & 0xFF00) >> 8,\n        t & 0xFF,\n    )\n    ts_chars = ''.join(map(chr, ts))\n    return bytes_(ip_chars + ts_chars)"
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "class AuthTktCookieHelper:\n    \"\"\"\n    A helper class for security policies that obtains data from an \"auth\n    ticket\" cookie.\n\n    Constructor Arguments\n\n    ``secret``\n\n       The secret (a string) used for auth_tkt cookie signing.  This value\n       should be unique across all values provided to Pyramid for various\n       subsystem secrets (see :ref:`admonishment_against_secret_sharing`).\n       Required.\n\n    ``cookie_name``\n\n       Default: ``auth_tkt``.  The cookie name used\n       (string).  Optional.\n\n    ``secure``\n\n       Default: ``False``.  Only send the cookie back over a secure\n       conn.  Optional.\n\n    ``include_ip``\n\n       Default: ``False``.  Make the requesting IP address part of\n       the authentication data in the cookie.  Optional.\n\n       For IPv6 this option is not recommended. The ``mod_auth_tkt``\n       specification does not specify how to handle IPv6 addresses, so using\n       this option in combination with IPv6 addresses may cause an\n       incompatible cookie. It ties the authentication ticket to that\n       individual's IPv6 address.\n\n    ``timeout``\n\n       Default: ``None``.  Maximum number of seconds which a newly\n       issued ticket will be considered valid.  After this amount of\n       time, the ticket will expire (effectively logging the user\n       out).  If this value is ``None``, the ticket never expires.\n       Optional.\n\n    ``reissue_time``\n\n       Default: ``None``.  If this parameter is set, it represents the number\n       of seconds that must pass before an authentication token cookie is\n       automatically reissued as the result of a request which requires\n       authentication.  The duration is measured as the number of seconds\n       since the last auth_tkt cookie was issued and 'now'.  If this value is\n       ``0``, a new ticket cookie will be reissued on every request which\n       requires authentication.\n\n       A good rule of thumb: if you want auto-expired cookies based on\n       inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n       ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n       (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n       than the ``reissue_time`` value, as the ticket will never be reissued\n       if so.  However, such a configuration is not explicitly prevented.\n\n       Optional.\n\n    ``max_age``\n\n       Default: ``None``.  The max age of the auth_tkt cookie, in\n       seconds.  This differs from ``timeout`` inasmuch as ``timeout``\n       represents the lifetime of the ticket contained in the cookie,\n       while this value represents the lifetime of the cookie itself.\n       When this value is set, the cookie's ``Max-Age`` and\n       ``Expires`` settings will be set, allowing the auth_tkt cookie\n       to last between browser sessions.  It is typically nonsensical\n       to set this to a value that is lower than ``timeout`` or\n       ``reissue_time``, although it is not explicitly prevented.\n       Optional.\n\n    ``path``\n\n       Default: ``/``. The path for which the auth_tkt cookie is valid.\n       May be desirable if the application only serves part of a domain.\n       Optional.\n\n    ``http_only``\n\n       Default: ``False``. Hide cookie from JavaScript by setting the\n       HttpOnly flag. Not honored by all browsers.\n       Optional.\n\n    ``wild_domain``\n\n       Default: ``True``. An auth_tkt cookie will be generated for the\n       wildcard domain. If your site is hosted as ``example.com`` this\n       will make the cookie available for sites underneath ``example.com``\n       such as ``www.example.com``.\n       Optional.\n\n    ``parent_domain``\n\n       Default: ``False``. An auth_tkt cookie will be generated for the\n       parent domain of the current site. For example if your site is\n       hosted under ``www.example.com`` a cookie will be generated for\n       ``.example.com``. This can be useful if you have multiple sites\n       sharing the same domain. This option supercedes the ``wild_domain``\n       option.\n       Optional.\n\n    ``domain``\n\n       Default: ``None``. If provided the auth_tkt cookie will only be\n       set for this domain. This option is not compatible with ``wild_domain``\n       and ``parent_domain``.\n       Optional.\n\n    ``hashalg``\n\n       Default: ``sha512`` (the literal string).\n\n       Any hash algorithm supported by Python's ``hashlib.new()`` function\n       can be used as the ``hashalg``.\n\n       Cookies generated by different instances of AuthTktAuthenticationPolicy\n       using different ``hashalg`` options are not compatible. Switching the\n       ``hashalg`` will imply that all existing users with a valid cookie will\n       be required to re-login.\n\n       Optional.\n\n    ``debug``\n\n        Default: ``False``.  If ``debug`` is ``True``, log messages to the\n        Pyramid debug logger about the results of various authentication\n        steps.  The output from debugging is useful for reporting to maillist\n        or IRC channels when asking for support. Optional.\n\n    ``samesite``\n\n        Default: ``'Lax'``.  The 'samesite' option of the session cookie. Set\n        the value to ``None`` to turn off the samesite option. Optional.\n\n    .. versionchanged:: 2.0\n\n        The default ``hashalg`` was changed from ``md5`` to ``sha512``.\n\n    \"\"\"\n\n    parse_ticket = staticmethod(parse_ticket)  # for tests\n    AuthTicket = AuthTicket  # for tests\n    BadTicket = BadTicket  # for tests\n    now = None  # for tests\n\n    userid_type_decoders = {\n        'int': int,\n        'unicode': lambda x: utf_8_decode(x)[0],  # bw compat for old cookies\n        'b64unicode': lambda x: utf_8_decode(b64decode(x))[0],\n        'b64str': lambda x: b64decode(x),\n    }\n\n    userid_type_encoders = {\n        int: ('int', str),\n        str: ('b64unicode', lambda x: b64encode(utf_8_encode(x)[0])),\n        bytes: ('b64str', lambda x: b64encode(x)),\n    }\n\n    def __init__(\n        self,\n        secret,\n        cookie_name='auth_tkt',\n        secure=False,\n        include_ip=False,\n        timeout=None,\n        reissue_time=None,\n        max_age=None,\n        http_only=False,\n        path=\"/\",\n        wild_domain=True,\n        hashalg='sha512',\n        parent_domain=False,\n        domain=None,\n        samesite='Lax',\n    ):\n        self.cookie_profile = CookieProfile(\n            cookie_name=cookie_name,\n            secure=secure,\n            max_age=max_age,\n            httponly=http_only,\n            path=path,\n            serializer=SimpleSerializer(),\n            samesite=samesite,\n        )\n\n        self.secret = secret\n        self.cookie_name = cookie_name\n        self.secure = secure\n        self.include_ip = include_ip\n        self.timeout = timeout if timeout is None else int(timeout)\n        self.reissue_time = (\n            reissue_time if reissue_time is None else int(reissue_time)\n        )\n        self.max_age = max_age if max_age is None else int(max_age)\n        self.wild_domain = wild_domain\n        self.parent_domain = parent_domain\n        self.domain = domain\n        self.hashalg = hashalg\n\n    def _get_cookies(self, request, value, max_age=None):\n        if self.domain:\n            domain = self.domain\n        else:\n            cur_domain = request.domain\n            if self.parent_domain and cur_domain.count('.') > 1:\n                domain = cur_domain.split('.', 1)[1]\n            elif self.wild_domain:\n                domain = cur_domain\n            else:\n                domain = None\n\n        profile = self.cookie_profile(request)\n\n        kw = {'domains': [domain]}\n        if max_age is not None:\n            kw['max_age'] = max_age\n\n        headers = profile.get_headers(value, **kw)\n        return headers\n\n    def identify(self, request):\n        \"\"\"Return a dictionary with authentication information, or ``None``\n        if no valid auth_tkt is attached to ``request``\"\"\"\n        environ = request.environ\n        cookie = request.cookies.get(self.cookie_name)\n\n        if cookie is None:\n            return None\n\n        if self.include_ip:\n            remote_addr = environ['REMOTE_ADDR']\n        else:\n            remote_addr = '0.0.0.0'\n\n        try:\n            timestamp, userid, tokens, user_data = self.parse_ticket(\n                self.secret, cookie, remote_addr, self.hashalg\n            )\n        except self.BadTicket:\n            return None\n\n        now = self.now  # service tests\n\n        if now is None:\n            now = time_mod.time()\n\n        if self.timeout and ((timestamp + self.timeout) < now):\n            # the auth_tkt data has expired\n            return None\n\n        userid_typename = 'userid_type:'\n        user_data_info = user_data.split('|')\n        for datum in filter(None, user_data_info):\n            if datum.startswith(userid_typename):\n                userid_type = datum[len(userid_typename) :]\n                decoder = self.userid_type_decoders.get(userid_type)\n                if decoder:\n                    userid = decoder(userid)\n\n        reissue = self.reissue_time is not None\n\n        if reissue and not hasattr(request, '_authtkt_reissued'):\n            if (now - timestamp) > self.reissue_time:\n                # See https://github.com/Pylons/pyramid/issues#issue/108\n                tokens = list(filter(None, tokens))\n                headers = self.remember(\n                    request, userid, max_age=self.max_age, tokens=tokens\n                )\n\n                def reissue_authtkt(request, response):\n                    if not hasattr(request, '_authtkt_reissue_revoked'):\n                        for k, v in headers:\n                            response.headerlist.append((k, v))\n\n                request.add_response_callback(reissue_authtkt)\n                request._authtkt_reissued = True\n\n        environ['REMOTE_USER_TOKENS'] = tokens\n        environ['REMOTE_USER_DATA'] = user_data\n        environ['AUTH_TYPE'] = 'cookie'\n\n        identity = {}\n        identity['timestamp'] = timestamp\n        identity['userid'] = userid\n        identity['tokens'] = tokens\n        identity['userdata'] = user_data\n        return identity\n\n    def forget(self, request):\n        \"\"\"Return a set of expires Set-Cookie headers, which will destroy\n        any existing auth_tkt cookie when attached to a response\"\"\"\n        request._authtkt_reissue_revoked = True\n        return self._get_cookies(request, None)\n\n    def remember(self, request, userid, max_age=None, tokens=()):\n        \"\"\"Return a set of Set-Cookie headers; when set into a response,\n        these headers will represent a valid authentication ticket.\n\n        ``max_age``\n          The max age of the auth_tkt cookie, in seconds.  When this value is\n          set, the cookie's ``Max-Age`` and ``Expires`` settings will be set,\n          allowing the auth_tkt cookie to last between browser sessions.  If\n          this value is ``None``, the ``max_age`` value provided to the\n          helper itself will be used as the ``max_age`` value.  Default:\n          ``None``.\n\n        ``tokens``\n          A sequence of strings that will be placed into the auth_tkt tokens\n          field.  Each string in the sequence must be of the Python ``str``\n          type and must match the regex ``^[A-Za-z][A-Za-z0-9+_-]*$``.\n          Tokens are available in the returned identity when an auth_tkt is\n          found in the request and unpacked.  Default: ``()``.\n        \"\"\"\n        max_age = self.max_age if max_age is None else int(max_age)\n\n        environ = request.environ\n\n        if self.include_ip:\n            remote_addr = environ['REMOTE_ADDR']\n        else:\n            remote_addr = '0.0.0.0'\n\n        user_data = ''\n\n        encoding_data = self.userid_type_encoders.get(type(userid))\n\n        if encoding_data:\n            encoding, encoder = encoding_data\n        else:\n            warnings.warn(\n                \"userid is of type {}, and is not supported by the \"\n                \"AuthTktAuthenticationPolicy. Explicitly converting to string \"\n                \"and storing as base64. Subsequent requests will receive a \"\n                \"string as the userid, it will not be decoded back to the \"\n                \"type provided.\".format(type(userid)),\n                RuntimeWarning,\n            )\n            encoding, encoder = self.userid_type_encoders.get(str)\n            userid = str(userid)\n\n        userid = encoder(userid)\n        user_data = 'userid_type:%s' % encoding\n\n        new_tokens = []\n        for token in tokens:\n            if isinstance(token, str):\n                try:\n                    token = ascii_(token)\n                except UnicodeEncodeError:\n                    raise ValueError(f\"Invalid token {token!r}\")\n            if not (isinstance(token, str) and VALID_TOKEN.match(token)):\n                raise ValueError(f\"Invalid token {token!r}\")\n            new_tokens.append(token)\n        tokens = tuple(new_tokens)\n\n        if hasattr(request, '_authtkt_reissued'):\n            request._authtkt_reissue_revoked = True\n\n        ticket = self.AuthTicket(\n            self.secret,\n            userid,\n            remote_addr,\n            tokens=tokens,\n            user_data=user_data,\n            cookie_name=self.cookie_name,\n            secure=self.secure,\n            hashalg=self.hashalg,\n        )\n\n        cookie_value = ticket.cookie_value()\n        return self._get_cookies(request, cookie_value, max_age)"
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "@implementer(IAuthenticationPolicy)\nclass SessionAuthenticationPolicy(CallbackAuthenticationPolicy):\n    \"\"\"A :app:`Pyramid` authentication policy which gets its data from the\n    configured :term:`session`.  For this authentication policy to work, you\n    will have to follow the instructions in the :ref:`sessions_chapter` to\n    configure a :term:`session factory`.\n\n    Constructor Arguments\n\n    ``prefix``\n\n       A prefix used when storing the authentication parameters in the\n       session. Defaults to 'auth.'. Optional.\n\n    ``callback``\n\n       Default: ``None``.  A callback passed the userid and the\n       request, expected to return ``None`` if the userid doesn't\n       exist or a sequence of principal identifiers (possibly empty) if\n       the user does exist.  If ``callback`` is ``None``, the userid\n       will be assumed to exist with no principals.  Optional.\n\n    ``debug``\n\n        Default: ``False``.  If ``debug`` is ``True``, log messages to the\n        Pyramid debug logger about the results of various authentication\n        steps.  The output from debugging is useful for reporting to maillist\n        or IRC channels when asking for support.\n\n    \"\"\"\n\n    def __init__(self, prefix='auth.', callback=None, debug=False):\n        self.callback = callback\n        self.debug = debug\n        self.helper = SessionAuthenticationHelper(prefix)\n\n    def remember(self, request, userid, **kw):\n        \"\"\"Store a userid in the session.\"\"\"\n        return self.helper.remember(request, userid, **kw)\n\n    def forget(self, request):\n        \"\"\"Remove the stored userid from the session.\"\"\"\n        return self.helper.forget(request)\n\n    def unauthenticated_userid(self, request):\n        return self.helper.authenticated_userid(request)"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "class SessionAuthenticationHelper:\n    \"\"\"A helper for use with a :term:`security policy` which stores user data\n    in the configured :term:`session`.\n\n    Constructor Arguments\n\n    ``prefix``\n\n       A prefix used when storing the authentication parameters in the\n       session. Defaults to 'auth.'. Optional.\n\n    \"\"\"\n\n    def __init__(self, prefix='auth.'):\n        self.userid_key = prefix + 'userid'\n\n    def remember(self, request, userid, **kw):\n        \"\"\"Store a userid in the session.\"\"\"\n        request.session[self.userid_key] = userid\n        return []\n\n    def forget(self, request, **kw):\n        \"\"\"Remove the stored userid from the session.\"\"\"\n        if self.userid_key in request.session:\n            del request.session[self.userid_key]\n        return []\n\n    def authenticated_userid(self, request):\n        \"\"\"Return the stored userid.\"\"\"\n        return request.session.get(self.userid_key)"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "@implementer(IAuthenticationPolicy)\nclass BasicAuthAuthenticationPolicy(CallbackAuthenticationPolicy):\n    \"\"\"A :app:`Pyramid` authentication policy which uses HTTP standard basic\n    authentication protocol to authenticate users.  To use this policy you will\n    need to provide a callback which checks the supplied user credentials\n    against your source of login data.\n\n    Constructor Arguments\n\n    ``check``\n\n       A callback function passed a username, password and request, in that\n       order as positional arguments.  Expected to return ``None`` if the\n       userid doesn't exist or a sequence of principal identifiers (possibly\n       empty) if the user does exist.\n\n    ``realm``\n\n       Default: ``\"Realm\"``.  The Basic Auth Realm string.  Usually displayed\n       to the user by the browser in the login dialog.\n\n    ``debug``\n\n        Default: ``False``.  If ``debug`` is ``True``, log messages to the\n        Pyramid debug logger about the results of various authentication\n        steps.  The output from debugging is useful for reporting to maillist\n        or IRC channels when asking for support.\n\n    **Issuing a challenge**\n\n    Regular browsers will not send username/password credentials unless they\n    first receive a challenge from the server.  The following recipe will\n    register a view that will send a Basic Auth challenge to the user whenever\n    there is an attempt to call a view which results in a Forbidden response::\n\n        from pyramid.httpexceptions import HTTPUnauthorized\n        from pyramid.security import forget\n        from pyramid.view import forbidden_view_config\n\n        @forbidden_view_config()\n        def forbidden_view(request):\n            if request.authenticated_userid is None:\n                response = HTTPUnauthorized()\n                response.headers.update(forget(request))\n                return response\n            return HTTPForbidden()\n    \"\"\"\n\n    def __init__(self, check, realm='Realm', debug=False):\n        self.check = check\n        self.realm = realm\n        self.debug = debug\n\n    def unauthenticated_userid(self, request):\n        \"\"\"The userid parsed from the ``Authorization`` request header.\"\"\"\n        credentials = extract_http_basic_credentials(request)\n        if credentials:\n            return credentials.username\n\n    def remember(self, request, userid, **kw):\n        \"\"\"A no-op. Basic authentication does not provide a protocol for\n        remembering the user. Credentials are sent on every request.\n\n        \"\"\"\n        return []\n\n    def forget(self, request):\n        \"\"\"Returns challenge headers. This should be attached to a response\n        to indicate that credentials are required.\"\"\"\n        return [('WWW-Authenticate', 'Basic realm=\"%s\"' % self.realm)]\n\n    def callback(self, username, request):\n        # Username arg is ignored. Unfortunately\n        # extract_http_basic_credentials winds up getting called twice when\n        # authenticated_userid is called. Avoiding that, however,\n        # winds up duplicating logic from the superclass.\n        credentials = extract_http_basic_credentials(request)\n        if credentials:\n            username, password = credentials\n            return self.check(username, password, request)"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "HTTPBasicCredentials = namedtuple(\n    'HTTPBasicCredentials', ['username', 'password']\n)"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authentication.py",
      "content": "def extract_http_basic_credentials(request):\n    \"\"\"A helper function for extraction of HTTP Basic credentials\n    from a given :term:`request`.\n\n    Returns a :class:`.HTTPBasicCredentials` 2-tuple with ``username`` and\n    ``password`` attributes or ``None`` if no credentials could be found.\n\n    \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return None\n\n    try:\n        authmeth, auth = authorization.split(' ', 1)\n    except ValueError:  # not enough values to unpack\n        return None\n\n    if authmeth.lower() != 'basic':\n        return None\n\n    try:\n        authbytes = b64decode(auth.strip())\n    except (TypeError, binascii.Error):  # can't decode\n        return None\n\n    # try utf-8 first, then latin-1; see discussion in\n    # https://github.com/Pylons/pyramid/issues/898\n    try:\n        auth = authbytes.decode('utf-8')\n    except UnicodeDecodeError:\n        auth = authbytes.decode('latin-1')\n\n    try:\n        username, password = auth.split(':', 1)\n    except ValueError:  # not enough values to unpack\n        return None\n\n    return HTTPBasicCredentials(username, password)\n```"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/pyramid/src/pyramid/tweens.py",
      "content": "import sys"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/pyramid/src/pyramid/tweens.py",
      "content": "from pyramid.httpexceptions import HTTPNotFound\nfrom pyramid.util import reraise"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/pyramid/src/pyramid/tweens.py",
      "content": "def _error_handler(request, exc):\n    # NOTE: we do not need to delete exc_info because this function\n    # should never be in the call stack of the exception\n    exc_info = sys.exc_info()\n\n    try:\n        response = request.invoke_exception_view(exc_info)\n    except HTTPNotFound:\n        # re-raise the original exception as no exception views were\n        # able to handle the error\n        reraise(*exc_info)\n\n    return response"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/pyramid/src/pyramid/tweens.py",
      "content": "def excview_tween_factory(handler, registry):\n    \"\"\"A :term:`tween` factory which produces a tween that catches an\n    exception raised by downstream tweens (or the main Pyramid request\n    handler) and, if possible, converts it into a Response using an\n    :term:`exception view`.\n\n    .. versionchanged:: 1.9\n       The ``request.response`` will be remain unchanged even if the tween\n       handles an exception. Previously it was deleted after handling an\n       exception.\n\n       Also, ``request.exception`` and ``request.exc_info`` are only set if\n       the tween handles an exception and returns a response otherwise they\n       are left at their original values.\n\n    \"\"\"\n\n    def excview_tween(request):\n        try:\n            response = handler(request)\n        except Exception as exc:\n            response = _error_handler(request, exc)\n        return response\n\n    return excview_tween"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/pyramid/src/pyramid/tweens.py",
      "content": "MAIN = 'MAIN'\nINGRESS = 'INGRESS'\nEXCVIEW = 'pyramid.tweens.excview_tween_factory'"
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/pyramid/src/pyramid/wsgi.py",
      "content": "from functools import wraps\n\nfrom pyramid.request import call_app_with_subpath_as_path_info"
    },
    {
      "chunk_id": 295,
      "source": "__internal__/data_repo/pyramid/src/pyramid/wsgi.py",
      "content": "def wsgiapp(wrapped):\n    \"\"\"Decorator to turn a WSGI application into a :app:`Pyramid`\n    :term:`view callable`.  This decorator differs from the\n    :func:`pyramid.wsgi.wsgiapp2` decorator inasmuch as fixups of\n    ``PATH_INFO`` and ``SCRIPT_NAME`` within the WSGI environment *are\n    not* performed before the application is invoked.\n\n    E.g., the following in a ``views.py`` module::\n\n      @wsgiapp\n      def hello_world(environ, start_response):\n          body = 'Hello world'\n          start_response('200 OK', [ ('Content-Type', 'text/plain'),\n                                     ('Content-Length', len(body)) ] )\n          return [body]\n\n    Allows the following call to\n    :meth:`pyramid.config.Configurator.add_view`::\n\n        from views import hello_world\n        config.add_view(hello_world, name='hello_world.txt')\n\n    The ``wsgiapp`` decorator will convert the result of the WSGI\n    application to a :term:`Response` and return it to\n    :app:`Pyramid` as if the WSGI app were a :app:`Pyramid`\n    view.\n\n    \"\"\"\n\n    if wrapped is None:\n        raise ValueError('wrapped can not be None')\n\n    def decorator(context, request):\n        return request.get_response(wrapped)\n\n    # Support case where wrapped is a callable object instance\n    if getattr(wrapped, '__name__', None):\n        return wraps(wrapped)(decorator)\n    return wraps(wrapped, ('__module__', '__doc__'))(decorator)"
    },
    {
      "chunk_id": 296,
      "source": "__internal__/data_repo/pyramid/src/pyramid/wsgi.py",
      "content": "def wsgiapp2(wrapped):\n    \"\"\"Decorator to turn a WSGI application into a :app:`Pyramid`\n    view callable.  This decorator differs from the\n    :func:`pyramid.wsgi.wsgiapp` decorator inasmuch as fixups of\n    ``PATH_INFO`` and ``SCRIPT_NAME`` within the WSGI environment\n    *are* performed before the application is invoked.\n\n    E.g. the following in a ``views.py`` module::\n\n      @wsgiapp2\n      def hello_world(environ, start_response):\n          body = 'Hello world'\n          start_response('200 OK', [ ('Content-Type', 'text/plain'),\n                                     ('Content-Length', len(body)) ] )\n          return [body]\n\n    Allows the following call to\n    :meth:`pyramid.config.Configurator.add_view`::\n\n        from views import hello_world\n        config.add_view(hello_world, name='hello_world.txt')\n\n    The ``wsgiapp2`` decorator will convert the result of the WSGI\n    application to a Response and return it to :app:`Pyramid` as if the WSGI\n    app were a :app:`Pyramid` view.  The ``SCRIPT_NAME`` and ``PATH_INFO``\n    values present in the WSGI environment are fixed up before the\n    application is invoked.  In particular, a new WSGI environment is\n    generated, and the :term:`subpath` of the request passed to ``wsgiapp2``\n    is used as the new request's ``PATH_INFO`` and everything preceding the\n    subpath is used as the ``SCRIPT_NAME``.  The new environment is passed to\n    the downstream WSGI application.\"\"\"\n\n    if wrapped is None:\n        raise ValueError('wrapped can not be None')\n\n    def decorator(context, request):\n        return call_app_with_subpath_as_path_info(request, wrapped)\n\n    # Support case where wrapped is a callable object instance\n    if getattr(wrapped, '__name__', None):\n        return wraps(wrapped)(decorator)\n    return wraps(wrapped, ('__module__', '__doc__'))(decorator)"
    },
    {
      "chunk_id": 297,
      "source": "__internal__/data_repo/pyramid/src/pyramid/paster.py",
      "content": "from pyramid.scripting import prepare\nfrom pyramid.scripts.common import get_config_loader"
    },
    {
      "chunk_id": 298,
      "source": "__internal__/data_repo/pyramid/src/pyramid/paster.py",
      "content": "def setup_logging(config_uri, global_conf=None):\n    \"\"\"\n    Set up Python logging with the filename specified via ``config_uri``\n    (a string in the form ``filename#sectionname``).\n\n    Extra defaults can optionally be specified as a dict in ``global_conf``.\n    \"\"\"\n    loader = get_config_loader(config_uri)\n    loader.setup_logging(global_conf)"
    },
    {
      "chunk_id": 299,
      "source": "__internal__/data_repo/pyramid/src/pyramid/paster.py",
      "content": "def get_app(config_uri, name=None, options=None):\n    \"\"\"Return the WSGI application named ``name`` in the PasteDeploy\n    config file specified by ``config_uri``.\n\n    ``options``, if passed, should be a dictionary used as variable assignments\n    like ``{'http_port': 8080}``.  This is useful if e.g. ``%(http_port)s`` is\n    used in the config file.\n\n    If the ``name`` is None, this will attempt to parse the name from\n    the ``config_uri`` string expecting the format ``inifile#name``.\n    If no name is found, the name will default to \"main\".\n\n    \"\"\"\n    loader = get_config_loader(config_uri)\n    return loader.get_wsgi_app(name, options)"
    },
    {
      "chunk_id": 300,
      "source": "__internal__/data_repo/pyramid/src/pyramid/paster.py",
      "content": "def get_appsettings(config_uri, name=None, options=None):\n    \"\"\"Return a dictionary representing the key/value pairs in an ``app``\n    section within the file represented by ``config_uri``.\n\n    ``options``, if passed, should be a dictionary used as variable assignments\n    like ``{'http_port': 8080}``.  This is useful if e.g. ``%(http_port)s`` is\n    used in the config file.\n\n    If the ``name`` is None, this will attempt to parse the name from\n    the ``config_uri`` string expecting the format ``inifile#name``.\n    If no name is found, the name will default to \"main\".\n\n    \"\"\"\n    loader = get_config_loader(config_uri)\n    return loader.get_wsgi_app_settings(name, options)"
    },
    {
      "chunk_id": 301,
      "source": "__internal__/data_repo/pyramid/src/pyramid/paster.py",
      "content": "def bootstrap(config_uri, request=None, options=None):\n    \"\"\"Load a WSGI application from the PasteDeploy config file specified\n    by ``config_uri``. The environment will be configured as if it is\n    currently serving ``request``, leaving a natural environment in place\n    to write scripts that can generate URLs and utilize renderers.\n\n    This function returns a dictionary with ``app``, ``root``, ``closer``,\n    ``request``, and ``registry`` keys.  ``app`` is the WSGI app loaded\n    (based on the ``config_uri``), ``root`` is the traversal root resource\n    of the Pyramid application, and ``closer`` is a parameterless callback\n    that may be called when your script is complete (it pops a threadlocal\n    stack).\n\n    .. note::\n\n       Most operations within :app:`Pyramid` expect to be invoked within the\n       context of a WSGI request, thus it's important when loading your\n       application to anchor it when executing scripts and other code that is\n       not normally invoked during active WSGI requests.\n\n    .. note::\n\n       For a complex config file containing multiple :app:`Pyramid`\n       applications, this function will setup the environment under the context\n       of the last-loaded :app:`Pyramid` application. You may load a specific\n       application yourself by using the lower-level functions\n       :meth:`pyramid.paster.get_app` and :meth:`pyramid.scripting.prepare` in\n       conjunction with :attr:`pyramid.config.global_registries`.\n\n    ``config_uri`` -- specifies the PasteDeploy config file to use for the\n    interactive shell. The format is ``inifile#name``. If the name is left\n    off, ``main`` will be assumed.\n\n    ``request`` -- specified to anchor the script to a given set of WSGI\n    parameters. For example, most people would want to specify the host,\n    scheme and port such that their script will generate URLs in relation\n    to those parameters. A request with default parameters is constructed\n    for you if none is provided. You can mutate the request's ``environ``\n    later to setup a specific host/port/scheme/etc.\n\n    ``options`` Is passed to get_app for use as variable assignments like\n    {'http_port': 8080} and then use %(http_port)s in the\n    config file.\n\n    This function may be used as a context manager to call the ``closer``\n    automatically:\n\n    .. code-block:: python\n\n       with bootstrap('development.ini') as env:\n           request = env['request']\n           # ...\n\n    See :ref:`writing_a_script` for more information about how to use this\n    function.\n\n    .. versionchanged:: 1.8\n\n       Added the ability to use the return value as a context manager.\n\n    .. versionchanged:: 2.0\n\n       Request finished callbacks added via\n       :meth:`pyramid.request.Request.add_finished_callback` will be invoked\n       by the ``closer``.\n\n    \"\"\"\n    options = dict(options or {})\n    options.setdefault('__script__', 'bootstrap')\n    app = get_app(config_uri, options=options)\n    env = prepare(request)\n    env['app'] = app\n    return env"
    },
    {
      "chunk_id": 302,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "from zope.deprecation import deprecated\nfrom zope.interface import implementer, providedBy\n\nfrom pyramid.interfaces import (\n    IAuthenticationPolicy,\n    IAuthorizationPolicy,\n    ISecuredView,\n    ISecurityPolicy,\n    IView,\n    IViewClassifier,\n)\nfrom pyramid.threadlocal import get_current_registry\n\nNO_PERMISSION_REQUIRED = '__no_permission_required__'"
    },
    {
      "chunk_id": 303,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "def _get_security_policy(request):\n    return request.registry.queryUtility(ISecurityPolicy)"
    },
    {
      "chunk_id": 304,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "def remember(request, userid, **kw):\n    \"\"\"\n    Returns a sequence of header tuples (e.g. ``[('Set-Cookie', 'foo=abc')]``)\n    on this request's response.\n    These headers are suitable for 'remembering' a set of credentials\n    implied by the data passed as ``userid`` and ``*kw`` using the\n    current :term:`security policy`.  Common usage might look\n    like so within the body of a view function (``response`` is\n    assumed to be a :term:`WebOb` -style :term:`response` object\n    computed previously by the view code):\n\n    .. code-block:: python\n\n       from pyramid.security import remember\n       headers = remember(request, 'chrism', password='123', max_age='86400')\n       response = request.response\n       response.headerlist.extend(headers)\n       return response\n\n    If no :term:`security policy` is in use, this function will\n    always return an empty sequence. If used, the composition and\n    meaning of ``**kw`` must be agreed upon by the calling code and\n    the effective security policy.\n\n    .. versionchanged:: 1.6\n        Deprecated the ``principal`` argument in favor of ``userid`` to clarify\n        its relationship to the security policy.\n\n    .. versionchanged:: 1.10\n        Removed the deprecated ``principal`` argument.\n    \"\"\"\n    policy = _get_security_policy(request)\n    if policy is None:\n        return []\n    return policy.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 305,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "def forget(request, **kw):\n    \"\"\"\n    Return a sequence of header tuples (e.g. ``[('Set-Cookie',\n    'foo=abc')]``) suitable for 'forgetting' the set of credentials\n    possessed by the currently authenticated user.  A common usage\n    might look like so within the body of a view function\n    (``response`` is assumed to be an :term:`WebOb` -style\n    :term:`response` object computed previously by the view code):\n\n    .. code-block:: python\n\n       from pyramid.security import forget\n       headers = forget(request)\n       response.headerlist.extend(headers)\n       return response\n\n    If no :term:`security policy` is in use, this function will\n    always return an empty sequence.\n    \"\"\"\n    policy = _get_security_policy(request)\n    if policy is None:\n        return []\n    return policy.forget(request, **kw)"
    },
    {
      "chunk_id": 306,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "def principals_allowed_by_permission(context, permission):\n    \"\"\"\n    .. deprecated:: 2.0\n\n        The new security policy has removed the concept of principals.  See\n        :ref:`upgrading_auth_20` for more information.\n\n    Provided a ``context`` (a resource object), and a ``permission``\n    string, if an :term:`authorization policy` is\n    in effect, return a sequence of :term:`principal` ids that possess\n    the permission in the ``context``.  If no authorization policy is\n    in effect, this will return a sequence with the single value\n    :mod:`pyramid.authorization.Everyone` (the special principal\n    identifier representing all principals).\n\n    .. note::\n\n       Even if an :term:`authorization policy` is in effect,\n       some (exotic) authorization policies may not implement the\n       required machinery for this function; those will cause a\n       :exc:`NotImplementedError` exception to be raised when this\n       function is invoked.\n\n    \"\"\"\n    reg = get_current_registry()\n    policy = reg.queryUtility(IAuthorizationPolicy)\n    if policy is None:\n        from pyramid.authorization import Everyone  # noqa: F811\n\n        return [Everyone]\n    return policy.principals_allowed_by_permission(context, permission)"
    },
    {
      "chunk_id": 307,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "deprecated(\n    'principals_allowed_by_permission',\n    'The new security policy has removed the concept of principals.  See '\n    '\"Upgrading Authentication/Authorization\" in \"What\\'s New in Pyramid 2.0\" '\n    'of the documentation for more information.',\n)"
    },
    {
      "chunk_id": 308,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "def view_execution_permitted(context, request, name=''):\n    \"\"\"If the view specified by ``context`` and ``name`` is protected\n    by a :term:`permission`, check the permission associated with the\n    view using the effective authentication/authorization policies and\n    the ``request``.  Return a boolean result.  If no\n    :term:`security policy` is in effect, or if the view is not\n    protected by a permission, return ``True``. If no view can view found,\n    an exception will be raised.\n\n    .. versionchanged:: 1.4a4\n       An exception is raised if no view is found.\n\n    \"\"\"\n    reg = request.registry\n    provides = [IViewClassifier] + [providedBy(x) for x in (request, context)]\n    # XXX not sure what to do here about using _find_views or analogue;\n    # for now let's just keep it as-is\n    view = reg.adapters.lookup(provides, ISecuredView, name=name)\n    if view is None:\n        view = reg.adapters.lookup(provides, IView, name=name)\n        if view is None:\n            raise TypeError(\n                'No registered view satisfies the constraints. '\n                'It would not make sense to claim that this view '\n                '\"is\" or \"is not\" permitted.'\n            )\n        return Allowed(\n            'Allowed: view name %r in context %r (no permission defined)'\n            % (name, context)\n        )\n    return view.__permitted__(context, request)"
    },
    {
      "chunk_id": 309,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class PermitsResult(int):\n    def __new__(cls, s, *args):\n        \"\"\"\n        Create a new instance.\n\n        :param fmt: A format string explaining the reason for denial.\n        :param args: Arguments are stored and used with the format string\n                      to generate the ``msg``.\n\n        \"\"\"\n        inst = int.__new__(cls, cls.boolval)\n        inst.s = s\n        inst.args = args\n        return inst\n\n    @property\n    def msg(self):\n        \"\"\"A string indicating why the result was generated.\"\"\"\n        return self.s % self.args\n\n    def __str__(self):\n        return self.msg\n\n    def __repr__(self):\n        return '<{} instance at {} with msg {!r}>'.format(\n            self.__class__.__name__,\n            id(self),\n            self.msg,\n        )"
    },
    {
      "chunk_id": 310,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class Denied(PermitsResult):\n    \"\"\"\n    An instance of ``Denied`` is returned when a security-related\n    API or other :app:`Pyramid` code denies an action unrelated to\n    an ACL check.  It evaluates equal to all boolean false types.  It\n    has an attribute named ``msg`` describing the circumstances for\n    the deny.\n\n    \"\"\"\n\n    boolval = 0"
    },
    {
      "chunk_id": 311,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class Allowed(PermitsResult):\n    \"\"\"\n    An instance of ``Allowed`` is returned when a security-related\n    API or other :app:`Pyramid` code allows an action unrelated to\n    an ACL check.  It evaluates equal to all boolean true types.  It\n    has an attribute named ``msg`` describing the circumstances for\n    the allow.\n\n    \"\"\"\n\n    boolval = 1"
    },
    {
      "chunk_id": 312,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class SecurityAPIMixin:\n    \"\"\"Mixin for Request class providing auth-related properties.\"\"\"\n\n    @property\n    def identity(self):\n        \"\"\"\n        Return an opaque object identifying the current user or ``None`` if no\n        user is authenticated or there is no :term:`security policy` in effect.\n\n        \"\"\"\n        policy = _get_security_policy(self)\n        if policy is None:\n            return None\n        return policy.identity(self)\n\n    @property\n    def authenticated_userid(self):\n        \"\"\"\n        Return the :term:`userid` of the currently authenticated user or\n        ``None`` if there is no :term:`security policy` in effect or there is\n        no currently authenticated user.\n\n        .. versionchanged:: 2.0\n\n           This property delegates to the effective :term:`security policy`,\n           ignoring old-style :term:`authentication policy`.\n\n        \"\"\"\n        policy = _get_security_policy(self)\n        if policy is None:\n            return None\n        return policy.authenticated_userid(self)\n\n    @property\n    def is_authenticated(self):\n        \"\"\"Return ``True`` if a user is authenticated for this request.\"\"\"\n        return self.authenticated_userid is not None\n\n    def has_permission(self, permission, context=None):\n        \"\"\"Given a permission and an optional context, returns an instance of\n        :data:`pyramid.security.Allowed` if the permission is granted to this\n        request with the provided context, or the context already associated\n        with the request.  Otherwise, returns an instance of\n        :data:`pyramid.security.Denied`.  This method delegates to the current\n        security policy.  Returns\n        :data:`pyramid.security.Allowed` unconditionally if no security\n        policy has been registered for this request.  If ``context`` is not\n        supplied or is supplied as ``None``, the context used is the\n        ``request.context`` attribute.\n\n        :param permission: Does this request have the given permission?\n        :type permission: str\n        :param context: A resource object or ``None``\n        :type context: object\n        :returns: Either :class:`pyramid.security.Allowed` or\n                  :class:`pyramid.security.Denied`.\n\n        \"\"\"\n        if context is None:\n            context = self.context\n        policy = _get_security_policy(self)\n        if policy is None:\n            return Allowed('No security policy in use.')\n        return policy.permits(self, context, permission)"
    },
    {
      "chunk_id": 313,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class AuthenticationAPIMixin:\n    \"\"\"Mixin for Request class providing compatibility properties.\"\"\"\n\n    @property\n    def unauthenticated_userid(self):\n        \"\"\"\n        .. deprecated:: 2.0\n\n            ``unauthenticated_userid`` does not have an equivalent in the new\n            security system. Use :attr:`.authenticated_userid` or\n            :attr:`.identity` instead. See :ref:`upgrading_auth_20` for more\n            information.\n\n        Return an object which represents the *claimed* (not verified) user\n        id of the credentials present in the request. ``None`` if there is no\n        :term:`authentication policy` in effect or there is no user data\n        associated with the current request.  This differs from\n        :attr:`~pyramid.request.Request.authenticated_userid`, because the\n        effective authentication policy will not ensure that a record\n        associated with the userid exists in persistent storage.\n\n        \"\"\"\n        security = _get_security_policy(self)\n        if security is None:\n            return None\n        if isinstance(security, LegacySecurityPolicy):\n            authn = security._get_authn_policy(self)\n            return authn.unauthenticated_userid(self)\n        return security.authenticated_userid(self)\n\n    unauthenticated_userid = deprecated(\n        unauthenticated_userid,\n        (\n            'The new security policy has deprecated unauthenticated_userid. '\n            'See \"Upgrading Authentication/Authorization\" in \"What\\'s New in '\n            'Pyramid 2.0\" of the documentation for more information.'\n        ),\n    )\n\n    @property\n    def effective_principals(self):\n        \"\"\"\n        .. deprecated:: 2.0\n\n            The new security policy has removed the concept of principals.  See\n            :ref:`upgrading_auth_20` for more information.\n\n        Return the list of 'effective' :term:`principal` identifiers\n        for the ``request``. If no :term:`authentication policy` is in effect,\n        this will return a one-element list containing the\n        :data:`pyramid.authorization.Everyone` principal.\n\n        \"\"\"\n        from pyramid.authorization import Everyone  # noqa: F811\n\n        security = _get_security_policy(self)\n        if security is not None and isinstance(security, LegacySecurityPolicy):\n            authn = security._get_authn_policy(self)\n            return authn.effective_principals(self)\n        return [Everyone]\n\n    effective_principals = deprecated(\n        effective_principals,\n        (\n            'The new security policy has deprecated effective_principals. '\n            'See \"Upgrading Authentication/Authorization\" in \"What\\'s New in '\n            'Pyramid 2.0\" of the documentation for more information.'\n        ),\n    )"
    },
    {
      "chunk_id": 314,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "@implementer(ISecurityPolicy)\nclass LegacySecurityPolicy:\n    \"\"\"\n    A :term:`security policy` which provides a backwards compatibility shim for\n    the :term:`authentication policy` and the :term:`authorization policy`.\n\n    \"\"\"\n\n    def _get_authn_policy(self, request):\n        return request.registry.getUtility(IAuthenticationPolicy)\n\n    def _get_authz_policy(self, request):\n        return request.registry.getUtility(IAuthorizationPolicy)\n\n    def identity(self, request):\n        return self.authenticated_userid(request)\n\n    def authenticated_userid(self, request):\n        authn = self._get_authn_policy(request)\n        return authn.authenticated_userid(request)\n\n    def remember(self, request, userid, **kw):\n        authn = self._get_authn_policy(request)\n        return authn.remember(request, userid, **kw)\n\n    def forget(self, request, **kw):\n        if kw:\n            raise ValueError(\n                'Legacy authentication policies do not support keyword '\n                'arguments for `forget`'\n            )\n        authn = self._get_authn_policy(request)\n        return authn.forget(request)\n\n    def permits(self, request, context, permission):\n        authn = self._get_authn_policy(request)\n        authz = self._get_authz_policy(request)\n        principals = authn.effective_principals(request)\n        return authz.permits(context, principals, permission)"
    },
    {
      "chunk_id": 315,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "Everyone = 'system.Everyone'\nAuthenticated = 'system.Authenticated'\nAllow = 'Allow'\nDeny = 'Deny'"
    },
    {
      "chunk_id": 316,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class AllPermissionsList:\n    \"\"\"Stand in 'permission list' to represent all permissions\"\"\"\n\n    def __iter__(self):\n        return iter(())\n\n    def __contains__(self, other):\n        return True\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__)"
    },
    {
      "chunk_id": 317,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "ALL_PERMISSIONS = AllPermissionsList()\nDENY_ALL = (Deny, Everyone, ALL_PERMISSIONS)"
    },
    {
      "chunk_id": 318,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class ACLPermitsResult(PermitsResult):\n    def __new__(cls, ace, acl, permission, principals, context):\n        \"\"\"\n        Create a new instance.\n\n        :param ace: The :term:`ACE` that matched, triggering the result.\n        :param acl: The :term:`ACL` containing ``ace``.\n        :param permission: The required :term:`permission`.\n        :param principals: The list of :term:`principals <principal>` provided.\n        :param context: The :term:`context` providing the :term:`lineage`\n                        searched.\n\n        \"\"\"\n        fmt = (\n            '%s permission %r via ACE %r in ACL %r on context %r for '\n            'principals %r'\n        )\n        inst = PermitsResult.__new__(\n            cls, fmt, cls.__name__, permission, ace, acl, context, principals\n        )\n        inst.permission = permission\n        inst.ace = ace\n        inst.acl = acl\n        inst.principals = principals\n        inst.context = context\n        return inst"
    },
    {
      "chunk_id": 319,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class ACLDenied(ACLPermitsResult, Denied):\n    \"\"\"\n    An instance of ``ACLDenied`` is a specialization of\n    :class:`pyramid.security.Denied` that represents that a security check\n    made explicitly against ACL was denied.  It evaluates equal to all\n    boolean false types.  It also has the following attributes: ``acl``,\n    ``ace``, ``permission``, ``principals``, and ``context``.  These\n    attributes indicate the security values involved in the request.  Its\n    ``__str__`` method prints a summary of these attributes for debugging\n    purposes. The same summary is available as the ``msg`` attribute.\n\n    \"\"\""
    },
    {
      "chunk_id": 320,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "class ACLAllowed(ACLPermitsResult, Allowed):\n    \"\"\"\n    An instance of ``ACLAllowed`` is a specialization of\n    :class:`pyramid.security.Allowed` that represents that a security check\n    made explicitly against ACL was allowed.  It evaluates equal to all\n    boolean true types.  It also has the following attributes: ``acl``,\n    ``ace``, ``permission``, ``principals``, and ``context``.  These\n    attributes indicate the security values involved in the request.  Its\n    ``__str__`` method prints a summary of these attributes for debugging\n    purposes. The same summary is available as the ``msg`` attribute.\n\n    \"\"\""
    },
    {
      "chunk_id": 321,
      "source": "__internal__/data_repo/pyramid/src/pyramid/security.py",
      "content": "for attr in (\n    'ALL_PERMISSIONS',\n    'DENY_ALL',\n    'ACLAllowed',\n    'ACLDenied',\n    'AllPermissionsList',\n    'Allow',\n    'Authenticated',\n    'Deny',\n    'Everyone',\n):\n    deprecated(\n        attr,\n        '\"pyramid.security.{attr}\" is deprecated in Pyramid 2.0. Adjust your '\n        'import to \"pyramid.authorization.{attr}\"'.format(attr=attr),\n    )"
    },
    {
      "chunk_id": 322,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "from contextlib import contextmanager\nimport copy\nimport os\nfrom webob.acceptparse import create_accept_header\nfrom zope.interface import alsoProvides, implementer\n\nfrom pyramid.config import Configurator\nfrom pyramid.decorator import reify\nfrom pyramid.i18n import LocalizerRequestMixin\nfrom pyramid.interfaces import IRequest, ISession\nfrom pyramid.path import caller_package\nfrom pyramid.registry import Registry\nfrom pyramid.request import CallbackMethodsMixin\nfrom pyramid.response import _get_response_factory\nfrom pyramid.security import AuthenticationAPIMixin, SecurityAPIMixin\nfrom pyramid.threadlocal import get_current_registry, manager\nfrom pyramid.url import URLMethodsMixin\nfrom pyramid.util import PYPY, InstancePropertyMixin\nfrom pyramid.view import ViewMethodsMixin\n\n_marker = object()"
    },
    {
      "chunk_id": 323,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class DummyRootFactory:\n    __parent__ = None\n    __name__ = None\n\n    def __init__(self, request):\n        if 'bfg.routes.matchdict' in request:\n            self.__dict__.update(request['bfg.routes.matchdict'])"
    },
    {
      "chunk_id": 324,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class DummySecurityPolicy:\n    \"\"\"A standin for a :term:`security policy`.\"\"\"\n\n    def __init__(\n        self,\n        userid=None,\n        identity=None,\n        permissive=True,\n        remember_result=None,\n        forget_result=None,\n    ):\n        self.userid = userid\n        self._identity = identity\n        self.permissive = permissive\n        if remember_result is None:\n            remember_result = []\n        if forget_result is None:\n            forget_result = []\n        self.remember_result = remember_result\n        self.forget_result = forget_result\n\n    def identity(self, request):\n        return self._identity\n\n    def authenticated_userid(self, request):\n        return self.userid\n\n    def permits(self, request, context, permission):\n        return self.permissive\n\n    def remember(self, request, userid, **kw):\n        self.remembered = userid\n        return self.remember_result\n\n    def forget(self, request, **kw):\n        self.forgotten = True\n        return self.forget_result"
    },
    {
      "chunk_id": 325,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class DummyTemplateRenderer:\n    \"\"\"\n    An instance of this class is returned from\n    :meth:`pyramid.config.Configurator.testing_add_renderer`.  It has a\n    helper function (``assert_``) that makes it possible to make an\n    assertion which compares data passed to the renderer by the view\n    function against expected key/value pairs.\n    \"\"\"\n\n    def __init__(self, string_response=''):\n        self._received = {}\n        self._string_response = string_response\n        self._implementation = MockTemplate(string_response)\n\n    # For in-the-wild test code that doesn't create its own renderer,\n    # but mutates our internals instead.  When all you read is the\n    # source code, *everything* is an API!\n    def _get_string_response(self):\n        return self._string_response\n\n    def _set_string_response(self, response):\n        self._string_response = response\n        self._implementation.response = response\n\n    string_response = property(_get_string_response, _set_string_response)\n\n    def implementation(self):\n        return self._implementation\n\n    def __call__(self, kw, system=None):\n        if system:\n            self._received.update(system)\n        self._received.update(kw)\n        return self.string_response\n\n    def __getattr__(self, k):\n        \"\"\"Backwards compatibility\"\"\"\n        val = self._received.get(k, _marker)\n        if val is _marker:\n            val = self._implementation._received.get(k, _marker)\n            if val is _marker:\n                raise AttributeError(k)\n        return val\n\n    def assert_(self, **kw):\n        \"\"\"Accept an arbitrary set of assertion key/value pairs.  For\n        each assertion key/value pair assert that the renderer\n        (eg. :func:`pyramid.renderers.render_to_response`)\n        received the key with a value that equals the asserted\n        value. If the renderer did not receive the key at all, or the\n        value received by the renderer doesn't match the assertion\n        value, raise an :exc:`AssertionError`.\"\"\"\n        for k, v in kw.items():\n            myval = self._received.get(k, _marker)\n            if myval is _marker:\n                myval = self._implementation._received.get(k, _marker)\n                if myval is _marker:\n                    raise AssertionError(\n                        'A value for key \"%s\" was not passed to the renderer'\n                        % k\n                    )\n\n            if myval != v:\n                raise AssertionError(\n                    '\\nasserted value for %s: %r\\nactual value: %r'\n                    % (k, v, myval)\n                )\n        return True"
    },
    {
      "chunk_id": 326,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class DummyResource:\n    \"\"\"A dummy :app:`Pyramid` :term:`resource` object.\"\"\"\n\n    def __init__(\n        self, __name__=None, __parent__=None, __provides__=None, **kw\n    ):\n        \"\"\"The resource's ``__name__`` attribute will be set to the\n        value of the ``__name__`` argument, and the resource's\n        ``__parent__`` attribute will be set to the value of the\n        ``__parent__`` argument.  If ``__provides__`` is specified, it\n        should be an interface object or tuple of interface objects\n        that will be attached to the resulting resource via\n        :func:`zope.interface.alsoProvides`. Any extra keywords passed\n        in the ``kw`` argument will be set as direct attributes of\n        the resource object.\n\n        .. note:: For backwards compatibility purposes, this class can also\n                  be imported as :class:`pyramid.testing.DummyModel`.\n\n        \"\"\"\n        self.__name__ = __name__\n        self.__parent__ = __parent__\n        if __provides__ is not None:\n            alsoProvides(self, __provides__)\n        self.kw = kw\n        self.__dict__.update(**kw)\n        self.subs = {}\n\n    def __setitem__(self, name, val):\n        \"\"\"When the ``__setitem__`` method is called, the object\n        passed in as ``val`` will be decorated with a ``__parent__``\n        attribute pointing at the dummy resource and a ``__name__``\n        attribute that is the value of ``name``.  The value will then\n        be returned when dummy resource's ``__getitem__`` is called with\n        the name ``name```.\"\"\"\n        val.__name__ = name\n        val.__parent__ = self\n        self.subs[name] = val\n\n    def __getitem__(self, name):\n        \"\"\"Return a named subobject (see ``__setitem__``)\"\"\"\n        ob = self.subs[name]\n        return ob\n\n    def __delitem__(self, name):\n        del self.subs[name]\n\n    def get(self, name, default=None):\n        return self.subs.get(name, default)\n\n    def values(self):\n        \"\"\"Return the values set by __setitem__\"\"\"\n        return self.subs.values()\n\n    def items(self):\n        \"\"\"Return the items set by __setitem__\"\"\"\n        return self.subs.items()\n\n    def keys(self):\n        \"\"\"Return the keys set by __setitem__\"\"\"\n        return self.subs.keys()\n\n    __iter__ = keys\n\n    def __bool__(self):\n        return True\n\n    def __len__(self):\n        return len(self.subs)\n\n    def __contains__(self, name):\n        return name in self.subs\n\n    def clone(self, __name__=_marker, __parent__=_marker, **kw):\n        \"\"\"Create a clone of the resource object.  If ``__name__`` or\n        ``__parent__`` arguments are passed, use these values to\n        override the existing ``__name__`` or ``__parent__`` of the\n        resource.  If any extra keyword args are passed in via the ``kw``\n        argument, use these keywords to add to or override existing\n        resource keywords (attributes).\"\"\"\n        oldkw = self.kw.copy()\n        oldkw.update(kw)\n        inst = self.__class__(self.__name__, self.__parent__, **oldkw)\n        inst.subs = copy.deepcopy(self.subs)\n        if __name__ is not _marker:\n            inst.__name__ = __name__\n        if __parent__ is not _marker:\n            inst.__parent__ = __parent__\n        return inst"
    },
    {
      "chunk_id": 327,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "DummyModel = DummyResource  # b/w compat (forever)"
    },
    {
      "chunk_id": 328,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "@implementer(ISession)\nclass DummySession(dict):\n    created = None\n    new = True\n\n    def changed(self):\n        pass\n\n    def invalidate(self):\n        self.clear()\n\n    def flash(self, msg, queue='', allow_duplicate=True):\n        storage = self.setdefault('_f_' + queue, [])\n        if allow_duplicate or (msg not in storage):\n            storage.append(msg)\n\n    def pop_flash(self, queue=''):\n        storage = self.pop('_f_' + queue, [])\n        return storage\n\n    def peek_flash(self, queue=''):\n        storage = self.get('_f_' + queue, [])\n        return storage\n\n    def new_csrf_token(self):\n        token = '0123456789012345678901234567890123456789'\n        self['_csrft_'] = token\n        return token\n\n    def get_csrf_token(self):\n        token = self.get('_csrft_', None)\n        if token is None:\n            token = self.new_csrf_token()\n        return token"
    },
    {
      "chunk_id": 329,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "@implementer(IRequest)\nclass DummyRequest(\n    URLMethodsMixin,\n    CallbackMethodsMixin,\n    InstancePropertyMixin,\n    LocalizerRequestMixin,\n    SecurityAPIMixin,\n    AuthenticationAPIMixin,\n    ViewMethodsMixin,\n):\n    \"\"\"A DummyRequest object (incompletely) imitates a :term:`request` object.\n\n    The ``params``, ``environ``, ``headers``, ``path``, and\n    ``cookies`` arguments correspond to their :term:`WebOb`\n    equivalents.\n\n    The ``post`` argument,  if passed, populates the request's\n    ``POST`` attribute, but *not* ``params``, in order to allow testing\n    that the app accepts data for a given view only from POST requests.\n    This argument also sets ``self.method`` to \"POST\".\n\n    Extra keyword arguments are assigned as attributes of the request\n    itself.\n\n    Note that DummyRequest does not have complete fidelity with a \"real\"\n    request.  For example, by default, the DummyRequest ``GET`` and ``POST``\n    attributes are of type ``dict``, unlike a normal Request's GET and POST,\n    which are of type ``MultiDict``. If your code uses the features of\n    MultiDict, you should either use a real :class:`pyramid.request.Request`\n    or adapt your DummyRequest by replacing the attributes with ``MultiDict``\n    instances.\n\n    Other similar incompatibilities exist.  If you need all the features of\n    a Request, use the :class:`pyramid.request.Request` class itself\n    rather than this class while writing tests.\n    \"\"\"\n\n    method = 'GET'\n    application_url = 'http://example.com'\n    host = 'example.com:80'\n    domain = 'example.com'\n    content_length = 0\n    query_string = ''\n    charset = 'UTF-8'\n    script_name = ''\n    _registry = None\n    _accept = None\n    request_iface = IRequest\n\n    def __init__(\n        self,\n        params=None,\n        environ=None,\n        headers=None,\n        path='/',\n        cookies=None,\n        post=None,\n        accept=None,\n        **kw,\n    ):\n        if environ is None:\n            environ = {}\n        if params is None:\n            params = {}\n        if headers is None:\n            headers = {}\n        if cookies is None:\n            cookies = {}\n        self.environ = environ\n        self.headers = headers\n        self.params = params\n        self.cookies = cookies\n        self.matchdict = {}\n        self.GET = params\n        if post is not None:\n            self.method = 'POST'\n            self.POST = post\n        else:\n            self.POST = params\n        self.host_url = self.application_url\n        self.path_url = self.application_url\n        self.url = self.application_url\n        self.path = path\n        self.path_info = path\n        self.script_name = ''\n        self.path_qs = ''\n        self.body = ''\n        self.view_name = ''\n        self.subpath = ()\n        self.traversed = ()\n        self.virtual_root_path = ()\n        self.context = None\n        self.root = None\n        self.virtual_root = None\n        self.marshalled = params  # repoze.monty\n        self.session = DummySession()\n        self.accept = accept\n        self.__dict__.update(kw)\n\n    def _get_registry(self):\n        if self._registry is None:\n            return get_current_registry()\n        return self._registry\n\n    def _set_registry(self, registry):\n        self._registry = registry\n\n    def _del_registry(self):\n        self._registry = None\n\n    registry = property(_get_registry, _set_registry, _del_registry)\n\n    def _set_accept(self, value):\n        self._accept = create_accept_header(value)\n\n    def _get_accept(self):\n        if self._accept is None:\n            self._accept = create_accept_header(None)\n        return self._accept\n\n    def _del_accept(self):\n        self._accept = None\n\n    accept = property(_get_accept, _set_accept, _del_accept)\n\n    @reify\n    def response(self):\n        f = _get_response_factory(self.registry)\n        return f(self)"
    },
    {
      "chunk_id": 330,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "have_zca = True"
    },
    {
      "chunk_id": 331,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "def setUp(\n    registry=None,\n    request=None,\n    hook_zca=True,\n    autocommit=True,\n    settings=None,\n    package=None,\n):\n    \"\"\"\n    Set :app:`Pyramid` registry and request thread locals for the\n    duration of a single unit test.\n\n    Use this function in the ``setUp`` method of a unittest test case\n    which directly or indirectly uses:\n\n    - any method of the :class:`pyramid.config.Configurator`\n      object returned by this function.\n\n    - the :func:`pyramid.threadlocal.get_current_registry` or\n      :func:`pyramid.threadlocal.get_current_request` functions.\n\n    If you use the ``get_current_*`` functions (or call :app:`Pyramid` code\n    that uses these functions) without calling ``setUp``,\n    :func:`pyramid.threadlocal.get_current_registry` will return a *global*\n    :term:`application registry`, which may cause unit tests to not be\n    isolated with respect to registrations they perform.\n\n    If the ``registry`` argument is ``None``, a new empty\n    :term:`application registry` will be created (an instance of the\n    :class:`pyramid.registry.Registry` class).  If the ``registry``\n    argument is not ``None``, the value passed in should be an\n    instance of the :class:`pyramid.registry.Registry` class or a\n    suitable testing analogue.\n\n    After ``setUp`` is finished, the registry returned by the\n    :func:`pyramid.threadlocal.get_current_registry` function will\n    be the passed (or constructed) registry until\n    :func:`pyramid.testing.tearDown` is called (or\n    :func:`pyramid.testing.setUp` is called again) .\n\n    If the ``hook_zca`` argument is ``True``, ``setUp`` will attempt\n    to perform the operation ``zope.component.getSiteManager.sethook(\n    pyramid.threadlocal.get_current_registry)``, which will cause\n    the :term:`Zope Component Architecture` global API\n    (e.g. :func:`zope.component.getSiteManager`,\n    :func:`zope.component.getAdapter`, and so on) to use the registry\n    constructed by ``setUp`` as the value it returns from\n    :func:`zope.component.getSiteManager`.  If the\n    :mod:`zope.component` package cannot be imported, or if\n    ``hook_zca`` is ``False``, the hook will not be set.\n\n    If ``settings`` is not ``None``, it must be a dictionary representing the\n    values passed to a Configurator as its ``settings=`` argument.\n\n    If ``package`` is ``None`` it will be set to the caller's package. The\n    ``package`` setting in the :class:`pyramid.config.Configurator` will\n    affect any relative imports made via\n    :meth:`pyramid.config.Configurator.include` or\n    :meth:`pyramid.config.Configurator.maybe_dotted`.\n\n    This function returns an instance of the\n    :class:`pyramid.config.Configurator` class, which can be\n    used for further configuration to set up an environment suitable\n    for a unit or integration test.  The ``registry`` attribute\n    attached to the Configurator instance represents the 'current'\n    :term:`application registry`; the same registry will be returned\n    by :func:`pyramid.threadlocal.get_current_registry` during the\n    execution of the test.\n    \"\"\"\n    manager.clear()\n    if registry is None:\n        registry = Registry('testing')\n    if package is None:\n        package = caller_package()\n    config = Configurator(\n        registry=registry, autocommit=autocommit, package=package\n    )\n    if settings is None:\n        settings = {}\n    config._fix_registry()\n    if getattr(registry, 'settings', None) is None:\n        config._set_settings(settings)\n    if hasattr(registry, 'registerUtility'):\n        # Sometimes nose calls us with a non-registry object because\n        # it thinks this function is module test setup.  Likewise,\n        # someone may be passing us an esoteric \"dummy\" registry, and\n        # the below won't succeed if it doesn't have a registerUtility\n        # method.\n        config.add_default_response_adapters()\n        config.add_default_renderers()\n        config.add_default_accept_view_order()\n        config.add_default_view_predicates()\n        config.add_default_view_derivers()\n        config.add_default_route_predicates()\n        config.add_default_tweens()\n        config.add_default_security()\n    config.commit()\n    global have_zca\n    try:\n        have_zca and hook_zca and config.hook_zca()\n    except ImportError:  # pragma: no cover\n        # (dont choke on not being able to import z.component)\n        have_zca = False\n    config.begin(request=request)\n    return config"
    },
    {
      "chunk_id": 332,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "def tearDown(unhook_zca=True):\n    \"\"\"Undo the effects of :func:`pyramid.testing.setUp`.  Use this\n    function in the ``tearDown`` method of a unit test that uses\n    :func:`pyramid.testing.setUp` in its ``setUp`` method.\n\n    If the ``unhook_zca`` argument is ``True`` (the default), call\n    :func:`zope.component.getSiteManager.reset`.  This undoes the\n    action of :func:`pyramid.testing.setUp` when called with the\n    argument ``hook_zca=True``.  If :mod:`zope.component` cannot be\n    imported, ``unhook_zca`` is set to ``False``.\n    \"\"\"\n    global have_zca\n    if unhook_zca and have_zca:\n        try:\n            from zope.component import getSiteManager\n\n            getSiteManager.reset()\n        except ImportError:  # pragma: no cover\n            have_zca = False\n    info = manager.pop()\n    manager.clear()\n    if info is not None:\n        registry = info['registry']\n        if hasattr(registry, '__init__') and hasattr(registry, '__name__'):\n            try:\n                registry.__init__(registry.__name__)\n            except TypeError:\n                # calling __init__ is largely for the benefit of\n                # people who want to use the global ZCA registry;\n                # however maybe somebody's using a registry we don't\n                # understand, let's not blow up\n                pass"
    },
    {
      "chunk_id": 333,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "def cleanUp(*arg, **kw):\n    \"\"\"An alias for :func:`pyramid.testing.setUp`.\"\"\"\n    package = kw.get('package', None)\n    if package is None:\n        package = caller_package()\n        kw['package'] = package\n    return setUp(*arg, **kw)"
    },
    {
      "chunk_id": 334,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class DummyRendererFactory:\n    \"\"\"Registered by\n    :meth:`pyramid.config.Configurator.testing_add_renderer` as\n    a dummy renderer factory.  The indecision about what to use as a\n    key (a spec vs. a relative name) is caused by test suites in the\n    wild believing they can register either.  The ``factory`` argument\n    passed to this constructor is usually the *real* template renderer\n    factory, found when ``testing_add_renderer`` is called.\"\"\"\n\n    def __init__(self, name, factory):\n        self.name = name\n        self.factory = factory  # the \"real\" renderer factory reg'd previously\n        self.renderers = {}\n\n    def add(self, spec, renderer):\n        self.renderers[spec] = renderer\n        if ':' in spec:\n            package, relative = spec.split(':', 1)\n            self.renderers[relative] = renderer\n\n    def __call__(self, info):\n        spec = info.name\n        renderer = self.renderers.get(spec)\n        if renderer is None:\n            if ':' in spec:\n                package, relative = spec.split(':', 1)\n                renderer = self.renderers.get(relative)\n            if renderer is None:\n                if self.factory:\n                    renderer = self.factory(info)\n                else:\n                    raise KeyError(\n                        'No testing renderer registered for %r' % spec\n                    )\n        return renderer"
    },
    {
      "chunk_id": 335,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "class MockTemplate:\n    def __init__(self, response):\n        self._received = {}\n        self.response = response\n\n    def __getattr__(self, attrname):\n        return self\n\n    def __getitem__(self, attrname):\n        return self\n\n    def __call__(self, *arg, **kw):\n        self._received.update(kw)\n        return self.response"
    },
    {
      "chunk_id": 336,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "def skip_on(*platforms):  # pragma: no  cover\n    skip = False\n    for platform in platforms:\n        if skip_on.os_name.startswith(platform):\n            skip = True\n        if platform == 'pypy' and PYPY:\n            skip = True\n\n    def decorator(func):\n        if isinstance(func, type):\n            if skip:\n                return None\n            else:\n                return func\n        else:\n\n            def wrapper(*args, **kw):\n                if skip:\n                    return\n                return func(*args, **kw)\n\n            wrapper.__name__ = func.__name__\n            wrapper.__doc__ = func.__doc__\n            return wrapper\n\n    return decorator"
    },
    {
      "chunk_id": 337,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "skip_on.os_name = os.name  # for testing"
    },
    {
      "chunk_id": 338,
      "source": "__internal__/data_repo/pyramid/src/pyramid/testing.py",
      "content": "@contextmanager\ndef testConfig(\n    registry=None, request=None, hook_zca=True, autocommit=True, settings=None\n):\n    \"\"\"Returns a context manager for test set up.\n\n    This context manager calls :func:`pyramid.testing.setUp` when\n    entering and :func:`pyramid.testing.tearDown` when exiting.\n\n    All arguments are passed directly to :func:`pyramid.testing.setUp`.\n    If the ZCA is hooked, it will always be un-hooked in tearDown.\n\n    This context manager allows you to write test code like this:\n\n    .. code-block:: python\n        :linenos:\n\n        with testConfig() as config:\n            config.add_route('bar', '/bar/{id}')\n            req = DummyRequest()\n            resp = myview(req)\n    \"\"\"\n    config = setUp(\n        registry=registry,\n        request=request,\n        hook_zca=hook_zca,\n        autocommit=autocommit,\n        settings=settings,\n    )\n    try:\n        yield config\n    finally:\n        tearDown(unhook_zca=hook_zca)"
    },
    {
      "chunk_id": 339,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "from contextlib import contextmanager\nimport functools\nfrom hmac import compare_digest\nimport inspect\nimport platform\nimport weakref\n\nfrom pyramid.path import DottedNameResolver as _DottedNameResolver\n\n_marker = object()\n\nWIN = platform.system() == 'Windows'\n\ntry:  # pragma: no cover\n    import __pypy__\n\n    PYPY = True\nexcept BaseException:  # pragma: no cover\n    __pypy__ = None\n    PYPY = False"
    },
    {
      "chunk_id": 340,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class DottedNameResolver(_DottedNameResolver):\n    def __init__(self, package=None):  # default to package = None for bw compat\n        _DottedNameResolver.__init__(self, package)"
    },
    {
      "chunk_id": 341,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def text_(s, encoding='latin-1', errors='strict'):\n    \"\"\"If ``s`` is an instance of ``bytes``, return\n    ``s.decode(encoding, errors)``, otherwise return ``s``\"\"\"\n    if isinstance(s, bytes):\n        return s.decode(encoding, errors)\n    return s"
    },
    {
      "chunk_id": 342,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def bytes_(s, encoding='latin-1', errors='strict'):\n    \"\"\"If ``s`` is an instance of ``str``, return\n    ``s.encode(encoding, errors)``, otherwise return ``s``\"\"\"\n    if isinstance(s, str):\n        return s.encode(encoding, errors)\n    return s"
    },
    {
      "chunk_id": 343,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def ascii_(s):\n    \"\"\"\n    If ``s`` is an instance of ``str``, return\n    ``s.encode('ascii')``, otherwise return ``str(s, 'ascii', 'strict')``\n    \"\"\"\n    if isinstance(s, str):\n        s = s.encode('ascii')\n    return str(s, 'ascii', 'strict')"
    },
    {
      "chunk_id": 344,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def is_nonstr_iter(v):\n    if isinstance(v, str):\n        return False\n    return hasattr(v, '__iter__')"
    },
    {
      "chunk_id": 345,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def is_string_or_iterable(v):\n    if isinstance(v, str):\n        return True\n    if hasattr(v, '__iter__'):\n        return True"
    },
    {
      "chunk_id": 346,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def as_sorted_tuple(val):\n    if not is_nonstr_iter(val):\n        val = (val,)\n    val = tuple(sorted(val))\n    return val"
    },
    {
      "chunk_id": 347,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class SettableProperty:\n    # this is just like reify but does not store the computed result on\n    # the class such that subsequent invocations invoke the callable again\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        functools.update_wrapper(self, wrapped)\n\n    def __get__(self, obj, type=None):\n        if obj is None:  # pragma: no cover\n            return self\n        return self.wrapped(obj)"
    },
    {
      "chunk_id": 348,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class InstancePropertyHelper:\n    \"\"\"A helper object for assigning properties and descriptors to instances.\n    It is not normally possible to do this because descriptors must be\n    defined on the class itself.\n\n    This class is optimized for adding multiple properties at once to an\n    instance. This is done by calling :meth:`.add_property` once\n    per-property and then invoking :meth:`.apply` on target objects.\n    \"\"\"\n\n    def __init__(self):\n        self.properties = {}\n\n    @classmethod\n    def make_property(cls, callable, name=None, reify=False):\n        \"\"\"Convert a callable into one suitable for adding to the\n        instance. This will return a 2-tuple containing the computed\n        (name, property) pair.\n        \"\"\"\n        if name is None:\n            if not hasattr(callable, '__name__'):\n                raise ValueError(\n                    'missing __name__, must specify \"name\" for property'\n                )\n            name = callable.__name__\n        name = get_callable_name(name)\n        is_data_descriptor = inspect.isdatadescriptor(callable)\n        if reify and is_data_descriptor:\n            raise ValueError('cannot reify a data descriptor')\n        if is_data_descriptor:\n            fn = callable\n        else:\n            wrapped = lambda this: callable(this)\n            wrapped.__name__ = name\n            wrapped.__doc__ = callable.__doc__\n\n            if reify:\n                import pyramid.decorator  # avoid circular import\n\n                fn = pyramid.decorator.reify(wrapped)\n            else:\n                fn = SettableProperty(wrapped)\n\n        return name, fn"
    },
    {
      "chunk_id": 349,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "@classmethod\n    def apply_properties(cls, target, properties):\n        \"\"\"Accept a list or dict of ``properties`` generated from\n        :meth:`.make_property` and apply them to a ``target`` object.\n        \"\"\"\n        attrs = dict(properties)\n        if attrs:\n            parent = target.__class__\n            # fix the module name so it appears to still be the parent\n            # e.g. pyramid.request instead of pyramid.util\n            attrs.setdefault('__module__', parent.__module__)\n            newcls = type(parent.__name__, (parent, object), attrs)\n            # We assign __provides__ and __implemented__ below to prevent a\n            # memory leak that results from from the usage of this instance's\n            # eventual use in an adapter lookup.  Adapter lookup results in\n            # ``zope.interface.implementedBy`` being called with the\n            # newly-created class as an argument.  Because the newly-created\n            # class has no interface specification data of its own, lookup\n            # causes new ClassProvides and Implements instances related to our\n            # just-generated class to be created and set into the newly-created\n            # class' __dict__.  We don't want these instances to be created; we\n            # want this new class to behave exactly like it is the parent class\n            # instead.  See GitHub issues #1212, #1529 and #1568 for more\n            # information.\n            for name in ('__implemented__', '__provides__'):\n                # we assign these attributes conditionally to make it possible\n                # to test this class in isolation without having any interfaces\n                # attached to it\n                val = getattr(parent, name, _marker)\n                if val is not _marker:\n                    setattr(newcls, name, val)\n            target.__class__ = newcls"
    },
    {
      "chunk_id": 350,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "@classmethod\n    def set_property(cls, target, callable, name=None, reify=False):\n        \"\"\"A helper method to apply a single property to an instance.\"\"\"\n        prop = cls.make_property(callable, name=name, reify=reify)\n        cls.apply_properties(target, [prop])"
    },
    {
      "chunk_id": 351,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def add_property(self, callable, name=None, reify=False):\n        \"\"\"Add a new property configuration.\n\n        This should be used in combination with :meth:`.apply` as a\n        more efficient version of :meth:`.set_property`.\n        \"\"\"\n        name, fn = self.make_property(callable, name=name, reify=reify)\n        self.properties[name] = fn"
    },
    {
      "chunk_id": 352,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def apply(self, target):\n        \"\"\"Apply all configured properties to the ``target`` instance.\"\"\"\n        if self.properties:\n            self.apply_properties(target, self.properties)"
    },
    {
      "chunk_id": 353,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class InstancePropertyMixin:\n    \"\"\"Mixin that will allow an instance to add properties at\n    run-time as if they had been defined via @property or @reify\n    on the class itself.\n    \"\"\"\n\n    def set_property(self, callable, name=None, reify=False):\n        \"\"\"Add a callable or a property descriptor to the instance.\n\n        Properties, unlike attributes, are lazily evaluated by executing\n        an underlying callable when accessed. They can be useful for\n        adding features to an object without any cost if those features\n        go unused.\n\n        A property may also be reified via the\n        :class:`pyramid.decorator.reify` decorator by setting\n        ``reify=True``, allowing the result of the evaluation to be\n        cached. Using this method, the value of the property is only\n        computed once for the lifetime of the object.\n\n        ``callable`` can either be a callable that accepts the instance\n        as its single positional parameter, or it can be a property\n        descriptor.\n\n        If the ``callable`` is a property descriptor, the ``name``\n        parameter must be supplied or a ``ValueError`` will be raised.\n        Also note that a property descriptor cannot be reified, so\n        ``reify`` must be ``False``.\n\n        If ``name`` is None, the name of the property will be computed\n        from the name of the ``callable``.\n        \"\"\"\n        InstancePropertyHelper.set_property(\n            self, callable, name=name, reify=reify\n        )"
    },
    {
      "chunk_id": 354,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class WeakOrderedSet:\n    \"\"\"Maintain a set of items.\n\n    Each item is stored as a weakref to avoid extending their lifetime.\n\n    The values may be iterated over or the last item added may be\n    accessed via the ``last`` property.\n\n    If items are added more than once, the most recent addition will\n    be remembered in the order:\n\n        order = WeakOrderedSet()\n        order.add('1')\n        order.add('2')\n        order.add('1')\n\n        list(order) == ['2', '1']\n        order.last == '1'\n    \"\"\"\n\n    def __init__(self):\n        self._items = {}\n        self._order = []\n\n    def add(self, item):\n        \"\"\"Add an item to the set.\"\"\"\n        oid = id(item)\n        if oid in self._items:\n            self._order.remove(oid)\n            self._order.append(oid)\n            return\n        ref = weakref.ref(item, lambda x: self._remove_by_id(oid))\n        self._items[oid] = ref\n        self._order.append(oid)"
    },
    {
      "chunk_id": 355,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def _remove_by_id(self, oid):\n        \"\"\"Remove an item from the set.\"\"\"\n        if oid in self._items:\n            del self._items[oid]\n            self._order.remove(oid)\n\n    def remove(self, item):\n        \"\"\"Remove an item from the set.\"\"\"\n        self._remove_by_id(id(item))\n\n    def empty(self):\n        \"\"\"Clear all objects from the set.\"\"\"\n        self._items = {}\n        self._order = []\n\n    def __len__(self):\n        return len(self._order)\n\n    def __contains__(self, item):\n        oid = id(item)\n        return oid in self._items\n\n    def __iter__(self):\n        return (self._items[oid]() for oid in self._order)\n\n    @property\n    def last(self):\n        if self._order:\n            oid = self._order[-1]\n            return self._items[oid]()"
    },
    {
      "chunk_id": 356,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def strings_differ(string1, string2):\n    \"\"\"Check whether two strings differ while avoiding timing attacks.\n\n    This function returns True if the given strings differ and False\n    if they are equal.  It's careful not to leak information about *where*\n    they differ as a result of its running time, which can be very important\n    to avoid certain timing-related crypto attacks:\n    \"\"\"\n    len_eq = len(string1) == len(string2)\n    if len_eq:\n        invalid_bits = 0\n        left = string1\n    else:\n        invalid_bits = 1\n        left = string2\n    right = string2\n\n    invalid_bits += not compare_digest(left, right)\n    return invalid_bits != 0"
    },
    {
      "chunk_id": 357,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def object_description(object):\n    \"\"\"Produce a human-consumable text description of ``object``,\n    usually involving a Python dotted name. For example:\n    \"\"\"\n    if isinstance(object, str):\n        return object\n    if isinstance(object, int):\n        return str(object)\n    if isinstance(object, (bool, float, type(None))):\n        return str(object)\n    if isinstance(object, set):\n        return shortrepr(object, '}')\n    if isinstance(object, tuple):\n        return shortrepr(object, ')')\n    if isinstance(object, list):\n        return shortrepr(object, ']')\n    if isinstance(object, dict):\n        return shortrepr(object, '}')\n    module = inspect.getmodule(object)\n    if module is None:\n        return 'object %s' % str(object)\n    modulename = module.__name__\n    if inspect.ismodule(object):\n        return 'module %s' % modulename\n    if inspect.ismethod(object):\n        oself = getattr(object, '__self__', None)\n        return 'method {} of class {}.{}'.format(\n            object.__name__,\n            modulename,\n            oself.__class__.__name__,\n        )\n\n    if inspect.isclass(object):\n        dottedname = f'{modulename}.{object.__name__}'\n        return 'class %s' % dottedname\n    if inspect.isfunction(object):\n        dottedname = f'{modulename}.{object.__name__}'\n        return 'function %s' % dottedname\n    return 'object %s' % str(object)"
    },
    {
      "chunk_id": 358,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def shortrepr(object, closer):\n    r = str(object)\n    if len(r) > 100:\n        r = r[:100] + ' ... %s' % closer\n    return r"
    },
    {
      "chunk_id": 359,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class Sentinel:\n    def __init__(self, repr):\n        self.repr = repr\n\n    def __repr__(self):\n        return self.repr"
    },
    {
      "chunk_id": 360,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "FIRST = Sentinel('FIRST')\nLAST = Sentinel('LAST')"
    },
    {
      "chunk_id": 361,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class TopologicalSorter:\n    \"\"\"A utility class which can be used to perform topological sorts against\n    tuple-like data.\"\"\"\n\n    def __init__(self, default_before=LAST, default_after=None, first=FIRST, last=LAST):\n        self.names = []\n        self.req_before = set()\n        self.req_after = set()\n        self.name2before = {}\n        self.name2after = {}\n        self.name2val = {}\n        self.order = []\n        self.default_before = default_before\n        self.default_after = default_after\n        self.first = first\n        self.last = last"
    },
    {
      "chunk_id": 362,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def values(self):\n        return self.name2val.values()\n\n    def remove(self, name):\n        \"\"\"Remove a node from the sort input\"\"\"\n        self.names.remove(name)\n        del self.name2val[name]\n        after = self.name2after.pop(name, [])\n        if after:\n            self.req_after.remove(name)\n            for u in after:\n                self.order.remove((u, name))\n        before = self.name2before.pop(name, [])\n        if before:\n            self.req_before.remove(name)\n            for u in before:\n                self.order.remove((name, u))"
    },
    {
      "chunk_id": 363,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def add(self, name, val, after=None, before=None):\n        \"\"\"Add a node to the sort input.  The ``name`` should be a string or\n        any other hashable object, the ``val`` should be the sortable (doesn't\n        need to be hashable).  ``after`` and ``before`` represents the name of\n        one of the other sortables (or a sequence of such named) or one of the\n        special sentinel values :attr:`pyramid.util.FIRST`` or\n        :attr:`pyramid.util.LAST` representing the first or last positions\n        respectively.  ``FIRST`` and ``LAST`` can also be part of a sequence\n        passed as ``before`` or ``after``.  A sortable should not be added\n        after LAST or before FIRST.  An example::\n        \"\"\"\n        if name in self.names:\n            self.remove(name)\n        self.names.append(name)\n        self.name2val[name] = val\n        if after is None and before is None:\n            before = self.default_before\n            after = self.default_after\n        if after is not None:\n            if not is_nonstr_iter(after):\n                after = (after,)\n            self.name2after[name] = after\n            self.order += [(u, name) for u in after]\n            self.req_after.add(name)\n        if before is not None:\n            if not is_nonstr_iter(before):\n                before = (before,)\n            self.name2before[name] = before\n            self.order += [(name, o) for o in before]\n            self.req_before.add(name)"
    },
    {
      "chunk_id": 364,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def sorted(self):\n        \"\"\"Returns the sort input values in topologically sorted order\"\"\"\n        order = [(self.first, self.last)]\n        roots = []\n        graph = {}\n        names = [self.first, self.last]\n        names.extend(self.names)\n\n        for a, b in self.order:\n            order.append((a, b))\n\n        def add_node(node):\n            if node not in graph:\n                roots.append(node)\n                graph[node] = [0]  # 0 = number of arcs coming into this node\n\n        def add_arc(fromnode, tonode):\n            graph[fromnode].append(tonode)\n            graph[tonode][0] += 1\n            if tonode in roots:\n                roots.remove(tonode)\n\n        for name in names:\n            add_node(name)\n\n        has_before, has_after = set(), set()\n        for a, b in order:\n            if a in names and b in names:  # deal with missing dependencies\n                add_arc(a, b)\n                has_before.add(a)\n                has_after.add(b)\n\n        if not self.req_before.issubset(has_before):\n            # avoid circular dependency\n            from pyramid.exceptions import ConfigurationError\n\n            raise ConfigurationError(\n                'Unsatisfied before dependencies: %s'\n                % (', '.join(sorted(self.req_before - has_before)))\n            )\n        if not self.req_after.issubset(has_after):\n            # avoid circular dependency\n            from pyramid.exceptions import ConfigurationError\n\n            raise ConfigurationError(\n                'Unsatisfied after dependencies: %s'\n                % (', '.join(sorted(self.req_after - has_after)))\n            )\n\n        sorted_names = []\n\n        while roots:\n            root = roots.pop(0)\n            sorted_names.append(root)\n            children = graph[root][1:]\n            for child in children:\n                arcs = graph[child][0]\n                arcs -= 1\n                graph[child][0] = arcs\n                if arcs == 0:\n                    roots.insert(0, child)\n            del graph[root]\n\n        if graph:\n            # avoid circular dependency\n            from pyramid.exceptions import CyclicDependencyError\n\n            # loop in input\n            cycledeps = {}\n            for k, v in graph.items():\n                cycledeps[k] = v[1:]\n            raise CyclicDependencyError(cycledeps)\n\n        result = []\n\n        for name in sorted_names:\n            if name in self.names:\n                result.append((name, self.name2val[name]))\n\n        return result"
    },
    {
      "chunk_id": 365,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def get_callable_name(name):\n    \"\"\"\n    Verifies that the ``name`` is ascii and will raise a ``ConfigurationError``\n    if it is not.\n    \"\"\"\n    try:\n        return ascii_(name)\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        # avoid circular dependency\n        from pyramid.exceptions import ConfigurationError\n\n        msg = (\n            '`name=\"%s\"` is invalid. `name` must be ascii because it is '\n            'used on __name__ of the method'\n        )\n        raise ConfigurationError(msg % name)"
    },
    {
      "chunk_id": 366,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "@contextmanager\ndef hide_attrs(obj, *attrs):\n    \"\"\"\n    Temporarily delete object attrs and restore afterward.\n    \"\"\"\n    obj_vals = obj.__dict__ if obj is not None else {}\n    saved_vals = {}\n    for name in attrs:\n        saved_vals[name] = obj_vals.pop(name, _marker)\n    try:\n        yield\n    finally:\n        for name in attrs:\n            saved_val = saved_vals[name]\n            if saved_val is not _marker:\n                obj_vals[name] = saved_val\n            elif name in obj_vals:\n                del obj_vals[name]"
    },
    {
      "chunk_id": 367,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def is_same_domain(host, pattern):\n    \"\"\"\n    Return ``True`` if the host is either an exact match or a match\n    to the wildcard pattern.\n    Any pattern beginning with a period matches a domain and all of its\n    subdomains. (e.g. ``.example.com`` matches ``example.com`` and\n    ``foo.example.com``). Anything else is an exact string match.\n    \"\"\"\n    if not pattern:\n        return False\n\n    pattern = pattern.lower()\n    return (\n        pattern[0] == \".\"\n        and (host.endswith(pattern) or host == pattern[1:])\n        or pattern == host\n    )"
    },
    {
      "chunk_id": 368,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def make_contextmanager(fn):\n    if inspect.isgeneratorfunction(fn):\n        return contextmanager(fn)\n\n    if fn is None:\n        fn = lambda *a, **kw: None\n\n    @contextmanager\n    @functools.wraps(fn)\n    def wrapper(*a, **kw):\n        yield fn(*a, **kw)\n\n    return wrapper"
    },
    {
      "chunk_id": 369,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def takes_one_arg(callee, attr=None, argname=None, allow_varargs=True):\n    ismethod = False\n    if attr is None:\n        attr = '__call__'\n    if inspect.isroutine(callee):\n        fn = callee\n    elif inspect.isclass(callee):\n        fn = callee.__init__\n        ismethod = hasattr(fn, '__call__')\n    else:\n        try:\n            fn = getattr(callee, attr)\n        except AttributeError:\n            return False\n\n    argspec = inspect.getfullargspec(fn)\n    args = argspec[0]\n\n    if hasattr(fn, '__func__') or ismethod:\n        # it's an instance method\n        if not args:\n            return False\n        args = args[1:]\n\n    if not args:\n        return False\n\n    if not allow_varargs and argspec.varargs:\n        return False\n\n    if len(args) == 1:\n        return True\n\n    if argname:\n        defaults = argspec[3]\n        if defaults is None:\n            defaults = ()\n\n        if args[0] == argname:\n            if len(args) - len(defaults) == 1:\n                return True\n\n    return False"
    },
    {
      "chunk_id": 370,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "class SimpleSerializer:\n    def loads(self, bstruct):\n        return text_(bstruct)\n\n    def dumps(self, appstruct):\n        return bytes_(appstruct)"
    },
    {
      "chunk_id": 371,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def is_bound_method(ob):\n    return inspect.ismethod(ob) and getattr(ob, '__self__', None) is not None"
    },
    {
      "chunk_id": 372,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def is_unbound_method(fn):\n    \"\"\"\n    This consistently verifies that the callable is bound to a\n    class.\n    \"\"\"\n    is_bound = is_bound_method(fn)\n\n    if not is_bound and inspect.isroutine(fn):\n        spec = inspect.getfullargspec(fn)\n        has_self = len(spec.args) > 0 and spec.args[0] == 'self'\n\n        if inspect.isfunction(fn) and has_self:\n            return True\n\n    return False"
    },
    {
      "chunk_id": 373,
      "source": "__internal__/data_repo/pyramid/src/pyramid/util.py",
      "content": "def reraise(tp, value, tb=None):\n    try:\n        if value is None:\n            value = tp()\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:\n        value = None\n        tb = None"
    },
    {
      "chunk_id": 374,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "import inspect\nimport itertools\nimport sys\nimport venusian\nfrom zope.interface import providedBy\n\nfrom pyramid.exceptions import ConfigurationError, PredicateMismatch\nfrom pyramid.httpexceptions import (\n    HTTPNotFound,\n    HTTPTemporaryRedirect,\n    default_exceptionresponse_view,\n)\nfrom pyramid.interfaces import (\n    IExceptionViewClassifier,\n    IMultiView,\n    IRequest,\n    IRoutesMapper,\n    ISecuredView,\n    IView,\n    IViewClassifier,\n)\nfrom pyramid.threadlocal import get_current_registry, manager\nfrom pyramid.util import hide_attrs, reraise as reraise_\n\n_marker = object()"
    },
    {
      "chunk_id": 375,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def render_view_to_response(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return a :term:`response` object.  This function will return\n    ``None`` if a corresponding :term:`view callable` cannot be found\n    (when no :term:`view configuration` matches the combination of\n    ``name`` / ``context`` / and ``request``).\n\n    If `secure`` is ``True``, and the :term:`view callable` found is\n    protected by a permission, the permission will be checked before calling\n    the view function.  If the permission check disallows view execution\n    (based on the current :term:`authorization policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised.\n    The exception's ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n    registry = getattr(request, 'registry', None)\n    if registry is None:\n        registry = get_current_registry()\n\n    context_iface = providedBy(context)\n    request_iface = providedBy(request)\n\n    response = _call_view(\n        registry,\n        request,\n        context,\n        context_iface,\n        name,\n        secure=secure,\n        request_iface=request_iface,\n    )\n\n    return response  # NB: might be None"
    },
    {
      "chunk_id": 376,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def render_view_to_iterable(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request`` and\n    return an iterable object which represents the body of a response.\n    This function will return ``None`` if a corresponding :term:`view\n    callable` cannot be found (when no :term:`view configuration`\n    matches the combination of ``name`` / ``context`` / and\n    ``request``).  Additionally, this function will raise a\n    :exc:`ValueError` if a view function is found and called but the\n    view function's result does not have an ``app_iter`` attribute.\n\n    You can usually get the bytestring representation of the return value of\n    this function by calling ``b''.join(iterable)``, or just use\n    :func:`pyramid.view.render_view` instead.\n\n    If ``secure`` is ``True``, and the view is protected by a permission, the\n    permission will be checked before the view function is invoked.  If the\n    permission check disallows view execution (based on the current\n    :term:`security policy`), a\n    :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be raised; its\n    ``args`` attribute explains why the view access was disallowed.\n\n    If ``secure`` is ``False``, no permission checking is\n    done.\"\"\"\n    response = render_view_to_response(context, request, name, secure)\n    if response is None:\n        return None\n    return response.app_iter"
    },
    {
      "chunk_id": 377,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def render_view(context, request, name='', secure=True):\n    \"\"\"Call the :term:`view callable` configured with a :term:`view\n    configuration` that matches the :term:`view name` ``name``\n    registered against the specified ``context`` and ``request``\n    and unwind the view response's ``app_iter`` (see\n    :ref:`the_response`) into a single bytestring.  This function will\n    return ``None`` if a corresponding :term:`view callable` cannot be\n    found (when no :term:`view configuration` matches the combination\n    of ``name`` / ``context`` / and ``request``).  Additionally, this\n    function will raise a :exc:`ValueError` if a view function is\n    found and called but the view function's result does not have an\n    ``app_iter`` attribute. This function will return ``None`` if a\n    corresponding view cannot be found.\n\n    If ``secure`` is ``True``, and the view is protected by a permission, the\n    permission will be checked before the view is invoked.  If the permission\n    check disallows view execution (based on the current :term:`authorization\n    policy`), a :exc:`pyramid.httpexceptions.HTTPForbidden` exception will be\n    raised; its ``args`` attribute explains why the view access was\n    disallowed.\n\n    If ``secure`` is ``False``, no permission checking is done.\"\"\"\n    iterable = render_view_to_iterable(context, request, name, secure)\n    if iterable is None:\n        return None\n    return b''.join(iterable)"
    },
    {
      "chunk_id": 378,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class view_config:\n    \"\"\"A function, class or method :term:`decorator` which allows a\n    developer to create view registrations nearer to a :term:`view\n    callable` definition than use :term:`imperative\n    configuration` to do the same.\n\n    For example, this code in a module ``views.py``::\n\n      from resources import MyResource\n\n      @view_config(name='my_view', context=MyResource, permission='read',\n                   route_name='site1')\n      def my_view(context, request):\n          return 'OK'\n\n    Might replace the following call to the\n    :meth:`pyramid.config.Configurator.add_view` method::\n\n       import views\n       from resources import MyResource\n       config.add_view(views.my_view, context=MyResource, name='my_view',\n                       permission='read', route_name='site1')\n\n    .. note: :class:`pyramid.view.view_config` is also importable, for\n             backwards compatibility purposes, as the name\n             :class:`pyramid.view.bfg_view`.\n\n    :class:`pyramid.view.view_config` supports the following keyword\n    arguments: ``context``, ``exception``, ``permission``, ``name``,\n    ``request_type``, ``route_name``, ``request_method``, ``request_param``,\n    ``containment``, ``xhr``, ``accept``, ``header``, ``path_info``,\n    ``custom_predicates``, ``decorator``, ``mapper``, ``http_cache``,\n    ``require_csrf``, ``match_param``, ``physical_path``, and\n    ``view_options``.\n\n    The meanings of these arguments are the same as the arguments passed to\n    :meth:`pyramid.config.Configurator.add_view`.  If any argument is left\n    out, its default will be the equivalent ``add_view`` default.\n\n    Two additional keyword arguments which will be passed to the\n    :term:`venusian` ``attach`` function are ``_depth`` and ``_category``.\n\n    ``_depth`` is provided for people who wish to reuse this class from another\n    decorator. The default value is ``0`` and should be specified relative to\n    the ``view_config`` invocation. It will be passed in to the\n    :term:`venusian` ``attach`` function as the depth of the callstack when\n    Venusian checks if the decorator is being used in a class or module\n    context. It's not often used, but it can be useful in this circumstance.\n\n    ``_category`` sets the decorator category name. It can be useful in\n    combination with the ``category`` argument of ``scan`` to control which\n    views should be processed.\n\n    See the :py:func:`venusian.attach` function in Venusian for more\n    information about the ``_depth`` and ``_category`` arguments.\n\n    .. seealso::\n\n        See also :ref:`mapping_views_using_a_decorator_section` for\n        details about using :class:`pyramid.view.view_config`.\n\n    .. note::\n\n        Because of a limitation with ``venusian.Scanner.scan``, note that\n        ``view_config`` will work only for the following conditions.\n\n        -   In Python packages that have an ``__init__.py`` file in their\n            directory.\n\n            .. seealso::\n\n                See also https://github.com/Pylons/venusian/issues/68\n\n        -   On module top level members.\n        -   On Python source (``.py``) files.\n            Compiled Python files (``.pyc``, ``.pyo``) without a corresponding\n            source file are ignored.\n\n        .. seealso::\n\n            See also the `Venusian documentation\n            <https://docs.pylonsproject.org/projects/venusian/en/latest/#using-venusian>`_.\n    \"\"\"\n\n    venusian = venusian  # for testing injection\n\n    def __init__(self, **settings):\n        if 'for_' in settings:\n            if settings.get('context') is None:\n                settings['context'] = settings['for_']\n        self.__dict__.update(settings)\n        self._get_info()\n\n    def _get_info(self):\n        depth = self.__dict__.get('_depth', 0)\n        frame = sys._getframe(depth + 2)\n        frameinfo = inspect.getframeinfo(frame)\n        sourceline = frameinfo[3][0].strip()\n        self._info = frameinfo[0], frameinfo[1], frameinfo[2], sourceline\n\n    def __call__(self, wrapped):\n        settings = self.__dict__.copy()\n        depth = settings.pop('_depth', 0)\n        category = settings.pop('_category', 'pyramid')\n\n        def callback(context, name, ob):\n            config = context.config.with_package(info.module)\n            config.add_view(view=ob, **settings)\n\n        info = self.venusian.attach(\n            wrapped, callback, category=category, depth=depth + 1\n        )\n\n        if info.scope == 'class':\n            if settings.get('attr') is None:\n                settings['attr'] = wrapped.__name__\n\n        return wrapped"
    },
    {
      "chunk_id": 379,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "bfg_view = view_config  # bw compat (forever)"
    },
    {
      "chunk_id": 380,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def view_defaults(**settings):\n    \"\"\"A class :term:`decorator` which, when applied to a class, will\n    provide defaults for all view configurations that use the class.  This\n    decorator accepts all the arguments accepted by\n    :meth:`pyramid.view.view_config`, and each has the same meaning.\n\n    See :ref:`view_defaults` for more information.\n    \"\"\"\n\n    def wrap(wrapped):\n        wrapped.__view_defaults__ = settings\n        return wrapped\n\n    return wrap"
    },
    {
      "chunk_id": 381,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class AppendSlashNotFoundViewFactory:\n    \"\"\"There can only be one :term:`Not Found view` in any\n    :app:`Pyramid` application.  Even if you use\n    :func:`pyramid.view.append_slash_notfound_view` as the Not\n    Found view, :app:`Pyramid` still must generate a ``404 Not\n    Found`` response when it cannot redirect to a slash-appended URL;\n    this not found response will be visible to site users.\n\n    If you don't care what this 404 response looks like, and you only\n    need redirections to slash-appended route URLs, you may use the\n    :func:`pyramid.view.append_slash_notfound_view` object as the\n    Not Found view.  However, if you wish to use a *custom* notfound\n    view callable when a URL cannot be redirected to a slash-appended\n    URL, you may wish to use an instance of this class as the Not\n    Found view, supplying a :term:`view callable` to be used as the\n    custom notfound view as the first argument to its constructor.\n    For instance:\n\n    .. code-block:: python\n\n       from pyramid.httpexceptions import HTTPNotFound\n       from pyramid.view import AppendSlashNotFoundViewFactory\n\n       def notfound_view(context, request): return HTTPNotFound('nope')\n\n       custom_append_slash = AppendSlashNotFoundViewFactory(notfound_view)\n       config.add_view(custom_append_slash, context=HTTPNotFound)\n\n    The ``notfound_view`` supplied must adhere to the two-argument\n    view callable calling convention of ``(context, request)``\n    (``context`` will be the exception object).\n\n    .. deprecated:: 1.3\n\n    \"\"\"\n\n    def __init__(\n        self, notfound_view=None, redirect_class=HTTPTemporaryRedirect\n    ):\n        if notfound_view is None:\n            notfound_view = default_exceptionresponse_view\n        self.notfound_view = notfound_view\n        self.redirect_class = redirect_class\n\n    def __call__(self, context, request):\n        path = request.path_info\n        registry = request.registry\n        mapper = registry.queryUtility(IRoutesMapper)\n        if mapper is not None and not path.endswith('/'):\n            slashpath = path + '/'\n            for route in mapper.get_routes():\n                if route.match(slashpath) is not None:\n                    qs = request.query_string\n                    if qs:\n                        qs = '?' + qs\n                    return self.redirect_class(\n                        location=request.path + '/' + qs\n                    )\n        return self.notfound_view(context, request)"
    },
    {
      "chunk_id": 382,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "append_slash_notfound_view = AppendSlashNotFoundViewFactory()\nappend_slash_notfound_view.__doc__ = \"\"\"\\\nFor behavior like Django's ``APPEND_SLASH=True``, use this view as the\n:term:`Not Found view` in your application.\n\nWhen this view is the Not Found view (indicating that no view was found), and\nany routes have been defined in the configuration of your application, if the\nvalue of the ``PATH_INFO`` WSGI environment variable does not already end in\na slash, and if the value of the ``PATH_INFO`` *plus* a slash matches any route's\npath, do an HTTP redirect to the slash-appended PATH_INFO.  Note that this\nwill *lose* ``POST`` data information (turning it into a GET), so you\nshouldn't rely on this to redirect POST requests.  Note also that static\nroutes are not considered when attempting to find a matching route.\n\nUse the :meth:`pyramid.config.Configurator.add_view` method to configure this\nview as the Not Found view::\n\n  from pyramid.httpexceptions import HTTPNotFound\n  from pyramid.view import append_slash_notfound_view\n  config.add_view(append_slash_notfound_view, context=HTTPNotFound)\n\n.. deprecated:: 1.3\n\n\"\"\""
    },
    {
      "chunk_id": 383,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class notfound_view_config:\n    \"\"\"\n    .. versionadded:: 1.3\n\n    An analogue of :class:`pyramid.view.view_config` which registers a\n    :term:`Not Found View` using\n    :meth:`pyramid.config.Configurator.add_notfound_view`.\n\n    The ``notfound_view_config`` constructor accepts most of the same arguments\n    as the constructor of :class:`pyramid.view.view_config`.  It can be used\n    in the same places, and behaves in largely the same way, except it always\n    registers a not found exception view instead of a 'normal' view.\n\n    Example:\n\n    .. code-block:: python\n\n        from pyramid.view import notfound_view_config\n        from pyramid.response import Response\n\n        @notfound_view_config()\n        def notfound(request):\n            return Response('Not found!', status='404 Not Found')\n\n    All arguments except ``append_slash`` have the same meaning as\n    :meth:`pyramid.view.view_config` and each predicate\n    argument restricts the set of circumstances under which this notfound\n    view will be invoked.\n\n    If ``append_slash`` is ``True``, when the Not Found View is invoked, and\n    the current path info does not end in a slash, the notfound logic will\n    attempt to find a :term:`route` that matches the request's path info\n    suffixed with a slash.  If such a route exists, Pyramid will issue a\n    redirect to the URL implied by the route; if it does not, Pyramid will\n    return the result of the view callable provided as ``view``, as normal.\n\n    If the argument provided as ``append_slash`` is not a boolean but\n    instead implements :class:`~pyramid.interfaces.IResponse`, the\n    append_slash logic will behave as if ``append_slash=True`` was passed,\n    but the provided class will be used as the response class instead of\n    the default :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect`\n    response class when a redirect is performed.  For example:\n\n      .. code-block:: python\n\n        from pyramid.httpexceptions import (\n            HTTPMovedPermanently,\n            HTTPNotFound\n            )\n\n        @notfound_view_config(append_slash=HTTPMovedPermanently)\n        def aview(request):\n            return HTTPNotFound('not found')\n\n    The above means that a redirect to a slash-appended route will be\n    attempted, but instead of\n    :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect`\n    being used, :class:`~pyramid.httpexceptions.HTTPMovedPermanently will\n    be used` for the redirect response if a slash-appended route is found.\n\n    See :ref:`changing_the_notfound_view` for detailed usage information.\n\n    .. versionchanged:: 1.9.1\n       Added the ``_depth`` and ``_category`` arguments.\n\n    \"\"\"\n\n    venusian = venusian\n\n    def __init__(self, **settings):\n        self.__dict__.update(settings)\n\n    def __call__(self, wrapped):\n        settings = self.__dict__.copy()\n        depth = settings.pop('_depth', 0)\n        category = settings.pop('_category', 'pyramid')\n\n        def callback(context, name, ob):\n            config = context.config.with_package(info.module)\n            config.add_notfound_view(view=ob, **settings)\n\n        info = self.venusian.attach(\n            wrapped, callback, category=category, depth=depth + 1\n        )\n\n        if info.scope == 'class':\n            if settings.get('attr') is None:\n                settings['attr'] = wrapped.__name__\n\n        settings['_info'] = info.codeinfo  # fbo \"action_method\"\n        return wrapped"
    },
    {
      "chunk_id": 384,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class forbidden_view_config:\n    \"\"\"\n    .. versionadded:: 1.3\n\n    An analogue of :class:`pyramid.view.view_config` which registers a\n    :term:`forbidden view` using\n    :meth:`pyramid.config.Configurator.add_forbidden_view`.\n\n    The forbidden_view_config constructor accepts most of the same arguments\n    as the constructor of :class:`pyramid.view.view_config`.  It can be used\n    in the same places, and behaves in largely the same way, except it always\n    registers a forbidden exception view instead of a 'normal' view.\n\n    Example:\n\n    .. code-block:: python\n\n        from pyramid.view import forbidden_view_config\n        from pyramid.response import Response\n\n        @forbidden_view_config()\n        def forbidden(request):\n            return Response('You are not allowed', status='403 Forbidden')\n\n    All arguments passed to this function have the same meaning as\n    :meth:`pyramid.view.view_config` and each predicate argument restricts\n    the set of circumstances under which this notfound view will be invoked.\n\n    See :ref:`changing_the_forbidden_view` for detailed usage information.\n\n    .. versionchanged:: 1.9.1\n       Added the ``_depth`` and ``_category`` arguments.\n\n    \"\"\"\n\n    venusian = venusian\n\n    def __init__(self, **settings):\n        self.__dict__.update(settings)\n\n    def __call__(self, wrapped):\n        settings = self.__dict__.copy()\n        depth = settings.pop('_depth', 0)\n        category = settings.pop('_category', 'pyramid')\n\n        def callback(context, name, ob):\n            config = context.config.with_package(info.module)\n            config.add_forbidden_view(view=ob, **settings)\n\n        info = self.venusian.attach(\n            wrapped, callback, category=category, depth=depth + 1\n        )\n\n        if info.scope == 'class':\n            if settings.get('attr') is None:\n                settings['attr'] = wrapped.__name__\n\n        settings['_info'] = info.codeinfo  # fbo \"action_method\"\n        return wrapped"
    },
    {
      "chunk_id": 385,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class exception_view_config:\n    \"\"\"\n    .. versionadded:: 1.8\n\n    An analogue of :class:`pyramid.view.view_config` which registers an\n    :term:`exception view` using\n    :meth:`pyramid.config.Configurator.add_exception_view`.\n\n    The ``exception_view_config`` constructor requires an exception context,\n    and additionally accepts most of the same arguments as the constructor of\n    :class:`pyramid.view.view_config`.  It can be used in the same places,\n    and behaves in largely the same way, except it always registers an\n    exception view instead of a \"normal\" view that dispatches on the request\n    :term:`context`.\n\n    Example:\n\n    .. code-block:: python\n\n        from pyramid.view import exception_view_config\n        from pyramid.response import Response\n\n        @exception_view_config(ValueError, renderer='json')\n        def error_view(request):\n            return {'error': str(request.exception)}\n\n    All arguments passed to this function have the same meaning as\n    :meth:`pyramid.view.view_config`, and each predicate argument restricts\n    the set of circumstances under which this exception view will be invoked.\n\n    .. versionchanged:: 1.9.1\n       Added the ``_depth`` and ``_category`` arguments.\n\n    \"\"\"\n\n    venusian = venusian\n\n    def __init__(self, *args, **settings):\n        if 'context' not in settings and len(args) > 0:\n            exception, args = args[0], args[1:]\n            settings['context'] = exception\n        if len(args) > 0:\n            raise ConfigurationError('unknown positional arguments')\n        self.__dict__.update(settings)\n\n    def __call__(self, wrapped):\n        settings = self.__dict__.copy()\n        depth = settings.pop('_depth', 0)\n        category = settings.pop('_category', 'pyramid')\n\n        def callback(context, name, ob):\n            config = context.config.with_package(info.module)\n            config.add_exception_view(view=ob, **settings)\n\n        info = self.venusian.attach(\n            wrapped, callback, category=category, depth=depth + 1\n        )\n\n        if info.scope == 'class':\n            if settings.get('attr') is None:\n                settings['attr'] = wrapped.__name__\n\n        settings['_info'] = info.codeinfo  # fbo \"action_method\"\n        return wrapped"
    },
    {
      "chunk_id": 386,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def _find_views(\n    registry,\n    request_iface,\n    context_iface,\n    view_name,\n    view_types=None,\n    view_classifier=None,\n):\n    if view_types is None:\n        view_types = (IView, ISecuredView, IMultiView)\n    if view_classifier is None:\n        view_classifier = IViewClassifier\n    registered = registry.adapters.registered\n    cache = registry._view_lookup_cache\n    views = cache.get((request_iface, context_iface, view_name))\n    if views is None:\n        views = []\n        for req_type, ctx_type in itertools.product(\n            request_iface.__sro__, context_iface.__sro__\n        ):\n            source_ifaces = (view_classifier, req_type, ctx_type)\n            for view_type in view_types:\n                view_callable = registered(\n                    source_ifaces, view_type, name=view_name\n                )\n                if view_callable is not None:\n                    views.append(view_callable)\n        if views:\n            with registry._lock:\n                cache[(request_iface, context_iface, view_name)] = views\n\n    return views"
    },
    {
      "chunk_id": 387,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "def _call_view(\n    registry,\n    request,\n    context,\n    context_iface,\n    view_name,\n    view_types=None,\n    view_classifier=None,\n    secure=True,\n    request_iface=None,\n):\n    if request_iface is None:\n        request_iface = getattr(request, 'request_iface', IRequest)\n    view_callables = _find_views(\n        registry,\n        request_iface,\n        context_iface,\n        view_name,\n        view_types=view_types,\n        view_classifier=view_classifier,\n    )\n\n    pme = None\n    response = None\n\n    for view_callable in view_callables:\n        try:\n            if not secure:\n                view_callable = getattr(\n                    view_callable, '__call_permissive__', view_callable\n                )\n\n            response = view_callable(context, request)\n            return response\n        except PredicateMismatch as _pme:\n            pme = _pme\n\n    if pme is not None:\n        raise pme\n\n    return response"
    },
    {
      "chunk_id": 388,
      "source": "__internal__/data_repo/pyramid/src/pyramid/view.py",
      "content": "class ViewMethodsMixin:\n    \"\"\"Request methods mixin for BaseRequest having to do with executing\n    views\"\"\"\n\n    def invoke_exception_view(\n        self, exc_info=None, request=None, secure=True, reraise=False\n    ):\n        \"\"\"Executes an exception view related to the request it's called upon.\n        The arguments it takes are these:\n\n        ``exc_info``\n\n            If provided, should be a 3-tuple in the form provided by\n            ``sys.exc_info()``.  If not provided,\n            ``sys.exc_info()`` will be called to obtain the current\n            interpreter exception information.  Default: ``None``.\n\n        ``request``\n\n            If the request to be used is not the same one as the instance that\n            this method is called upon, it may be passed here.  Default:\n            ``None``.\n\n        ``secure``\n\n            If the exception view should not be rendered if the current user\n            does not have the appropriate permission, this should be ``True``.\n            Default: ``True``.\n\n        ``reraise``\n\n            A boolean indicating whether the original error should be reraised\n            if a :term:`response` object could not be created. If ``False``\n            then an :class:`pyramid.httpexceptions.HTTPNotFound`` exception\n            will be raised. Default: ``False``.\n\n        If a response is generated then ``request.exception`` and\n        ``request.exc_info`` will be left at the values used to render the\n        response. Otherwise the previous values for ``request.exception`` and\n        ``request.exc_info`` will be restored.\n\n        .. versionadded:: 1.7\n\n        .. versionchanged:: 1.9\n           The ``request.exception`` and ``request.exc_info`` properties will\n           reflect the exception used to render the response where previously\n           they were reset to the values prior to invoking the method.\n\n           Also added the ``reraise`` argument.\n\n        \"\"\"\n        if request is None:\n            request = self\n        registry = getattr(request, 'registry', None)\n        if registry is None:\n            registry = get_current_registry()\n\n        if registry is None:\n            raise RuntimeError(\"Unable to retrieve registry\")\n\n        if exc_info is None:\n            exc_info = sys.exc_info()\n\n        exc = exc_info[1]\n        attrs = request.__dict__\n        context_iface = providedBy(exc)\n\n        with hide_attrs(request, 'response', 'exc_info', 'exception'):\n            attrs['exception'] = exc\n            attrs['exc_info'] = exc_info\n            request_iface = attrs.get('request_iface', IRequest)\n\n            manager.push({'request': request, 'registry': registry})\n\n            try:\n                response = _call_view(\n                    registry,\n                    request,\n                    exc,\n                    context_iface,\n                    '',\n                    view_types=None,\n                    view_classifier=IExceptionViewClassifier,\n                    secure=secure,\n                    request_iface=request_iface.combined,\n                )\n            except Exception:\n                if reraise:\n                    reraise_(*exc_info)\n                raise\n            finally:\n                manager.pop()\n\n        if response is None:\n            if reraise:\n                reraise_(*exc_info)\n            raise HTTPNotFound\n\n        attrs['exception'] = exc\n        attrs['exc_info'] = exc_info\n        return response"
    },
    {
      "chunk_id": 389,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "from collections import deque\nimport functools\nimport weakref\nfrom webob import BaseRequest\nfrom zope.interface import implementer\nfrom zope.interface.interface import InterfaceClass\n\nfrom pyramid.decorator import reify\nfrom pyramid.i18n import LocalizerRequestMixin\nfrom pyramid.interfaces import (\n    IRequest,\n    IRequestExtensions,\n    IResponse,\n    ISessionFactory,\n)\nfrom pyramid.response import Response, _get_response_factory\nfrom pyramid.security import AuthenticationAPIMixin, SecurityAPIMixin\nfrom pyramid.url import URLMethodsMixin\nfrom pyramid.util import (\n    InstancePropertyHelper,\n    InstancePropertyMixin,\n    Sentinel,\n    bytes_,\n    text_,\n)\nfrom pyramid.view import ViewMethodsMixin"
    },
    {
      "chunk_id": 390,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "class TemplateContext:\n    pass"
    },
    {
      "chunk_id": 391,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "class CallbackMethodsMixin:\n    @reify\n    def finished_callbacks(self):\n        return deque()\n\n    @reify\n    def response_callbacks(self):\n        return deque()\n\n    def add_response_callback(self, callback):\n        \"\"\"\n        Add a callback to the set of callbacks to be called by the\n        :term:`router` at a point after a :term:`response` object is\n        successfully created.  :app:`Pyramid` does not have a\n        global response object: this functionality allows an\n        application to register an action to be performed against the\n        response once one is created.\n\n        A 'callback' is a callable which accepts two positional\n        parameters: ``request`` and ``response``.  For example:\n\n        .. code-block:: python\n           :linenos:\n\n           def cache_callback(request, response):\n               'Set the cache_control max_age for the response'\n               response.cache_control.max_age = 360\n           request.add_response_callback(cache_callback)\n\n        Response callbacks are called in the order they're added\n        (first-to-most-recently-added).  No response callback is\n        called if an exception happens in application code, or if the\n        response object returned by :term:`view` code is invalid.\n\n        All response callbacks are called *after* the tweens and\n        *before* the :class:`pyramid.events.NewResponse` event is sent.\n\n        Errors raised by callbacks are not handled specially.  They\n        will be propagated to the caller of the :app:`Pyramid`\n        router application.\n\n        .. seealso::\n\n            See also :ref:`using_response_callbacks`.\n        \"\"\"\n\n        self.response_callbacks.append(callback)\n\n    def _process_response_callbacks(self, response):\n        callbacks = self.response_callbacks\n        while callbacks:\n            callback = callbacks.popleft()\n            callback(self, response)\n\n    def add_finished_callback(self, callback):\n        \"\"\"\n        Add a callback to the set of callbacks to be called\n        unconditionally by the :term:`router` at the very end of\n        request processing.\n\n        ``callback`` is a callable which accepts a single positional\n        parameter: ``request``.  For example:\n\n        .. code-block:: python\n           :linenos:\n\n           import transaction\n\n           def commit_callback(request):\n               '''commit or abort the transaction associated with request'''\n               if request.exception is not None:\n                   transaction.abort()\n               else:\n                   transaction.commit()\n           request.add_finished_callback(commit_callback)\n\n        Finished callbacks are called in the order they're added (\n        first- to most-recently- added).  Finished callbacks (unlike\n        response callbacks) are *always* called, even if an exception\n        happens in application code that prevents a response from\n        being generated.\n\n        The set of finished callbacks associated with a request are\n        called *very late* in the processing of that request; they are\n        essentially the last thing called by the :term:`router`. They\n        are called after response processing has already occurred in a\n        top-level ``finally:`` block within the router request\n        processing code.  As a result, mutations performed to the\n        ``request`` provided to a finished callback will have no\n        meaningful effect, because response processing will have\n        already occurred, and the request's scope will expire almost\n        immediately after all finished callbacks have been processed.\n\n        Errors raised by finished callbacks are not handled specially.\n        They will be propagated to the caller of the :app:`Pyramid`\n        router application.\n\n        .. seealso::\n\n            See also :ref:`using_finished_callbacks`.\n        \"\"\"\n        self.finished_callbacks.append(callback)\n\n    def _process_finished_callbacks(self):\n        callbacks = self.finished_callbacks\n        while callbacks:\n            callback = callbacks.popleft()\n            callback(self)"
    },
    {
      "chunk_id": 392,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "@implementer(IRequest)\nclass Request(\n    BaseRequest,\n    URLMethodsMixin,\n    CallbackMethodsMixin,\n    InstancePropertyMixin,\n    LocalizerRequestMixin,\n    SecurityAPIMixin,\n    AuthenticationAPIMixin,\n    ViewMethodsMixin,\n):\n    \"\"\"\n    A subclass of the :term:`WebOb` Request class.  An instance of\n    this class is created by the :term:`router` and is provided to a\n    view callable (and to other subsystems) as the ``request``\n    argument.\n\n    The documentation below (save for the ``add_response_callback`` and\n    ``add_finished_callback`` methods, which are defined in this subclass\n    itself, and the attributes ``context``, ``registry``, ``root``,\n    ``subpath``, ``traversed``, ``view_name``, ``virtual_root`` , and\n    ``virtual_root_path``, each of which is added to the request by the\n    :term:`router` at request ingress time) are autogenerated from the WebOb\n    source code used when this documentation was generated.\n\n    Due to technical constraints, we can't yet display the WebOb\n    version number from which this documentation is autogenerated, but\n    it will be the 'prevailing WebOb version' at the time of the\n    release of this :app:`Pyramid` version.  See\n    https://webob.org/ for further information.\n    \"\"\"\n\n    exception = None\n    exc_info = None\n    matchdict = None\n    matched_route = None\n    request_iface = IRequest\n\n    ResponseClass = Response\n\n    @reify\n    def tmpl_context(self):\n        # docs-deprecated template context for Pylons-like apps; do not\n        # remove.\n        return TemplateContext()\n\n    @reify\n    def session(self):\n        \"\"\"Obtain the :term:`session` object associated with this\n        request.  If a :term:`session factory` has not been registered\n        during application configuration, a\n        :class:`pyramid.exceptions.ConfigurationError` will be raised\"\"\"\n        factory = self.registry.queryUtility(ISessionFactory)\n        if factory is None:\n            raise AttributeError(\n                'No session factory registered '\n                '(see the Sessions chapter of the Pyramid documentation)'\n            )\n        return factory(self)\n\n    @reify\n    def response(self):\n        \"\"\"This attribute is actually a \"reified\" property which returns an\n        instance of the :class:`pyramid.response.Response`. class.  The\n        response object returned does not exist until this attribute is\n        accessed.  Subsequent accesses will return the same Response object.\n\n        The ``request.response`` API is used by renderers.  A render obtains\n        the response object it will return from a view that uses that renderer\n        by accessing ``request.response``.  Therefore, it's possible to use the\n        ``request.response`` API to set up a response object with \"the\n        right\" attributes (e.g. by calling ``request.response.set_cookie()``)\n        within a view that uses a renderer.  Mutations to this response object\n        will be preserved in the response sent to the client.\"\"\"\n        response_factory = _get_response_factory(self.registry)\n        return response_factory(self)\n\n    def is_response(self, ob):\n        \"\"\"Return ``True`` if the object passed as ``ob`` is a valid\n        response object, ``False`` otherwise.\"\"\"\n        if ob.__class__ is Response:\n            return True\n        registry = self.registry\n        adapted = registry.queryAdapterOrSelf(ob, IResponse)\n        if adapted is None:\n            return False\n        return adapted is ob"
    },
    {
      "chunk_id": 393,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "def route_request_iface(name, bases=()):\n    # zope.interface treats the __name__ as the __doc__ and changes __name__\n    # to None for interfaces that contain spaces if you do not pass a\n    # nonempty __doc__ (insane); see\n    # zope.interface.interface.Element.__init__ and\n    # https://github.com/Pylons/pyramid/issues/232; as a result, always pass\n    # __doc__ to the InterfaceClass constructor.\n    iface = InterfaceClass(\n        '%s_IRequest' % name,\n        bases=bases,\n        __doc__=\"route_request_iface-generated interface\",\n    )\n    # for exception view lookups\n    iface.combined = InterfaceClass(\n        '%s_combined_IRequest' % name,\n        bases=(iface, IRequest),\n        __doc__='route_request_iface-generated combined interface',\n    )\n    return iface"
    },
    {
      "chunk_id": 394,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "def add_global_response_headers(request, headerlist):\n    def add_headers(request, response):\n        for k, v in headerlist:\n            response.headerlist.append((k, v))\n\n    request.add_response_callback(add_headers)"
    },
    {
      "chunk_id": 395,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "def call_app_with_subpath_as_path_info(request, app):\n    # Copy the request.  Use the source request's subpath (if it exists) as\n    # the new request's PATH_INFO.  Set the request copy's SCRIPT_NAME to the\n    # prefix before the subpath.  Call the application with the new request\n    # and return a response.\n    #\n    # Postconditions:\n    # - SCRIPT_NAME and PATH_INFO are empty or start with /\n    # - At least one of SCRIPT_NAME or PATH_INFO are set.\n    # - SCRIPT_NAME is not '/' (it should be '', and PATH_INFO should\n    #   be '/').\n\n    environ = request.environ\n    script_name = environ.get('SCRIPT_NAME', '')\n    path_info = environ.get('PATH_INFO', '/')\n    subpath = list(getattr(request, 'subpath', ()))\n\n    new_script_name = ''\n\n    # compute new_path_info\n    new_path_info = '/' + '/'.join(\n        [text_(x.encode('utf-8'), 'latin-1') for x in subpath]\n    )\n\n    if new_path_info != '/':  # don't want a sole double-slash\n        if path_info != '/':  # if orig path_info is '/', we're already done\n            if path_info.endswith('/'):\n                # readd trailing slash stripped by subpath (traversal)\n                # conversion\n                new_path_info += '/'\n\n    # compute new_script_name\n    workback = (script_name + path_info).split('/')\n\n    tmp = []\n    while workback:\n        if tmp == subpath:\n            break\n        el = workback.pop()\n        if el:\n            tmp.insert(0, text_(bytes_(el, 'latin-1'), 'utf-8'))\n\n    # strip all trailing slashes from workback to avoid appending undue slashes\n    # to end of script_name\n    while workback and (workback[-1] == ''):\n        workback = workback[:-1]\n\n    new_script_name = '/'.join(workback)\n\n    new_request = request.copy()\n    new_request.environ['SCRIPT_NAME'] = new_script_name\n    new_request.environ['PATH_INFO'] = new_path_info\n\n    return new_request.get_response(app)"
    },
    {
      "chunk_id": 396,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "def apply_request_extensions(request, extensions=None):\n    \"\"\"Apply request extensions (methods and properties) to an instance of\n    :class:`pyramid.interfaces.IRequest`. This method is dependent on the\n    ``request`` containing a properly initialized registry.\n\n    After invoking this method, the ``request`` should have the methods\n    and properties that were defined using\n    :meth:`pyramid.config.Configurator.add_request_method`.\n    \"\"\"\n    if extensions is None:\n        extensions = request.registry.queryUtility(IRequestExtensions)\n    if extensions is not None:\n        for name, fn in extensions.methods.items():\n            method = fn.__get__(request, request.__class__)\n            setattr(request, name, method)\n\n        InstancePropertyHelper.apply_properties(\n            request, extensions.descriptors\n        )"
    },
    {
      "chunk_id": 397,
      "source": "__internal__/data_repo/pyramid/src/pyramid/request.py",
      "content": "class RequestLocalCache:\n    \"\"\"\n    A store that caches values during for the lifecycle of a request.\n\n    Wrapping Functions\n\n    Instantiate and use it to decorate functions that accept a request\n    parameter. The result is cached and returned in subsequent invocations\n    of the function.\n\n    .. code-block:: python\n\n        @RequestLocalCache()\n        def get_user(request):\n            result = ...  # do some expensive computations\n            return result\n\n        value = get_user(request)\n\n        # manipulate the cache directly\n        get_user.cache.clear(request)\n\n    The cache instance is attached to the resulting function as the ``cache``\n    attribute such that the function may be used to manipulate the cache.\n\n    Wrapping Methods\n\n    A method can be used as the creator function but it needs to be bound to\n    an instance such that it only accepts one argument - the request. An easy\n    way to do this is to bind the creator in the constructor and then use\n    :meth:`.get_or_create`:\n\n    .. code-block:: python\n\n        class SecurityPolicy:\n            def __init__(self):\n                self.identity_cache = RequestLocalCache(self.load_identity)\n\n            def load_identity(self, request):\n                result = ...  # do some expensive computations\n                return result\n\n            def identity(self, request):\n                return self.identity_cache.get_or_create(request)\n\n    The cache maintains a weakref to each request and will release the cached\n    values when the request is garbage-collected. However, in most scenarios,\n    it will release resources earlier via\n    :meth:`pyramid.request.Request.add_finished_callback`.\n\n    .. versionadded:: 2.0\n\n    \"\"\"\n\n    NO_VALUE = Sentinel('NO_VALUE')\n\n    def __init__(self, creator=None):\n        self._store = weakref.WeakKeyDictionary()\n        self._creator = creator\n\n    def __call__(self, fn):\n        @functools.wraps(fn)\n        def wrapper(request):\n            return wrapper.cache.get_or_create(request, fn)\n\n        wrapper.cache = self\n        self._creator = fn\n        return wrapper\n\n    def get_or_create(self, request, creator=None):\n        \"\"\"\n        Return the value from the cache. Compute if necessary.\n\n        If no value is cached then execute the creator, cache the result,\n        and return it.\n\n        The creator may be passed in as an argument or bound to the cache\n        by decorating a function or supplied as a constructor argument.\n\n        \"\"\"\n        result = self._store.get(request, self.NO_VALUE)\n        if result is self.NO_VALUE:\n            if creator is None:\n                creator = self._creator\n                if creator is None:\n                    raise ValueError(\n                        'no creator function has been registered with the '\n                        'cache or supplied to \"get_or_create\"'\n                    )\n            result = creator(request)\n            self.set(request, result)\n        return result\n\n    def get(self, request, default=NO_VALUE):\n        \"\"\"\n        Return the value from the cache.\n\n        The cached value is returned or ``default``.\n\n        \"\"\"\n        return self._store.get(request, default)\n\n    def set(self, request, value):\n        \"\"\"\n        Update the cache with a new value.\n\n        \"\"\"\n        already_set = request in self._store\n        self._store[request] = value\n\n        # avoid registering the callback more than once\n        if not already_set:\n            request.add_finished_callback(self._store.pop)\n\n    def clear(self, request):\n        \"\"\"\n        Delete the value from the cache.\n\n        The cached value is returned or :attr:`.NO_VALUE`.\n\n        \"\"\"\n        old_value = self.NO_VALUE\n        if request in self._store:\n            old_value = self._store[request]\n\n            # keep a value in the store so that we don't register another\n            # finished callback when set is invoked\n            self._store[request] = self.NO_VALUE\n        return old_value"
    },
    {
      "chunk_id": 398,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "import re\n\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.traversal import (\n    find_interface,\n    resource_path_tuple,\n    traversal_path,\n)\nfrom pyramid.urldispatch import _compile_route\nfrom pyramid.util import as_sorted_tuple, is_nonstr_iter, object_description\n\n_marker = object()"
    },
    {
      "chunk_id": 399,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class XHRPredicate:\n    def __init__(self, val, config):\n        self.val = bool(val)\n\n    def text(self):\n        return 'xhr = %s' % self.val\n\n    phash = text\n\n    def __call__(self, context, request):\n        return bool(request.is_xhr) is self.val"
    },
    {
      "chunk_id": 400,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class RequestMethodPredicate:\n    def __init__(self, val, config):\n        request_method = as_sorted_tuple(val)\n        if 'GET' in request_method and 'HEAD' not in request_method:\n            # GET implies HEAD too\n            request_method = as_sorted_tuple(request_method + ('HEAD',))\n        self.val = request_method\n\n    def text(self):\n        return 'request_method = %s' % (','.join(self.val))\n\n    phash = text\n\n    def __call__(self, context, request):\n        return request.method in self.val"
    },
    {
      "chunk_id": 401,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class PathInfoPredicate:\n    def __init__(self, val, config):\n        self.orig = val\n        try:\n            val = re.compile(val)\n        except re.error as why:\n            raise ConfigurationError(why.args[0])\n        self.val = val\n\n    def text(self):\n        return f'path_info = {self.orig}'\n\n    phash = text\n\n    def __call__(self, context, request):\n        return self.val.match(request.upath_info) is not None"
    },
    {
      "chunk_id": 402,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class RequestParamPredicate:\n    def __init__(self, val, config):\n        val = as_sorted_tuple(val)\n        reqs = []\n        for p in val:\n            k = p\n            v = None\n            if p.startswith('='):\n                if '=' in p[1:]:\n                    k, v = p[1:].split('=', 1)\n                    k = '=' + k\n                    k, v = k.strip(), v.strip()\n            elif '=' in p:\n                k, v = p.split('=', 1)\n                k, v = k.strip(), v.strip()\n            reqs.append((k, v))\n        self.val = val\n        self.reqs = reqs\n\n    def text(self):\n        return 'request_param %s' % ','.join(\n            [f'{x}={y}' if y else x for x, y in self.reqs]\n        )\n\n    phash = text\n\n    def __call__(self, context, request):\n        for k, v in self.reqs:\n            actual = request.params.get(k)\n            if actual is None:\n                return False\n            if v is not None and actual != v:\n                return False\n        return True"
    },
    {
      "chunk_id": 403,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class HeaderPredicate:\n    def __init__(self, val, config):\n        values = []\n\n        val = as_sorted_tuple(val)\n        for name in val:\n            v, val_str = None, None\n            if ':' in name:\n                name, val_str = name.split(':', 1)\n                try:\n                    v = re.compile(val_str)\n                except re.error as why:\n                    raise ConfigurationError(why.args[0])\n\n            values.append((name, v, val_str))\n\n        self.val = values\n\n    def text(self):\n        return 'header %s' % ', '.join(\n            f'{name}={val_str}' if val_str else name\n            for name, _, val_str in self.val\n        )\n\n    phash = text\n\n    def __call__(self, context, request):\n        for name, val, _ in self.val:\n            if val is None:\n                if name not in request.headers:\n                    return False\n            else:\n                value = request.headers.get(name)\n                if value is None:\n                    return False\n                if val.match(value) is None:\n                    return False\n\n        return True"
    },
    {
      "chunk_id": 404,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class AcceptPredicate:\n    def __init__(self, values, config):\n        if not is_nonstr_iter(values):\n            values = (values,)\n        self.values = values\n\n    def text(self):\n        return 'accept = {}'.format(', '.join(self.values))\n\n    phash = text\n\n    def __call__(self, context, request):\n        return bool(request.accept.acceptable_offers(self.values))"
    },
    {
      "chunk_id": 405,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class ContainmentPredicate:\n    def __init__(self, val, config):\n        self.val = config.maybe_dotted(val)\n\n    def text(self):\n        return f'containment = {self.val}'\n\n    phash = text\n\n    def __call__(self, context, request):\n        ctx = getattr(request, 'context', context)\n        return find_interface(ctx, self.val) is not None"
    },
    {
      "chunk_id": 406,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class RequestTypePredicate:\n    def __init__(self, val, config):\n        self.val = val\n\n    def text(self):\n        return f'request_type = {self.val}'\n\n    phash = text\n\n    def __call__(self, context, request):\n        return self.val.providedBy(request)"
    },
    {
      "chunk_id": 407,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class MatchParamPredicate:\n    def __init__(self, val, config):\n        val = as_sorted_tuple(val)\n        self.val = val\n        reqs = [p.split('=', 1) for p in val]\n        self.reqs = [(x.strip(), y.strip()) for x, y in reqs]\n\n    def text(self):\n        return 'match_param %s' % ','.join([f'{x}={y}' for x, y in self.reqs])\n\n    phash = text\n\n    def __call__(self, context, request):\n        if not request.matchdict:\n            # might be None\n            return False\n        for k, v in self.reqs:\n            if request.matchdict.get(k) != v:\n                return False\n        return True"
    },
    {
      "chunk_id": 408,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class CustomPredicate:\n    def __init__(self, func, config):\n        self.func = func\n\n    def text(self):\n        return getattr(\n            self.func,\n            '__text__',\n            'custom predicate: %s' % object_description(self.func),\n        )\n\n    def phash(self):\n        # using hash() here rather than id() is intentional: we\n        # want to allow custom predicates that are part of\n        # frameworks to be able to define custom __hash__\n        # functions for custom predicates, so that the hash output\n        # of predicate instances which are \"logically the same\"\n        # may compare equal.\n        return 'custom:%r' % hash(self.func)\n\n    def __call__(self, context, request):\n        return self.func(context, request)"
    },
    {
      "chunk_id": 409,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class TraversePredicate:\n    # Can only be used as a *route* \"predicate\"; it adds 'traverse' to the\n    # matchdict if it's specified in the routing args.  This causes the\n    # ResourceTreeTraverser to use the resolved traverse pattern as the\n    # traversal path.\n    def __init__(self, val, config):\n        _, self.tgenerate = _compile_route(val)\n        self.val = val\n\n    def text(self):\n        return 'traverse matchdict pseudo-predicate'\n\n    def phash(self):\n        # This isn't actually a predicate, it's just a infodict modifier that\n        # injects ``traverse`` into the matchdict.  As a result, we don't\n        # need to update the hash.\n        return ''\n\n    def __call__(self, context, request):\n        if 'traverse' in context:\n            return True\n        m = context['match']\n        tvalue = self.tgenerate(m)  # tvalue will be urlquoted string\n        m['traverse'] = traversal_path(tvalue)\n        # This isn't actually a predicate, it's just a infodict modifier that\n        # injects ``traverse`` into the matchdict.  As a result, we just\n        # return True.\n        return True"
    },
    {
      "chunk_id": 410,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class PhysicalPathPredicate:\n    def __init__(self, val, config):\n        if is_nonstr_iter(val):\n            self.val = tuple(val)\n        else:\n            val = tuple(filter(None, val.split('/')))\n            self.val = ('',) + val\n\n    def text(self):\n        return f'physical_path = {self.val}'\n\n    phash = text\n\n    def __call__(self, context, request):\n        if getattr(context, '__name__', _marker) is not _marker:\n            return resource_path_tuple(context) == self.val\n        return False"
    },
    {
      "chunk_id": 411,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class IsAuthenticatedPredicate:\n    def __init__(self, val, config):\n        self.val = val\n\n    def text(self):\n        return f\"is_authenticated = {self.val!r}\"\n\n    phash = text\n\n    def __call__(self, context, request):\n        return request.is_authenticated == self.val"
    },
    {
      "chunk_id": 412,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class EffectivePrincipalsPredicate:\n    def __init__(self, val, config):\n        if is_nonstr_iter(val):\n            self.val = set(val)\n        else:\n            self.val = {val}\n\n    def text(self):\n        return 'effective_principals = %s' % sorted(list(self.val))\n\n    phash = text\n\n    def __call__(self, context, request):\n        req_principals = request.effective_principals\n        if is_nonstr_iter(req_principals):\n            rpset = set(req_principals)\n            if self.val.issubset(rpset):\n                return True\n        return False"
    },
    {
      "chunk_id": 413,
      "source": "__internal__/data_repo/pyramid/src/pyramid/predicates.py",
      "content": "class Notted:\n    def __init__(self, predicate):\n        self.predicate = predicate\n\n    def _notted_text(self, val):\n        # if the underlying predicate doesnt return a value, it's not really\n        # a predicate, it's just something pretending to be a predicate,\n        # so dont update the hash\n        if val:\n            val = '!' + val\n        return val\n\n    def text(self):\n        return self._notted_text(self.predicate.text())\n\n    def phash(self):\n        return self._notted_text(self.predicate.phash())\n\n    def __call__(self, context, request):\n        result = self.predicate(context, request)\n        phash = self.phash()\n        if phash:\n            result = not result\n        return result"
    },
    {
      "chunk_id": 414,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "import warnings\nfrom zope.interface import implementer\n\nfrom pyramid.interfaces import IAuthorizationPolicy\nfrom pyramid.location import lineage\nfrom pyramid.util import is_nonstr_iter\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore')\n    from pyramid.security import (\n        ACLAllowed as _ACLAllowed,\n        ACLDenied as _ACLDenied,\n        Allow,\n        AllPermissionsList as _AllPermissionsList,\n        Authenticated,\n        Deny,\n        Everyone,\n    )"
    },
    {
      "chunk_id": 415,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "Everyone = Everyone  # api\nAuthenticated = Authenticated  # api\nAllow = Allow  # api\nDeny = Deny  # api"
    },
    {
      "chunk_id": 416,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "class AllPermissionsList(_AllPermissionsList):\n    pass"
    },
    {
      "chunk_id": 417,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "class ACLAllowed(_ACLAllowed):\n    pass"
    },
    {
      "chunk_id": 418,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "class ACLDenied(_ACLDenied):\n    pass"
    },
    {
      "chunk_id": 419,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "ALL_PERMISSIONS = AllPermissionsList()  # api\nDENY_ALL = (Deny, Everyone, ALL_PERMISSIONS)  # api"
    },
    {
      "chunk_id": 420,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "@implementer(IAuthorizationPolicy)\nclass ACLAuthorizationPolicy:\n    \"\"\"An :term:`authorization policy` which consults an :term:`ACL`\n    object attached to a :term:`context` to determine authorization\n    information about a :term:`principal` or multiple principals.\n    This class is a wrapper around :class:`.ACLHelper`, refer to that class for\n    more detailed documentation.\n\n    Objects of this class implement the\n    :class:`pyramid.interfaces.IAuthorizationPolicy` interface.\n\n    .. deprecated:: 2.0\n\n        Authorization policies have been deprecated by the new security system.\n        See :ref:`upgrading_auth_20` for more information.\n\n    \"\"\"\n\n    def __init__(self):\n        self.helper = ACLHelper()"
    },
    {
      "chunk_id": 421,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "def permits(self, context, principals, permission):\n        \"\"\"Return an instance of\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\n        permits access, return an instance of\n        :class:`pyramid.authorization.ACLDenied` if not.\"\"\"\n        return self.helper.permits(context, principals, permission)"
    },
    {
      "chunk_id": 422,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "def principals_allowed_by_permission(self, context, permission):\n        \"\"\"Return the set of principals explicitly granted the\n        permission named ``permission`` according to the ACL directly\n        attached to the ``context`` as well as inherited ACLs based on\n        the :term:`lineage`.\"\"\"\n        return self.helper.principals_allowed_by_permission(\n            context, permission\n        )"
    },
    {
      "chunk_id": 423,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "class ACLHelper:\n    \"\"\"A helper for use with constructing a :term:`security policy` which\n    consults an :term:`ACL` object attached to a :term:`context` to determine\n    authorization information about a :term:`principal` or multiple principals.\n    If the context is part of a :term:`lineage`, the context's parents are\n    consulted for ACL information too.\n\n    \"\"\""
    },
    {
      "chunk_id": 424,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "def permits(self, context, principals, permission):\n        \"\"\"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\n        the ACL allows access a user with the given principals, return an\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\n\n        When checking if principals are allowed, the security policy consults\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\n        one does exist but the ACL does not explicitly allow or deny access for\n        any of the effective principals, consult the context's parent ACL, and\n        so on, until the lineage is exhausted or we determine that the policy\n        permits or denies.\n\n        During this processing, if any :data:`pyramid.authorization.Deny`\n        ACE is found matching any principal in ``principals``, stop\n        processing by returning an\n        :class:`pyramid.authorization.ACLDenied` instance (equals\n        ``False``) immediately.  If any\n        :data:`pyramid.authorization.Allow` ACE is found matching any\n        principal, stop processing by returning an\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\n        ``True``) immediately.  If we exhaust the context's\n        :term:`lineage`, and no ACE has explicitly permitted or denied\n        access, return an instance of\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\n\n        \"\"\"\n        acl = '<No ACL found on any object in resource lineage>'\n\n        for location in lineage(context):\n            try:\n                acl = location.__acl__\n            except AttributeError:\n                continue\n\n            if acl and callable(acl):\n                acl = acl()\n\n            for ace in acl:\n                ace_action, ace_principal, ace_permissions = ace\n                if ace_principal in principals:\n                    if not is_nonstr_iter(ace_permissions):\n                        ace_permissions = [ace_permissions]\n                    if permission in ace_permissions:\n                        if ace_action == Allow:\n                            return ACLAllowed(\n                                ace, acl, permission, principals, location\n                            )\n                        else:\n                            return ACLDenied(\n                                ace, acl, permission, principals, location\n                            )\n\n        return ACLDenied(\n            '<default deny>', acl, permission, principals, context\n        )"
    },
    {
      "chunk_id": 425,
      "source": "__internal__/data_repo/pyramid/src/pyramid/authorization.py",
      "content": "def principals_allowed_by_permission(self, context, permission):\n        \"\"\"Return the set of principals explicitly granted the permission\n        named ``permission`` according to the ACL directly attached to the\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\n\n        When computing principals allowed by a permission, we compute the set\n        of principals that are explicitly granted the ``permission`` in the\n        provided ``context``.  We do this by walking 'up' the object graph\n        *from the root* to the context.  During this walking process, if we\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\n        principal that matches the ``permission``, the principal is included in\n        the allow list.  However, if later in the walking process that\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\n        for the permission, the principal is removed from the allow list.  If\n        a :data:`pyramid.authorization.Deny` to the principal\n        :data:`pyramid.authorization.Everyone` is encountered during the\n        walking process that matches the ``permission``, the allow list is\n        cleared for all principals encountered in previous ACLs.  The walking\n        process ends after we've processed the any ACL directly attached to\n        ``context``; a set of principals is returned.\n\n        \"\"\"\n        allowed = set()\n\n        for location in reversed(list(lineage(context))):\n            try:\n                acl = location.__acl__\n            except AttributeError:\n                continue\n\n            allowed_here = set()\n            denied_here = set()\n\n            if acl and callable(acl):\n                acl = acl()\n\n            for ace_action, ace_principal, ace_permissions in acl:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if (ace_action == Allow) and (permission in ace_permissions):\n                    if ace_principal not in denied_here:\n                        allowed_here.add(ace_principal)\n                if (ace_action == Deny) and (permission in ace_permissions):\n                    denied_here.add(ace_principal)\n                    if ace_principal == Everyone:\n                        allowed = set()\n                        break\n                    elif ace_principal in allowed:\n                        allowed.remove(ace_principal)\n\n            allowed.update(allowed_here)\n\n        return allowed"
    },
    {
      "chunk_id": 426,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "```python"
    },
    {
      "chunk_id": 427,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "import json\nfrom string import Template\nfrom webob import html_escape as _html_escape\nfrom webob.acceptparse import create_accept_header\nfrom zope.interface import implementer\n\nfrom pyramid.interfaces import IExceptionResponse\nfrom pyramid.response import Response\nfrom pyramid.util import text_"
    },
    {
      "chunk_id": 428,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def _no_escape(value):\n    if value is None:\n        return ''\n    if not isinstance(value, str):\n        if isinstance(value, bytes):\n            value = text_(value, 'utf-8')\n        else:\n            value = str(value)\n    return value"
    },
    {
      "chunk_id": 429,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "@implementer(IExceptionResponse)\nclass HTTPException(Response, Exception):\n    code = 520\n    title = 'Unknown Error'\n    explanation = ''\n    body_template_obj = Template(\n        '''\\\n${explanation}${br}${br}\n${detail}\n${html_comment}\n'''\n    )\n\n    plain_template_obj = Template(\n        '''\\\n${status}\n\n${body}'''\n    )\n\n    html_template_obj = Template(\n        '''\\\n<html>\n <head>\n  <title>${status}</title>\n </head>\n <body>\n  <h1>${status}</h1>\n  ${body}\n </body>\n</html>'''\n    )\n\n    empty_body = False\n\n    def __init__(\n        self,\n        detail=None,\n        headers=None,\n        comment=None,\n        body_template=None,\n        json_formatter=None,\n        **kw,\n    ):\n        status = f'{self.code} {self.title}'\n        Response.__init__(self, status=status, **kw)\n        Exception.__init__(self, detail)\n        self.detail = self.message = detail\n        if headers:\n            self.headers.extend(headers)\n        self.comment = comment\n        if body_template is not None:\n            self.body_template = body_template\n            self.body_template_obj = Template(body_template)\n        if json_formatter is not None:\n            self._json_formatter = json_formatter\n\n        if self.empty_body:\n            del self.content_type\n            del self.content_length"
    },
    {
      "chunk_id": 430,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def __str__(self):\n        return str(self.detail) if self.detail else self.explanation"
    },
    {
      "chunk_id": 431,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def _json_formatter(self, status, body, title, environ):\n        return {'message': body, 'code': status, 'title': self.title}"
    },
    {
      "chunk_id": 432,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def prepare(self, environ):\n        if not self.has_body and not self.empty_body:\n            html_comment = ''\n            comment = self.comment or ''\n            accept_value = environ.get('HTTP_ACCEPT', '')\n            accept = create_accept_header(accept_value)\n            acceptable = accept.acceptable_offers(\n                ['text/html', 'application/json']\n            )\n            acceptable = [offer[0] for offer in acceptable] + ['text/plain']\n            match = acceptable[0]\n\n            if match == 'text/html':\n                self.content_type = 'text/html'\n                escape = _html_escape\n                page_template = self.html_template_obj\n                br = '<br/>'\n                if comment:\n                    html_comment = '<!-- %s -->' % escape(comment)\n            elif match == 'application/json':\n                self.content_type = 'application/json'\n                self.charset = None\n                escape = _no_escape\n                br = '\\n'\n                if comment:\n                    html_comment = escape(comment)\n\n                class JsonPageTemplate:\n                    def __init__(self, excobj):\n                        self.excobj = excobj\n\n                    def substitute(self, status, body):\n                        jsonbody = self.excobj._json_formatter(\n                            status=status,\n                            body=body,\n                            title=self.excobj.title,\n                            environ=environ,\n                        )\n                        return json.dumps(jsonbody)\n\n                page_template = JsonPageTemplate(self)\n            else:\n                self.content_type = 'text/plain'\n                escape = _no_escape\n                page_template = self.plain_template_obj\n                br = '\\n'\n                if comment:\n                    html_comment = escape(comment)\n            args = {\n                'br': br,\n                'explanation': escape(self.explanation),\n                'detail': escape(self.detail or ''),\n                'comment': escape(comment),\n                'html_comment': html_comment,\n            }\n            body_tmpl = self.body_template_obj\n            if HTTPException.body_template_obj is not body_tmpl:\n                for k, v in environ.items():\n                    if (not k.startswith('wsgi.')) and ('.' in k):\n                        continue\n                    args[k] = escape(v)\n                for k, v in self.headers.items():\n                    args[k.lower()] = escape(v)\n            body = body_tmpl.substitute(args)\n            page = page_template.substitute(status=self.status, body=body)\n            if isinstance(page, str):\n                page = page.encode(self.charset if self.charset else 'UTF-8')\n            self.app_iter = [page]\n            self.body = page"
    },
    {
      "chunk_id": 433,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "@property\n    def wsgi_response(self):\n        return self\n\n    exception = wsgi_response"
    },
    {
      "chunk_id": 434,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def __call__(self, environ, start_response):\n        self.prepare(environ)\n        return Response.__call__(self, environ, start_response)"
    },
    {
      "chunk_id": 435,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "WSGIHTTPException = HTTPException"
    },
    {
      "chunk_id": 436,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPError(HTTPException):\n    \"\"\"base class for exceptions with status codes in the 400s and 500s\"\"\""
    },
    {
      "chunk_id": 437,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRedirection(HTTPException):\n    \"\"\"base class for exceptions with status codes in the 300s (redirections)\"\"\""
    },
    {
      "chunk_id": 438,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPSuccessful(HTTPException):\n    \"\"\"Base class for exceptions with status codes in the 200s (successful responses)\"\"\""
    },
    {
      "chunk_id": 439,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPOk(HTTPSuccessful):\n    code = 200\n    title = 'OK'"
    },
    {
      "chunk_id": 440,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPCreated(HTTPSuccessful):\n    code = 201\n    title = 'Created'"
    },
    {
      "chunk_id": 441,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPAccepted(HTTPSuccessful):\n    code = 202\n    title = 'Accepted'\n    explanation = 'The request is accepted for processing.'"
    },
    {
      "chunk_id": 442,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNonAuthoritativeInformation(HTTPSuccessful):\n    code = 203\n    title = 'Non-Authoritative Information'"
    },
    {
      "chunk_id": 443,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNoContent(HTTPSuccessful):\n    code = 204\n    title = 'No Content'\n    empty_body = True"
    },
    {
      "chunk_id": 444,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPResetContent(HTTPSuccessful):\n    code = 205\n    title = 'Reset Content'\n    empty_body = True"
    },
    {
      "chunk_id": 445,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPPartialContent(HTTPSuccessful):\n    code = 206\n    title = 'Partial Content'"
    },
    {
      "chunk_id": 446,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class _HTTPMove(HTTPRedirection):\n    explanation = 'The resource has been moved to'\n    body_template_obj = Template(\n        '''\\\n${explanation} ${location}; you should be redirected automatically.\n${detail}\n${html_comment}'''\n    )\n\n    def __init__(\n        self,\n        location='',\n        detail=None,\n        headers=None,\n        comment=None,\n        body_template=None,\n        **kw,\n    ):\n        if location is None:\n            raise ValueError(\"HTTP redirects need a location to redirect to.\")\n        super().__init__(\n            detail=detail,\n            headers=headers,\n            comment=comment,\n            body_template=body_template,\n            location=location,\n            **kw,\n        )"
    },
    {
      "chunk_id": 447,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPMultipleChoices(_HTTPMove):\n    code = 300\n    title = 'Multiple Choices'"
    },
    {
      "chunk_id": 448,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPMovedPermanently(_HTTPMove):\n    code = 301\n    title = 'Moved Permanently'"
    },
    {
      "chunk_id": 449,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPFound(_HTTPMove):\n    code = 302\n    title = 'Found'\n    explanation = 'The resource was found at'"
    },
    {
      "chunk_id": 450,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPSeeOther(_HTTPMove):\n    code = 303\n    title = 'See Other'"
    },
    {
      "chunk_id": 451,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNotModified(HTTPRedirection):\n    code = 304\n    title = 'Not Modified'\n    empty_body = True"
    },
    {
      "chunk_id": 452,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPUseProxy(_HTTPMove):\n    code = 305\n    title = 'Use Proxy'\n    explanation = 'The resource must be accessed through a proxy located at'"
    },
    {
      "chunk_id": 453,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPTemporaryRedirect(_HTTPMove):\n    code = 307\n    title = 'Temporary Redirect'"
    },
    {
      "chunk_id": 454,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPPermanentRedirect(_HTTPMove):\n    code = 308\n    title = 'Permanent Redirect'"
    },
    {
      "chunk_id": 455,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPClientError(HTTPError):\n    code = 400\n    title = 'Bad Request'"
    },
    {
      "chunk_id": 456,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPBadRequest(HTTPClientError):\n    explanation = (\n        'The server could not comply with the request since '\n        'it is either malformed or otherwise incorrect.'\n    )"
    },
    {
      "chunk_id": 457,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPUnauthorized(HTTPClientError):\n    code = 401\n    title = 'Unauthorized'\n    explanation = (\n        'This server could not verify that you are authorized to '\n        'access the document you requested.  Either you supplied the '\n        'wrong credentials (e.g., bad password), or your browser '\n        'does not understand how to supply the credentials required.'\n    )"
    },
    {
      "chunk_id": 458,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPPaymentRequired(HTTPClientError):\n    code = 402\n    title = 'Payment Required'\n    explanation = 'Access was denied for financial reasons.'"
    },
    {
      "chunk_id": 459,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPForbidden(HTTPClientError):\n    code = 403\n    title = 'Forbidden'\n    explanation = 'Access was denied to this resource.'\n\n    def __init__(\n        self,\n        detail=None,\n        headers=None,\n        comment=None,\n        body_template=None,\n        result=None,\n        **kw,\n    ):\n        HTTPClientError.__init__(\n            self,\n            detail=detail,\n            headers=headers,\n            comment=comment,\n            body_template=body_template,\n            **kw,\n        )\n        self.result = result"
    },
    {
      "chunk_id": 460,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNotFound(HTTPClientError):\n    code = 404\n    title = 'Not Found'\n    explanation = 'The resource could not be found.'"
    },
    {
      "chunk_id": 461,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPMethodNotAllowed(HTTPClientError):\n    code = 405\n    title = 'Method Not Allowed'\n    body_template_obj = Template(\n        '''\\\nThe method ${REQUEST_METHOD} is not allowed for this resource. ${br}${br}\n${detail}'''\n    )"
    },
    {
      "chunk_id": 462,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNotAcceptable(HTTPClientError):\n    code = 406\n    title = 'Not Acceptable'"
    },
    {
      "chunk_id": 463,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPProxyAuthenticationRequired(HTTPClientError):\n    code = 407\n    title = 'Proxy Authentication Required'\n    explanation = 'Authentication with a local proxy is needed.'"
    },
    {
      "chunk_id": 464,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRequestTimeout(HTTPClientError):\n    code = 408\n    title = 'Request Timeout'\n    explanation = (\n        'The server has waited too long for the request to '\n        'be sent by the client.'\n    )"
    },
    {
      "chunk_id": 465,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPConflict(HTTPClientError):\n    code = 409\n    title = 'Conflict'\n    explanation = 'There was a conflict when trying to complete your request.'"
    },
    {
      "chunk_id": 466,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPGone(HTTPClientError):\n    code = 410\n    title = 'Gone'\n    explanation = (\n        'This resource is no longer available.  No forwarding '\n        'address is given.'\n    )"
    },
    {
      "chunk_id": 467,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPLengthRequired(HTTPClientError):\n    code = 411\n    title = 'Length Required'\n    explanation = 'Content-Length header required.'"
    },
    {
      "chunk_id": 468,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPPreconditionFailed(HTTPClientError):\n    code = 412\n    title = 'Precondition Failed'\n    explanation = 'Request precondition failed.'"
    },
    {
      "chunk_id": 469,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRequestEntityTooLarge(HTTPClientError):\n    code = 413\n    title = 'Request Entity Too Large'\n    explanation = 'The body of your request was too large for this server.'"
    },
    {
      "chunk_id": 470,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRequestURITooLong(HTTPClientError):\n    code = 414\n    title = 'Request-URI Too Long'\n    explanation = 'The request URI was too long for this server.'"
    },
    {
      "chunk_id": 471,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPUnsupportedMediaType(HTTPClientError):\n    code = 415\n    title = 'Unsupported Media Type'"
    },
    {
      "chunk_id": 472,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRequestRangeNotSatisfiable(HTTPClientError):\n    code = 416\n    title = 'Request Range Not Satisfiable'\n    explanation = 'The Range requested is not available.'"
    },
    {
      "chunk_id": 473,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPExpectationFailed(HTTPClientError):\n    code = 417\n    title = 'Expectation Failed'\n    explanation = 'Expectation failed.'"
    },
    {
      "chunk_id": 474,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPImATeapot(HTTPClientError):\n    code = 418\n    title = \"I'm a teapot\"\n    explanation = \"Refusing to brew coffee because I'm a teapot.\""
    },
    {
      "chunk_id": 475,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPUnprocessableEntity(HTTPClientError):\n    code = 422\n    title = 'Unprocessable Entity'\n    explanation = 'Unable to process the contained instructions'"
    },
    {
      "chunk_id": 476,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPLocked(HTTPClientError):\n    code = 423\n    title = 'Locked'\n    explanation = 'The resource is locked'"
    },
    {
      "chunk_id": 477,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPFailedDependency(HTTPClientError):\n    code = 424\n    title = 'Failed Dependency'\n    explanation = (\n        'The method could not be performed because the requested '\n        'action dependended on another action and that action failed'\n    )"
    },
    {
      "chunk_id": 478,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPPreconditionRequired(HTTPClientError):\n    code = 428\n    title = 'Precondition Required'\n    explanation = 'The origin server requires the request to be conditional.'"
    },
    {
      "chunk_id": 479,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPTooManyRequests(HTTPClientError):\n    code = 429\n    title = 'Too Many Requests'\n    explanation = (\n        'The action could not be performed because there were too '\n        'many requests by the client.'\n    )"
    },
    {
      "chunk_id": 480,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPRequestHeaderFieldsTooLarge(HTTPClientError):\n    code = 431\n    title = 'Request Header Fields Too Large'\n    explanation = 'The requests header fields were too large.'"
    },
    {
      "chunk_id": 481,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPServerError(HTTPError):\n    code = 500\n    title = 'Internal Server Error'"
    },
    {
      "chunk_id": 482,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPInternalServerError(HTTPServerError):\n    explanation = (\n        'The server has either erred or is incapable of performing '\n        'the requested operation.'\n    )"
    },
    {
      "chunk_id": 483,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPNotImplemented(HTTPServerError):\n    code = 501\n    title = 'Not Implemented'"
    },
    {
      "chunk_id": 484,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPBadGateway(HTTPServerError):\n    code = 502\n    title = 'Bad Gateway'\n    explanation = 'Bad gateway.'"
    },
    {
      "chunk_id": 485,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPServiceUnavailable(HTTPServerError):\n    code = 503\n    title = 'Service Unavailable'\n    explanation = (\n        'The server is currently unavailable. '\n        'Please try again at a later time.'\n    )"
    },
    {
      "chunk_id": 486,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPGatewayTimeout(HTTPServerError):\n    code = 504\n    title = 'Gateway Timeout'\n    explanation = 'The gateway has timed out.'"
    },
    {
      "chunk_id": 487,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPVersionNotSupported(HTTPServerError):\n    code = 505\n    title = 'HTTP Version Not Supported'\n    explanation = 'The HTTP version is not supported.'"
    },
    {
      "chunk_id": 488,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "class HTTPInsufficientStorage(HTTPServerError):\n    code = 507\n    title = 'Insufficient Storage'\n    explanation = 'There was not enough space to save the resource'"
    },
    {
      "chunk_id": 489,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def exception_response(status_code, **kw):\n    \"\"\"Creates an HTTP exception based on a status code. Example::\n\n        raise exception_response(404) # raises an HTTPNotFound exception.\n\n    The values passed as ``kw`` are provided to the exception's constructor.\n    \"\"\"\n    exc = status_map[status_code](**kw)\n    return exc"
    },
    {
      "chunk_id": 490,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "def default_exceptionresponse_view(context, request):\n    if not isinstance(context, Exception):\n        context = request.exception or context\n    return context"
    },
    {
      "chunk_id": 491,
      "source": "__internal__/data_repo/pyramid/src/pyramid/httpexceptions.py",
      "content": "status_map = {}\ncode = None\nfor name, value in list(globals().items()):\n    if (\n        isinstance(value, type)\n        and issubclass(value, HTTPException)\n        and value not in {HTTPClientError, HTTPServerError}\n        and not name.startswith('_')\n    ):\n        code = getattr(value, 'code', None)\n        if code:\n            status_map[code] = value\ndel name, value, code\n```"
    },
    {
      "chunk_id": 492,
      "source": "__internal__/data_repo/pyramid/src/pyramid/settings.py",
      "content": "truthy = frozenset(('t', 'true', 'y', 'yes', 'on', '1'))\nfalsey = frozenset(('f', 'false', 'n', 'no', 'off', '0'))"
    },
    {
      "chunk_id": 493,
      "source": "__internal__/data_repo/pyramid/src/pyramid/settings.py",
      "content": "def asbool(s):\n    \"\"\"Return the boolean value ``True`` if the case-lowered value of string\n    input ``s`` is a :term:`truthy string`. If ``s`` is already one of the\n    boolean values ``True`` or ``False``, return it.\"\"\"\n    if s is None:\n        return False\n    if isinstance(s, bool):\n        return s\n    s = str(s).strip()\n    return s.lower() in truthy"
    },
    {
      "chunk_id": 494,
      "source": "__internal__/data_repo/pyramid/src/pyramid/settings.py",
      "content": "def aslist_cronly(value):\n    if isinstance(value, str):\n        value = filter(None, [x.strip() for x in value.splitlines()])\n    return list(value)"
    },
    {
      "chunk_id": 495,
      "source": "__internal__/data_repo/pyramid/src/pyramid/settings.py",
      "content": "def aslist(value, flatten=True):\n    \"\"\"Return a list, separating the input based on newlines.\n    Also if ``flatten`` is ``True`` (the default), and if the line\n    is a string, then the line will be split on spaces.\n    \"\"\"\n    values = aslist_cronly(value)\n    if not flatten:\n        return values\n    result = []\n    for value in values:\n        if isinstance(value, str):\n            value = value.split()\n            result.extend(value)\n        else:\n            result.append(value)\n    return result"
    },
    {
      "chunk_id": 496,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "from urllib.parse import urlparse\nimport uuid\nfrom webob.cookies import CookieProfile\nfrom zope.interface import implementer\n\nfrom pyramid.exceptions import BadCSRFOrigin, BadCSRFToken\nfrom pyramid.interfaces import ICSRFStoragePolicy\nfrom pyramid.settings import aslist\nfrom pyramid.util import (\n    SimpleSerializer,\n    bytes_,\n    is_same_domain,\n    strings_differ,\n    text_,\n)"
    },
    {
      "chunk_id": 497,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "@implementer(ICSRFStoragePolicy)\nclass LegacySessionCSRFStoragePolicy:\n    \"\"\"A CSRF storage policy that defers control of CSRF storage to the\n    session.\n\n    This policy maintains compatibility with legacy ISession implementations\n    that know how to manage CSRF tokens themselves via\n    ``ISession.new_csrf_token`` and ``ISession.get_csrf_token``.\n\n    Note that using this CSRF implementation requires that\n    a :term:`session factory` is configured.\n\n    .. versionadded:: 1.9\n\n    \"\"\"\n\n    def new_csrf_token(self, request):\n        \"\"\"Sets a new CSRF token into the session and returns it.\"\"\"\n        return request.session.new_csrf_token()\n\n    def get_csrf_token(self, request):\n        \"\"\"Returns the currently active CSRF token from the session,\n        generating a new one if needed.\"\"\"\n        return request.session.get_csrf_token()\n\n    def check_csrf_token(self, request, supplied_token):\n        \"\"\"Returns ``True`` if the ``supplied_token`` is valid.\"\"\"\n        expected_token = self.get_csrf_token(request)\n        return not strings_differ(\n            bytes_(expected_token), bytes_(supplied_token)\n        )"
    },
    {
      "chunk_id": 498,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "@implementer(ICSRFStoragePolicy)\nclass SessionCSRFStoragePolicy:\n    \"\"\"A CSRF storage policy that persists the CSRF token in the session.\n\n    Note that using this CSRF implementation requires that\n    a :term:`session factory` is configured.\n\n    ``key``\n\n        The session key where the CSRF token will be stored.\n        Default: `_csrft_`.\n\n    .. versionadded:: 1.9\n\n    \"\"\"\n\n    _token_factory = staticmethod(lambda: text_(uuid.uuid4().hex))\n\n    def __init__(self, key='_csrft_'):\n        self.key = key\n\n    def new_csrf_token(self, request):\n        \"\"\"Sets a new CSRF token into the session and returns it.\"\"\"\n        token = self._token_factory()\n        request.session[self.key] = token\n        return token\n\n    def get_csrf_token(self, request):\n        \"\"\"Returns the currently active CSRF token from the session,\n        generating a new one if needed.\"\"\"\n        token = request.session.get(self.key, None)\n        if not token:\n            token = self.new_csrf_token(request)\n        return token\n\n    def check_csrf_token(self, request, supplied_token):\n        \"\"\"Returns ``True`` if the ``supplied_token`` is valid.\"\"\"\n        expected_token = self.get_csrf_token(request)\n        return not strings_differ(\n            bytes_(expected_token), bytes_(supplied_token)\n        )"
    },
    {
      "chunk_id": 499,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "@implementer(ICSRFStoragePolicy)\nclass CookieCSRFStoragePolicy:\n    \"\"\"An alternative CSRF implementation that stores its information in\n    unauthenticated cookies, known as the 'Double Submit Cookie' method in the\n    `OWASP CSRF guidelines\n    <https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie>`_.\n    This gives some additional flexibility with\n    regards to scaling as the tokens can be generated and verified by a\n    front-end server.\n\n    .. versionadded:: 1.9\n\n    .. versionchanged: 1.10\n\n       Added the ``samesite`` option and made the default ``'Lax'``.\n\n    \"\"\"\n\n    _token_factory = staticmethod(lambda: text_(uuid.uuid4().hex))\n\n    def __init__(\n        self,\n        cookie_name='csrf_token',\n        secure=False,\n        httponly=False,\n        domain=None,\n        max_age=None,\n        path='/',\n        samesite='Lax',\n    ):\n        self.cookie_profile = CookieProfile(\n            cookie_name=cookie_name,\n            secure=secure,\n            max_age=max_age,\n            httponly=httponly,\n            path=path,\n            domains=[domain],\n            serializer=SimpleSerializer(),\n            samesite=samesite,\n        )\n        self.cookie_name = cookie_name\n\n    def new_csrf_token(self, request):\n        \"\"\"Sets a new CSRF token into the request and returns it.\"\"\"\n        token = self._token_factory()\n        request.cookies[self.cookie_name] = token\n\n        def set_cookie(request, response):\n            self.cookie_profile.set_cookies(response, token)\n\n        request.add_response_callback(set_cookie)\n        return token\n\n    def get_csrf_token(self, request):\n        \"\"\"Returns the currently active CSRF token by checking the cookies\n        sent with the current request.\"\"\"\n        bound_cookies = self.cookie_profile.bind(request)\n        token = bound_cookies.get_value()\n        if not token:\n            token = self.new_csrf_token(request)\n        return token\n\n    def check_csrf_token(self, request, supplied_token):\n        \"\"\"Returns ``True`` if the ``supplied_token`` is valid.\"\"\"\n        expected_token = self.get_csrf_token(request)\n        return not strings_differ(\n            bytes_(expected_token), bytes_(supplied_token)\n        )"
    },
    {
      "chunk_id": 500,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "def get_csrf_token(request):\n    \"\"\"Get the currently active CSRF token for the request passed, generating\n    a new one using ``new_csrf_token(request)`` if one does not exist. This\n    calls the equivalent method in the chosen CSRF protection implementation.\n\n    .. versionadded :: 1.9\n\n    \"\"\"\n    registry = request.registry\n    csrf = registry.getUtility(ICSRFStoragePolicy)\n    return csrf.get_csrf_token(request)"
    },
    {
      "chunk_id": 501,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "def new_csrf_token(request):\n    \"\"\"Generate a new CSRF token for the request passed and persist it in an\n    implementation defined manner. This calls the equivalent method in the\n    chosen CSRF protection implementation.\n\n    .. versionadded :: 1.9\n\n    \"\"\"\n    registry = request.registry\n    csrf = registry.getUtility(ICSRFStoragePolicy)\n    return csrf.new_csrf_token(request)"
    },
    {
      "chunk_id": 502,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "def check_csrf_token(\n    request, token='csrf_token', header='X-CSRF-Token', raises=True\n):\n    \"\"\"Check the CSRF token returned by the\n    :class:`pyramid.interfaces.ICSRFStoragePolicy` implementation against the\n    value in ``request.POST.get(token)`` (if a POST request) or\n    ``request.headers.get(header)``. If a ``token`` keyword is not supplied to\n    this function, the string ``csrf_token`` will be used to look up the token\n    in ``request.POST``. If a ``header`` keyword is not supplied to this\n    function, the string ``X-CSRF-Token`` will be used to look up the token in\n    ``request.headers``.\n\n    If the value supplied by post or by header cannot be verified by the\n    :class:`pyramid.interfaces.ICSRFStoragePolicy`, and ``raises`` is\n    ``True``, this function will raise an\n    :exc:`pyramid.exceptions.BadCSRFToken` exception. If the values differ\n    and ``raises`` is ``False``, this function will return ``False``.  If the\n    CSRF check is successful, this function will return ``True``\n    unconditionally.\n\n    See :ref:`auto_csrf_checking` for information about how to secure your\n    application automatically against CSRF attacks.\n\n    .. versionadded:: 1.4a2\n\n    .. versionchanged:: 1.7a1\n       A CSRF token passed in the query string of the request is no longer\n       considered valid. It must be passed in either the request body or\n       a header.\n\n    .. versionchanged:: 1.9\n       Moved from :mod:`pyramid.session` to :mod:`pyramid.csrf` and updated\n       to use the configured :class:`pyramid.interfaces.ICSRFStoragePolicy` to\n       verify the CSRF token.\n\n    \"\"\"\n    supplied_token = \"\"\n    # We first check the headers for a csrf token, as that is significantly\n    # cheaper than checking the POST body\n    if header is not None:\n        supplied_token = request.headers.get(header, \"\")\n\n    # If this is a POST/PUT/etc request, then we'll check the body to see if it\n    # has a token. We explicitly use request.POST here because CSRF tokens\n    # should never appear in an URL as doing so is a security issue. We also\n    # explicitly check for request.POST here as we do not support sending form\n    # encoded data over anything but a request.POST.\n    if supplied_token == \"\" and token is not None:\n        supplied_token = request.POST.get(token, \"\")\n\n    policy = request.registry.getUtility(ICSRFStoragePolicy)\n    if not policy.check_csrf_token(request, text_(supplied_token)):\n        if raises:\n            raise BadCSRFToken('check_csrf_token(): Invalid token')\n        return False\n    return True"
    },
    {
      "chunk_id": 503,
      "source": "__internal__/data_repo/pyramid/src/pyramid/csrf.py",
      "content": "def check_csrf_origin(\n    request, *, trusted_origins=None, allow_no_origin=False, raises=True\n):\n    \"\"\"\n    Check the ``Origin`` of the request to see if it is a cross site request or\n    not.\n\n    If the value supplied by the ``Origin`` or ``Referer`` header isn't one of\n    the trusted origins and ``raises`` is ``True``, this function will raise a\n    :exc:`pyramid.exceptions.BadCSRFOrigin` exception, but if ``raises`` is\n    ``False``, this function will return ``False`` instead. If the CSRF origin\n    checks are successful this function will return ``True`` unconditionally.\n\n    Additional trusted origins may be added by passing a list of domain (and\n    ports if non-standard like ``['example.com', 'dev.example.com:8080']``) in\n    with the ``trusted_origins`` parameter. If ``trusted_origins`` is ``None``\n    (the default) this list of additional domains will be pulled from the\n    ``pyramid.csrf_trusted_origins`` setting.\n\n    ``allow_no_origin`` determines whether to return ``True`` when the\n    origin cannot be determined via either the ``Referer`` or ``Origin``\n    header. The default is ``False`` which will reject the check.\n\n    Note that this function will do nothing if ``request.scheme`` is not\n    ``https``.\n\n    .. versionadded:: 1.7\n\n    .. versionchanged:: 1.9\n       Moved from :mod:`pyramid.session` to :mod:`pyramid.csrf`\n\n    .. versionchanged:: 2.0\n       Added the ``allow_no_origin`` option.\n\n    \"\"\"\n\n    def _fail(reason):\n        if raises:\n            raise BadCSRFOrigin(\"Origin checking failed - \" + reason)\n        else:\n            return False\n\n    # Origin checks are only trustworthy / useful on HTTPS requests.\n    if request.scheme != \"https\":\n        return True\n\n    # Suppose user visits http://example.com/\n    # An active network attacker (man-in-the-middle, MITM) sends a\n    # POST form that targets https://example.com/detonate-bomb/ and\n    # submits it via JavaScript.\n    #\n    # The attacker will need to provide a CSRF cookie and token, but\n    # that's no problem for a MITM when we cannot make any assumptions\n    # about what kind of session storage is being used. So the MITM can\n    # circumvent the CSRF protection. This is true for any HTTP connection,\n    # but anyone using HTTPS expects better! For this reason, for\n    # https://example.com/ we need additional protection that treats\n    # http://example.com/ as completely untrusted. Under HTTPS,\n    # Barth et al. found that the Referer header is missing for\n    # same-domain requests in only about 0.2% of cases or less, so\n    # we can use strict Referer checking.\n\n    # Determine the origin of this request\n    origin = request.headers.get(\"Origin\")\n    origin_is_referrer = False\n    if origin is None:\n        origin = request.referrer\n        origin_is_referrer = True\n\n    else:\n        # use the last origin in the list under the assumption that the\n        # server generally appends values and we want the origin closest\n        # to us\n        origin = origin.split(' ')[-1]\n\n    # If we can't find an origin, fail or pass immediately depending on\n    # ``allow_no_origin``\n    if not origin:\n        if allow_no_origin:\n            return True\n        else:\n            return _fail(\"missing Origin or Referer.\")\n\n    # Determine which origins we trust, which by default will include the\n    # current origin.\n    if trusted_origins is None:\n        trusted_origins = aslist(\n            request.registry.settings.get(\"pyramid.csrf_trusted_origins\", [])\n        )\n\n    if request.host_port not in {\"80\", \"443\"}:\n        trusted_origins.append(\"{0.domain}:{0.host_port}\".format(request))\n    else:\n        trusted_origins.append(request.domain)\n\n    # Check \"Origin: null\" against trusted_origins\n    if not origin_is_referrer and origin == 'null':\n        if origin in trusted_origins:\n            return True\n        else:\n            return _fail(\"null does not match any trusted origins.\")\n\n    # Parse our origin so we we can extract the required information from\n    # it.\n    originp = urlparse(origin)\n\n    # Ensure that our Referer is also secure.\n    if originp.scheme != \"https\":\n        return _fail(\"Origin is insecure while host is secure.\")\n\n    # Actually check to see if the request's origin matches any of our\n    # trusted origins.\n    if not any(\n        is_same_domain(originp.netloc, host) for host in trusted_origins\n    ):\n        return _fail(f\"{origin} does not match any trusted origins.\")\n\n    return True"
    },
    {
      "chunk_id": 504,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "from functools import lru_cache\nimport json\nimport mimetypes\nimport os\nfrom os.path import exists, getmtime, getsize, isdir, join, normcase, normpath\nfrom pkg_resources import resource_exists, resource_filename, resource_isdir\nimport warnings\n\nfrom pyramid.asset import abspath_from_asset_spec, resolve_asset_spec\nfrom pyramid.httpexceptions import HTTPMovedPermanently, HTTPNotFound\nfrom pyramid.path import caller_package\nfrom pyramid.response import FileResponse, _guess_type\nfrom pyramid.traversal import traversal_path_info"
    },
    {
      "chunk_id": 505,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "class static_view:\n    \"\"\"An instance of this class is a callable which can act as a\n    :app:`Pyramid` :term:`view callable`; this view will serve\n    static files from a directory on disk based on the ``root_dir``\n    you provide to its constructor.\n\n    The directory may contain subdirectories (recursively); the static\n    view implementation will descend into these directories as\n    necessary based on the components of the URL in order to resolve a\n    path into a response.\n\n    You may pass an absolute or relative filesystem path or a\n    :term:`asset specification` representing the directory\n    containing static files as the ``root_dir`` argument to this\n    class' constructor.\n\n    If the ``root_dir`` path is relative, and the ``package_name``\n    argument is ``None``, ``root_dir`` will be considered relative to\n    the directory in which the Python file which *calls* ``static``\n    resides.  If the ``package_name`` name argument is provided, and a\n    relative ``root_dir`` is provided, the ``root_dir`` will be\n    considered relative to the Python :term:`package` specified by\n    ``package_name`` (a dotted path to a Python package).\n\n    ``cache_max_age`` influences the ``Expires`` and ``Max-Age``\n    response headers returned by the view (default is 3600 seconds or\n    one hour).\n\n    ``use_subpath`` influences whether ``request.subpath`` will be used as\n    ``PATH_INFO`` when calling the underlying WSGI application which actually\n    serves the static files.  If it is ``True``, the static application will\n    consider ``request.subpath`` as ``PATH_INFO`` input.  If it is ``False``,\n    the static application will consider request.environ[``PATH_INFO``] as\n    ``PATH_INFO`` input. By default, this is ``False``.\n\n    ``reload`` controls whether a cache of files is maintained or the asset\n    subsystem is queried per-request to determine what files are available.\n    By default, this is ``False`` and new files added while the process is\n    running are not recognized.\n\n    ``content_encodings`` is a list of alternative file encodings supported\n    in the ``Accept-Encoding`` HTTP Header. Alternative files are found using\n    file extensions defined in :attr:`mimetypes.encodings_map`. An encoded\n    asset will be returned with the ``Content-Encoding`` header set to the\n    selected encoding. If the asset contains alternative encodings then the\n    ``Accept-Encoding`` value will be added to the response's ``Vary`` header.\n    By default, the list is empty and no alternatives will be supported.\n\n    .. note::\n\n       If the ``root_dir`` is relative to a :term:`package`, or is a\n       :term:`asset specification` the :app:`Pyramid`\n       :class:`pyramid.config.Configurator` method can be used to override\n       assets within the named ``root_dir`` package-relative directory.\n       However, if the ``root_dir`` is absolute, configuration will not be able\n       to override the assets it contains.\n\n    .. versionchanged:: 2.0\n\n       Added ``reload`` and ``content_encodings`` options.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        root_dir,\n        cache_max_age=3600,\n        package_name=None,\n        use_subpath=False,\n        index='index.html',\n        reload=False,\n        content_encodings=(),\n    ):\n        # package_name is for bw compat; it is preferred to pass in a\n        # package-relative path as root_dir\n        # (e.g. ``anotherpackage:foo/static``).\n        self.cache_max_age = cache_max_age\n        if package_name is None:\n            package_name = caller_package().__name__\n        package_name, docroot = resolve_asset_spec(root_dir, package_name)\n        if package_name:\n            try:\n                __import__(package_name)\n            except ImportError:\n                warnings.warn(\n                    f'A \"pyramid.static.static_view\" is being created with an'\n                    f' asset spec referencing a package \"{package_name}\" that'\n                    f' does not exist. This will break in the future.'\n                    f' If this is done to override an asset, you must adjust'\n                    f' this to override a location inside a real package.',\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n        self.use_subpath = use_subpath\n        self.package_name = package_name\n        self.docroot = docroot\n        self.norm_docroot = normcase(normpath(docroot))\n        self.index = index\n        self.reload = reload\n        self.content_encodings = _compile_content_encodings(content_encodings)\n        self.filemap = {}"
    },
    {
      "chunk_id": 506,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def __call__(self, context, request):\n        resource_name = self.get_resource_name(request)\n        files = self.get_possible_files(resource_name)\n        filepath, content_encoding = self.find_best_match(request, files)\n        if filepath is None:\n            raise HTTPNotFound(request.url)\n\n        content_type, _ = _guess_type(resource_name)\n        response = FileResponse(\n            filepath,\n            request,\n            self.cache_max_age,\n            content_type,\n            content_encoding,\n        )\n        if len(files) > 1:\n            _add_vary(response, 'Accept-Encoding')\n        return response"
    },
    {
      "chunk_id": 507,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def get_resource_name(self, request):\n        \"\"\"\n        Return the computed name of the requested resource.\n\n        The returned file is not guaranteed to exist.\n\n        \"\"\"\n        if self.use_subpath:\n            path_tuple = request.subpath\n        else:\n            path_tuple = traversal_path_info(request.path_info)\n        path = _secure_path(path_tuple)\n\n        if path is None:\n            raise HTTPNotFound('Out of bounds: %s' % request.url)\n\n        # normalize asset spec or fs path into resource_path\n        if self.package_name:  # package resource\n            resource_path = '{}/{}'.format(self.docroot.rstrip('/'), path)\n            if resource_isdir(self.package_name, resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = '{}/{}'.format(\n                    resource_path.rstrip('/'),\n                    self.index,\n                )\n\n        else:  # filesystem file\n            # os.path.normpath converts / to \\ on windows\n            resource_path = normcase(normpath(join(self.norm_docroot, path)))\n            if isdir(resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = join(resource_path, self.index)\n\n        return resource_path"
    },
    {
      "chunk_id": 508,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def find_resource_path(self, name):\n        \"\"\"\n        Return the absolute path to the resource or ``None`` if it doesn't\n        exist.\n\n        \"\"\"\n        if self.package_name:\n            if resource_exists(self.package_name, name):\n                return resource_filename(self.package_name, name)\n\n        elif exists(name):\n            return name"
    },
    {
      "chunk_id": 509,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def get_possible_files(self, resource_name):\n        \"\"\"Return a sorted list of ``(size, encoding, path)`` entries.\"\"\"\n        result = self.filemap.get(resource_name)\n        if result is not None:\n            return result\n\n        # XXX we could put a lock around this work but worst case scenario a\n        # couple requests scan the disk for files at the same time and then\n        # the cache is set going forward so do not bother\n        result = []\n\n        # add the identity\n        path = self.find_resource_path(resource_name)\n        if path:\n            result.append((path, None))\n\n        # add each file we find for the supported encodings\n        # we don't mind adding multiple files for the same encoding if there\n        # are copies with different extensions because we sort by size so the\n        # smallest is always found first and the rest ignored\n        for encoding, extensions in self.content_encodings.items():\n            for ext in extensions:\n                encoded_name = resource_name + ext\n                path = self.find_resource_path(encoded_name)\n                if path:\n                    result.append((path, encoding))\n\n        # sort the files by size, smallest first\n        result.sort(key=lambda x: getsize(x[0]))\n\n        # only cache the results if reload is disabled\n        if not self.reload:\n            self.filemap[resource_name] = result\n        return result"
    },
    {
      "chunk_id": 510,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def find_best_match(self, request, files):\n        \"\"\"Return ``(path | None, encoding)``.\"\"\"\n        # if the client did not specify encodings then assume only the\n        # identity is acceptable\n        if not request.accept_encoding:\n            identity_path = next(\n                (path for path, encoding in files if encoding is None),\n                None,\n            )\n            return identity_path, None\n\n        # find encodings the client will accept\n        acceptable_encodings = {\n            x[0]\n            for x in request.accept_encoding.acceptable_offers(\n                [encoding for path, encoding in files if encoding is not None]\n            )\n        }\n        acceptable_encodings.add(None)\n\n        # return the smallest file from the acceptable encodings\n        # we know that files is sorted by size, smallest first\n        for path, encoding in files:\n            if encoding in acceptable_encodings:\n                return path, encoding\n        return None, None"
    },
    {
      "chunk_id": 511,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def add_slash_redirect(self, request):\n        url = request.path_url + '/'\n        qs = request.query_string\n        if qs:\n            url = url + '?' + qs\n        return HTTPMovedPermanently(url)"
    },
    {
      "chunk_id": 512,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def _compile_content_encodings(encodings):\n    \"\"\"\n    Convert mimetypes.encodings_map into a dict of\n    ``(encoding) -> [file extensions]``.\n\n    \"\"\"\n    result = {}\n    for ext, encoding in mimetypes.encodings_map.items():\n        if encoding in encodings:\n            result.setdefault(encoding, []).append(ext)\n    return result"
    },
    {
      "chunk_id": 513,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def _add_vary(response, option):\n    vary = response.vary or []\n    if not any(x.lower() == option.lower() for x in vary):\n        vary.append(option)\n    response.vary = vary"
    },
    {
      "chunk_id": 514,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "_invalid_element_chars = {'/', os.sep, '\\x00'}"
    },
    {
      "chunk_id": 515,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def _contains_invalid_element_char(item):\n    for invalid_element_char in _invalid_element_chars:\n        if invalid_element_char in item:\n            return True"
    },
    {
      "chunk_id": 516,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "_has_insecure_pathelement = {'..', '.', ''}.intersection"
    },
    {
      "chunk_id": 517,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "@lru_cache(1000)\ndef _secure_path(path_tuple):\n    if _has_insecure_pathelement(path_tuple):\n        # belt-and-suspenders security; this should never be true\n        # unless someone screws up the traversal_path code\n        # (request.subpath is computed via traversal_path too)\n        return None\n    if any([_contains_invalid_element_char(item) for item in path_tuple]):\n        return None\n    encoded = '/'.join(path_tuple)  # will be unicode\n    return encoded"
    },
    {
      "chunk_id": 518,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "class QueryStringCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    a token for cache busting in the query string of an asset URL.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    To use this class, subclass it and provide a ``tokenize`` method which\n    accepts ``request, pathspec, kw`` and returns a token.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, param='x'):\n        self.param = param"
    },
    {
      "chunk_id": 519,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def __call__(self, request, subpath, kw):\n        token = self.tokenize(request, subpath, kw)\n        query = kw.setdefault('_query', {})\n        if isinstance(query, dict):\n            query[self.param] = token\n        else:\n            kw['_query'] = tuple(query) + ((self.param, token),)\n        return subpath, kw"
    },
    {
      "chunk_id": 520,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "class QueryStringConstantCacheBuster(QueryStringCacheBuster):\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    an arbitrary token for cache busting in the query string of an asset URL.\n\n    The ``token`` parameter is the token string to use for cache busting and\n    will be the same for every request.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, token, param='x'):\n        super().__init__(param=param)\n        self._token = token"
    },
    {
      "chunk_id": 521,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def tokenize(self, request, subpath, kw):\n        return self._token"
    },
    {
      "chunk_id": 522,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "class ManifestCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which\n    uses a supplied manifest file to map an asset path to a cache-busted\n    version of the path.\n\n    The ``manifest_spec`` can be an absolute path or a :term:`asset\n    specification` pointing to a package-relative file.\n\n    The manifest file is expected to conform to the following simple JSON\n    format:\n\n    .. code-block:: json\n\n       {\n           \"css/main.css\": \"css/main-678b7c80.css\",\n           \"images/background.png\": \"images/background-a8169106.png\",\n       }\n\n    By default, it is a JSON-serialized dictionary where the keys are the\n    source asset paths used in calls to\n    :meth:`~pyramid.request.Request.static_url`. For example:\n\n    .. code-block:: pycon\n\n       >>> request.static_url('myapp:static/css/main.css')\n       \"http://www.example.com/static/css/main-678b7c80.css\"\n\n    The file format and location can be changed by subclassing and overriding\n    :meth:`.parse_manifest`.\n\n    If a path is not found in the manifest it will pass through unchanged.\n\n    If ``reload`` is ``True`` then the manifest file will be reloaded when\n    changed. It is not recommended to leave this enabled in production.\n\n    If the manifest file cannot be found on disk it will be treated as\n    an empty mapping unless ``reload`` is ``False``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    exists = staticmethod(exists)  # testing\n    getmtime = staticmethod(getmtime)  # testing"
    },
    {
      "chunk_id": 523,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def __init__(self, manifest_spec, reload=False):\n        package_name = caller_package().__name__\n        self.manifest_path = abspath_from_asset_spec(\n            manifest_spec, package_name\n        )\n        self.reload = reload\n\n        self._mtime = None\n        if not reload:\n            self._manifest = self.get_manifest()"
    },
    {
      "chunk_id": 524,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def get_manifest(self):\n        with open(self.manifest_path, 'rb') as fp:\n            return self.parse_manifest(fp.read())"
    },
    {
      "chunk_id": 525,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def parse_manifest(self, content):\n        \"\"\"\n        Parse the ``content`` read from the ``manifest_path`` into a\n        dictionary mapping.\n\n        Subclasses may override this method to use something other than\n        ``json.loads`` to load any type of file format and return a conforming\n        dictionary.\n\n        \"\"\"\n        return json.loads(content.decode('utf-8'))"
    },
    {
      "chunk_id": 526,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "@property\n    def manifest(self):\n        \"\"\"The current manifest dictionary.\"\"\"\n        if self.reload:\n            if not self.exists(self.manifest_path):\n                return {}\n            mtime = self.getmtime(self.manifest_path)\n            if self._mtime is None or mtime > self._mtime:\n                self._manifest = self.get_manifest()\n                self._mtime = mtime\n        return self._manifest"
    },
    {
      "chunk_id": 527,
      "source": "__internal__/data_repo/pyramid/src/pyramid/static.py",
      "content": "def __call__(self, request, subpath, kw):\n        subpath = self.manifest.get(subpath, subpath)\n        return (subpath, kw)"
    },
    {
      "chunk_id": 528,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "import threading\n\nfrom pyramid.registry import global_registry"
    },
    {
      "chunk_id": 529,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "class ThreadLocalManager(threading.local):\n    def __init__(self, default=None):\n        # http://code.google.com/p/google-app-engine-django/issues/detail?id=119\n        # we *must* use a keyword argument for ``default`` here instead\n        # of a positional argument to work around a bug in the\n        # implementation of _threading_local.local in Python, which is\n        # used by GAE instead of _thread.local\n        self.stack = []\n        self.default = default"
    },
    {
      "chunk_id": 530,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def push(self, info):\n        self.stack.append(info)"
    },
    {
      "chunk_id": 531,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def pop(self):\n        if self.stack:\n            return self.stack.pop()"
    },
    {
      "chunk_id": 532,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def get(self):\n        try:\n            return self.stack[-1]\n        except IndexError:\n            return self.default()"
    },
    {
      "chunk_id": 533,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def clear(self):\n        self.stack[:] = []"
    },
    {
      "chunk_id": 534,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def defaults():\n    return {'request': None, 'registry': global_registry}"
    },
    {
      "chunk_id": 535,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "manager = ThreadLocalManager(default=defaults)"
    },
    {
      "chunk_id": 536,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def get_current_request():\n    \"\"\"\n    Return the currently active request or ``None`` if no request\n    is currently active.\n\n    This function should be used *extremely sparingly*, usually only\n    in unit testing code.  It's almost always usually a mistake to use\n    ``get_current_request`` outside a testing context because its\n    usage makes it possible to write code that can be neither easily\n    tested nor scripted.\n\n    \"\"\"\n    return manager.get()['request']"
    },
    {
      "chunk_id": 537,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def get_current_registry(\n    context=None,\n):  # context required by getSiteManager API\n    \"\"\"\n    Return the currently active :term:`application registry` or the\n    global application registry if no request is currently active.\n\n    This function should be used *extremely sparingly*, usually only\n    in unit testing code.  It's almost always usually a mistake to use\n    ``get_current_registry`` outside a testing context because its\n    usage makes it possible to write code that can be neither easily\n    tested nor scripted.\n\n    \"\"\"\n    return manager.get()['registry']"
    },
    {
      "chunk_id": 538,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "class RequestContext:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 539,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def begin(self):\n        request = self.request\n        registry = request.registry\n        manager.push({'registry': registry, 'request': request})\n        return request"
    },
    {
      "chunk_id": 540,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def end(self):\n        manager.pop()"
    },
    {
      "chunk_id": 541,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def __enter__(self):\n        return self.begin()"
    },
    {
      "chunk_id": 542,
      "source": "__internal__/data_repo/pyramid/src/pyramid/threadlocal.py",
      "content": "def __exit__(self, *args):\n        self.end()"
    },
    {
      "chunk_id": 543,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "from pyramid.httpexceptions import HTTPBadRequest, HTTPForbidden, HTTPNotFound\n\nNotFound = HTTPNotFound  # bw compat\nForbidden = HTTPForbidden  # bw compat"
    },
    {
      "chunk_id": 544,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class BadCSRFOrigin(HTTPBadRequest):\n    \"\"\"\n    This exception indicates the request has failed cross-site request forgery\n    origin validation.\n    \"\"\"\n\n    explanation = (\n        \"Bad CSRF Origin. Access is denied. This server can not verify that \"\n        \"the origin or referrer of your request matches the current site. \"\n        \"Either your browser supplied the wrong Origin or Referrer or it did \"\n        \"not supply one at all.\"\n    )"
    },
    {
      "chunk_id": 545,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class BadCSRFToken(HTTPBadRequest):\n    \"\"\"\n    This exception indicates the request has failed cross-site request\n    forgery token validation.\n    \"\"\"\n\n    explanation = (\n        'Bad CSRF token received. Access is denied. This server can not '\n        'verify that your cross-site request forgery token belongs to your '\n        'login session. Either you supplied the wrong cross-site request '\n        'forgery token or your session no longer exists. This may be due to '\n        'session timeout or because browser is not supplying the credentials '\n        'required, as can happen when the browser has cookies turned off.'\n    )"
    },
    {
      "chunk_id": 546,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class PredicateMismatch(HTTPNotFound):\n    \"\"\"\n    This exception is raised by multiviews when no view matches\n    all given predicates.\n\n    This exception subclasses the :class:`HTTPNotFound` exception for a\n    specific reason: if it reaches the main exception handler, it should\n    be treated as :class:`HTTPNotFound`` by any exception view\n    registrations. Thus, typically, this exception will not be seen\n    publicly.\n\n    However, this exception will be raised if the predicates of all\n    views configured to handle another exception context cannot be\n    successfully matched.  For instance, if a view is configured to\n    handle a context of ``HTTPForbidden`` and the configured with\n    additional predicates, then :class:`PredicateMismatch` will be\n    raised if:\n\n    * An original view callable has raised :class:`HTTPForbidden` (thus\n      invoking an exception view); and\n    * The given request fails to match all predicates for said\n      exception view associated with :class:`HTTPForbidden`.\n\n    The same applies to any type of exception being handled by an\n    exception view.\n    \"\"\""
    },
    {
      "chunk_id": 547,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class URLDecodeError(UnicodeDecodeError):\n    \"\"\"\n    This exception is raised when :app:`Pyramid` cannot\n    successfully decode a URL or a URL path segment.  This exception\n    behaves just like the Python builtin\n    :exc:`UnicodeDecodeError`. It is a subclass of the builtin\n    :exc:`UnicodeDecodeError` exception only for identity purposes,\n    mostly so an exception view can be registered when a URL cannot be\n    decoded.\n    \"\"\""
    },
    {
      "chunk_id": 548,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class ConfigurationError(Exception):\n    \"\"\"Raised when inappropriate input values are supplied to an API\n    method of a :term:`Configurator`\"\"\""
    },
    {
      "chunk_id": 549,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class ConfigurationConflictError(ConfigurationError):\n    \"\"\"Raised when a configuration conflict is detected during action\n    processing\"\"\"\n\n    def __init__(self, conflicts):\n        self._conflicts = conflicts\n\n    def __str__(self):\n        r = [\"Conflicting configuration actions\"]\n        for discriminator, infos in self._conflicts.items():\n            r.append(f\"  For: {discriminator}\")\n            for info in infos:\n                for line in str(info).rstrip().split('\\n'):\n                    r.append(\"    \" + line)\n\n        return '\\n'.join(r)"
    },
    {
      "chunk_id": 550,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class ConfigurationExecutionError(ConfigurationError):\n    \"\"\"An error occurred during execution of a configuration action\"\"\"\n\n    def __init__(self, etype, evalue, info):\n        self.etype, self.evalue, self.info = etype, evalue, info\n\n    def __str__(self):\n        return f\"{self.etype}: {self.evalue}\\n  in:\\n  {self.info}\""
    },
    {
      "chunk_id": 551,
      "source": "__internal__/data_repo/pyramid/src/pyramid/exceptions.py",
      "content": "class CyclicDependencyError(Exception):\n    \"\"\"The exception raised when the Pyramid topological sorter detects a\n    cyclic dependency.\"\"\"\n\n    def __init__(self, cycles):\n        self.cycles = cycles\n\n    def __str__(self):\n        L = []\n        cycles = self.cycles\n        for cycle in cycles:\n            dependent = cycle\n            dependees = cycles[cycle]\n            L.append(f'{dependent!r} sorts before {dependees!r}')\n        msg = 'Implicit ordering cycle:' + '; '.join(L)\n        return msg"
    },
    {
      "chunk_id": 552,
      "source": "__internal__/data_repo/pyramid/src/pyramid/asset.py",
      "content": "import os\nimport pkg_resources\n\nfrom pyramid.path import package_name, package_path"
    },
    {
      "chunk_id": 553,
      "source": "__internal__/data_repo/pyramid/src/pyramid/asset.py",
      "content": "def resolve_asset_spec(spec, pname='__main__'):\n    if pname and not isinstance(pname, str):\n        pname = pname.__name__  # as package\n    if os.path.isabs(spec):\n        return None, spec\n    filename = spec\n    if ':' in spec:\n        pname, filename = spec.split(':', 1)\n    elif pname is None:\n        pname, filename = None, spec\n    return pname, filename"
    },
    {
      "chunk_id": 554,
      "source": "__internal__/data_repo/pyramid/src/pyramid/asset.py",
      "content": "def asset_spec_from_abspath(abspath, package):\n    \"\"\"Try to convert an absolute path to a resource in a package to\n    a resource specification if possible; otherwise return the\n    absolute path.\"\"\"\n    if getattr(package, '__name__', None) == '__main__':\n        return abspath\n    pp = package_path(package) + os.path.sep\n    if abspath.startswith(pp):\n        relpath = abspath[len(pp) :]\n        return '{}:{}'.format(\n            package_name(package),\n            relpath.replace(os.path.sep, '/'),\n        )\n    return abspath"
    },
    {
      "chunk_id": 555,
      "source": "__internal__/data_repo/pyramid/src/pyramid/asset.py",
      "content": "def abspath_from_asset_spec(spec, pname='__main__'):\n    if pname is None:\n        return spec\n    pname, filename = resolve_asset_spec(spec, pname)\n    if pname is None:\n        return filename\n    return pkg_resources.resource_filename(pname, filename)"
    },
    {
      "chunk_id": 556,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "import gettext\nimport os\nfrom translationstring import Pluralizer, Translator\nfrom translationstring import TranslationString  # API\nfrom translationstring import TranslationStringFactory  # API\n\nfrom pyramid.decorator import reify\nfrom pyramid.interfaces import (\n    ILocaleNegotiator,\n    ILocalizer,\n    ITranslationDirectories,\n)\nfrom pyramid.threadlocal import get_current_registry\n\nTranslationString = TranslationString  # PyFlakes\nTranslationStringFactory = TranslationStringFactory  # PyFlakes\n\nDEFAULT_PLURAL = lambda n: int(n != 1)"
    },
    {
      "chunk_id": 557,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "class Localizer:\n    \"\"\"\n    An object providing translation and pluralizations related to\n    the current request's locale name.  A\n    :class:`pyramid.i18n.Localizer` object is created using the\n    :func:`pyramid.i18n.get_localizer` function.\n    \"\"\"\n\n    def __init__(self, locale_name, translations):\n        self.locale_name = locale_name\n        self.translations = translations\n        self.pluralizer = None\n        self.translator = None"
    },
    {
      "chunk_id": 558,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def translate(self, tstring, domain=None, mapping=None):\n        \"\"\"\n        Translate a :term:`translation string` to the current language\n        and interpolate any *replacement markers* in the result.  The\n        ``translate`` method accepts three arguments: ``tstring``\n        (required), ``domain`` (optional) and ``mapping`` (optional).\n        When called, it will translate the ``tstring`` translation\n        string using the current locale.  If the current locale could not be\n        determined, the result of interpolation of the default value is\n        returned.  The optional ``domain`` argument can be used to specify\n        or override the domain of the ``tstring`` (useful when ``tstring``\n        is a normal string rather than a translation string).  The optional\n        ``mapping`` argument can specify or override the ``tstring``\n        interpolation mapping, useful when the ``tstring`` argument is\n        a simple string instead of a translation string.\n\n        Example::\n\n           from pyramid.i18n import TranslationString\n           ts = TranslationString('Add ${item}', domain='mypackage',\n                                  mapping={'item':'Item'})\n           translated = localizer.translate(ts)\n\n        Example::\n\n           translated = localizer.translate('Add ${item}', domain='mypackage',\n                                            mapping={'item':'Item'})\n\n        \"\"\"\n        if self.translator is None:\n            self.translator = Translator(self.translations)\n        return self.translator(tstring, domain=domain, mapping=mapping)"
    },
    {
      "chunk_id": 559,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def pluralize(self, singular, plural, n, domain=None, mapping=None):\n        \"\"\"\n        Return a string translation by using two\n        :term:`message identifier` objects as a singular/plural pair\n        and an ``n`` value representing the number that appears in the\n        message using gettext plural forms support.  The ``singular``\n        and ``plural`` objects should be strings. There is no\n        reason to use translation string objects as arguments as all\n        metadata is ignored.\n\n        ``n`` represents the number of elements. ``domain`` is the\n        translation domain to use to do the pluralization, and ``mapping``\n        is the interpolation mapping that should be used on the result. If\n        the ``domain`` is not supplied, a default domain is used (usually\n        ``messages``).\n\n        Example::\n\n           num = 1\n           translated = localizer.pluralize('Add ${num} item',\n                                            'Add ${num} items',\n                                            num,\n                                            mapping={'num':num})\n\n        If using the gettext plural support, which is required for\n        languages that have pluralisation rules other than n != 1, the\n        ``singular`` argument must be the message_id defined in the\n        translation file. The plural argument is not used in this case.\n\n        Example::\n\n           num = 1\n           translated = localizer.pluralize('item_plural',\n                                            '',\n                                            num,\n                                            mapping={'num':num})\n\n\n        \"\"\"\n        if self.pluralizer is None:\n            self.pluralizer = Pluralizer(self.translations)\n        return self.pluralizer(\n            singular, plural, n, domain=domain, mapping=mapping\n        )"
    },
    {
      "chunk_id": 560,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def default_locale_negotiator(request):\n    \"\"\"The default :term:`locale negotiator`.  Returns a locale name\n    or ``None``.\n\n    - First, the negotiator looks for the ``_LOCALE_`` attribute of\n      the request object (possibly set by a view or a listener for an\n      :term:`event`). If the attribute exists and it is not ``None``,\n      its value will be used.\n\n    - Then it looks for the ``request.params['_LOCALE_']`` value.\n\n    - Then it looks for the ``request.cookies['_LOCALE_']`` value.\n\n    - Finally, the negotiator returns ``None`` if the locale could not\n      be determined via any of the previous checks (when a locale\n      negotiator returns ``None``, it signifies that the\n      :term:`default locale name` should be used.)\n    \"\"\"\n    name = '_LOCALE_'\n    locale_name = getattr(request, name, None)\n    if locale_name is None:\n        locale_name = request.params.get(name)\n        if locale_name is None:\n            locale_name = request.cookies.get(name)\n    return locale_name"
    },
    {
      "chunk_id": 561,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def negotiate_locale_name(request):\n    \"\"\"Negotiate and return the :term:`locale name` associated with\n    the current request.\"\"\"\n    try:\n        registry = request.registry\n    except AttributeError:\n        registry = get_current_registry()\n    negotiator = registry.queryUtility(\n        ILocaleNegotiator, default=default_locale_negotiator\n    )\n    locale_name = negotiator(request)\n\n    if locale_name is None:\n        settings = registry.settings or {}\n        locale_name = settings.get('default_locale_name', 'en')\n\n    return locale_name"
    },
    {
      "chunk_id": 562,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def get_locale_name(request):\n    \"\"\"\n    .. deprecated:: 1.5\n        Use :attr:`pyramid.request.Request.locale_name` directly instead.\n        Return the :term:`locale name` associated with the current request.\n    \"\"\"\n    return request.locale_name"
    },
    {
      "chunk_id": 563,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def make_localizer(current_locale_name, translation_directories):\n    \"\"\"Create a :class:`pyramid.i18n.Localizer` object\n    corresponding to the provided locale name from the\n    translations found in the list of translation directories.\"\"\"\n    translations = Translations()\n    translations._catalog = {}\n\n    locales_to_try = []\n    if '_' in current_locale_name:\n        locales_to_try = [current_locale_name.split('_')[0]]\n    locales_to_try.append(current_locale_name)\n\n    # intent: order locales left to right in least specific to most specific,\n    # e.g. ['de', 'de_DE'].  This services the intent of creating a\n    # translations object that returns a \"more specific\" translation for a\n    # region, but will fall back to a \"less specific\" translation for the\n    # locale if necessary.  Ordering from least specific to most specific\n    # allows us to call translations.add in the below loop to get this\n    # behavior.\n\n    for tdir in translation_directories:\n        locale_dirs = []\n        for lname in locales_to_try:\n            ldir = os.path.realpath(os.path.join(tdir, lname))\n            if os.path.isdir(ldir):\n                locale_dirs.append(ldir)\n\n        for locale_dir in locale_dirs:\n            messages_dir = os.path.join(locale_dir, 'LC_MESSAGES')\n            if not os.path.isdir(os.path.realpath(messages_dir)):\n                continue\n            for mofile in os.listdir(messages_dir):\n                mopath = os.path.realpath(os.path.join(messages_dir, mofile))\n                if mofile.endswith('.mo') and os.path.isfile(mopath):\n                    with open(mopath, 'rb') as mofp:\n                        domain = mofile[:-3]\n                        dtrans = Translations(mofp, domain)\n                        translations.add(dtrans)\n\n    return Localizer(\n        locale_name=current_locale_name, translations=translations\n    )"
    },
    {
      "chunk_id": 564,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def get_localizer(request):\n    \"\"\"\n    .. deprecated:: 1.5\n        Use the :attr:`pyramid.request.Request.localizer` attribute directly\n        instead.  Retrieve a :class:`pyramid.i18n.Localizer` object\n        corresponding to the current request's locale name.\n    \"\"\"\n    return request.localizer"
    },
    {
      "chunk_id": 565,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "class Translations(gettext.GNUTranslations):\n    \"\"\"An extended translation catalog class (ripped off from Babel)\"\"\"\n\n    DEFAULT_DOMAIN = 'messages'\n\n    def __init__(self, fileobj=None, domain=DEFAULT_DOMAIN):\n        \"\"\"Initialize the translations catalog.\n\n        :param fileobj: the file-like object the translation should be read\n                        from\n        \"\"\"\n        # germanic plural by default; self.plural will be overwritten by\n        # GNUTranslations._parse (called as a side effect if fileobj is\n        # passed to GNUTranslations.__init__) with a \"real\" self.plural for\n        # this domain; see https://github.com/Pylons/pyramid/issues/235\n        # It is only overridden the first time a new message file is found\n        # for a given domain, so all message files must have matching plural\n        # rules if they are in the same domain. We keep track of if we have\n        # overridden so we can special case the default domain, which is always\n        # instantiated before a message file is read.\n        # See also https://github.com/Pylons/pyramid/pull/2102\n        self.plural = DEFAULT_PLURAL\n        gettext.GNUTranslations.__init__(self, fp=fileobj)\n        self.files = list(filter(None, [getattr(fileobj, 'name', None)]))\n        self.domain = domain\n        self._domains = {}"
    },
    {
      "chunk_id": 566,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "@classmethod\n    def load(cls, dirname=None, locales=None, domain=DEFAULT_DOMAIN):\n        \"\"\"Load translations from the given directory.\n\n        :param dirname: the directory containing the ``MO`` files\n        :param locales: the list of locales in order of preference (items in\n                        this list can be either `Locale` objects or locale\n                        strings)\n        :param domain: the message domain\n        :return: the loaded catalog, or a ``NullTranslations`` instance if no\n                 matching translations were found\n        :rtype: `Translations`\n        \"\"\"\n        if locales is not None:\n            if not isinstance(locales, (list, tuple)):\n                locales = [locales]\n            locales = [str(locale) for locale in locales]\n        if not domain:\n            domain = cls.DEFAULT_DOMAIN\n        filename = gettext.find(domain, dirname, locales)\n        if not filename:\n            return gettext.NullTranslations()\n        with open(filename, 'rb') as fp:\n            return cls(fileobj=fp, domain=domain)"
    },
    {
      "chunk_id": 567,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def __repr__(self):\n        return '<{}: \"{}\">'.format(\n            type(self).__name__,\n            self._info.get('project-id-version'),\n        )"
    },
    {
      "chunk_id": 568,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def add(self, translations, merge=True):\n        \"\"\"Add the given translations to the catalog.\n\n        If the domain of the translations is different than that of the\n        current catalog, they are added as a catalog that is only accessible\n        by the various ``d*gettext`` functions.\n\n        :param translations: the `Translations` instance with the messages to\n                             add\n        :param merge: whether translations for message domains that have\n                      already been added should be merged with the existing\n                      translations\n        :return: the `Translations` instance (``self``) so that `merge` calls\n                 can be easily chained\n        :rtype: `Translations`\n        \"\"\"\n        domain = getattr(translations, 'domain', self.DEFAULT_DOMAIN)\n        if domain == self.DEFAULT_DOMAIN and self.plural is DEFAULT_PLURAL:\n            self.plural = translations.plural\n\n        if merge and domain == self.domain:\n            return self.merge(translations)\n\n        existing = self._domains.get(domain)\n        if merge and existing is not None:\n            existing.merge(translations)\n        else:\n            translations.add_fallback(self)\n            self._domains[domain] = translations\n\n        return self"
    },
    {
      "chunk_id": 569,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def merge(self, translations):\n        \"\"\"Merge the given translations into the catalog.\n\n        Message translations in the specified catalog override any messages\n        with the same identifier in the existing catalog.\n\n        :param translations: the `Translations` instance with the messages to\n                             merge\n        :return: the `Translations` instance (``self``) so that `merge` calls\n                 can be easily chained\n        :rtype: `Translations`\n        \"\"\"\n        if isinstance(translations, gettext.GNUTranslations):\n            self._catalog.update(translations._catalog)\n            if isinstance(translations, Translations):\n                self.files.extend(translations.files)\n\n        return self"
    },
    {
      "chunk_id": 570,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def dgettext(self, domain, message):\n        \"\"\"Like ``gettext()``, but look the message up in the specified\n        domain.\n        \"\"\"\n        return self._domains.get(domain, self).gettext(message)"
    },
    {
      "chunk_id": 571,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def dugettext(self, domain, message):\n        \"\"\"Like ``ugettext()``, but look the message up in the specified\n        domain.\n        \"\"\"\n        return self._domains.get(domain, self).gettext(message)"
    },
    {
      "chunk_id": 572,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def dngettext(self, domain, singular, plural, num):\n        \"\"\"Like ``ngettext()``, but look the message up in the specified\n        domain.\n        \"\"\"\n        return self._domains.get(domain, self).ngettext(singular, plural, num)"
    },
    {
      "chunk_id": 573,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "def dungettext(self, domain, singular, plural, num):\n        \"\"\"Like ``ungettext()`` but look the message up in the specified\n        domain.\n        \"\"\"\n        return self._domains.get(domain, self).ngettext(singular, plural, num)"
    },
    {
      "chunk_id": 574,
      "source": "__internal__/data_repo/pyramid/src/pyramid/i18n.py",
      "content": "class LocalizerRequestMixin:\n    @reify\n    def localizer(self):\n        \"\"\"Convenience property to return a localizer\"\"\"\n        registry = self.registry\n\n        current_locale_name = self.locale_name\n        localizer = registry.queryUtility(ILocalizer, name=current_locale_name)\n\n        if localizer is None:\n            # no localizer utility registered yet\n            tdirs = registry.queryUtility(ITranslationDirectories, default=[])\n            localizer = make_localizer(current_locale_name, tdirs)\n\n            registry.registerUtility(\n                localizer, ILocalizer, name=current_locale_name\n            )\n\n        return localizer\n\n    @reify\n    def locale_name(self):\n        locale_name = negotiate_locale_name(self)\n        return locale_name"
    },
    {
      "chunk_id": 575,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "from functools import lru_cache\nfrom urllib.parse import unquote_to_bytes\nfrom zope.interface import implementer\nfrom zope.interface.interfaces import IInterface\n\nfrom pyramid.encode import url_quote\nfrom pyramid.exceptions import URLDecodeError\nfrom pyramid.interfaces import (\n    VH_ROOT_KEY,\n    IRequestFactory,\n    IResourceURL,\n    ITraverser,\n)\nfrom pyramid.location import lineage\nfrom pyramid.threadlocal import get_current_registry\nfrom pyramid.util import ascii_, is_nonstr_iter, text_\n\nPATH_SEGMENT_SAFE = \"~!$&'()*+,;=:@\"  # from webob\nPATH_SAFE = PATH_SEGMENT_SAFE + \"/\""
    },
    {
      "chunk_id": 576,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def find_root(resource):\n    \"\"\"Find the root node in the resource tree to which ``resource``\n    belongs. Note that ``resource`` should be :term:`location`-aware.\n    Note that the root resource is available in the request object by\n    accessing the ``request.root`` attribute.\n    \"\"\"\n    for location in lineage(resource):\n        if location.__parent__ is None:\n            resource = location\n            break\n    return resource"
    },
    {
      "chunk_id": 577,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def find_resource(resource, path):\n    \"\"\"Given a resource object and a string or tuple representing a path\n    (such as the return value of :func:`pyramid.traversal.resource_path` or\n    :func:`pyramid.traversal.resource_path_tuple`), return a resource in this\n    application's resource tree at the specified path.  The resource passed\n    in *must* be :term:`location`-aware.  If the path cannot be resolved (if\n    the respective node in the resource tree does not exist), a\n    :exc:`KeyError` will be raised.\n\n    This function is the logical inverse of\n    :func:`pyramid.traversal.resource_path` and\n    :func:`pyramid.traversal.resource_path_tuple`; it can resolve any\n    path string or tuple generated by either of those functions.\n\n    Rules for passing a *string* as the ``path`` argument: if the\n    first character in the path string is the ``/``\n    character, the path is considered absolute and the resource tree\n    traversal will start at the root resource.  If the first character\n    of the path string is *not* the ``/`` character, the path is\n    considered relative and resource tree traversal will begin at the resource\n    object supplied to the function as the ``resource`` argument.  If an\n    empty string is passed as ``path``, the ``resource`` passed in will\n    be returned.  Resource path strings must be escaped in the following\n    manner: each path segment must be UTF-8 encoded and escaped via Python's\n    :mod:`urllib.quote`. For example, ``/path/to%20the/La%20Pe%C3%B1a``\n    (absolute) or ``to%20the/La%20Pe%C3%B1a`` (relative).  The\n    :func:`pyramid.traversal.resource_path` function generates strings\n    which follow these rules (albeit only absolute ones). The text may not\n    have any non-ASCII characters in it.\n\n    Rules for passing a *tuple* as the ``path`` argument: if the first\n    element in the path tuple is the empty string (for example ``('',\n    'a', 'b', 'c')``, the path is considered absolute and the resource tree\n    traversal will start at the resource tree root object.  If the first\n    element in the path tuple is not the empty string (for example\n    ``('a', 'b', 'c')``), the path is considered relative and resource tree\n    traversal will begin at the resource object supplied to the function\n    as the ``resource`` argument.  If an empty sequence is passed as\n    ``path``, the ``resource`` passed in itself will be returned.  No\n    URL-quoting of individual path segments within the tuple is required\n    (each segment may be any string representing a resource name).  Resource\n    path tuples generated by :func:`pyramid.traversal.resource_path_tuple` can\n    always be resolved by ``find_resource``.\n    \"\"\"\n    if isinstance(path, str):\n        path = ascii_(path)\n    D = traverse(resource, path)\n    view_name = D['view_name']\n    context = D['context']\n    if view_name:\n        raise KeyError(f'{context!r} has no subelement {view_name}')\n    return context"
    },
    {
      "chunk_id": 578,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "find_model = find_resource  # b/w compat (forever)"
    },
    {
      "chunk_id": 579,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def find_interface(resource, class_or_interface):\n    \"\"\"\n    Return the first resource found in the :term:`lineage` of ``resource``\n    which, a) if ``class_or_interface`` is a Python class object, is an\n    instance of the class or any subclass of that class or b) if\n    ``class_or_interface`` is a :term:`interface`, provides the specified\n    interface.  Return ``None`` if no resource providing ``interface_or_class``\n    can be found in the lineage.  The ``resource`` passed in *must* be\n    :term:`location`-aware.\n    \"\"\"\n    if IInterface.providedBy(class_or_interface):\n        test = class_or_interface.providedBy\n    else:\n        test = lambda arg: isinstance(arg, class_or_interface)\n    for location in lineage(resource):\n        if test(location):\n            return location"
    },
    {
      "chunk_id": 580,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def resource_path(resource, *elements):\n    \"\"\"Return a string object representing the absolute physical path of the\n    resource object based on its position in the resource tree, e.g\n    ``/foo/bar``.  Any positional arguments passed in as ``elements`` will be\n    appended as path segments to the end of the resource path.  For instance,\n    if the resource's path is ``/foo/bar`` and ``elements`` equals ``('a',\n    'b')``, the returned string will be ``/foo/bar/a/b``.  The first\n    character in the string will always be the ``/`` character (a leading\n    ``/`` character in a path string represents that the path is absolute).\n\n    Resource path strings returned will be escaped in the following\n    manner: each path segment will be encoded as UTF-8 and escaped via\n    Python's :mod:`urllib.quote`.\n    For example, ``/path/to%20the/La%20Pe%C3%B1a``.\n\n    This function is a logical inverse of\n    :mod:`pyramid.traversal.find_resource`: it can be used to generate\n    path references that can later be resolved via that function.\n\n    The ``resource`` passed in *must* be :term:`location`-aware.\n\n    .. note::\n\n       Each segment in the path string returned will use the ``__name__``\n       attribute of the resource it represents within the resource tree.  Each\n       of these segments *should* be a string (as per the\n       contract of :term:`location`-awareness).  However, no conversion or\n       safety checking of resource names is performed.  For instance, if one of\n       the resources in your tree has a ``__name__`` which (by error) is a\n       dictionary, the :func:`pyramid.traversal.resource_path` function will\n       attempt to append it to a string and it will cause a\n       :exc:`pyramid.exceptions.URLDecodeError`.\n\n    .. note::\n\n       The :term:`root` resource *must* have a ``__name__`` attribute with a\n       value of either ``None`` or the empty string for paths to be generated\n       properly.  If the root resource has a non-null ``__name__`` attribute,\n       its name will be prepended to the generated path rather than a single\n       leading '/' character.\n    \"\"\"\n    # joining strings is a bit expensive so we delegate to a function\n    # which caches the joined result for us\n    return _join_path_tuple(resource_path_tuple(resource, *elements))"
    },
    {
      "chunk_id": 581,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "model_path = resource_path  # b/w compat (forever)"
    },
    {
      "chunk_id": 582,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def traverse(resource, path):\n    \"\"\"Given a resource object as ``resource`` and a string or tuple\n    representing a path as ``path`` (such as the return value of\n    :func:`pyramid.traversal.resource_path` or\n    :func:`pyramid.traversal.resource_path_tuple` or the value of\n    ``request.environ['PATH_INFO']``), return a dictionary with the\n    keys ``context``, ``root``, ``view_name``, ``subpath``,\n    ``traversed``, ``virtual_root``, and ``virtual_root_path``.\n\n    A definition of each value in the returned dictionary:\n\n    - ``context``: The :term:`context` (a :term:`resource` object) found\n      via traversal or URL dispatch.  If the ``path`` passed in is the\n      empty string, the value of the ``resource`` argument passed to this\n      function is returned.\n\n    - ``root``: The resource object at which :term:`traversal` begins.\n      If the ``resource`` passed in was found via URL dispatch or if the\n      ``path`` passed in was relative (non-absolute), the value of the\n      ``resource`` argument passed to this function is returned.\n\n    - ``view_name``: The :term:`view name` found during\n      :term:`traversal` or :term:`URL dispatch`; if the ``resource`` was\n      found via traversal, this is usually a representation of the\n      path segment which directly follows the path to the ``context``\n      in the ``path``.  The ``view_name`` will be a  string.  The\n      ``view_name`` will be the empty string if\n      there is no element which follows the ``context`` path.  An\n      example: if the path passed is ``/foo/bar``, and a resource\n      object is found at ``/foo`` (but not at ``/foo/bar``), the 'view\n      name' will be ``'bar'``.  If the ``resource`` was found via\n      URL dispatch, the ``view_name`` will be the empty string unless\n      the ``traverse`` predicate was specified or the ``*traverse`` route\n      pattern was used, at which point normal traversal rules dictate the\n      result.\n\n    - ``subpath``: For a ``resource`` found via :term:`traversal`, this\n      is a sequence of path segments found in the ``path`` that follow\n      the ``view_name`` (if any).  Each of these items is a string.\n      If no path segments follow the ``view_name``, the\n      subpath will be the empty sequence.  An example: if the path\n      passed is ``/foo/bar/baz/buz``, and a resource object is found at\n      ``/foo`` (but not at ``/foo/bar``), the 'view name' will be\n      ``'bar'`` and the :term:`subpath` will be ``['baz', 'buz']``.\n      For a ``resource`` found via URL dispatch, the subpath will be a\n      sequence of values discerned from ``*subpath`` in the route\n      pattern matched or the empty sequence.\n\n    - ``traversed``: The sequence of path elements traversed from the\n      root to find the ``context`` object during :term:`traversal`.\n      Each of these items is a string.  If no path segments\n      were traversed to find the ``context`` object (e.g. if the\n      ``path`` provided is the empty string), the ``traversed`` value\n      will be the empty sequence.  If the ``resource`` is a resource found\n      via :term:`URL dispatch`, traversed will be None.\n\n    - ``virtual_root``: A resource object representing the 'virtual' root\n      of the resource tree being traversed during :term:`traversal`.\n      See :ref:`vhosting_chapter` for a definition of the virtual root\n      object.  If no virtual hosting is in effect, and the ``path``\n      passed in was absolute, the ``virtual_root`` will be the\n      *physical* root resource object (the object at which :term:`traversal`\n      begins).  If the ``resource`` passed in was found via :term:`URL\n      dispatch` or if the ``path`` passed in was relative, the\n      ``virtual_root`` will always equal the ``root`` object (the\n      resource passed in).\n\n    - ``virtual_root_path`` -- If :term:`traversal` was used to find\n      the ``resource``, this will be the sequence of path elements\n      traversed to find the ``virtual_root`` resource.  Each of these\n      items is a string.  If no path segments were traversed\n      to find the ``virtual_root`` resource (e.g. if virtual hosting is\n      not in effect), the ``traversed`` value will be the empty list.\n      If URL dispatch was used to find the ``resource``, this will be\n      ``None``.\n\n    If the path cannot be resolved, a :exc:`KeyError` will be raised.\n\n    Rules for passing a *string* as the ``path`` argument: if the\n    first character in the path string is the with the ``/``\n    character, the path will considered absolute and the resource tree\n    traversal will start at the root resource.  If the first character\n    of the path string is *not* the ``/`` character, the path is\n    considered relative and resource tree traversal will begin at the resource\n    object supplied to the function as the ``resource`` argument.  If an\n    empty string is passed as ``path``, the ``resource`` passed in will\n    be returned.  Resource path strings must be escaped in the following\n    manner: each path segment must be encoded as UTF-8 and escaped via\n    Python's :mod:`urllib.quote`. For example,\n    ``/path/to%20the/La%20Pe%C3%B1a`` (absolute) or\n    ``to%20the/La%20Pe%C3%B1a`` (relative).  The\n    :func:`pyramid.traversal.resource_path` function generates strings\n    which follow these rules (albeit only absolute ones).\n\n    Rules for passing a *tuple* as the ``path`` argument: if the first\n    element in the path tuple is the empty string (for example ``('',\n    'a', 'b', 'c')``, the path is considered absolute and the resource tree\n    traversal will start at the resource tree root object.  If the first\n    element in the path tuple is not the empty string (for example\n    ``('a', 'b', 'c')``), the path is considered relative and resource tree\n    traversal will begin at the resource object supplied to the function\n    as the ``resource`` argument.  If an empty sequence is passed as\n    ``path``, the ``resource`` passed in itself will be returned.  No\n    URL-quoting of individual path segments within\n    the tuple is required (each segment may be any string representing\n    a resource name).\n\n    Explanation of the decoding of ``path`` segment values during traversal:\n    Each segment is URL-unquoted, and UTF-8 decoded. Each segment is assumed\n    to be encoded using the UTF-8 encoding (or a subset, such as ASCII); a\n    :exc:`pyramid.exceptions.URLDecodeError` is raised if a segment\n    cannot be decoded.  If a segment name is empty or if it is ``.``,\n    it is ignored.  If a segment name is ``..``, the previous segment\n    is deleted, and the ``..`` is ignored.  As a result of this\n    process, the return values ``view_name``, each element in the\n    ``subpath``, each element in ``traversed``, and each element in\n    the ``virtual_root_path`` will be decoded strings.\n    \"\"\"\n\n    if is_nonstr_iter(path):\n        # the traverser factory expects PATH_INFO to be a string and it\n        # expects path segments to be utf-8 and\n        # urlencoded (it's the same traverser which accepts PATH_INFO\n        # from user agents; user agents always send strings).\n        if path:\n            path = _join_path_tuple(tuple(path))\n        else:\n            path = ''\n\n    # The user is supposed to pass us a string object, never Unicode.  In\n    # practice, however, users indeed pass Unicode to this API.  If they do\n    # pass a Unicode object, its data *must* be entirely encodeable to ASCII,\n    # so we encode it here as a convenience to the user and to prevent\n    # second-order failures from cropping up (all failures will occur at this\n    # step rather than later down the line as the result of calling\n    # ``traversal_path``).\n\n    path = ascii_(path)\n\n    if path and path[0] == '/':\n        resource = find_root(resource)\n\n    reg = get_current_registry()\n\n    request_factory = reg.queryUtility(IRequestFactory)\n    if request_factory is None:\n        from pyramid.request import Request  # avoid circdep\n\n        request_factory = Request\n\n    request = request_factory.blank(path)\n    request.registry = reg\n    traverser = reg.queryAdapter(resource, ITraverser)\n    if traverser is None:\n        traverser = ResourceTreeTraverser(resource)\n\n    return traverser(request)"
    },
    {
      "chunk_id": 583,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def resource_path_tuple(resource, *elements):\n    \"\"\"\n    Return a tuple representing the absolute physical path of the\n    ``resource`` object based on its position in a resource tree, e.g\n    ``('', 'foo', 'bar')``.  Any positional arguments passed in as\n    ``elements`` will be appended as elements in the tuple\n    representing the resource path.  For instance, if the resource's\n    path is ``('', 'foo', 'bar')`` and elements equals ``('a', 'b')``,\n    the returned tuple will be ``('', 'foo', 'bar', 'a', 'b')``.  The\n    first element of this tuple will always be the empty string (a\n    leading empty string element in a path tuple represents that the\n    path is absolute).\n\n    This function is a logical inverse of\n    :func:`pyramid.traversal.find_resource`: it can be used to\n    generate path references that can later be resolved by that function.\n\n    The ``resource`` passed in *must* be :term:`location`-aware.\n\n    .. note::\n\n       Each segment in the path tuple returned will equal the ``__name__``\n       attribute of the resource it represents within the resource tree.  Each\n       of these segments *should* be a string (as per the\n       contract of :term:`location`-awareness).  However, no conversion or\n       safety checking of resource names is performed.  For instance, if one of\n       the resources in your tree has a ``__name__`` which (by error) is a\n       dictionary, that dictionary will be placed in the path tuple; no warning\n       or error will be given.\n\n    .. note::\n\n       The :term:`root` resource *must* have a ``__name__`` attribute with a\n       value of either ``None`` or the empty string for path tuples to be\n       generated properly.  If the root resource has a non-null ``__name__``\n       attribute, its name will be the first element in the generated path\n       tuple rather than the empty string.\n    \"\"\"\n    return tuple(_resource_path_list(resource, *elements))"
    },
    {
      "chunk_id": 584,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "model_path_tuple = resource_path_tuple  # b/w compat (forever)"
    },
    {
      "chunk_id": 585,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def _resource_path_list(resource, *elements):\n    \"\"\"Implementation detail shared by resource_path and\n    resource_path_tuple\"\"\"\n    path = [loc.__name__ or '' for loc in lineage(resource)]\n    path.reverse()\n    path.extend(elements)\n    return path"
    },
    {
      "chunk_id": 586,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "_model_path_list = _resource_path_list  # b/w compat, not an API"
    },
    {
      "chunk_id": 587,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def virtual_root(resource, request):\n    \"\"\"\n    Provided any :term:`resource` and a :term:`request` object, return\n    the resource object representing the :term:`virtual root` of the\n    current :term:`request`.  Using a virtual root in a\n    :term:`traversal` -based :app:`Pyramid` application permits\n    rooting. For example, the resource at the traversal path ``/cms`` will\n    be found at ``http://example.com/`` instead of rooting it at\n    ``http://example.com/cms/``.\n\n    If the ``resource`` passed in is a context obtained via\n    :term:`traversal`, and if the ``HTTP_X_VHM_ROOT`` key is in the\n    WSGI environment, the value of this key will be treated as a\n    'virtual root path': the :func:`pyramid.traversal.find_resource`\n    API will be used to find the virtual root resource using this path;\n    if the resource is found, it will be returned.  If the\n    ``HTTP_X_VHM_ROOT`` key is not present in the WSGI environment,\n    the physical :term:`root` of the resource tree will be returned instead.\n\n    Virtual roots are not useful at all in applications that use\n    :term:`URL dispatch`. Contexts obtained via URL dispatch don't\n    really support being virtually rooted (each URL dispatch context\n    is both its own physical and virtual root).  However if this API\n    is called with a ``resource`` argument which is a context obtained\n    via URL dispatch, the resource passed in will be returned\n    unconditionally.\"\"\"\n    try:\n        reg = request.registry\n    except AttributeError:\n        reg = get_current_registry()\n    url_adapter = reg.queryMultiAdapter((resource, request), IResourceURL)\n    if url_adapter is None:\n        url_adapter = ResourceURL(resource, request)\n\n    vpath, rpath = url_adapter.virtual_path, url_adapter.physical_path\n    if rpath != vpath and rpath.endswith(vpath):\n        vroot_path = rpath[: -len(vpath)]\n        return find_resource(resource, vroot_path)\n\n    try:\n        return request.root\n    except AttributeError:\n        return find_root(resource)"
    },
    {
      "chunk_id": 588,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def traversal_path(path):\n    \"\"\"Variant of :func:`pyramid.traversal.traversal_path_info` suitable for\n    decoding paths that are URL-encoded.\n\n    If this function is passed a string, it *must* be directly encodeable to\n    ASCII.  For example, '/foo' will work but '/<unprintable unicode>' (a\n    string object with characters that cannot be encoded to ASCII) will\n    not. A :exc:`UnicodeEncodeError` will be raised if the string cannot be\n    encoded directly to ASCII.\n    \"\"\"\n    if isinstance(path, str):\n        # must not possess characters outside ascii\n        path = path.encode('ascii')\n    # we unquote this path exactly like a PEP 3333 server would\n    path = unquote_bytes_to_wsgi(path)  # result will be a native string\n    return traversal_path_info(path)  # result will be a tuple of unicode"
    },
    {
      "chunk_id": 589,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "@lru_cache(1000)\ndef traversal_path_info(path):\n    \"\"\"Given``path``, return a tuple representing that path which can be\n    used to traverse a resource tree.  ``path`` is assumed to be an\n    already-URL-decoded ``str`` type as if it had come to us from an upstream\n    WSGI server as the ``PATH_INFO`` environ variable.\n\n    The ``path`` is first decoded from its WSGI representation to text.\n    Per the :pep:`3333` spec, ``path`` is first encoded to bytes using the\n    Latin-1 encoding; the resulting set of bytes is subsequently decoded to\n    text using the UTF-8 encoding; a :exc:`pyramid.exc.URLDecodeError` is\n    raised if the URL cannot be decoded.\n\n    The ``path`` is split on slashes, creating a list of segments.  If a\n    segment name is empty or if it is ``.``, it is ignored.  If a segment\n    name is ``..``, the previous segment is deleted, and the ``..`` is\n    ignored.\n\n    Examples:\n\n    ``/``\n\n        ()\n\n    ``/foo/bar/baz``\n\n        ('foo', 'bar', 'baz')\n\n    ``foo/bar/baz``\n\n        ('foo', 'bar', 'baz')\n\n    ``/foo/bar/baz/``\n\n        ('foo', 'bar', 'baz')\n\n    ``/foo//bar//baz/``\n\n        ('foo', 'bar', 'baz')\n\n    ``/foo/bar/baz/..``\n\n        ('foo', 'bar')\n\n    ``/my%20archives/hello``\n\n        ('my archives', 'hello')\n\n    ``/archives/La%20Pe%C3%B1a``\n\n        ('archives', '<unprintable unicode>')\n\n    .. note::\n\n      This function does not generate the same type of tuples that\n      :func:`pyramid.traversal.resource_path_tuple` does.  In particular, the\n      leading empty string is not present in the tuple it returns, unlike\n      tuples returned by :func:`pyramid.traversal.resource_path_tuple`.  As a\n      result, tuples generated by ``traversal_path`` are not resolveable by\n      the :func:`pyramid.traversal.find_resource` API.  ``traversal_path`` is\n      a function mostly used by the internals of :app:`Pyramid` and by people\n      writing their own traversal machinery, as opposed to users writing\n      applications in :app:`Pyramid`.\n    \"\"\"\n    try:\n        path = decode_path_info(path)  # result will be Unicode\n    except UnicodeDecodeError as e:\n        raise URLDecodeError(e.encoding, e.object, e.start, e.end, e.reason)\n    return split_path_info(path)  # result will be tuple of Unicode"
    },
    {
      "chunk_id": 590,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "@lru_cache(1000)\ndef split_path_info(path):\n    # suitable for splitting an already-unquoted-already-decoded (unicode)\n    # path value\n    path = path.strip('/')\n    clean = []\n    for segment in path.split('/'):\n        if not segment or segment == '.':\n            continue\n        elif segment == '..':\n            if clean:\n                del clean[-1]\n        else:\n            clean.append(segment)\n    return tuple(clean)"
    },
    {
      "chunk_id": 591,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "# see PEP 3333 for why we encode to latin-1 then decode to utf-8\ndef decode_path_info(path):\n    return path.encode('latin-1').decode('utf-8')"
    },
    {
      "chunk_id": 592,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "# see PEP 3333 for why we decode the path to latin-1\ndef unquote_bytes_to_wsgi(bytestring):\n    return unquote_to_bytes(bytestring).decode('latin-1')"
    },
    {
      "chunk_id": 593,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "_segment_cache = {}"
    },
    {
      "chunk_id": 594,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "def quote_path_segment(segment, safe=PATH_SEGMENT_SAFE):\n    \"\"\"\n    Return a quoted representation of a 'path segment' (such as\n    the string ``__name__`` attribute of a resource) as a string.  If the\n    ``segment`` passed in is a bytes object, it is decoded as a UTF-8 string.\n    The result is then URL-quoted using Python's ``urllib.quote``.\n    If the segment passed in is not bytes nor a string, an error will be\n    raised. The return value of ``quote_path_segment`` is always a string.\n\n    You may pass a string of characters that need not be encoded as\n    the ``safe`` argument to this function.  This corresponds to the\n    ``safe`` argument to :mod:`urllib.quote`.\n\n    .. note::\n\n       The return value for each segment passed to this\n       function is cached in a module-scope dictionary for\n       speed: the cached version is returned when possible\n       rather than recomputing the quoted version.  No cache\n       emptying is ever done for the lifetime of an\n       application, however.  If you pass arbitrary\n       user-supplied strings to this function (as opposed to\n       some bounded set of values from a 'working set' known to\n       your application), it may become a memory leak.\n\n    \"\"\"\n    # The bit of this code that deals with ``_segment_cache`` is an\n    # optimization: we cache all the computation of URL path segments\n    # in this module-scope dictionary with the original string as the\n    # key, so we can look it up later without needing to reencode\n    # or re-url-quote it\n    try:\n        if segment.__class__ not in (str, bytes):\n            segment = str(segment)\n        return _segment_cache[(segment, safe)]\n    except KeyError:\n        result = url_quote(text_(segment, 'utf-8'), safe)\n        # we don't need a lock to mutate _segment_cache, as the below\n        # will generate exactly one Python bytecode (STORE_SUBSCR)\n        _segment_cache[(segment, safe)] = result\n        return result"
    },
    {
      "chunk_id": 595,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "@implementer(ITraverser)\nclass ResourceTreeTraverser:\n    \"\"\"A resource tree traverser that should be used (for speed) when\n    every resource in the tree supplies a ``__name__`` and\n    ``__parent__`` attribute (ie. every resource in the tree is\n    :term:`location` aware) .\"\"\"\n\n    VH_ROOT_KEY = VH_ROOT_KEY\n    VIEW_SELECTOR = '@@'\n\n    def __init__(self, root):\n        self.root = root\n\n    def __call__(self, request):\n        environ = request.environ\n        matchdict = request.matchdict\n\n        if matchdict is not None:\n            path = matchdict.get('traverse', '/') or '/'\n            if is_nonstr_iter(path):\n                # this is a *traverse stararg (not a {traverse})\n                # routing has already decoded these elements, so we just\n                # need to join them\n                path = '/' + '/'.join(path) or '/'\n\n            subpath = matchdict.get('subpath', ())\n            if not is_nonstr_iter(subpath):\n                # this is not a *subpath stararg (just a {subpath})\n                # routing has already decoded this string, so we just need\n                # to split it\n                subpath = split_path_info(subpath)\n\n        else:\n            # this request did not match a route\n            subpath = ()\n            try:\n                # empty if mounted under a path in mod_wsgi, for example\n                path = request.path_info or '/'\n            except KeyError:\n                # if environ['PATH_INFO'] is just not there\n                path = '/'\n            except UnicodeDecodeError as e:\n                raise URLDecodeError(\n                    e.encoding, e.object, e.start, e.end, e.reason\n                )\n\n        if self.VH_ROOT_KEY in environ:\n            # HTTP_X_VHM_ROOT\n            vroot_path = decode_path_info(environ[self.VH_ROOT_KEY])\n            vroot_tuple = split_path_info(vroot_path)\n            vpath = (\n                vroot_path + path\n            )  # both will (must) be unicode or asciistr\n            vroot_idx = len(vroot_tuple) - 1\n        else:\n            vroot_tuple = ()\n            vpath = path\n            vroot_idx = -1\n\n        root = self.root\n        ob = vroot = root\n\n        if vpath == '/':  # invariant: vpath must not be empty\n            # prevent a call to traversal_path if we know it's going\n            # to return the empty tuple\n            vpath_tuple = ()\n        else:\n            # we do dead reckoning here via tuple slicing instead of\n            # pushing and popping temporary lists for speed purposes\n            # and this hurts readability; apologies\n            i = 0\n            view_selector = self.VIEW_SELECTOR\n            vpath_tuple = split_path_info(vpath)\n            for segment in vpath_tuple:\n                if segment[:2] == view_selector:\n                    return {\n                        'context': ob,\n                        'view_name': segment[2:],\n                        'subpath': vpath_tuple[i + 1 :],\n                        'traversed': vpath_tuple[: vroot_idx + i + 1],\n                        'virtual_root': vroot,\n                        'virtual_root_path': vroot_tuple,\n                        'root': root,\n                    }\n                try:\n                    getitem = ob.__getitem__\n                except AttributeError:\n                    return {\n                        'context': ob,\n                        'view_name': segment,\n                        'subpath': vpath_tuple[i + 1 :],\n                        'traversed': vpath_tuple[: vroot_idx + i + 1],\n                        'virtual_root': vroot,\n                        'virtual_root_path': vroot_tuple,\n                        'root': root,\n                    }\n\n                try:\n                    next = getitem(segment)\n                except KeyError:\n                    return {\n                        'context': ob,\n                        'view_name': segment,\n                        'subpath': vpath_tuple[i + 1 :],\n                        'traversed': vpath_tuple[: vroot_idx + i + 1],\n                        'virtual_root': vroot,\n                        'virtual_root_path': vroot_tuple,\n                        'root': root,\n                    }\n                if i == vroot_idx:\n                    vroot = next\n                ob = next\n                i += 1\n\n        return {\n            'context': ob,\n            'view_name': '',\n            'subpath': subpath,\n            'traversed': vpath_tuple,\n            'virtual_root': vroot,\n            'virtual_root_path': vroot_tuple,\n            'root': root,\n        }"
    },
    {
      "chunk_id": 596,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "ModelGraphTraverser = (\n    ResourceTreeTraverser  # b/w compat, not API, used in wild\n)"
    },
    {
      "chunk_id": 597,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "@implementer(IResourceURL)\nclass ResourceURL:\n    VH_ROOT_KEY = VH_ROOT_KEY\n\n    def __init__(self, resource, request):\n        physical_path_tuple = resource_path_tuple(resource)\n        physical_path = _join_path_tuple(physical_path_tuple)\n\n        if physical_path_tuple != ('',):\n            physical_path_tuple = physical_path_tuple + ('',)\n            physical_path = physical_path + '/'\n\n        virtual_path = physical_path\n        virtual_path_tuple = physical_path_tuple\n\n        environ = request.environ\n        vroot_path = environ.get(self.VH_ROOT_KEY)\n\n        # if the physical path starts with the virtual root path, trim it out\n        # of the virtual path\n        if vroot_path is not None:\n            vroot_path = vroot_path.rstrip('/')\n            if vroot_path and physical_path.startswith(vroot_path):\n                vroot_path_tuple = tuple(vroot_path.split('/'))\n                numels = len(vroot_path_tuple)\n                virtual_path_tuple = ('',) + physical_path_tuple[numels:]\n                virtual_path = physical_path[len(vroot_path) :]\n\n        self.virtual_path = virtual_path  # IResourceURL attr\n        self.physical_path = physical_path  # IResourceURL attr\n        self.virtual_path_tuple = virtual_path_tuple  # IResourceURL attr (1.5)\n        self.physical_path_tuple = (\n            physical_path_tuple  # IResourceURL attr (1.5)\n        )"
    },
    {
      "chunk_id": 598,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "@lru_cache(1000)\ndef _join_path_tuple(tuple):\n    return tuple and '/'.join([quote_path_segment(x) for x in tuple]) or '/'"
    },
    {
      "chunk_id": 599,
      "source": "__internal__/data_repo/pyramid/src/pyramid/traversal.py",
      "content": "class DefaultRootFactory:\n    __parent__ = None\n    __name__ = None\n\n    def __init__(self, request):\n        pass"
    },
    {
      "chunk_id": 600,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "import binascii\nimport os\nimport pickle\nimport time\nfrom webob.cookies import JSONSerializer, SignedSerializer\nfrom zope.deprecation import deprecated\nfrom zope.interface import implementer\n\nfrom pyramid.csrf import check_csrf_origin, check_csrf_token\nfrom pyramid.interfaces import ISession\nfrom pyramid.util import bytes_, text_"
    },
    {
      "chunk_id": 601,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "def manage_accessed(wrapped):\n    \"\"\"Decorator which causes a cookie to be renewed when an accessor\n    method is called.\"\"\"\n\n    def accessed(session, *arg, **kw):\n        session.accessed = now = int(time.time())\n        if session._reissue_time is not None:\n            if now - session.renewed > session._reissue_time:\n                session.changed()\n        return wrapped(session, *arg, **kw)\n\n    accessed.__doc__ = wrapped.__doc__\n    return accessed"
    },
    {
      "chunk_id": 602,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "def manage_changed(wrapped):\n    \"\"\"Decorator which causes a cookie to be set when a setter method\n    is called.\"\"\"\n\n    def changed(session, *arg, **kw):\n        session.accessed = int(time.time())\n        session.changed()\n        return wrapped(session, *arg, **kw)\n\n    changed.__doc__ = wrapped.__doc__\n    return changed"
    },
    {
      "chunk_id": 603,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "class PickleSerializer:\n    \"\"\"\n    .. deprecated:: 2.0\n\n    .. warning::\n\n        In :app:`Pyramid` 2.0 the default ``serializer`` option changed to\n        use :class:`pyramid.session.JSONSerializer`, and ``PickleSerializer``\n        has been been removed from active Pyramid code.\n\n        Pyramid will require JSON-serializable objects in :app:`Pyramid` 2.0.\n\n        Please see :ref:`upgrading_session_20`.\n\n    A serializer that uses the pickle protocol to dump Python data to bytes.\n\n    This was the default serializer used by Pyramid, but has been deprecated.\n\n    ``protocol`` may be specified to control the version of pickle used.\n    Defaults to :attr:`pickle.HIGHEST_PROTOCOL`.\n    \"\"\"\n\n    def __init__(self, protocol=pickle.HIGHEST_PROTOCOL):\n        self.protocol = protocol\n\n    def loads(self, bstruct):\n        \"\"\"Accept bytes and return a Python object.\"\"\"\n        try:\n            return pickle.loads(bstruct)\n        except Exception:\n            # this block should catch at least:\n            # ValueError, AttributeError, ImportError; but more to be safe\n            raise ValueError\n\n    def dumps(self, appstruct):\n        \"\"\"Accept a Python object and return bytes.\"\"\"\n        return pickle.dumps(appstruct, self.protocol)"
    },
    {
      "chunk_id": 604,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "deprecated(\n    'PickleSerializer',\n    'pyramid.session.PickleSerializer is deprecated as of Pyramid 2.0 for '\n    'security concerns. Use pyramid.session.JSONSerializer or reference the '\n    'narrative documentation for information on building a migration tool.',\n)"
    },
    {
      "chunk_id": 605,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "JSONSerializer = JSONSerializer  # api"
    },
    {
      "chunk_id": 606,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "def BaseCookieSessionFactory(\n    serializer,\n    cookie_name='session',\n    max_age=None,\n    path='/',\n    domain=None,\n    secure=False,\n    httponly=False,\n    samesite='Lax',\n    timeout=1200,\n    reissue_time=0,\n    set_on_exception=True,\n):\n    \"\"\"\n    Configure a :term:`session factory` which will provide cookie-based\n    sessions.  The return value of this function is a :term:`session factory`,\n    which may be provided as the ``session_factory`` argument of a\n    :class:`pyramid.config.Configurator` constructor, or used as the\n    ``session_factory`` argument of the\n    :meth:`pyramid.config.Configurator.set_session_factory` method.\n\n    The session factory returned by this function will create sessions\n    which are limited to storing fewer than 4000 bytes of data (as the\n    payload must fit into a single cookie).\n\n    .. warning:\n\n       This class provides no protection from tampering and is only intended\n       to be used by framework authors to create their own cookie-based\n       session factories.\n\n    Parameters:\n\n    ``serializer``\n      An object with two methods: ``loads`` and ``dumps``.  The ``loads``\n      method should accept bytes and return a Python object.  The ``dumps``\n      method should accept a Python object and return bytes.  A ``ValueError``\n      should be raised for malformed inputs.\n\n    ``cookie_name``\n      The name of the cookie used for sessioning. Default: ``'session'``.\n\n    ``max_age``\n      The maximum age of the cookie used for sessioning (in seconds).\n      Default: ``None`` (browser scope).\n\n    ``path``\n      The path used for the session cookie. Default: ``'/'``.\n\n    ``domain``\n      The domain used for the session cookie.  Default: ``None`` (no domain).\n\n    ``secure``\n      The 'secure' flag of the session cookie. Default: ``False``.\n\n    ``httponly``\n      Hide the cookie from Javascript by setting the 'HttpOnly' flag of the\n      session cookie. Default: ``False``.\n\n    ``samesite``\n      The 'samesite' option of the session cookie. Set the value to ``None``\n      to turn off the samesite option.  Default: ``'Lax'``.\n\n    ``timeout``\n      A number of seconds of inactivity before a session times out. If\n      ``None`` then the cookie never expires. This lifetime only applies\n      to the *value* within the cookie. Meaning that if the cookie expires\n      due to a lower ``max_age``, then this setting has no effect.\n      Default: ``1200``.\n\n    ``reissue_time``\n      The number of seconds that must pass before the cookie is automatically\n      reissued as the result of a request which accesses the session. The\n      duration is measured as the number of seconds since the last session\n      cookie was issued and 'now'.  If this value is ``0``, a new cookie\n      will be reissued on every request accessing the session. If ``None``\n      then the cookie's lifetime will never be extended.\n\n      A good rule of thumb: if you want auto-expired cookies based on\n      inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n      ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n      (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n      than the ``reissue_time`` value, as the ticket will never be reissued.\n      However, such a configuration is not explicitly prevented.\n\n      Default: ``0``.\n\n    ``set_on_exception``\n      If ``True``, set a session cookie even if an exception occurs\n      while rendering a view. Default: ``True``.\n\n    .. versionadded: 1.5a3\n\n    .. versionchanged: 1.10\n\n       Added the ``samesite`` option and made the default ``'Lax'``.\n    \"\"\"\n\n    @implementer(ISession)\n    class CookieSession(dict):\n        \"\"\"Dictionary-like session object\"\"\"\n\n        # configuration parameters\n        _cookie_name = cookie_name\n        _cookie_max_age = max_age if max_age is None else int(max_age)\n        _cookie_path = path\n        _cookie_domain = domain\n        _cookie_secure = secure\n        _cookie_httponly = httponly\n        _cookie_samesite = samesite\n        _cookie_on_exception = set_on_exception\n        _timeout = timeout if timeout is None else int(timeout)\n        _reissue_time = (\n            reissue_time if reissue_time is None else int(reissue_time)\n        )\n\n        # dirty flag\n        _dirty = False\n\n        def __init__(self, request):\n            self.request = request\n            now = time.time()\n            created = renewed = now\n            new = True\n            value = None\n            state = {}\n            cookieval = request.cookies.get(self._cookie_name)\n            if cookieval is not None:\n                try:\n                    value = serializer.loads(bytes_(cookieval))\n                except ValueError:\n                    # the cookie failed to deserialize, dropped\n                    value = None\n\n            if value is not None:\n                try:\n                    # since the value is not necessarily signed, we have\n                    # to unpack it a little carefully\n                    rval, cval, sval = value\n                    renewed = float(rval)\n                    created = float(cval)\n                    state = sval\n                    new = False\n                except (TypeError, ValueError):\n                    # value failed to unpack properly or renewed was not\n                    # a numeric type so we'll fail deserialization here\n                    state = {}\n\n            if self._timeout is not None:\n                if now - renewed > self._timeout:\n                    # expire the session because it was not renewed\n                    # before the timeout threshold\n                    state = {}\n\n            self.created = created\n            self.accessed = renewed\n            self.renewed = renewed\n            self.new = new\n            dict.__init__(self, state)\n\n        # ISession methods\n        def changed(self):\n            if not self._dirty:\n                self._dirty = True\n\n                def set_cookie_callback(request, response):\n                    self._set_cookie(response)\n                    self.request = None  # explicitly break cycle for gc\n\n                self.request.add_response_callback(set_cookie_callback)\n\n        def invalidate(self):\n            self.clear()  # XXX probably needs to unset cookie\n\n        # non-modifying dictionary methods\n        get = manage_accessed(dict.get)\n        __getitem__ = manage_accessed(dict.__getitem__)\n        items = manage_accessed(dict.items)\n        values = manage_accessed(dict.values)\n        keys = manage_accessed(dict.keys)\n        __contains__ = manage_accessed(dict.__contains__)\n        __len__ = manage_accessed(dict.__len__)\n        __iter__ = manage_accessed(dict.__iter__)\n\n        # modifying dictionary methods\n        clear = manage_changed(dict.clear)\n        update = manage_changed(dict.update)\n        setdefault = manage_changed(dict.setdefault)\n        pop = manage_changed(dict.pop)\n        popitem = manage_changed(dict.popitem)\n        __setitem__ = manage_changed(dict.__setitem__)\n        __delitem__ = manage_changed(dict.__delitem__)\n\n        # flash API methods\n        @manage_changed\n        def flash(self, msg, queue='', allow_duplicate=True):\n            storage = self.setdefault('_f_' + queue, [])\n            if allow_duplicate or (msg not in storage):\n                storage.append(msg)\n\n        @manage_changed\n        def pop_flash(self, queue=''):\n            storage = self.pop('_f_' + queue, [])\n            return storage\n\n        @manage_accessed\n        def peek_flash(self, queue=''):\n            storage = self.get('_f_' + queue, [])\n            return storage\n\n        # CSRF API methods\n        @manage_changed\n        def new_csrf_token(self):\n            token = text_(binascii.hexlify(os.urandom(20)))\n            self['_csrft_'] = token\n            return token\n\n        @manage_accessed\n        def get_csrf_token(self):\n            token = self.get('_csrft_', None)\n            if token is None:\n                token = self.new_csrf_token()\n            return token\n\n        # non-API methods\n        def _set_cookie(self, response):\n            if not self._cookie_on_exception:\n                exception = getattr(self.request, 'exception', None)\n                if (\n                    exception is not None\n                ):  # dont set a cookie during exceptions\n                    return False\n            cookieval = text_(\n                serializer.dumps((self.accessed, self.created, dict(self)))\n            )\n            if len(cookieval) > 4064:\n                raise ValueError(\n                    'Cookie value is too long to store (%s bytes)'\n                    % len(cookieval)\n                )\n            response.set_cookie(\n                self._cookie_name,\n                value=cookieval,\n                max_age=self._cookie_max_age,\n                path=self._cookie_path,\n                domain=self._cookie_domain,\n                secure=self._cookie_secure,\n                httponly=self._cookie_httponly,\n                samesite=self._cookie_samesite,\n            )\n            return True\n\n    return CookieSession"
    },
    {
      "chunk_id": 607,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "def SignedCookieSessionFactory(\n    secret,\n    cookie_name='session',\n    max_age=None,\n    path='/',\n    domain=None,\n    secure=False,\n    httponly=False,\n    samesite='Lax',\n    set_on_exception=True,\n    timeout=1200,\n    reissue_time=0,\n    hashalg='sha512',\n    salt='pyramid.session.',\n    serializer=None,\n):\n    \"\"\"\n    Configure a :term:`session factory` which will provide signed\n    cookie-based sessions.  The return value of this\n    function is a :term:`session factory`, which may be provided as\n    the ``session_factory`` argument of a\n    :class:`pyramid.config.Configurator` constructor, or used\n    as the ``session_factory`` argument of the\n    :meth:`pyramid.config.Configurator.set_session_factory`\n    method.\n\n    The session factory returned by this function will create sessions\n    which are limited to storing fewer than 4000 bytes of data (as the\n    payload must fit into a single cookie).\n\n    Parameters:\n\n    ``secret``\n      A string which is used to sign the cookie. The secret should be at\n      least as long as the block size of the selected hash algorithm. For\n      ``sha512`` this would mean a 512 bit (64 character) secret.  It should\n      be unique within the set of secret values provided to Pyramid for\n      its various subsystems (see :ref:`admonishment_against_secret_sharing`).\n\n    ``hashalg``\n      The HMAC digest algorithm to use for signing. The algorithm must be\n      supported by the :mod:`hashlib` library. Default: ``'sha512'``.\n\n    ``salt``\n      A namespace to avoid collisions between different uses of a shared\n      secret. Reusing a secret for different parts of an application is\n      strongly discouraged (see :ref:`admonishment_against_secret_sharing`).\n      Default: ``'pyramid.session.'``.\n\n    ``cookie_name``\n      The name of the cookie used for sessioning. Default: ``'session'``.\n\n    ``max_age``\n      The maximum age of the cookie used for sessioning (in seconds).\n      Default: ``None`` (browser scope).\n\n    ``path``\n      The path used for the session cookie. Default: ``'/'``.\n\n    ``domain``\n      The domain used for the session cookie.  Default: ``None`` (no domain).\n\n    ``secure``\n      The 'secure' flag of the session cookie. Default: ``False``.\n\n    ``httponly``\n      Hide the cookie from Javascript by setting the 'HttpOnly' flag of the\n      session cookie. Default: ``False``.\n\n    ``samesite``\n      The 'samesite' option of the session cookie. Set the value to ``None``\n      to turn off the samesite option.  Default: ``'Lax'``.\n\n    ``timeout``\n      A number of seconds of inactivity before a session times out. If\n      ``None`` then the cookie never expires. This lifetime only applies\n      to the *value* within the cookie. Meaning that if the cookie expires\n      due to a lower ``max_age``, then this setting has no effect.\n      Default: ``1200``.\n\n    ``reissue_time``\n      The number of seconds that must pass before the cookie is automatically\n      reissued as the result of accessing the session. The\n      duration is measured as the number of seconds since the last session\n      cookie was issued and 'now'.  If this value is ``0``, a new cookie\n      will be reissued on every request accessing the session. If ``None``\n      then the cookie's lifetime will never be extended.\n\n      A good rule of thumb: if you want auto-expired cookies based on\n      inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n      ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n      (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n      than the ``reissue_time`` value, as the ticket will never be reissued.\n      However, such a configuration is not explicitly prevented.\n\n      Default: ``0``.\n\n    ``set_on_exception``\n      If ``True``, set a session cookie even if an exception occurs\n      while rendering a view. Default: ``True``.\n\n    ``serializer``\n      An object with two methods: ``loads`` and ``dumps``.  The ``loads``\n      method should accept bytes and return a Python object.  The ``dumps``\n      method should accept a Python object and return bytes.  A ``ValueError``\n      should be raised for malformed inputs.  If a serializer is not passed,\n      the :class:`pyramid.session.JSONSerializer` serializer will be used.\n\n    .. warning::\n\n        In :app:`Pyramid` 2.0 the default ``serializer`` option changed to\n        use :class:`pyramid.session.JSONSerializer`. See\n        :ref:`upgrading_session_20` for more information about why this\n        change was made.\n\n    .. versionadded: 1.5a3\n\n    .. versionchanged: 1.10\n\n        Added the ``samesite`` option and made the default ``Lax``.\n\n    .. versionchanged: 2.0\n\n        Changed the default ``serializer`` to be an instance of\n        :class:`pyramid.session.JSONSerializer`.\n\n    \"\"\"\n    if serializer is None:\n        serializer = JSONSerializer()\n\n    signed_serializer = SignedSerializer(\n        secret, salt, hashalg, serializer=serializer\n    )\n\n    return BaseCookieSessionFactory(\n        signed_serializer,\n        cookie_name=cookie_name,\n        max_age=max_age,\n        path=path,\n        domain=domain,\n        secure=secure,\n        httponly=httponly,\n        samesite=samesite,\n        timeout=timeout,\n        reissue_time=reissue_time,\n        set_on_exception=set_on_exception,\n    )"
    },
    {
      "chunk_id": 608,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "check_csrf_origin = check_csrf_origin  # api\ndeprecated(\n    'check_csrf_origin',\n    'pyramid.session.check_csrf_origin is deprecated as of Pyramid '\n    '1.9. Use pyramid.csrf.check_csrf_origin instead.',\n)"
    },
    {
      "chunk_id": 609,
      "source": "__internal__/data_repo/pyramid/src/pyramid/session.py",
      "content": "check_csrf_token = check_csrf_token  # api\ndeprecated(\n    'check_csrf_token',\n    'pyramid.session.check_csrf_token is deprecated as of Pyramid '\n    '1.9. Use pyramid.csrf.check_csrf_token instead.',\n)"
    },
    {
      "chunk_id": 610,
      "source": "__internal__/data_repo/pyramid/src/pyramid/decorator.py",
      "content": "class reify:\n    \"\"\"Use as a class method decorator.  It operates almost exactly like the\n    Python ``@property`` decorator, but it puts the result of the method it\n    decorates into the instance dict after the first call, effectively\n    replacing the function it decorates with an instance variable.  It is, in\n    Python parlance, a non-data descriptor.  The following is an example and\n    its usage:\n\n    .. doctest::\n\n        >>> from pyramid.decorator import reify\n\n        >>> class Foo:\n        ...     @reify\n        ...     def jammy(self):\n        ...         print('jammy called')\n        ...         return 1\n\n        >>> f = Foo()\n        >>> v = f.jammy\n        jammy called\n        >>> print(v)\n        1\n        >>> f.jammy\n        1\n        >>> # jammy func not called the second time; it replaced itself with 1\n        >>> # Note: reassignment is possible\n        >>> f.jammy = 2\n        >>> f.jammy\n        2\n    \"\"\""
    },
    {
      "chunk_id": 611,
      "source": "__internal__/data_repo/pyramid/src/pyramid/decorator.py",
      "content": "def __init__(self, wrapped):\n        self.wrapped = wrapped\n        self.__name__ = wrapped.__name__\n        self.__doc__ = wrapped.__doc__"
    },
    {
      "chunk_id": 612,
      "source": "__internal__/data_repo/pyramid/src/pyramid/decorator.py",
      "content": "def __get__(self, inst, objtype=None):\n        if inst is None:\n            return self\n        val = self.wrapped(inst)\n        # reify is a non-data-descriptor which is leveraging the fact\n        # that it is not invoked if the equivalent attribute is defined in the\n        # object's dict, so the setattr here effectively hides this descriptor\n        # from subsequent lookups\n        setattr(inst, self.wrapped.__name__, val)\n        return val"
    },
    {
      "chunk_id": 613,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "import inspect\nimport logging\nimport os\nimport threading\nimport venusian\nfrom webob.exc import WSGIHTTPException as WebobWSGIHTTPException\n\nfrom pyramid.asset import resolve_asset_spec\nfrom pyramid.authorization import ACLAuthorizationPolicy\nfrom pyramid.config.actions import (\n    ActionConfiguratorMixin,\n    ActionState,\n    action_method,\n)\nfrom pyramid.config.adapters import AdaptersConfiguratorMixin\nfrom pyramid.config.assets import AssetsConfiguratorMixin\nfrom pyramid.config.factories import FactoriesConfiguratorMixin\nfrom pyramid.config.i18n import I18NConfiguratorMixin\nfrom pyramid.config.predicates import PredicateConfiguratorMixin, not_\nfrom pyramid.config.rendering import RenderingConfiguratorMixin\nfrom pyramid.config.routes import RoutesConfiguratorMixin\nfrom pyramid.config.security import SecurityConfiguratorMixin\nfrom pyramid.config.settings import SettingsConfiguratorMixin\nfrom pyramid.config.testing import TestingConfiguratorMixin\nfrom pyramid.config.tweens import TweensConfiguratorMixin\nfrom pyramid.config.views import ViewsConfiguratorMixin\nfrom pyramid.config.zca import ZCAConfiguratorMixin\nfrom pyramid.events import ApplicationCreated\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.httpexceptions import default_exceptionresponse_view\nfrom pyramid.interfaces import (\n    PHASE0_CONFIG,\n    PHASE1_CONFIG,\n    PHASE2_CONFIG,\n    PHASE3_CONFIG,\n    IDebugLogger,\n    IExceptionResponse,\n)\nfrom pyramid.path import DottedNameResolver, caller_package, package_of\nfrom pyramid.registry import Introspectable, Introspector, Registry\nfrom pyramid.router import Router\nfrom pyramid.settings import aslist\nfrom pyramid.threadlocal import manager\nfrom pyramid.util import WeakOrderedSet, get_callable_name, object_description\n\n_marker = object()\n\nnot_ = not_  # api\n\nPHASE0_CONFIG = PHASE0_CONFIG  # api\nPHASE1_CONFIG = PHASE1_CONFIG  # api\nPHASE2_CONFIG = PHASE2_CONFIG  # api\nPHASE3_CONFIG = PHASE3_CONFIG  # api\n\nActionState = ActionState  # bw-compat for pyramid_zcml"
    },
    {
      "chunk_id": 614,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "class Configurator(\n    ActionConfiguratorMixin,\n    PredicateConfiguratorMixin,\n    TestingConfiguratorMixin,\n    TweensConfiguratorMixin,\n    SecurityConfiguratorMixin,\n    ViewsConfiguratorMixin,\n    RoutesConfiguratorMixin,\n    ZCAConfiguratorMixin,\n    I18NConfiguratorMixin,\n    RenderingConfiguratorMixin,\n    AssetsConfiguratorMixin,\n    SettingsConfiguratorMixin,\n    FactoriesConfiguratorMixin,\n    AdaptersConfiguratorMixin,\n):\n    \"\"\"\n    A Configurator is used to configure a :app:`Pyramid`\n    :term:`application registry`.\n\n    The Configurator lifecycle can be managed by using a context manager to\n    automatically handle calling :meth:`pyramid.config.Configurator.begin` and\n    :meth:`pyramid.config.Configurator.end` as well as\n    :meth:`pyramid.config.Configurator.commit`.\n\n    .. code-block:: python\n\n        with Configurator(settings=settings) as config:\n            config.add_route('home', '/')\n            app = config.make_wsgi_app()\n\n    If the ``registry`` argument is not ``None``, it must\n    be an instance of the :class:`pyramid.registry.Registry` class\n    representing the registry to configure.  If ``registry`` is ``None``, the\n    configurator will create a :class:`pyramid.registry.Registry` instance\n    itself; it will also perform some default configuration that would not\n    otherwise be done.  After its construction, the configurator may be used\n    to add further configuration to the registry.\n\n    .. warning:: If ``registry`` is assigned the above-mentioned class\n       instance, all other constructor arguments are ignored,\n       with the exception of ``package``.\n\n    If the ``package`` argument is passed, it must be a reference to a Python\n    :term:`package` (e.g. ``sys.modules['thepackage']``) or a :term:`dotted\n    Python name` to the same.  This value is used as a basis to convert\n    relative paths passed to various configuration methods, such as methods\n    which accept a ``renderer`` argument, into absolute paths.  If ``None``\n    is passed (the default), the package is assumed to be the Python package\n    in which the *caller* of the ``Configurator`` constructor lives.\n\n    If the ``root_package`` is passed, it will propagate through the\n    configuration hierarchy as a way for included packages to locate\n    resources relative to the package in which the main ``Configurator`` was\n    created. If ``None`` is passed (the default), the ``root_package`` will\n    be derived from the ``package`` argument. The ``package`` attribute is\n    always pointing at the package being included when using :meth:`.include`,\n    whereas the ``root_package`` does not change.\n\n    If the ``settings`` argument is passed, it should be a Python dictionary\n    representing the :term:`deployment settings` for this application.  These\n    are later retrievable using the\n    :attr:`pyramid.registry.Registry.settings` attribute (aka\n    ``request.registry.settings``).\n\n    If the ``root_factory`` argument is passed, it should be an object\n    representing the default :term:`root factory` for your application or a\n    :term:`dotted Python name` to the same.  If it is ``None``, a default\n    root factory will be used.\n\n    If ``security_policy`` is passed, it should be an instance of a\n    :term:`security policy` or a :term:`dotted Python name` to the same.\n\n    If ``authentication_policy`` is passed, it should be an instance\n    of an :term:`authentication policy` or a :term:`dotted Python\n    name` to the same.\n\n    If ``authorization_policy`` is passed, it should be an instance of\n    an :term:`authorization policy` or a :term:`dotted Python name` to\n    the same.\n\n    .. note:: A ``ConfigurationError`` will be raised when an\n       authorization policy is supplied without also supplying an\n       authentication policy (authorization requires authentication).\n\n    If ``renderers`` is ``None`` (the default), a default set of\n    :term:`renderer` factories is used. Else, it should be a list of\n    tuples representing a set of renderer factories which should be\n    configured into this application, and each tuple representing a set of\n    positional values that should be passed to\n    :meth:`pyramid.config.Configurator.add_renderer`.\n\n    If ``debug_logger`` is not passed, a default debug logger that logs to a\n    logger will be used (the logger name will be the package name of the\n    *caller* of this configurator).  If it is passed, it should be an\n    instance of the :class:`logging.Logger` (PEP 282) standard library class\n    or a Python logger name.  The debug logger is used by :app:`Pyramid`\n    itself to log warnings and authorization debugging information.\n\n    If ``locale_negotiator`` is passed, it should be a :term:`locale\n    negotiator` implementation or a :term:`dotted Python name` to\n    same.  See :ref:`custom_locale_negotiator`.\n\n    If ``request_factory`` is passed, it should be a :term:`request\n    factory` implementation or a :term:`dotted Python name` to the same.\n    See :ref:`changing_the_request_factory`.  By default it is ``None``,\n    which means use the default request factory.\n\n    If ``response_factory`` is passed, it should be a :term:`response\n    factory` implementation or a :term:`dotted Python name` to the same.\n    See :ref:`changing_the_response_factory`.  By default it is ``None``,\n    which means use the default response factory.\n\n    If ``default_permission`` is passed, it should be a\n    :term:`permission` string to be used as the default permission for\n    all view configuration registrations performed against this\n    Configurator.  An example of a permission string:``'view'``.\n    Adding a default permission makes it unnecessary to protect each\n    view configuration with an explicit permission, unless your\n    application policy requires some exception for a particular view.\n    By default, ``default_permission`` is ``None``, meaning that view\n    configurations which do not explicitly declare a permission will\n    always be executable by entirely anonymous users (any\n    authorization policy in effect is ignored).\n\n    .. seealso::\n\n        See also :ref:`setting_a_default_permission`.\n\n    If ``session_factory`` is passed, it should be an object which\n    implements the :term:`session factory` interface.  If a nondefault\n    value is passed, the ``session_factory`` will be used to create a\n    session object when ``request.session`` is accessed.  Note that\n    the same outcome can be achieved by calling\n    :meth:`pyramid.config.Configurator.set_session_factory`.  By\n    default, this argument is ``None``, indicating that no session\n    factory will be configured (and thus accessing ``request.session``\n    will throw an error) unless ``set_session_factory`` is called later\n    during configuration.\n\n    If ``autocommit`` is ``True``, every method called on the configurator\n    will cause an immediate action, and no configuration conflict detection\n    will be used. If ``autocommit`` is ``False``, most methods of the\n    configurator will defer their action until\n    :meth:`pyramid.config.Configurator.commit` is called.  When\n    :meth:`pyramid.config.Configurator.commit` is called, the actions implied\n    by the called methods will be checked for configuration conflicts unless\n    ``autocommit`` is ``True``.  If a conflict is detected, a\n    ``ConfigurationConflictError`` will be raised.  Calling\n    :meth:`pyramid.config.Configurator.make_wsgi_app` always implies a final\n    commit.\n\n    If ``default_view_mapper`` is passed, it will be used as the default\n    :term:`view mapper` factory for view configurations that don't otherwise\n    specify one (see :class:`pyramid.interfaces.IViewMapperFactory`).  If\n    ``default_view_mapper`` is not passed, a superdefault view mapper will\n    be used.\n\n    If ``exceptionresponse_view`` is passed, it must be a :term:`view\n    callable` or ``None``.  If it is a view callable, it will be used as an\n    exception view callable when an :term:`exception response` is raised. If\n    ``exceptionresponse_view`` is ``None``, no exception response view will\n    be registered, and all raised exception responses will be bubbled up to\n    Pyramid's caller.  By\n    default, the ``pyramid.httpexceptions.default_exceptionresponse_view``\n    function is used as the ``exceptionresponse_view``.\n\n    If ``route_prefix`` is passed, all routes added with\n    :meth:`pyramid.config.Configurator.add_route` will have the specified path\n    prepended to their pattern.\n\n    If ``introspection`` is passed, it must be a boolean value.  If it's\n    ``True``, introspection values during actions will be kept for use\n    for tools like the debug toolbar.  If it's ``False``, introspection\n    values provided by registrations will be ignored.  By default, it is\n    ``True``.\n\n    .. versionadded:: 1.1\n       The ``exceptionresponse_view`` argument.\n\n    .. versionadded:: 1.2\n       The ``route_prefix`` argument.\n\n    .. versionadded:: 1.3\n       The ``introspection`` argument.\n\n    .. versionadded:: 1.6\n       The ``root_package`` argument.\n       The ``response_factory`` argument.\n\n    .. versionadded:: 1.9\n       The ability to use the configurator as a context manager with the\n       ``with``-statement to make threadlocal configuration available for\n       further configuration with an implicit commit.\n    \"\"\"\n\n    manager = manager  # for testing injection\n    venusian = venusian  # for testing injection\n    _ainfo = None\n    basepath = None\n    includepath = ()\n    info = ''\n    object_description = staticmethod(object_description)\n    introspectable = Introspectable\n    inspect = inspect\n\n    def __init__(\n        self,\n        registry=None,\n        package=None,\n        settings=None,\n        root_factory=None,\n        security_policy=None,\n        authentication_policy=None,\n        authorization_policy=None,\n        renderers=None,\n        debug_logger=None,\n        locale_negotiator=None,\n        request_factory=None,\n        response_factory=None,\n        default_permission=None,\n        session_factory=None,\n        default_view_mapper=None,\n        autocommit=False,\n        exceptionresponse_view=default_exceptionresponse_view,\n        route_prefix=None,\n        introspection=True,\n        root_package=None,\n    ):\n        if package is None:\n            package = caller_package()\n        if root_package is None:\n            root_package = package\n        name_resolver = DottedNameResolver(package)\n        self.name_resolver = name_resolver\n        self.package_name = name_resolver.get_package_name()\n        self.package = name_resolver.get_package()\n        self.root_package = root_package\n        self.registry = registry\n        self.autocommit = autocommit\n        self.route_prefix = route_prefix\n        self.introspection = introspection\n        if registry is None:\n            registry = Registry(self.package_name)\n            self.registry = registry\n            self.setup_registry(\n                settings=settings,\n                root_factory=root_factory,\n                authentication_policy=authentication_policy,\n                authorization_policy=authorization_policy,\n                security_policy=security_policy,\n                renderers=renderers,\n                debug_logger=debug_logger,\n                locale_negotiator=locale_negotiator,\n                request_factory=request_factory,\n                response_factory=response_factory,\n                default_permission=default_permission,\n                session_factory=session_factory,\n                default_view_mapper=default_view_mapper,\n                exceptionresponse_view=exceptionresponse_view,\n            )"
    },
    {
      "chunk_id": 615,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def setup_registry(\n        self,\n        settings=None,\n        root_factory=None,\n        security_policy=None,\n        authentication_policy=None,\n        authorization_policy=None,\n        renderers=None,\n        debug_logger=None,\n        locale_negotiator=None,\n        request_factory=None,\n        response_factory=None,\n        default_permission=None,\n        session_factory=None,\n        default_view_mapper=None,\n        exceptionresponse_view=default_exceptionresponse_view,\n    ):\n        \"\"\"When you pass a non-``None`` ``registry`` argument to the\n        :term:`Configurator` constructor, no initial setup is performed\n        against the registry.  This is because the registry you pass in may\n        have already been initialized for use under :app:`Pyramid` via a\n        different configurator.  However, in some circumstances (such as when\n        you want to use a global registry instead of a registry created as a\n        result of the Configurator constructor), or when you want to reset\n        the initial setup of a registry, you *do* want to explicitly\n        initialize the registry associated with a Configurator for use under\n        :app:`Pyramid`.  Use ``setup_registry`` to do this initialization.\n\n        ``setup_registry`` configures settings, a root factory, security\n        policies, renderers, a debug logger, a locale negotiator, and various\n        other settings using the configurator's current registry, as per the\n        descriptions in the Configurator constructor.\"\"\"\n\n        registry = self.registry\n\n        self._fix_registry()\n\n        self._set_settings(settings)\n\n        if isinstance(debug_logger, str):\n            debug_logger = logging.getLogger(debug_logger)\n\n        if debug_logger is None:\n            debug_logger = logging.getLogger(self.package_name)\n\n        registry.registerUtility(debug_logger, IDebugLogger)\n\n        self.add_default_response_adapters()\n        self.add_default_renderers()\n        self.add_default_accept_view_order()\n        self.add_default_view_predicates()\n        self.add_default_view_derivers()\n        self.add_default_route_predicates()\n        self.add_default_tweens()\n        self.add_default_security()\n\n        if exceptionresponse_view is not None:\n            exceptionresponse_view = self.maybe_dotted(exceptionresponse_view)\n            self.add_view(exceptionresponse_view, context=IExceptionResponse)\n            self.add_view(\n                exceptionresponse_view, context=WebobWSGIHTTPException\n            )\n\n        # commit below because:\n        #\n        # - the default exceptionresponse_view requires the superdefault view\n        #   mapper, so we need to configure it before adding\n        #   default_view_mapper\n        #\n        # - superdefault renderers should be overrideable without requiring\n        #   the user to commit before calling config.add_renderer\n\n        self.commit()\n\n        # self.commit() should not be called within this method after this\n        # point because the following registrations should be treated as\n        # analogues of methods called by the user after configurator\n        # construction.  Rationale: user-supplied implementations should be\n        # preferred rather than add-on author implementations with the help of\n        # automatic conflict resolution.\n\n        if authentication_policy and not authorization_policy:\n            authorization_policy = ACLAuthorizationPolicy()  # default\n\n        if authorization_policy:\n            self.set_authorization_policy(authorization_policy)\n\n        if authentication_policy:\n            self.set_authentication_policy(authentication_policy)\n\n        if security_policy:\n            self.set_security_policy(security_policy)\n\n        if default_view_mapper is not None:\n            self.set_view_mapper(default_view_mapper)\n\n        if renderers:\n            for name, renderer in renderers:\n                self.add_renderer(name, renderer)\n\n        if root_factory is not None:\n            self.set_root_factory(root_factory)\n\n        if locale_negotiator:\n            self.set_locale_negotiator(locale_negotiator)\n\n        if request_factory:\n            self.set_request_factory(request_factory)\n\n        if response_factory:\n            self.set_response_factory(response_factory)\n\n        if default_permission:\n            self.set_default_permission(default_permission)\n\n        if session_factory is not None:\n            self.set_session_factory(session_factory)\n\n        tweens = aslist(registry.settings.get('pyramid.tweens', []))\n        for factory in tweens:\n            self._add_tween(factory, explicit=True)\n\n        includes = aslist(registry.settings.get('pyramid.includes', []))\n        for inc in includes:\n            self.include(inc)"
    },
    {
      "chunk_id": 616,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def _make_spec(self, path_or_spec):\n        package, filename = resolve_asset_spec(path_or_spec, self.package_name)\n        if package is None:\n            return filename  # absolute filename\n        return f'{package}:{filename}'"
    },
    {
      "chunk_id": 617,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def _fix_registry(self):\n        \"\"\"Fix up a ZCA component registry that is not a\n        pyramid.registry.Registry by adding analogues of ``has_listeners``,\n        ``notify``, ``queryAdapterOrSelf``, and ``registerSelfAdapter``\n        through monkey-patching.\"\"\"\n\n        _registry = self.registry\n\n        if not hasattr(_registry, 'notify'):\n\n            def notify(*events):\n                [_ for _ in _registry.subscribers(events, None)]\n\n            _registry.notify = notify\n\n        if not hasattr(_registry, 'has_listeners'):\n            _registry.has_listeners = True\n\n        if not hasattr(_registry, 'queryAdapterOrSelf'):\n\n            def queryAdapterOrSelf(object, interface, default=None):\n                if not interface.providedBy(object):\n                    return _registry.queryAdapter(\n                        object, interface, default=default\n                    )\n                return object\n\n            _registry.queryAdapterOrSelf = queryAdapterOrSelf\n\n        if not hasattr(_registry, 'registerSelfAdapter'):\n\n            def registerSelfAdapter(\n                required=None, provided=None, name='', info='', event=True\n            ):\n                return _registry.registerAdapter(\n                    lambda x: x,\n                    required=required,\n                    provided=provided,\n                    name=name,\n                    info=info,\n                    event=event,\n                )\n\n            _registry.registerSelfAdapter = registerSelfAdapter\n\n        if not hasattr(_registry, '_lock'):\n            _registry._lock = threading.Lock()\n\n        if not hasattr(_registry, '_clear_view_lookup_cache'):\n\n            def _clear_view_lookup_cache():\n                _registry._view_lookup_cache = {}\n\n            _registry._clear_view_lookup_cache = _clear_view_lookup_cache"
    },
    {
      "chunk_id": 618,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "# API\n\n    def _get_introspector(self):\n        introspector = getattr(self.registry, 'introspector', _marker)\n        if introspector is _marker:\n            introspector = Introspector()\n            self._set_introspector(introspector)\n        return introspector\n\n    def _set_introspector(self, introspector):\n        self.registry.introspector = introspector\n\n    def _del_introspector(self):\n        del self.registry.introspector\n\n    introspector = property(\n        _get_introspector, _set_introspector, _del_introspector\n    )"
    },
    {
      "chunk_id": 619,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def include(self, callable, route_prefix=None):\n        \"\"\"Include a configuration callable, to support imperative\n        application extensibility.\n\n        .. warning:: In versions of :app:`Pyramid` prior to 1.2, this\n            function accepted ``*callables``, but this has been changed\n            to support only a single callable.\n\n        A configuration callable should be a callable that accepts a single\n        argument named ``config``, which will be an instance of a\n        :term:`Configurator`.  However, be warned that it will not be the same\n        configurator instance on which you call this method.  The\n        code which runs as a result of calling the callable should invoke\n        methods on the configurator passed to it which add configuration\n        state.  The return value of a callable will be ignored.\n\n        Values allowed to be presented via the ``callable`` argument to\n        this method: any callable Python object or any :term:`dotted Python\n        name` which resolves to a callable Python object.  It may also be a\n        Python :term:`module`, in which case, the module will be searched for\n        a callable named ``includeme``, which will be treated as the\n        configuration callable.\n\n        For example, if the ``includeme`` function below lives in a module\n        named ``myapp.myconfig``:\n\n        .. code-block:: python\n           :linenos:\n\n           # myapp.myconfig module\n\n           def my_view(request):\n               from pyramid.response import Response\n               return Response('OK')\n\n           def includeme(config):\n               config.add_view(my_view)\n\n        You might cause it to be included within your Pyramid application like\n        so:\n\n        .. code-block:: python\n           :linenos:\n\n           from pyramid.config import Configurator\n\n           def main(global_config, **settings):\n               config = Configurator()\n               config.include('myapp.myconfig.includeme')\n\n        Because the function is named ``includeme``, the function name can\n        also be omitted from the dotted name reference:\n\n        .. code-block:: python\n           :linenos:\n\n           from pyramid.config import Configurator\n\n           def main(global_config, **settings):\n               config = Configurator()\n               config.include('myapp.myconfig')\n\n        Included configuration statements will be overridden by local\n        configuration statements if an included callable causes a\n        configuration conflict by registering something with the same\n        configuration parameters.\n\n        If the ``route_prefix`` is supplied, it must be a string and will\n        have a similar effect to using\n        :meth:`pyramid.config.Configurator.route_prefix_context`.  Any calls\n        to :meth:`pyramid.config.Configurator.add_route` within the included\n        callable will have their pattern prefixed with the value of\n        ``route_prefix``. This can be used to help mount a set of routes at a\n        different location than the included callable's author intended, while\n        still maintaining the same route names.  For example:\n\n        .. code-block:: python\n           :linenos:\n\n           from pyramid.config import Configurator\n\n           def included(config):\n               config.add_route('show_users', '/show')\n\n           def main(global_config, **settings):\n               config = Configurator()\n               config.include(included, route_prefix='/users')\n\n        In the above configuration, the ``show_users`` route will have an\n        effective route pattern of ``/users/show``, instead of ``/show``\n        because the ``route_prefix`` argument will be prepended to the\n        pattern.\n\n        .. versionadded:: 1.2\n           The ``route_prefix`` parameter.\n\n        .. versionchanged:: 1.9\n           The included function is wrapped with a call to\n           :meth:`pyramid.config.Configurator.begin` and\n           :meth:`pyramid.config.Configurator.end` while it is executed.\n\n        \"\"\"\n        # \"\"\" <-- emacs\n\n        action_state = self.action_state\n\n        c = self.maybe_dotted(callable)\n        module = self.inspect.getmodule(c)\n        if module is c:\n            try:\n                c = getattr(module, 'includeme')\n            except AttributeError:\n                raise ConfigurationError(\n                    \"module %r has no attribute 'includeme'\"\n                    % (module.__name__)\n                )\n\n        spec = module.__name__ + ':' + c.__name__\n        sourcefile = self.inspect.getsourcefile(c)\n\n        if sourcefile is None:\n            raise ConfigurationError(\n                'No source file for module %r (.py file must exist, '\n                'refusing to use orphan .pyc or .pyo file).' % module.__name__\n            )\n\n        if action_state.processSpec(spec):\n            with self.route_prefix_context(route_prefix):\n                configurator = self.__class__(\n                    registry=self.registry,\n                    package=package_of(module),\n                    root_package=self.root_package,\n                    autocommit=self.autocommit,\n                    route_prefix=self.route_prefix,\n                )\n                configurator.basepath = os.path.dirname(sourcefile)\n                configurator.includepath = self.includepath + (spec,)\n\n                self.begin()\n                try:\n                    c(configurator)\n                finally:\n                    self.end()"
    },
    {
      "chunk_id": 620,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def add_directive(self, name, directive, action_wrap=True):\n        \"\"\"\n        Add a directive method to the configurator.\n\n        .. warning:: This method is typically only used by :app:`Pyramid`\n           framework extension authors, not by :app:`Pyramid` application\n           developers.\n\n        Framework extenders can add directive methods to a configurator by\n        instructing their users to call ``config.add_directive('somename',\n        'some.callable')``.  This will make ``some.callable`` accessible as\n        ``config.somename``.  ``some.callable`` should be a function which\n        accepts ``config`` as a first argument, and arbitrary positional and\n        keyword arguments following.  It should use config.action as\n        necessary to perform actions.  Directive methods can then be invoked\n        like 'built-in' directives such as ``add_view``, ``add_route``, etc.\n\n        The ``action_wrap`` argument should be ``True`` for directives which\n        perform ``config.action`` with potentially conflicting\n        discriminators.  ``action_wrap`` will cause the directive to be\n        wrapped in a decorator which provides more accurate conflict\n        cause information.\n\n        ``add_directive`` does not participate in conflict detection, and\n        later calls to ``add_directive`` will override earlier calls.\n        \"\"\"\n        name = get_callable_name(name)\n        c = self.maybe_dotted(directive)\n        if not hasattr(self.registry, '_directives'):\n            self.registry._directives = {}\n        self.registry._directives[name] = (c, action_wrap)"
    },
    {
      "chunk_id": 621,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def __getattr__(self, name):\n        # allow directive extension names to work\n        directives = getattr(self.registry, '_directives', {})\n        c = directives.get(name)\n        if c is None:\n            raise AttributeError(name)\n        c, action_wrap = c\n        if action_wrap:\n            c = action_method(c)\n        # Create a bound method (works on both Py2 and Py3)\n        # http://stackoverflow.com/a/1015405/209039\n        m = c.__get__(self, self.__class__)\n        return m"
    },
    {
      "chunk_id": 622,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def with_package(self, package):\n        \"\"\"Return a new Configurator instance with the same registry\n        as this configurator. ``package`` may be an actual Python package\n        object or a :term:`dotted Python name` representing a package.\"\"\"\n        configurator = self.__class__(\n            registry=self.registry,\n            package=package,\n            root_package=self.root_package,\n            autocommit=self.autocommit,\n            route_prefix=self.route_prefix,\n            introspection=self.introspection,\n        )\n        configurator.basepath = self.basepath\n        configurator.includepath = self.includepath\n        configurator.info = self.info\n        return configurator"
    },
    {
      "chunk_id": 623,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def maybe_dotted(self, dotted):\n        \"\"\"Resolve the :term:`dotted Python name` ``dotted`` to a\n        global Python object.  If ``dotted`` is not a string, return\n        it without attempting to do any name resolution.  If\n        ``dotted`` is a relative dotted name (e.g. ``.foo.bar``,\n        consider it relative to the ``package`` argument supplied to\n        this Configurator's constructor.\"\"\"\n        return self.name_resolver.maybe_resolve(dotted)"
    },
    {
      "chunk_id": 624,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def absolute_asset_spec(self, relative_spec):\n        \"\"\"Resolve the potentially relative :term:`asset\n        specification` string passed as ``relative_spec`` into an\n        absolute asset specification string and return the string.\n        Use the ``package`` of this configurator as the package to\n        which the asset specification will be considered relative\n        when generating an absolute asset specification.  If the\n        provided ``relative_spec`` argument is already absolute, or if\n        the ``relative_spec`` is not a string, it is simply returned.\"\"\"\n        if not isinstance(relative_spec, str):\n            return relative_spec\n        return self._make_spec(relative_spec)\n\n    absolute_resource_spec = absolute_asset_spec  # b/w compat forever"
    },
    {
      "chunk_id": 625,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def begin(self, request=_marker):\n        \"\"\"Indicate that application or test configuration has begun.\n        This pushes a dictionary containing the :term:`application\n        registry` implied by ``registry`` attribute of this\n        configurator and the :term:`request` implied by the\n        ``request`` argument onto the :term:`thread local` stack\n        consulted by various :mod:`pyramid.threadlocal` API\n        functions.\n\n        If ``request`` is not specified and the registry owned by the\n        configurator is already pushed as the current threadlocal registry\n        then this method will keep the current threadlocal request unchanged.\n\n        .. versionchanged:: 1.8\n           The current threadlocal request is propagated if the current\n           threadlocal registry remains unchanged.\n\n        \"\"\"\n        if request is _marker:\n            current = self.manager.get()\n            if current['registry'] == self.registry:\n                request = current['request']\n            else:\n                request = None\n        self.manager.push({'registry': self.registry, 'request': request})"
    },
    {
      "chunk_id": 626,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def end(self):\n        \"\"\"Indicate that application or test configuration has ended.\n        This pops the last value pushed onto the :term:`thread local`\n        stack (usually by the ``begin`` method) and returns that\n        value.\n        \"\"\"\n        return self.manager.pop()"
    },
    {
      "chunk_id": 627,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def __enter__(self):\n        self.begin()\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        self.end()\n\n        if exc_value is None:\n            self.commit()"
    },
    {
      "chunk_id": 628,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "# this is *not* an action method (uses caller_package)\n    def scan(\n        self,\n        package=None,\n        categories=('pyramid',),\n        onerror=None,\n        ignore=None,\n        **kw,\n    ):\n        \"\"\"Scan a Python package and any of its subpackages for objects\n        marked with :term:`configuration decoration` such as\n        :class:`pyramid.view.view_config`.  Any decorated object found will\n        influence the current configuration state.\n\n        The ``package`` argument should be a Python :term:`package` or module\n        object (or a :term:`dotted Python name` which refers to such a\n        package or module).  If ``package`` is ``None``, the package of the\n        *caller* is used.\n\n        The ``categories`` argument, if provided, should be the\n        :term:`Venusian` 'scan categories' to use during scanning.  Providing\n        this argument is not often necessary; specifying scan categories is\n        an extremely advanced usage.  By default, ``categories`` is\n        ``['pyramid']`` which will execute only :app:`Pyramid`-related Venusian\n        decorator callbacks such as from :class:`pyramid.view.view_config`.\n        See the :term:`Venusian` documentation for more information about\n        limiting a scan by using an explicit set of categories. Pass ``None``\n        to pick up *all* Venusian decorators.\n\n        The ``onerror`` argument, if provided, should be a Venusian\n        ``onerror`` callback function.  The onerror function is passed to\n        :meth:`venusian.Scanner.scan` to influence error behavior when an\n        exception is raised during the scanning process.  See the\n        :term:`Venusian` documentation for more information about ``onerror``\n        callbacks.\n\n        The ``ignore`` argument, if provided, should be a Venusian ``ignore``\n        value.  Providing an ``ignore`` argument allows the scan to ignore\n        particular modules, packages, or global objects during a scan.\n        ``ignore`` can be a string or a callable, or a list containing\n        strings or callables.  The simplest usage of ``ignore`` is to provide\n        a module or package by providing a full path to its dotted name.  For\n        example: ``config.scan(ignore='my.module.subpackage')`` would ignore\n        the ``my.module.subpackage`` package during a scan, which would\n        prevent the subpackage and any of its submodules from being imported\n        and scanned.  See the :term:`Venusian` documentation for more\n        information about the ``ignore`` argument.\n\n        To perform a ``scan``, Pyramid creates a Venusian ``Scanner`` object.\n        The ``kw`` argument represents a set of keyword arguments to pass to\n        the Venusian ``Scanner`` object's constructor.  See the\n        :term:`venusian` documentation (its ``Scanner`` class) for more\n        information about the constructor.  By default, the only keyword\n        arguments passed to the Scanner constructor are ``{'config':self}``\n        where ``self`` is this configurator object.  This services the\n        requirement of all built-in Pyramid decorators, but extension systems\n        may require additional arguments.  Providing this argument is not\n        often necessary; it's an advanced usage.\n\n        .. versionadded:: 1.1\n           The ``**kw`` argument.\n\n        .. versionadded:: 1.3\n           The ``ignore`` argument.\n\n        .. versionchanged:: 2.0\n           The ``categories`` argument now defaults to ``['pyramid']`` instead\n           of ``None`` to control which decorator callbacks are executed.\n\n        \"\"\"\n        package = self.maybe_dotted(package)\n        if package is None:  # pragma: no cover\n            package = caller_package()\n\n        ctorkw = {'config': self}\n        ctorkw.update(kw)\n\n        scanner = self.venusian.Scanner(**ctorkw)\n\n        scanner.scan(\n            package, categories=categories, onerror=onerror, ignore=ignore\n        )"
    },
    {
      "chunk_id": 629,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "def make_wsgi_app(self):\n        \"\"\"Commits any pending configuration statements, sends a\n        :class:`pyramid.events.ApplicationCreated` event to all listeners,\n        adds this configuration's registry to\n        :attr:`pyramid.config.global_registries`, and returns a\n        :app:`Pyramid` WSGI application representing the committed\n        configuration state.\"\"\"\n        self.commit()\n        app = Router(self.registry)\n\n        # Allow tools like \"pshell development.ini\" to find the 'last'\n        # registry configured.\n        global_registries.add(self.registry)\n\n        # Push the registry onto the stack in case any code that depends on\n        # the registry threadlocal APIs used in listeners subscribed to the\n        # IApplicationCreated event.\n        self.begin()\n        try:\n            self.registry.notify(ApplicationCreated(app))\n        finally:\n            self.end()\n\n        return app"
    },
    {
      "chunk_id": 630,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/__init__.py",
      "content": "global_registries = WeakOrderedSet()"
    },
    {
      "chunk_id": 631,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/factories.py",
      "content": "from zope.interface import implementer\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.interfaces import (\n    IDefaultRootFactory,\n    IExecutionPolicy,\n    IRequestExtensions,\n    IRequestFactory,\n    IResponseFactory,\n    IRootFactory,\n    ISessionFactory,\n)\nfrom pyramid.router import default_execution_policy\nfrom pyramid.traversal import DefaultRootFactory\nfrom pyramid.util import InstancePropertyHelper, get_callable_name"
    },
    {
      "chunk_id": 632,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/factories.py",
      "content": "class FactoriesConfiguratorMixin:\n    @action_method\n    def set_root_factory(self, factory):\n        \"\"\"Add a :term:`root factory` to the current configuration\n        state.  If the ``factory`` argument is ``None`` a default root\n        factory will be registered.\n\n        .. note::\n\n           Using the ``root_factory`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n        \"\"\"\n        factory = self.maybe_dotted(factory)\n        if factory is None:\n            factory = DefaultRootFactory\n\n        def register():\n            self.registry.registerUtility(factory, IRootFactory)\n            self.registry.registerUtility(factory, IDefaultRootFactory)  # b/c\n\n        intr = self.introspectable(\n            'root factories',\n            None,\n            self.object_description(factory),\n            'root factory',\n        )\n        intr['factory'] = factory\n        self.action(IRootFactory, register, introspectables=(intr,))\n\n    _set_root_factory = set_root_factory  # bw compat\n\n    @action_method\n    def set_session_factory(self, factory):\n        \"\"\"\n        Configure the application with a :term:`session factory`.  If this\n        method is called, the ``factory`` argument must be a session\n        factory callable or a :term:`dotted Python name` to that factory.\n\n        .. note::\n\n           Using the ``session_factory`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n        \"\"\"\n        factory = self.maybe_dotted(factory)\n\n        def register():\n            self.registry.registerUtility(factory, ISessionFactory)\n\n        intr = self.introspectable(\n            'session factory',\n            None,\n            self.object_description(factory),\n            'session factory',\n        )\n        intr['factory'] = factory\n        self.action(ISessionFactory, register, introspectables=(intr,))\n\n    @action_method\n    def set_request_factory(self, factory):\n        \"\"\"The object passed as ``factory`` should be an object (or a\n        :term:`dotted Python name` which refers to an object) which\n        will be used by the :app:`Pyramid` router to create all\n        request objects.  This factory object must have the same\n        methods and attributes as the\n        :class:`pyramid.request.Request` class (particularly\n        ``__call__``, and ``blank``).\n\n        See :meth:`pyramid.config.Configurator.add_request_method`\n        for a less intrusive way to extend the request objects with\n        custom methods and properties.\n\n        .. note::\n\n           Using the ``request_factory`` argument to the\n           :class:`pyramid.config.Configurator` constructor\n           can be used to achieve the same purpose.\n        \"\"\"\n        factory = self.maybe_dotted(factory)\n\n        def register():\n            self.registry.registerUtility(factory, IRequestFactory)\n\n        intr = self.introspectable(\n            'request factory',\n            None,\n            self.object_description(factory),\n            'request factory',\n        )\n        intr['factory'] = factory\n        self.action(IRequestFactory, register, introspectables=(intr,))\n\n    @action_method\n    def set_response_factory(self, factory):\n        \"\"\"The object passed as ``factory`` should be an object (or a\n        :term:`dotted Python name` which refers to an object) which\n        will be used by the :app:`Pyramid` as the default response\n        objects. The factory should conform to the\n        :class:`pyramid.interfaces.IResponseFactory` interface.\n\n        .. note::\n\n           Using the ``response_factory`` argument to the\n           :class:`pyramid.config.Configurator` constructor\n           can be used to achieve the same purpose.\n        \"\"\"\n        factory = self.maybe_dotted(factory)\n\n        def register():\n            self.registry.registerUtility(factory, IResponseFactory)\n\n        intr = self.introspectable(\n            'response factory',\n            None,\n            self.object_description(factory),\n            'response factory',\n        )\n        intr['factory'] = factory\n        self.action(IResponseFactory, register, introspectables=(intr,))\n\n    @action_method\n    def add_request_method(\n        self, callable=None, name=None, property=False, reify=False\n    ):\n        \"\"\"Add a property or method to the request object.\n\n        When adding a method to the request, ``callable`` may be any\n        function that receives the request object as the first\n        parameter. If ``name`` is ``None`` then it will be computed\n        from the name of the ``callable``.\n\n        When adding a property to the request, ``callable`` can either\n        be a callable that accepts the request as its single positional\n        parameter, or it can be a property descriptor. If ``callable`` is\n        a property descriptor, it has to be an instance of a class which is\n        a subclass of ``property``. If ``name`` is ``None``, the name of\n        the property will be computed from the name of the ``callable``.\n\n        If the ``callable`` is a property descriptor a ``ValueError``\n        will be raised if ``name`` is ``None`` or ``reify`` is ``True``.\n\n        See :meth:`pyramid.request.Request.set_property` for more\n        details on ``property`` vs ``reify``. When ``reify`` is\n        ``True``, the value of ``property`` is assumed to also be\n        ``True``.\n\n        In all cases, ``callable`` may also be a\n        :term:`dotted Python name` which refers to either a callable or\n        a property descriptor.\n\n        If ``callable`` is ``None`` then the method is only used to\n        assist in conflict detection between different addons requesting\n        the same attribute on the request object.\n\n        This is the recommended method for extending the request object\n        and should be used in favor of providing a custom request\n        factory via\n        :meth:`pyramid.config.Configurator.set_request_factory`.\n\n        .. versionadded:: 1.4\n        \"\"\"\n        if callable is not None:\n            callable = self.maybe_dotted(callable)\n\n        property = property or reify\n        if property:\n            name, callable = InstancePropertyHelper.make_property(\n                callable, name=name, reify=reify\n            )\n        elif name is None:\n            name = callable.__name__\n        else:\n            name = get_callable_name(name)\n\n        def register():\n            exts = self.registry.queryUtility(IRequestExtensions)\n\n            if exts is None:\n                exts = _RequestExtensions()\n                self.registry.registerUtility(exts, IRequestExtensions)\n\n            plist = exts.descriptors if property else exts.methods\n            plist[name] = callable\n\n        if callable is None:\n            self.action(('request extensions', name), None)\n        elif property:\n            intr = self.introspectable(\n                'request extensions',\n                name,\n                self.object_description(callable),\n                'request property',\n            )\n            intr['callable'] = callable\n            intr['property'] = True\n            intr['reify'] = reify\n            self.action(\n                ('request extensions', name), register, introspectables=(intr,)\n            )\n        else:\n            intr = self.introspectable(\n                'request extensions',\n                name,\n                self.object_description(callable),\n                'request method',\n            )\n            intr['callable'] = callable\n            intr['property'] = False\n            intr['reify'] = False\n            self.action(\n                ('request extensions', name), register, introspectables=(intr,)\n            )\n\n    @action_method\n    def set_execution_policy(self, policy):\n        \"\"\"\n        Override the :app:`Pyramid` :term:`execution policy` in the\n        current configuration.  The ``policy`` argument must be an instance\n        of an :class:`pyramid.interfaces.IExecutionPolicy` or a\n        :term:`dotted Python name` that points at an instance of an\n        execution policy.\n\n        \"\"\"\n        policy = self.maybe_dotted(policy)\n        if policy is None:\n            policy = default_execution_policy\n\n        def register():\n            self.registry.registerUtility(policy, IExecutionPolicy)\n\n        intr = self.introspectable(\n            'execution policy',\n            None,\n            self.object_description(policy),\n            'execution policy',\n        )\n        intr['policy'] = policy\n        self.action(IExecutionPolicy, register, introspectables=(intr,))"
    },
    {
      "chunk_id": 633,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/factories.py",
      "content": "@implementer(IRequestExtensions)\nclass _RequestExtensions:\n    def __init__(self):\n        self.descriptors = {}\n        self.methods = {}"
    },
    {
      "chunk_id": 634,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "from zope.interface import implementer\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import ITweens\nfrom pyramid.tweens import EXCVIEW, INGRESS, MAIN\nfrom pyramid.util import (\n    TopologicalSorter,\n    is_nonstr_iter,\n    is_string_or_iterable,\n)"
    },
    {
      "chunk_id": 635,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "class TweensConfiguratorMixin:\n    def add_tween(self, tween_factory, under=None, over=None):\n        \"\"\"\n        .. versionadded:: 1.2\n\n        Add a 'tween factory'.  A :term:`tween` (a contraction of 'between')\n        is a bit of code that sits between the Pyramid router's main request\n        handling function and the upstream WSGI component that uses\n        :app:`Pyramid` as its 'app'.  Tweens are a feature that may be used\n        by Pyramid framework extensions, to provide, for example,\n        Pyramid-specific view timing support, bookkeeping code that examines\n        exceptions before they are returned to the upstream WSGI application,\n        or a variety of other features.  Tweens behave a bit like\n        :term:`WSGI` 'middleware' but they have the benefit of running in a\n        context in which they have access to the Pyramid :term:`application\n        registry` as well as the Pyramid rendering machinery.\n\n        .. note:: You can view the tween ordering configured into a given\n                  Pyramid application by using the ``ptweens``\n                  command.  See :ref:`displaying_tweens`.\n\n        The ``tween_factory`` argument must be a :term:`dotted Python name`\n        to a global object representing the tween factory.\n\n        The ``under`` and ``over`` arguments allow the caller of\n        ``add_tween`` to provide a hint about where in the tween chain this\n        tween factory should be placed when an implicit tween chain is used.\n        These hints are only used when an explicit tween chain is not used\n        (when the ``pyramid.tweens`` configuration value is not set).\n        Allowable values for ``under`` or ``over`` (or both) are:\n\n        - ``None`` (the default).\n\n        - A :term:`dotted Python name` to a tween factory: a string\n          representing the dotted name of a tween factory added in a call to\n          ``add_tween`` in the same configuration session.\n\n        - One of the constants :attr:`pyramid.tweens.MAIN`,\n          :attr:`pyramid.tweens.INGRESS`, or :attr:`pyramid.tweens.EXCVIEW`.\n\n        - An iterable of any combination of the above. This allows the user\n          to specify fallbacks if the desired tween is not included, as well\n          as compatibility with multiple other tweens.\n\n        ``under`` means 'closer to the main Pyramid application than',\n        ``over`` means 'closer to the request ingress than'.\n\n        For example, calling ``add_tween('myapp.tfactory',\n        over=pyramid.tweens.MAIN)`` will attempt to place the tween factory\n        represented by the dotted name ``myapp.tfactory`` directly 'above'\n        (in ``ptweens`` order) the main Pyramid request handler.\n        Likewise, calling ``add_tween('myapp.tfactory',\n        over=pyramid.tweens.MAIN, under='mypkg.someothertween')`` will\n        attempt to place this tween factory 'above' the main handler but\n        'below' (a fictional) 'mypkg.someothertween' tween factory.\n\n        If all options for ``under`` (or ``over``) cannot be found in the\n        current configuration, it is an error. If some options are specified\n        purely for compatibility with other tweens, just add a fallback of\n        MAIN or INGRESS. For example, ``under=('mypkg.someothertween',\n        'mypkg.someothertween2', INGRESS)``.  This constraint will require\n        the tween to be located under both the 'mypkg.someothertween' tween,\n        the 'mypkg.someothertween2' tween, and INGRESS. If any of these is\n        not in the current configuration, this constraint will only organize\n        itself based on the tweens that are present.\n\n        Specifying neither ``over`` nor ``under`` is equivalent to specifying\n        ``under=INGRESS``.\n\n        Implicit tween ordering is obviously only best-effort.  Pyramid will\n        attempt to present an implicit order of tweens as best it can, but\n        the only surefire way to get any particular ordering is to use an\n        explicit tween order.  A user may always override the implicit tween\n        ordering by using an explicit ``pyramid.tweens`` configuration value\n        setting.\n\n        ``under``, and ``over`` arguments are ignored when an explicit tween\n        chain is specified using the ``pyramid.tweens`` configuration value.\n\n        For more information, see :ref:`registering_tweens`.\n\n        \"\"\"\n        return self._add_tween(\n            tween_factory, under=under, over=over, explicit=False\n        )\n\n    def add_default_tweens(self):\n        self.add_tween(EXCVIEW)"
    },
    {
      "chunk_id": 636,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "@action_method\n    def _add_tween(self, tween_factory, under=None, over=None, explicit=False):\n        if not isinstance(tween_factory, str):\n            raise ConfigurationError(\n                'The \"tween_factory\" argument to add_tween must be a '\n                'dotted name to a globally importable object, not %r'\n                % tween_factory\n            )\n\n        name = tween_factory\n\n        if name in (MAIN, INGRESS):\n            raise ConfigurationError('%s is a reserved tween name' % name)\n\n        tween_factory = self.maybe_dotted(tween_factory)\n\n        for t, p in [('over', over), ('under', under)]:\n            if p is not None:\n                if not is_string_or_iterable(p):\n                    raise ConfigurationError(\n                        f'\"{t}\" must be a string or iterable, not {p}'\n                    )\n\n        if over is INGRESS or is_nonstr_iter(over) and INGRESS in over:\n            raise ConfigurationError('%s cannot be over INGRESS' % name)\n\n        if under is MAIN or is_nonstr_iter(under) and MAIN in under:\n            raise ConfigurationError('%s cannot be under MAIN' % name)\n\n        registry = self.registry\n        introspectables = []\n\n        tweens = registry.queryUtility(ITweens)\n        if tweens is None:\n            tweens = Tweens()\n            registry.registerUtility(tweens, ITweens)\n\n        def register():\n            if explicit:\n                tweens.add_explicit(name, tween_factory)\n            else:\n                tweens.add_implicit(\n                    name, tween_factory, under=under, over=over\n                )\n\n        discriminator = ('tween', name, explicit)\n        tween_type = explicit and 'explicit' or 'implicit'\n\n        intr = self.introspectable(\n            'tweens', discriminator, name, '%s tween' % tween_type\n        )\n        intr['name'] = name\n        intr['factory'] = tween_factory\n        intr['type'] = tween_type\n        intr['under'] = under\n        intr['over'] = over\n        introspectables.append(intr)\n        self.action(discriminator, register, introspectables=introspectables)"
    },
    {
      "chunk_id": 637,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "@implementer(ITweens)\nclass Tweens:\n    def __init__(self):\n        self.sorter = TopologicalSorter(\n            default_before=None,\n            default_after=INGRESS,\n            first=INGRESS,\n            last=MAIN,\n        )\n        self.explicit = []"
    },
    {
      "chunk_id": 638,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "def add_explicit(self, name, factory):\n        self.explicit.append((name, factory))"
    },
    {
      "chunk_id": 639,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "def add_implicit(self, name, factory, under=None, over=None):\n        self.sorter.add(name, factory, after=under, before=over)"
    },
    {
      "chunk_id": 640,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "def implicit(self):\n        return self.sorter.sorted()"
    },
    {
      "chunk_id": 641,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/tweens.py",
      "content": "def __call__(self, handler, registry):\n        if self.explicit:\n            use = self.explicit\n        else:\n            use = self.implicit()\n        for name, factory in use[::-1]:\n            handler = factory(handler, registry)\n        return handler"
    },
    {
      "chunk_id": 642,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/security.py",
      "content": "import warnings\nfrom zope.interface import implementer\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.csrf import LegacySessionCSRFStoragePolicy\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import (\n    PHASE1_CONFIG,\n    PHASE2_CONFIG,\n    IAuthenticationPolicy,\n    IAuthorizationPolicy,\n    ICSRFStoragePolicy,\n    IDefaultCSRFOptions,\n    IDefaultPermission,\n    ISecurityPolicy,\n)\nfrom pyramid.security import LegacySecurityPolicy\nfrom pyramid.util import as_sorted_tuple"
    },
    {
      "chunk_id": 643,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/security.py",
      "content": "class SecurityConfiguratorMixin:\n    def add_default_security(self):\n        self.set_csrf_storage_policy(LegacySessionCSRFStoragePolicy())\n\n    @action_method\n    def set_security_policy(self, policy):\n        \"\"\"Override the :app:`Pyramid` :term:`security policy` in the current\n        configuration.  The ``policy`` argument must be an instance\n        of a security policy or a :term:`dotted Python name`\n        that points at an instance of a security policy.\n\n        .. note::\n\n           Using the ``security_policy`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n\n        \"\"\"\n        def register():\n            self.registry.registerUtility(policy, ISecurityPolicy)\n\n        policy = self.maybe_dotted(policy)\n        intr = self.introspectable(\n            'security policy',\n            None,\n            self.object_description(policy),\n            'security policy',\n        )\n        intr['policy'] = policy\n        self.action(\n            ISecurityPolicy,\n            register,\n            order=PHASE2_CONFIG,\n            introspectables=(intr,),\n        )\n\n    @action_method\n    def set_authentication_policy(self, policy):\n        \"\"\"\n        .. deprecated:: 2.0\n\n            Authentication policies have been replaced by security policies.\n            See :ref:`upgrading_auth_20` for more information.\n\n        Override the :app:`Pyramid` :term:`authentication policy` in the\n        current configuration.  The ``policy`` argument must be an instance\n        of an authentication policy or a :term:`dotted Python name`\n        that points at an instance of an authentication policy.\n\n        .. note::\n\n           Using the ``authentication_policy`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n\n        \"\"\"\n        warnings.warn(\n            'Authentication and authorization policies have been deprecated '\n            'in favor of security policies.  See \"Upgrading '\n            'Authentication/Authorization\" in \"What\\'s New in Pyramid 2.0\" '\n            'of the documentation for more information.',\n            DeprecationWarning,\n            stacklevel=3,\n        )\n\n        def register():\n            self.registry.registerUtility(policy, IAuthenticationPolicy)\n            if self.registry.queryUtility(IAuthorizationPolicy) is None:\n                raise ConfigurationError(\n                    'Cannot configure an authentication policy without '\n                    'also configuring an authorization policy '\n                    '(use the set_authorization_policy method)'\n                )\n            if self.registry.queryUtility(ISecurityPolicy) is not None:\n                raise ConfigurationError(\n                    'Cannot configure an authentication and authorization'\n                    'policy with a configured security policy.'\n                )\n            security_policy = LegacySecurityPolicy()\n            self.registry.registerUtility(security_policy, ISecurityPolicy)\n\n        policy = self.maybe_dotted(policy)\n        intr = self.introspectable(\n            'authentication policy',\n            None,\n            self.object_description(policy),\n            'authentication policy',\n        )\n        intr['policy'] = policy\n        # authentication policy used by view config (phase 3)\n        self.action(\n            IAuthenticationPolicy,\n            register,\n            order=PHASE2_CONFIG,\n            introspectables=(intr,),\n        )\n\n    @action_method\n    def set_authorization_policy(self, policy):\n        \"\"\"\n        .. deprecated:: 2.0\n\n            Authentication policies have been replaced by security policies.\n            See :ref:`upgrading_auth_20` for more information.\n\n        Override the :app:`Pyramid` :term:`authorization policy` in the\n        current configuration.  The ``policy`` argument must be an instance\n        of an authorization policy or a :term:`dotted Python name` that points\n        at an instance of an authorization policy.\n\n        .. note::\n\n           Using the ``authorization_policy`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n\n        \"\"\"\n        warnings.warn(\n            'Authentication and authorization policies have been deprecated '\n            'in favor of security policies.  See \"Upgrading '\n            'Authentication/Authorization\" in \"What\\'s New in Pyramid 2.0\" '\n            'of the documentation for more information.',\n            DeprecationWarning,\n            stacklevel=3,\n        )\n\n        def register():\n            self.registry.registerUtility(policy, IAuthorizationPolicy)\n\n        def ensure():\n            if self.autocommit:\n                return\n            if self.registry.queryUtility(IAuthenticationPolicy) is None:\n                raise ConfigurationError(\n                    'Cannot configure an authorization policy without '\n                    'also configuring an authentication policy '\n                    '(use the set_authorization_policy method)'\n                )\n\n        policy = self.maybe_dotted(policy)\n        intr = self.introspectable(\n            'authorization policy',\n            None,\n            self.object_description(policy),\n            'authorization policy',\n        )\n        intr['policy'] = policy\n        # authorization policy used by view config (phase 3) and\n        # authentication policy (phase 2)\n        self.action(\n            IAuthorizationPolicy,\n            register,\n            order=PHASE1_CONFIG,\n            introspectables=(intr,),\n        )\n        self.action(None, ensure)\n\n    @action_method\n    def set_default_permission(self, permission):\n        \"\"\"\n        Set the default permission to be used by all subsequent\n        :term:`view configuration` registrations.  ``permission``\n        should be a :term:`permission` string to be used as the\n        default permission.  An example of a permission\n        string:``'view'``.  Adding a default permission makes it\n        unnecessary to protect each view configuration with an\n        explicit permission, unless your application policy requires\n        some exception for a particular view.\n\n        If a default permission is *not* set, views represented by\n        view configuration registrations which do not explicitly\n        declare a permission will be executable by entirely anonymous\n        users (any authorization policy is ignored).\n\n        Later calls to this method override will conflict with earlier calls;\n        there can be only one default permission active at a time within an\n        application.\n\n        .. warning::\n\n          If a default permission is in effect, view configurations meant to\n          create a truly anonymously accessible view (even :term:`exception\n          view` views) *must* use the value of the permission importable as\n          :data:`pyramid.security.NO_PERMISSION_REQUIRED`.  When this string\n          is used as the ``permission`` for a view configuration, the default\n          permission is ignored, and the view is registered, making it\n          available to all callers regardless of their credentials.\n\n        .. seealso::\n\n            See also :ref:`setting_a_default_permission`.\n\n        .. note::\n\n           Using the ``default_permission`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n        \"\"\"\n        def register():\n            self.registry.registerUtility(permission, IDefaultPermission)\n\n        intr = self.introspectable(\n            'default permission', None, permission, 'default permission'\n        )\n        intr['value'] = permission\n        perm_intr = self.introspectable(\n            'permissions', permission, permission, 'permission'\n        )\n        perm_intr['value'] = permission\n        # default permission used during view registration (phase 3)\n        self.action(\n            IDefaultPermission,\n            register,\n            order=PHASE1_CONFIG,\n            introspectables=(intr, perm_intr),\n        )\n\n    def add_permission(self, permission_name):\n        \"\"\"\n        A configurator directive which registers a free-standing\n        permission without associating it with a view callable.  This can be\n        used so that the permission shows up in the introspectable data under\n        the ``permissions`` category (permissions mentioned via ``add_view``\n        already end up in there).  For example::\n\n          config = Configurator()\n          config.add_permission('view')\n        \"\"\"\n        intr = self.introspectable(\n            'permissions', permission_name, permission_name, 'permission'\n        )\n        intr['value'] = permission_name\n        self.action(None, introspectables=(intr,))\n\n    @action_method\n    def set_default_csrf_options(\n        self,\n        require_csrf=True,\n        token='csrf_token',\n        header='X-CSRF-Token',\n        safe_methods=('GET', 'HEAD', 'OPTIONS', 'TRACE'),\n        check_origin=True,\n        allow_no_origin=False,\n        callback=None,\n    ):\n        \"\"\"\n        Set the default CSRF options used by subsequent view registrations.\n\n        ``require_csrf`` controls whether CSRF checks will be automatically\n        enabled on each view in the application. This value is used as the\n        fallback when ``require_csrf`` is left at the default of ``None`` on\n        :meth:`pyramid.config.Configurator.add_view`.\n\n        ``token`` is the name of the CSRF token used in the body of the\n        request, accessed via ``request.POST[token]``. Default: ``csrf_token``.\n\n        ``header`` is the name of the header containing the CSRF token,\n        accessed via ``request.headers[header]``. Default: ``X-CSRF-Token``.\n\n        If ``token`` or ``header`` are set to ``None`` they will not be used\n        for checking CSRF tokens.\n\n        ``safe_methods`` is an iterable of HTTP methods which are expected to\n        not contain side-effects as defined by RFC2616. Safe methods will\n        never be automatically checked for CSRF tokens.\n        Default: ``('GET', 'HEAD', 'OPTIONS', TRACE')``.\n\n        ``check_origin`` is a boolean. If ``False``, the ``Origin`` and\n        ``Referer`` headers will not be validated as part of automated\n        CSRF checks.\n\n        ``allow_no_origin`` is a boolean.  If ``True``, a request lacking both\n        an ``Origin`` and ``Referer`` header will pass the CSRF check. This\n        option has no effect if ``check_origin`` is ``False``.\n\n        If ``callback`` is set, it must be a callable accepting ``(request)``\n        and returning ``True`` if the request should be checked for a valid\n        CSRF token. This callback allows an application to support\n        alternate authentication methods that do not rely on cookies which\n        are not subject to CSRF attacks. For example, if a request is\n        authenticated using the ``Authorization`` header instead of a cookie,\n        this may return ``False`` for that request so that clients do not\n        need to send the ``X-CSRF-Token`` header. The callback is only tested\n        for non-safe methods as defined by ``safe_methods``.\n\n        .. versionadded:: 1.7\n\n        .. versionchanged:: 1.8\n           Added the ``callback`` option.\n\n        .. versionchanged:: 2.0\n           Added the ``allow_no_origin`` and ``check_origin`` options.\n\n        \"\"\"\n        options = DefaultCSRFOptions(\n            require_csrf=require_csrf,\n            token=token,\n            header=header,\n            safe_methods=safe_methods,\n            check_origin=check_origin,\n            allow_no_origin=allow_no_origin,\n            callback=callback,\n        )\n\n        def register():\n            self.registry.registerUtility(options, IDefaultCSRFOptions)\n\n        intr = self.introspectable(\n            'default csrf view options',\n            None,\n            options,\n            'default csrf view options',\n        )\n        intr['require_csrf'] = require_csrf\n        intr['token'] = token\n        intr['header'] = header\n        intr['safe_methods'] = as_sorted_tuple(safe_methods)\n        intr['check_origin'] = allow_no_origin\n        intr['allow_no_origin'] = check_origin\n        intr['callback'] = callback\n\n        self.action(\n            IDefaultCSRFOptions,\n            register,\n            order=PHASE1_CONFIG,\n            introspectables=(intr,),\n        )\n\n    @action_method\n    def set_csrf_storage_policy(self, policy):\n        \"\"\"\n        Set the :term:`CSRF storage policy` used by subsequent view\n        registrations.\n\n        ``policy`` is a class that implements the\n        :meth:`pyramid.interfaces.ICSRFStoragePolicy` interface and defines\n        how to generate and persist CSRF tokens.\n\n        \"\"\"\n        def register():\n            self.registry.registerUtility(policy, ICSRFStoragePolicy)\n\n        intr = self.introspectable(\n            'csrf storage policy', None, policy, 'csrf storage policy'\n        )\n        intr['policy'] = policy\n        self.action(ICSRFStoragePolicy, register, introspectables=(intr,))"
    },
    {
      "chunk_id": 644,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/security.py",
      "content": "@implementer(IDefaultCSRFOptions)\nclass DefaultCSRFOptions:\n    def __init__(\n        self,\n        require_csrf,\n        token,\n        header,\n        safe_methods,\n        check_origin,\n        allow_no_origin,\n        callback,\n    ):\n        self.require_csrf = require_csrf\n        self.token = token\n        self.header = header\n        self.safe_methods = frozenset(safe_methods)\n        self.check_origin = check_origin\n        self.allow_no_origin = allow_no_origin\n        self.callback = callback"
    },
    {
      "chunk_id": 645,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "from zope.interface import Interface\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.interfaces import IRendererFactory, ISecurityPolicy, ITraverser\nfrom pyramid.renderers import RendererHelper\nfrom pyramid.traversal import split_path_info"
    },
    {
      "chunk_id": 646,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "class TestingConfiguratorMixin:\n    \"\"\"Testing configurator mixin for unit/integration testing helpers.\"\"\"\n\n    def __init__(self):\n        self.registry = None  # Placeholder for registry initialization"
    },
    {
      "chunk_id": 647,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "def testing_securitypolicy(\n        self,\n        userid=None,\n        identity=None,\n        permissive=True,\n        remember_result=None,\n        forget_result=None,\n    ):\n        \"\"\"Unit/integration testing helper.  Registers a faux :term:`security\n        policy`.\n        \"\"\"\n        from pyramid.testing import DummySecurityPolicy\n\n        policy = DummySecurityPolicy(\n            userid, identity, permissive, remember_result, forget_result\n        )\n        self.registry.registerUtility(policy, ISecurityPolicy)\n        return policy"
    },
    {
      "chunk_id": 648,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "def testing_resources(self, resources):\n        \"\"\"Unit/integration testing helper: registers a dictionary of\n        :term:`resource` objects that can be resolved via the\n        :func:`pyramid.traversal.find_resource` API.\n        \"\"\"\n\n        class DummyTraverserFactory:\n            def __init__(self, context):\n                self.context = context\n\n            def __call__(self, request):\n                path = request.path_info\n                ob = resources[path]\n                traversed = split_path_info(path)\n                return {\n                    'context': ob,\n                    'view_name': '',\n                    'subpath': (),\n                    'traversed': traversed,\n                    'virtual_root': ob,\n                    'virtual_root_path': (),\n                    'root': ob,\n                }\n\n        self.registry.registerAdapter(\n            DummyTraverserFactory, (Interface,), ITraverser\n        )\n        return resources"
    },
    {
      "chunk_id": 649,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "testing_models = testing_resources  # b/w compat"
    },
    {
      "chunk_id": 650,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "@action_method\n    def testing_add_subscriber(self, event_iface=None):\n        \"\"\"Unit/integration testing helper: Registers a\n        :term:`subscriber` which listens for events of the type\n        ``event_iface``.\n        \"\"\"\n        event_iface = self.maybe_dotted(event_iface)\n        L = []\n\n        def subscriber(*event):\n            L.extend(event)\n\n        self.add_subscriber(subscriber, event_iface)\n        return L"
    },
    {
      "chunk_id": 651,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "def testing_add_renderer(self, path, renderer=None):\n        \"\"\"Unit/integration testing helper: register a renderer at\n        ``path`` and return the renderer object.\n        \"\"\"\n        from pyramid.testing import DummyRendererFactory\n\n        helper = RendererHelper(name=path, registry=self.registry)\n        factory = self.registry.queryUtility(\n            IRendererFactory, name=helper.type\n        )\n        if not isinstance(factory, DummyRendererFactory):\n            factory = DummyRendererFactory(helper.type, factory)\n            self.registry.registerUtility(\n                factory, IRendererFactory, name=helper.type\n            )\n\n        from pyramid.testing import DummyTemplateRenderer\n\n        if renderer is None:\n            renderer = DummyTemplateRenderer()\n        factory.add(path, renderer)\n        return renderer"
    },
    {
      "chunk_id": 652,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/testing.py",
      "content": "testing_add_template = testing_add_renderer"
    },
    {
      "chunk_id": 653,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "```python"
    },
    {
      "chunk_id": 654,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "import functools\nimport inspect\nimport operator\nimport os\nimport posixpath\nfrom urllib.parse import quote, urljoin, urlparse, urlunparse\nimport warnings\nfrom webob.acceptparse import Accept\nfrom zope.interface import Interface, implementedBy, implementer\nfrom zope.interface.interfaces import IInterface\n\nfrom pyramid import renderers\nfrom pyramid.asset import resolve_asset_spec\nfrom pyramid.config.actions import action_method\nfrom pyramid.config.predicates import (\n    DEFAULT_PHASH,\n    MAX_ORDER,\n    normalize_accept_offer,\n    predvalseq,\n    sort_accept_offers,\n)\nfrom pyramid.decorator import reify\nfrom pyramid.exceptions import ConfigurationError, PredicateMismatch\nfrom pyramid.httpexceptions import (\n    HTTPForbidden,\n    HTTPNotFound,\n    default_exceptionresponse_view,\n)\nfrom pyramid.interfaces import (\n    PHASE1_CONFIG,\n    IAcceptOrder,\n    IException,\n    IExceptionViewClassifier,\n    IMultiView,\n    IPackageOverrides,\n    IRendererFactory,\n    IRequest,\n    IResponse,\n    IRouteRequest,\n    ISecuredView,\n    IStaticURLInfo,\n    IView,\n    IViewClassifier,\n    IViewDeriverInfo,\n    IViewDerivers,\n    IViewMapperFactory,\n)\nimport pyramid.predicates\nfrom pyramid.registry import Deferred\nfrom pyramid.security import NO_PERMISSION_REQUIRED\nfrom pyramid.static import static_view\nfrom pyramid.url import parse_url_overrides\nfrom pyramid.util import (\n    WIN,\n    TopologicalSorter,\n    as_sorted_tuple,\n    is_nonstr_iter,\n)\nfrom pyramid.view import AppendSlashNotFoundViewFactory\nimport pyramid.viewderivers\nfrom pyramid.viewderivers import (\n    INGRESS,\n    VIEW,\n    DefaultViewMapper,\n    preserve_view_attrs,\n    requestonly,\n    view_description,\n    wraps_view,\n)"
    },
    {
      "chunk_id": 655,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "DefaultViewMapper = DefaultViewMapper  # bw-compat\npreserve_view_attrs = preserve_view_attrs  # bw-compat\nrequestonly = requestonly  # bw-compat\nview_description = view_description  # bw-compat"
    },
    {
      "chunk_id": 656,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "@implementer(IMultiView)\nclass MultiView:\n    def __init__(self, name):\n        self.name = name\n        self.media_views = {}\n        self.views = []\n        self.accepts = []\n\n    def __discriminator__(self, context, request):\n        view = self.match(context, request)\n        return view.__discriminator__(context, request)\n\n    def add(self, view, order, phash=None, accept=None, accept_order=None):\n        if phash is not None:\n            for i, (s, v, h) in enumerate(list(self.views)):\n                if phash == h:\n                    self.views[i] = (order, view, phash)\n                    return\n\n        if accept is None:\n            self.views.append((order, view, phash))\n            self.views.sort(key=operator.itemgetter(0))\n        else:\n            subset = self.media_views.setdefault(accept, [])\n            for i, (s, v, h) in enumerate(list(subset)):\n                if phash == h:\n                    subset[i] = (order, view, phash)\n                    return\n            else:\n                subset.append((order, view, phash))\n                subset.sort(key=operator.itemgetter(0))\n            accepts = set(self.accepts)\n            accepts.add(accept)\n            if accept_order:\n                accept_order = [v for _, v in accept_order.sorted()]\n            self.accepts = sort_accept_offers(accepts, accept_order)\n\n    def get_views(self, request):\n        if self.accepts and hasattr(request, 'accept'):\n            views = []\n            for offer, _ in request.accept.acceptable_offers(self.accepts):\n                views.extend(self.media_views[offer])\n            views.extend(self.views)\n            return views\n        return self.views\n\n    def match(self, context, request):\n        for order, view, phash in self.get_views(request):\n            if not hasattr(view, '__predicated__'):\n                return view\n            if view.__predicated__(context, request):\n                return view\n        raise PredicateMismatch(self.name)\n\n    def __permitted__(self, context, request):\n        view = self.match(context, request)\n        if hasattr(view, '__permitted__'):\n            return view.__permitted__(context, request)\n        return True\n\n    def __call_permissive__(self, context, request):\n        view = self.match(context, request)\n        view = getattr(view, '__call_permissive__', view)\n        return view(context, request)\n\n    def __call__(self, context, request):\n        for order, view, phash in self.get_views(request):\n            try:\n                return view(context, request)\n            except PredicateMismatch:\n                continue\n        raise PredicateMismatch(self.name)"
    },
    {
      "chunk_id": 657,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def attr_wrapped_view(view, info):\n    accept, order, phash = (\n        info.options.get('accept', None),\n        getattr(info, 'order', MAX_ORDER),\n        getattr(info, 'phash', DEFAULT_PHASH),\n    )\n    if (accept is None) and (order == MAX_ORDER) and (phash == DEFAULT_PHASH):\n        return view  # defaults\n\n    def attr_view(context, request):\n        return view(context, request)\n\n    attr_view.__accept__ = accept\n    attr_view.__order__ = order\n    attr_view.__phash__ = phash\n    attr_view.__view_attr__ = info.options.get('attr')\n    attr_view.__permission__ = info.options.get('permission')\n    return attr_view\n\nattr_wrapped_view.options = ('accept', 'attr', 'permission')"
    },
    {
      "chunk_id": 658,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def predicated_view(view, info):\n    preds = info.predicates\n    if not preds:\n        return view\n\n    def predicate_wrapper(context, request):\n        for predicate in preds:\n            if not predicate(context, request):\n                view_name = getattr(view, '__name__', view)\n                raise PredicateMismatch(\n                    'predicate mismatch for view %s (%s)'\n                    % (view_name, predicate.text())\n                )\n        return view(context, request)\n\n    def checker(context, request):\n        return all(predicate(context, request) for predicate in preds)\n\n    predicate_wrapper.__predicated__ = checker\n    predicate_wrapper.__predicates__ = preds\n    return predicate_wrapper"
    },
    {
      "chunk_id": 659,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def viewdefaults(wrapped):\n    \"\"\"Decorator for add_view-like methods which takes into account\n    __view_defaults__ attached to view it is passed.  Not a documented API but\n    used by some external systems.\"\"\"\n\n    def wrapper(self, *arg, **kw):\n        defaults = {}\n        if arg:\n            view = arg[0]\n        else:\n            view = kw.get('view')\n        view = self.maybe_dotted(view)\n        if inspect.isclass(view):\n            defaults = getattr(view, '__view_defaults__', {}).copy()\n        if '_backframes' not in kw:\n            kw['_backframes'] = 1  # for action_method\n        defaults.update(kw)\n        return wrapped(self, *arg, **defaults)\n\n    return functools.wraps(wrapped)(wrapper)"
    },
    {
      "chunk_id": 660,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def combine_decorators(*decorators):\n    def decorated(view_callable):\n        for decorator in reversed(decorators):\n            view_callable = decorator(view_callable)\n        return view_callable\n\n    return decorated"
    },
    {
      "chunk_id": 661,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "class ViewsConfiguratorMixin:\n    @viewdefaults\n    @action_method\n    def add_view(\n        self,\n        view=None,\n        name=\"\",\n        for_=None,\n        permission=None,\n        request_type=None,\n        route_name=None,\n        request_method=None,\n        request_param=None,\n        containment=None,\n        attr=None,\n        renderer=None,\n        wrapper=None,\n        xhr=None,\n        accept=None,\n        header=None,\n        path_info=None,\n        custom_predicates=(),\n        context=None,\n        decorator=None,\n        mapper=None,\n        http_cache=None,\n        match_param=None,\n        require_csrf=None,\n        exception_only=False,\n        **view_options,\n    ):\n        \"\"\"Add a :term:`view configuration` to the current\n        configuration state.  Arguments to ``add_view`` are broken\n        down below into *predicate* arguments and *non-predicate*\n        arguments.  Predicate arguments narrow the circumstances in\n        which the view callable will be invoked when a request is\n        presented to :app:`Pyramid`; non-predicate arguments are\n        informational.\n\n        Non-Predicate Arguments\n\n        view\n\n          A :term:`view callable` or a :term:`dotted Python name`\n          which refers to a view callable.  This argument is required\n          unless a ``renderer`` argument also exists.  If a\n          ``renderer`` argument is passed, and a ``view`` argument is\n          not provided, the view callable defaults to a callable that\n          returns an empty dictionary (see\n          :ref:`views_which_use_a_renderer`).\n\n        permission\n\n          A :term:`permission` that the user must possess in order to invoke\n          the :term:`view callable`.  See :ref:`view_security_section` for\n          more information about view security and permissions.  This is\n          often a string like ``view`` or ``edit``.\n\n          If ``permission`` is omitted, a *default* permission may be used\n          for this view registration if one was named as the\n          :class:`pyramid.config.Configurator` constructor's\n          ``default_permission`` argument, or if\n          :meth:`pyramid.config.Configurator.set_default_permission` was used\n          prior to this view registration.  Pass the value\n          :data:`pyramid.security.NO_PERMISSION_REQUIRED` as the permission\n          argument to explicitly indicate that the view should always be\n          executable by entirely anonymous users, regardless of the default\n          permission, bypassing any :term:`authorization policy` that may be\n          in effect.\n\n        attr\n\n          This knob is most useful when the view definition is a class.\n\n          The view machinery defaults to using the ``__call__`` method\n          of the :term:`view callable` (or the function itself, if the\n          view callable is a function) to obtain a response.  The\n          ``attr`` value allows you to vary the method attribute used\n          to obtain the response.  For example, if your view was a\n          class, and the class has a method named ``index`` and you\n          wanted to use this method instead of the class' ``__call__``\n          method to return the response, you'd say ``attr=\"index\"`` in the\n          view configuration for the view.\n\n        renderer\n\n          This is either a single string term (e.g. ``json``) or a\n          string implying a path or :term:`asset specification`\n          (e.g. ``templates/views.pt``) naming a :term:`renderer`\n          implementation.  If the ``renderer`` value does not contain\n          a dot ``.``, the specified string will be used to look up a\n          renderer implementation, and that renderer implementation\n          will be used to construct a response from the view return\n          value.  If the ``renderer`` value contains a dot (``.``),\n          the specified term will be treated as a path, and the\n          filename extension of the last element in the path will be\n          used to look up the renderer implementation, which will be\n          passed the full path.  The renderer implementation will be\n          used to construct a :term:`response` from the view return\n          value.\n\n          Note that if the view itself returns a :term:`response` (see\n          :ref:`the_response`), the specified renderer implementation\n          is never called.\n\n          When the renderer is a path, although a path is usually just\n          a simple relative pathname (e.g. ``templates/foo.pt``,\n          implying that a template named \"foo.pt\" is in the\n          \"templates\" directory relative to the directory of the\n          current :term:`package` of the Configurator), a path can be\n          absolute, starting with a slash on UNIX or a drive letter\n          prefix on Windows.  The path can alternately be a\n          :term:`asset specification` in the form\n          ``some.dotted.package_name:relative/path``, making it\n          possible to address template assets which live in a\n          separate package.\n\n          The ``renderer`` attribute is optional.  If it is not\n          defined, the \"null\" renderer is assumed (no rendering is\n          performed and the value is passed back to the upstream\n          :app:`Pyramid` machinery unmodified).\n\n        http_cache\n\n          .. versionadded:: 1.1\n\n          When you supply an ``http_cache`` value to a view configuration,\n          the ``Expires`` and ``Cache-Control`` headers of a response\n          generated by the associated view callable are modified.  The value\n          for ``http_cache`` may be one of the following:\n\n          - A nonzero integer.  If it's a nonzero integer, it's treated as a\n            number of seconds.  This number of seconds will be used to\n            compute the ``Expires`` header and the ``Cache-Control:\n            max-age`` parameter of responses to requests which call this view.\n            For example: ``http_cache=3600`` instructs the requesting browser\n            to 'cache this response for an hour, please'.\n\n          - A ``datetime.timedelta`` instance.  If it's a\n            ``datetime.timedelta`` instance, it will be converted into a\n            number of seconds, and that number of seconds will be used to\n            compute the ``Expires`` header and the ``Cache-Control:\n            max-age`` parameter of responses to requests which call this view.\n            For example: ``http_cache=datetime.timedelta(days=1)`` instructs\n            the requesting browser to 'cache this response for a day, please'.\n\n          - Zero (``0``).  If the value is zero, the ``Cache-Control`` and\n            ``Expires`` headers present in all responses from this view will\n            be composed such that client browser cache (and any intermediate\n            caches) are instructed to never cache the response.\n\n          - A two-tuple.  If it's a two tuple (e.g. ``http_cache=(1,\n            {'public':True})``), the first value in the tuple may be a\n            nonzero integer or a ``datetime.timedelta`` instance; in either\n            case this value will be used as the number of seconds to cache\n            the response.  The second value in the tuple must be a\n            dictionary.  The values present in the dictionary will be used as\n            input to the ``Cache-Control`` response header.  For example:\n            ``http_cache=(3600, {'public':True})`` means 'cache for an hour,\n            and add ``public`` to the Cache-Control header of the response'.\n            All keys and values supported by the\n            ``webob.cachecontrol.CacheControl`` interface may be added to the\n            dictionary.  Supplying ``{'public':True}`` is equivalent to\n            calling ``response.cache_control.public = True``.\n\n          Providing a non-tuple value as ``http_cache`` is equivalent to\n          calling ``response.cache_expires(value)`` within your view's body.\n\n          Providing a two-tuple value as ``http_cache`` is equivalent to\n          calling ``response.cache_expires(value[0], **value[1])`` within your\n          view's body.\n\n          If you wish to avoid influencing, the ``Expires`` header, and\n          instead wish to only influence ``Cache-Control`` headers, pass a\n          tuple as ``http_cache`` with the first element of ``None``, e.g.:\n          ``(None, {'public':True})``.\n\n          If you wish to prevent a view that uses ``http_cache`` in its\n          configuration from having its caching response headers changed by\n          this machinery, set ``response.cache_control.prevent_auto = True``\n          before returning the response from the view.  This effectively\n          disables any HTTP caching done by ``http_cache`` for that response.\n\n        require_csrf\n\n          .. versionadded:: 1.7\n\n          A boolean option or ``None``. Default: ``None``.\n\n          If this option is set to ``True`` then CSRF checks will be enabled\n          for requests to this view. The required token or header default to\n          ``csrf_token`` and ``X-CSRF-Token``, respectively.\n\n          CSRF checks only affect \"unsafe\" methods as defined by RFC2616. By\n          default, these methods are anything except\n          ``GET``, ``HEAD``, ``OPTIONS``, and ``TRACE``.\n\n          The defaults here may be overridden by\n          :meth:`pyramid.config.Configurator.set_default_csrf_options`.\n\n          This feature requires a configured :term:`session factory`.\n\n          If this option is set to ``False`` then CSRF checks will be disabled\n          regardless of the default ``require_csrf`` setting passed\n          to ``set_default_csrf_options``.\n\n          See :ref:`auto_csrf_checking` for more information.\n\n        wrapper\n\n          The :term:`view name` of a different :term:`view\n          configuration` which will receive the response body of this\n          view as the ``request.wrapped_body`` attribute of its own\n          :term:`request`, and the :term:`response` returned by this\n          view as the ``request.wrapped_response`` attribute of its\n          own request.  Using a wrapper makes it possible to \"chain\"\n          views together to form a composite response.  The response\n          of the outermost wrapper view will be returned to the user.\n          The wrapper view will be found as any view is found: see\n          :ref:`view_lookup`.  The context and request of a wrapper\n          view is the same context and request of the inner view.  If\n          this attribute is unspecified, no view wrapping is done.\n\n        decorator\n\n          A :term:`dotted Python name` to function (or the function itself,\n          or an iterable of the aforementioned) which will be used to\n          decorate the registered :term:`view callable`.  The decorator\n          function(s) will be called with the view callable as a single\n          argument.  The view callable it is passed will accept\n          ``(context, request)``.  The decorator(s) must return a\n          replacement view callable which also accepts ``(context,\n          request)``.\n\n          If decorator is an iterable, the callables will be combined and\n          used in the order provided as a decorator.\n          For example::\n\n            @view_config(...,\n                decorator=(decorator2,\n                           decorator1))\n            def myview(request):\n                ....\n\n          Is similar to doing::\n\n            @view_config(...)\n            @decorator2\n            @decorator1\n            def myview(request):\n                ...\n\n          Except with the existing benefits of ``decorator=`` (having a common\n          decorator syntax for all view calling conventions and not having to\n          think about preserving function attributes such as ``__name__`` and\n          ``__module__`` within decorator logic).\n\n          An important distinction is that each decorator will receive a\n          response object implementing :class:`pyramid.interfaces.IResponse`\n          instead of the raw value returned from the view callable. All\n          decorators in the chain must return a response object or raise an\n          exception:\n\n          .. code-block:: python\n\n             def log_timer(wrapped):\n                 def wrapper(context, request):\n                     start = time.time()\n                     response = wrapped(context, request)\n                     duration = time.time() - start\n                     response.headers['X-View-Time'] = '%.3f' % (duration,)\n                     log.info('view took %.3f seconds', duration)\n                     return response\n                 return wrapper\n\n          .. versionchanged:: 1.4a4\n             Passing an iterable.\n\n        mapper\n\n          A Python object or :term:`dotted Python name` which refers to a\n          :term:`view mapper`, or ``None``.  By default it is ``None``, which\n          indicates that the view should use the default view mapper.  This\n          plug-point is useful for Pyramid extension developers, but it's not\n          very useful for 'civilians' who are just developing stock Pyramid\n          applications. Pay no attention to the man behind the curtain.\n\n        accept\n\n          A :term:`media type` that will be matched against the ``Accept``\n          HTTP request header.  If this value is specified, it must be a\n          specific media type such as ``text/html`` or ``text/html;level=1``.\n          If the media type is acceptable by the ``Accept`` header of the\n          request, or if the ``Accept`` header isn't set at all in the request,\n          this predicate will match. If this does not match the ``Accept``\n          header of the request, view matching continues.\n\n          If ``accept`` is not specified, the ``HTTP_ACCEPT`` HTTP header is\n          not taken into consideration when deciding whether or not to invoke\n          the associated view callable.\n\n          The ``accept`` argument is technically not a predicate and does\n          not support wrapping with :func:`pyramid.config.not_`.\n\n          See :ref:`accept_content_negotiation` for more information.\n\n          .. versionchanged:: 1.10\n\n              Specifying a media range is deprecated and will be removed in\n              :app:`Pyramid` 2.0. Use explicit media types to avoid any\n              ambiguities in content negotiation.\n\n          .. versionchanged:: 2.0\n\n              Removed support for media ranges.\n\n        exception_only\n\n          .. versionadded:: 1.8\n\n          When this value is ``True``, the ``context`` argument must be\n          a subclass of ``Exception``. This flag indicates that only an\n          :term:`exception view` should be created, and that this view should\n          not match if the traversal :term:`context` matches the ``context``\n          argument. If the ``context`` is a subclass of ``Exception`` and\n          this value is ``False`` (the default), then a view will be\n          registered to match the traversal :term:`context` as well.\n\n        Predicate Arguments\n\n        name\n\n          The :term:`view name`.  Read :ref:`traversal_chapter` to\n          understand the concept of a view name.\n\n        context\n\n          An object or a :term:`dotted Python name` referring to an\n          interface or class object that the :term:`context` must be\n          an instance of, *or* the :term:`interface` that the\n          :term:`context` must provide in order for this view to be\n          found and called.  This predicate is true when the\n          :term:`context` is an instance of the represented class or\n          if the :term:`context` provides the represented interface;\n          it is otherwise false.  This argument may also be provided\n          to ``add_view`` as ``for_`` (an older, still-supported\n          spelling). If the view should *only* match when handling\n          exceptions, then set the ``exception_only`` to ``True``.\n\n        route_name\n\n          This value must match the ``name`` of a :term:`route\n          configuration` declaration (see :ref:`urldispatch_chapter`)\n          that must match before this view will be called.\n\n        request_type\n\n          This value should be an :term:`interface` that the\n          :term:`request` must provide in order for this view to be\n          found and called.  This value exists only for backwards\n          compatibility purposes.\n\n        request_method\n\n          This value can be either a string (such as ``\"GET\"``, ``\"POST\"``,\n          ``\"PUT\"``, ``\"DELETE\"``, ``\"HEAD\"`` or ``\"OPTIONS\"``) representing\n          an HTTP ``REQUEST_METHOD``, or a tuple containing one or more of\n          these strings.  A view declaration with this argument ensures that\n          the view will only be called when the ``method`` attribute of the\n          request (aka the ``REQUEST_METHOD`` of the WSGI environment) matches\n          a supplied value.  Note that use of ``GET`` also implies that the\n          view will respond to ``HEAD`` as of Pyramid 1.4.\n\n          .. versionchanged:: 1.2\n             The ability to pass a tuple of items as ``request_method``.\n             Previous versions allowed only a string.\n\n        request_param\n\n          This value can be any string or any sequence of strings.  A view\n          declaration with this argument ensures that the view will only be\n          called when the :term:`request` has a key in the ``request.params``\n          dictionary (an HTTP ``GET`` or ``POST`` variable) that has a\n          name which matches the supplied value (if the value is a string)\n          or values (if the value is a tuple).  If any value\n          supplied has a ``=`` sign in it,\n          e.g. ``request_param=\"foo=123\"``, then the key (``foo``)\n          must both exist in the ``request.params`` dictionary, *and*\n          the value must match the right hand side of the expression\n          (``123``) for the view to \"match\" the current request.\n\n        match_param\n\n          .. versionadded:: 1.2\n\n          This value can be a string of the format \"key=value\" or a tuple\n          containing one or more of these strings.\n\n          A view declaration with this argument ensures that the view will\n          only be called when the :term:`request` has key/value pairs in its\n          :term:`matchdict` that equal those supplied in the predicate.\n          e.g. ``match_param=\"action=edit\"`` would require the ``action``\n          parameter in the :term:`matchdict` match the right hand side of\n          the expression (``edit``) for the view to \"match\" the current\n          request.\n\n          If the ``match_param`` is a tuple, every key/value pair must match\n          for the predicate to pass.\n\n        containment\n\n          This value should be a Python class or :term:`interface` (or a\n          :term:`dotted Python name`) that an object in the\n          :term:`lineage` of the context must provide in order for this view\n          to be found and called.  The nodes in your object graph must be\n          \"location-aware\" to use this feature.  See\n          :ref:`location_aware` for more information about\n          location-awareness.\n\n        xhr\n\n          This value should be either ``True`` or ``False``.  If this\n          value is specified and is ``True``, the :term:`request`\n          must possess an ``HTTP_X_REQUESTED_WITH`` (aka\n          ``X-Requested-With``) header that has the value\n          ``XMLHttpRequest`` for this view to be found and called.\n          This is useful for detecting AJAX requests issued from\n          jQuery, Prototype and other Javascript libraries.\n\n        header\n\n          This argument can be a string or an iterable of strings for HTTP\n          headers.  The matching is determined as follow:\n\n          - If a string does not contain a ``:`` (colon), it will be\n            considered to be a header name (example ``If-Modified-Since``).\n            In this case, the header specified by the name must be present\n            in the request for this string to match.  Case is not significant.\n\n          - If a string contains a colon, it will be considered a\n            name/value pair (for example ``User-Agent:Mozilla/.*`` or\n            ``Host:localhost``), where the value part is a regular\n            expression.  The header specified by the name must be present\n            in the request *and* the regular expression specified as the\n            value part must match the value of the request header.  Case is\n            not significant for the header name, but it is for the value.\n\n          All strings must be matched for this predicate to return ``True``.\n          If this predicate returns ``False``, view matching continues.\n\n        path_info\n\n          This value represents a regular expression pattern that will\n          be tested against the ``PATH_INFO`` WSGI environment\n          variable.  If the regex matches, this predicate will be\n          ``True``.\n\n        physical_path\n\n          If specified, this value should be a string or a tuple representing\n          the :term:`physical path` of the context found via traversal for this\n          predicate to match as true.  For example: ``physical_path='/'`` or\n          ``physical_path='/a/b/c'`` or ``physical_path=('', 'a', 'b', 'c')``.\n          This is not a path prefix match or a regex, it's a whole-path match.\n          It's useful when you want to always potentially show a view when some\n          object is traversed to, but you can't be sure about what kind of\n          object it will be, so you can't use the ``context`` predicate.  The\n          individual path elements in between slash characters or in tuple\n          elements should be the Unicode representation of the name of the\n          resource and should not be encoded in any way.\n\n          .. versionadded:: 1.4a3\n\n        is_authenticated\n\n          This value, if specified, must be either ``True`` or ``False``.\n          If it is specified and ``True``, only a request from an authenticated\n          user, as determined by the :term:`security policy` in use, will\n          satisfy the predicate.\n          If it is specified and ``False``, only a request from a user who is\n          not authenticated will satisfy the predicate.\n\n          .. versionadded:: 2.0\n\n        effective_principals\n\n          If specified, this value should be a :term:`principal` identifier or\n          a sequence of principal identifiers.  If the\n          :attr:`pyramid.request.Request.effective_principals` property\n          indicates that every principal named in the argument list is present\n          in the current request, this predicate will return True; otherwise it\n          will return False.  For example:\n          ``effective_principals=pyramid.authorization.Authenticated`` or\n          ``effective_principals=('fred', 'group:admins')``.\n\n          .. versionadded:: 1.4a4\n\n          .. deprecated:: 2.0\n              Use ``is_authenticated`` or a custom predicate.\n\n        custom_predicates\n\n            .. deprecated:: 1.5\n                This value should be a sequence of references to custom\n                predicate callables.  Each custom predicate callable\n                should accept two arguments:\n                ``context`` and ``request`` and should return either\n                ``True`` or ``False`` after doing arbitrary evaluation of\n                the context and/or the request.  The ability to register\n                custom view predicates via\n                :meth:`pyramid.config.Configurator.add_view_predicate`\n                obsoletes this argument, but it is kept around for backwards\n                compatibility.\n\n        \\\\*\\\\*view_options\n\n          Pass extra keyword parameters to use custom predicates\n          or set a value for a view deriver. See\n          :meth:`pyramid.config.Configurator.add_view_predicate` and\n          :meth:`pyramid.config.Configurator.add_view_deriver`. See\n          :ref:`view_and_route_predicates` for more information about\n          custom predicates and :ref:`view_derivers` for information\n          about view derivers.\n\n          .. versionadded: 1.4a1\n\n          .. versionchanged: 1.7\n\n             Support setting view deriver options. Previously, only custom\n             view predicate values could be supplied.\n\n          .. versionchanged:: 2.0\n\n             Removed support for the ``check_csrf`` predicate.\n\n        \"\"\"\n        if custom_predicates:\n            warnings.warn(\n                (\n                    'The \"custom_predicates\" argument to '\n                    'Configurator.add_view is deprecated as of Pyramid 1.5. '\n                    'Use \"config.add_view_predicate\" and use the registered '\n                    'view predicate as a predicate argument to add_view '\n                    'instead. See \"Adding A Custom View, Route, or '\n                    'Subscriber Predicate\" in the \"Hooks\" chapter of the '\n                    'documentation for more information.'\n                ),\n                DeprecationWarning,\n                stacklevel=4,\n            )\n\n        if 'effective_principals' in view_options:\n            warnings.warn(\n                (\n                    'The new security policy has deprecated '\n                    'effective_principals. See \"Upgrading '\n                    'Authentication/Authorization\" in \"What\\'s New in '\n                    'Pyramid 2.0\" of the documentation for more information.'\n                ),\n                DeprecationWarning,\n                stacklevel=4,\n            )\n\n        if accept is not None:\n            if is_nonstr_iter(accept):\n                raise ConfigurationError(\n                    'A list is not supported in the \"accept\" view predicate.'\n                )\n            accept = normalize_accept_offer(accept)\n\n        view = self.maybe_dotted(view)\n        context = self.maybe_dotted(context)\n        for_ = self.maybe_dotted(for_)\n        containment = self.maybe_dotted(containment)\n        mapper = self.maybe_dotted(mapper)\n\n        if is_nonstr_iter(decorator):\n            decorator = combine_decorators(*map(self.maybe_dotted, decorator))\n        else:\n            decorator = self.maybe_dotted(decorator)\n\n        if not view:\n            if renderer:\n\n                def view(context, request):\n                    return {}\n\n            else:\n                raise ConfigurationError(\n                    '\"view\" was not specified and no \"renderer\" specified'\n                )\n\n        if request_type is not None:\n            request_type = self.maybe_dotted(request_type)\n            if not IInterface.providedBy(request_type):\n                raise ConfigurationError(\n                    'request_type must be an interface, not %s' % request_type\n                )\n\n        if context is None:\n            context = for_\n\n        isexc = isexception(context)\n        if exception_only and not isexc:\n            raise ConfigurationError(\n                'view \"context\" must be an exception type when '\n                '\"exception_only\" is True'\n            )\n\n        r_context = context\n        if r_context is None:\n            r_context = Interface\n        if not IInterface.providedBy(r_context):\n            r_context = implementedBy(r_context)\n\n        if isinstance(renderer, str):\n            renderer = renderers.RendererHelper(\n                name=renderer, package=self.package, registry=self.registry\n            )\n\n        introspectables = []\n        ovals = view_options.copy()\n        ovals.update(\n            dict(\n                xhr=xhr,\n                request_method=request_method,\n                path_info=path_info,\n                request_param=request_param,\n                header=header,\n                accept=accept,\n                containment=containment,\n                request_type=request_type,\n                match_param=match_param,\n                custom=predvalseq(custom_predicates),\n            )\n        )\n\n        def discrim_func():\n            predlist = self.get_predlist('view')\n            valid_predicates = predlist.names()\n            pvals = {}\n            dvals = {}\n\n            for k, v in ovals.items():\n                if k in valid_predicates:\n                    pvals[k] = v\n                else:\n                    dvals[k] = v\n\n            self._check_view_options(**dvals)\n\n            order, preds, phash = predlist.make(self, **pvals)\n\n            view_intr.update(\n                {'phash': phash, 'order': order, 'predicates': preds}\n            )\n            return ('view', context, name, route_name, phash)\n\n        discriminator = Deferred(discrim_func)\n\n        if inspect.isclass(view) and attr:\n            view_desc = 'method {!r} of {}'.format(\n                attr,\n                self.object_description(view),\n            )\n        else:\n            view_desc = self.object_description(view)\n\n        tmpl_intr = None\n\n        view_intr = self.introspectable(\n            'views', discriminator, view_desc, 'view'\n        )\n        view_intr.update(\n            dict(\n                name=name,\n                context=context,\n                exception_only=exception_only,\n                containment=containment,\n                request_param=request_param,\n                request_methods=request_method,\n                route_name=route_name,\n                attr=attr,\n                xhr=xhr,\n                accept=accept,\n                header=header,\n                path_info=path_info,\n                match_param=match_param,\n                http_cache=http_cache,\n                require_csrf=require_csrf,\n                callable=view,\n                mapper=mapper,\n                decorator=decorator,\n            )\n        )\n        view_intr.update(view_options)\n        introspectables.append(view_intr)\n\n        def register(permission=permission, renderer=renderer):\n            request_iface = IRequest\n            if route_name is not None:\n                request_iface = self.registry.queryUtility(\n                    IRouteRequest, name=route_name\n                )\n                if request_iface is None:\n                    raise ConfigurationError(\n                        'No route named %s found for view registration'\n                        % route_name\n                    )\n\n            if renderer is None:\n                if self.registry.queryUtility(IRendererFactory) is not None:\n                    renderer = renderers.RendererHelper(\n                        name=None, package=self.package, registry=self.registry\n                    )\n\n            renderer_type = getattr(renderer, 'type', None)\n            intrspc = self.introspector\n            if (\n                renderer_type is not None\n                and tmpl_intr is not None\n                and intrspc is not None\n                and intrspc.get('renderer factories', renderer_type)\n                is not None\n            ):\n                tmpl_intr.relate('renderer factories', renderer.type)\n\n            if not exception_only:\n                derived_view = derive_view(False, renderer)\n                register_view(IViewClassifier, request_iface, derived_view)\n            if isexc:\n                derived_exc_view = derive_view(True, renderer)\n                register_view(\n                    IExceptionViewClassifier, request_iface, derived_exc_view\n                )\n\n                if exception_only:\n                    derived_view = derived_exc_view\n\n            if not exception_only and isexc:\n                derived_view = runtime_exc_view(derived_view, derived_exc_view)\n\n            derived_view.__discriminator__ = lambda *arg: discriminator\n            view_intr['derived_callable'] = derived_view\n\n            self.registry._clear_view_lookup_cache()\n\n        def derive_view(isexc_only, renderer):\n            preds = view_intr['predicates']\n            order = view_intr['order']\n            phash = view_intr['phash']\n\n            derived_view = self._derive_view(\n                view,\n                route_name=route_name,\n                permission=permission,\n                predicates=preds,\n                attr=attr,\n                context=context,\n                exception_only=isexc_only,\n                renderer=renderer,\n                wrapper_viewname=wrapper,\n                viewname=name,\n                accept=accept,\n                order=order,\n                phash=phash,\n                decorator=decorator,\n                mapper=mapper,\n                http_cache=http_cache,\n                require_csrf=require_csrf,\n                extra_options=ovals,\n            )\n            return derived_view\n\n        def register_view(classifier, request_iface, derived_view):\n            old_view = None\n            order, phash = view_intr['order'], view_intr['phash']\n            registered = self.registry.adapters.registered\n\n            for view_type in (IView, ISecuredView, IMultiView):\n                old_view = registered(\n                    (classifier, request_iface, r_context), view_type, name\n                )\n                if old_view is not None:\n                    break\n\n            old_phash = getattr(old_view, '__phash__', DEFAULT_PHASH)\n            is_multiview = IMultiView.providedBy(old_view)\n            want_multiview = (\n                is_multiview\n                or (old_view is not None and old_phash != phash)\n            )\n\n            if not want_multiview:\n                if hasattr(derived_view, '__call_permissive__'):\n                    view_iface = ISecuredView\n                else:\n                    view_iface = IView\n                self.registry.registerAdapter(\n                    derived_view,\n                    (classifier, request_iface, context),\n                    view_iface,\n                    name,\n                )\n\n            else:\n                if is_multiview:\n                    multiview = old_view\n                else:\n                    multiview = MultiView(name)\n                    old_accept = getattr(old_view, '__accept__', None)\n                    old_order = getattr(old_view, '__order__', MAX_ORDER)\n                    multiview.add(old_view, old_order, old_phash, old_accept)\n                accept_order = self.registry.queryUtility(IAcceptOrder)\n                multiview.add(derived_view, order, phash, accept, accept_order)\n                for view_type in (IView, ISecuredView):\n                    self.registry.adapters.unregister(\n                        (classifier, request_iface, r_context),\n                        view_type,\n                        name=name,\n                    )\n                self.registry.registerAdapter(\n                    multiview,\n                    (classifier, request_iface, context),\n                    IMultiView,\n                    name=name,\n                )\n\n        if mapper:\n            mapper_intr = self.introspectable(\n                'view mappers',\n                discriminator,\n                'view mapper for %s' % view_desc,\n                'view mapper',\n            )\n            mapper_intr['mapper'] = mapper\n            mapper_intr.relate('views', discriminator)\n            introspectables.append(mapper_intr)\n        if route_name:\n            view_intr.relate('routes', route_name)\n        if renderer is not None and renderer.name and '.' in renderer.name:\n            tmpl_intr = self.introspectable(\n                'templates', discriminator, renderer.name, 'template'\n            )\n            tmpl_intr.relate('views', discriminator)\n            tmpl_intr['name'] = renderer.name\n            tmpl_intr['type'] = renderer.type\n            tmpl_intr['renderer'] = renderer\n            introspectables.append(tmpl_intr)\n        if permission is not None:\n            perm_intr = self.introspectable(\n                'permissions', permission, permission, 'permission'\n            )\n            perm_intr['value'] = permission\n            perm_intr.relate('views', discriminator)\n            introspectables.append(perm_intr)\n        self.action(discriminator, register, introspectables=introspectables)\n\n    def _check_view_options(self, **kw):\n        derivers = self.registry.getUtility(IViewDerivers)\n        for deriver in derivers.values():\n            for opt in getattr(deriver, 'options', []):\n                kw.pop(opt, None)\n        if kw:\n            raise ConfigurationError(f'Unknown view options: {kw}')\n\n    def _apply_view_derivers(self, info):\n        outer_derivers = [\n            ('attr_wrapped_view', attr_wrapped_view),\n            ('predicated_view', predicated_view),\n        ]\n\n        view = info.original_view\n        derivers = self.registry.getUtility(IViewDerivers)\n        for name, deriver in reversed(outer_derivers + derivers.sorted()):\n            view = wraps_view(deriver)(view, info)\n        return view\n\n    @action_method\n    def add_view_predicate(\n        self, name, factory, weighs_more_than=None, weighs_less_than=None\n    ):\n        \"\"\"\n        .. versionadded:: 1.4\n\n        Adds a view predicate factory.  The associated view predicate can\n        later be named as a keyword argument to\n        :meth:`pyramid.config.Configurator.add_view` in the\n        ``predicates`` anonyous keyword argument dictionary.\n\n        ``name`` should be the name of the predicate.  It must be a valid\n        Python identifier (it will be used as a keyword argument to\n        ``add_view`` by others).\n\n        ``factory`` should be a :term:`predicate factory` or :term:`dotted\n        Python name` which refers to a predicate factory.\n\n        See :ref:`view_and_route_predicates` for more information.\n        \"\"\"\n        self._add_predicate(\n            'view',\n            name,\n            factory,\n            weighs_more_than=weighs_more_than,\n            weighs_less_than=weighs_less_than,\n        )\n\n    def add_default_view_predicates(self):\n        p = pyramid.predicates\n        for name, factory in (\n            ('xhr', p.XHRPredicate),\n            ('request_method', p.RequestMethodPredicate),\n            ('path_info', p.PathInfoPredicate),\n            ('request_param', p.RequestParamPredicate),\n            ('header', p.HeaderPredicate),\n            ('accept', p.AcceptPredicate),\n            ('containment', p.ContainmentPredicate),\n            ('request_type', p.RequestTypePredicate),\n            ('match_param', p.MatchParamPredicate),\n            ('physical_path', p.PhysicalPathPredicate),\n            ('is_authenticated', p.IsAuthenticatedPredicate),\n            ('effective_principals', p.EffectivePrincipalsPredicate),\n            ('custom', p.CustomPredicate),\n        ):\n            self.add_view_predicate(name, factory)\n\n    def add_default_accept_view_order(self):\n        for accept in (\n            'text/html',\n            'application/xhtml+xml',\n            'application/xml',\n            'text/xml',\n            'text/plain',\n            'application/json',\n        ):\n            self.add_accept_view_order(accept)\n\n    @action_method\n    def add_accept_view_order(\n        self, value, weighs_more_than=None, weighs_less_than=None\n    ):\n        \"\"\"\n        Specify an ordering preference for the ``accept`` view option used\n        during :term:`view lookup`.\n\n        By default, if two views have different ``accept`` options and a\n        request specifies ``Accept: */*`` or omits the header entirely then\n        it is random which view will be selected. This method provides a way\n        to specify a server-side, relative ordering between accept media types.\n\n        ``value`` should be a :term:`media type` as specified by\n        :rfc:`7231#section-5.3.2`. For example, ``text/plain;charset=utf8``,\n        ``application/json`` or ``text/html``.\n\n        ``weighs_more_than`` and ``weighs_less_than`` control the ordering\n        of media types. Each value may be a string or a list of strings. If\n        all options for ``weighs_more_than`` (or ``weighs_less_than``) cannot\n        be found, it is an error.\n\n        Earlier calls to ``add_accept_view_order`` are given higher priority\n        over later calls, assuming similar constraints but standard conflict\n        resolution mechanisms can be used to override constraints.\n\n        See :ref:`accept_content_negotiation` for more information.\n\n        .. versionadded:: 1.10\n\n        \"\"\"\n\n        def check_type(than):\n            than_type, than_subtype, than_params = Accept.parse_offer(than)\n            if bool(offer_params) ^ bool(than_params):\n                raise ConfigurationError(\n                    'cannot compare a media type with params to one without '\n                    'params'\n                )\n            if offer_params and (\n                offer_subtype != than_subtype or offer_type != than_type\n            ):\n                raise ConfigurationError(\n                    'cannot compare params across different media types'\n                )\n\n        def normalize_types(thans):\n            thans = [normalize_accept_offer(than) for than in thans]\n            for than in thans:\n                check_type(than)\n            return thans\n\n        value = normalize_accept_offer(value)\n        offer_type, offer_subtype, offer_params = Accept.parse_offer(value)\n\n        if weighs_more_than:\n            if not is_nonstr_iter(weighs_more_than):\n                weighs_more_than = [weighs_more_than]\n            weighs_more_than = normalize_types(weighs_more_than)\n\n        if weighs_less_than:\n            if not is_nonstr_iter(weighs_less_than):\n                weighs_less_than = [weighs_less_than]\n            weighs_less_than = normalize_types(weighs_less_than)\n\n        discriminator = ('accept view order', value)\n        intr = self.introspectable(\n            'accept view order', value, value, 'accept view order'\n        )\n        intr['value'] = value\n        intr['weighs_more_than'] = weighs_more_than\n        intr['weighs_less_than'] = weighs_less_than\n\n        def register():\n            sorter = self.registry.queryUtility(IAcceptOrder)\n            if sorter is None:\n                sorter = TopologicalSorter()\n                self.registry.registerUtility(sorter, IAcceptOrder)\n            sorter.add(\n                value, value, before=weighs_more_than, after=weighs_less_than\n            )\n\n        self.action(\n            discriminator,\n            register,\n            introspectables=(intr,),\n            order=PHASE1_CONFIG,\n        )  # must be registered before add_view\n\n    @action_method\n    def add_view_deriver(self, deriver, name=None, under=None, over=None):\n        \"\"\"\n        .. versionadded:: 1.7\n\n        Add a :term:`view deriver` to the view pipeline. View derivers are\n        a feature used by extension authors to wrap views in custom code\n        controllable by view-specific options.\n\n        ``deriver`` should be a callable conforming to the\n        :class:`pyramid.interfaces.IViewDeriver` interface.\n\n        ``name`` should be the name of the view deriver.  There are no\n        restrictions on the name of a view deriver. If left unspecified, the\n        name will be constructed from the name of the ``deriver``.\n\n        The ``under`` and ``over`` options can be used to control the ordering\n        of view derivers by providing hints about where in the view pipeline\n        the deriver is used. Each option may be a string or a list of strings.\n        At least one view deriver in each, the over and under directions, must\n        exist to fully satisfy the constraints.\n\n        ``under`` means closer to the user-defined :term:`view callable`,\n        and ``over`` means closer to view pipeline ingress.\n\n        The default value for ``over`` is ``rendered_view`` and ``under`` is\n        ``decorated_view``. This places the deriver somewhere between the two\n        in the view pipeline. If the deriver should be placed elsewhere in the\n        pipeline, such as above ``decorated_view``, then you MUST also specify\n        ``under`` to something earlier in the order, or a\n        ``CyclicDependencyError`` will be raised when trying to sort the\n        derivers.\n\n        See :ref:`view_derivers` for more information.\n\n        \"\"\"\n        deriver = self.maybe_dotted(deriver)\n\n        if name is None:\n            name = deriver.__name__\n\n        if name in (INGRESS, VIEW):\n            raise ConfigurationError(\n                '%s is a reserved view deriver name' % name\n            )\n\n        if under is None:\n            under = 'decorated_view'\n\n        if over is None:\n            over = 'rendered_view'\n\n        over = as_sorted_tuple(over)\n        under = as_sorted_tuple(under)\n\n        if INGRESS in over:\n            raise ConfigurationError('%s cannot be over INGRESS' % name)\n\n        if VIEW in over and name != 'mapped_view':\n            over = as_sorted_tuple(over + ('mapped_view',))\n\n        if VIEW in under:\n            raise ConfigurationError('%s cannot be under VIEW' % name)\n        if 'mapped_view' in under:\n            raise ConfigurationError('%s cannot be under \"mapped_view\"' % name)\n\n        discriminator = ('view deriver', name)\n        intr = self.introspectable('view derivers', name, name, 'view deriver')\n        intr['name'] = name\n        intr['deriver'] = deriver\n        intr['under'] = under\n        intr['over'] = over\n\n        def register():\n            derivers = self.registry.queryUtility(IViewDerivers)\n            if derivers is None:\n                derivers = TopologicalSorter(\n                    default_before=None,\n                    default_after=INGRESS,\n                    first=INGRESS,\n                    last=VIEW,\n                )\n                self.registry.registerUtility(derivers, IViewDerivers)\n            derivers.add(name, deriver, before=over, after=under)\n\n        self.action(\n            discriminator,\n            register,\n            introspectables=(intr,),\n            order=PHASE1_CONFIG,\n        )  # must be registered before add_view\n\n    def add_default_view_derivers(self):\n        d = pyramid.viewderivers\n        derivers = [\n            ('secured_view', d.secured_view),\n            ('owrapped_view', d.owrapped_view),\n            ('http_cached_view', d.http_cached_view),\n            ('decorated_view', d.decorated_view),\n            ('rendered_view', d.rendered_view),\n            ('mapped_view', d.mapped_view),\n        ]\n        last = INGRESS\n        for name, deriver in derivers:\n            self.add_view_deriver(deriver, name=name, under=last, over=VIEW)\n            last = name\n\n        self.add_view_deriver(\n            d.csrf_view,\n            'csrf_view',\n            under='secured_view',\n            over='owrapped_view',\n        )\n\n    def derive_view(self, view, attr=None, renderer=None):\n        \"\"\"\n        Create a :term:`view callable` using the function, instance,\n        or class (or :term:`dotted Python name` referring to the same)\n        provided as ``view`` object.\n\n        .. warning::\n\n           This method is typically only used by :app:`Pyramid` framework\n           extension authors, not by :app:`Pyramid` application developers.\n\n        This is API is useful to framework extenders who create\n        pluggable systems which need to register 'proxy' view\n        callables for functions, instances, or classes which meet the\n        requirements of being a :app:`Pyramid` view callable.  For\n        example, a ``some_other_framework`` function in another\n        framework may want to allow a user to supply a view callable,\n        but he may want to wrap the view callable in his own before\n        registering the wrapper as a :app:`Pyramid` view callable.\n        Because a :app:`Pyramid` view callable can be any of a\n        number of valid objects, the framework extender will not know\n        how to call the user-supplied object.  Running it through\n        ``derive_view`` normalizes it to a callable which accepts two\n        arguments: ``context`` and ``request``.\n\n        For example:\n\n        .. code-block:: python\n\n           def some_other_framework(user_supplied_view):\n               config = Configurator(reg)\n               proxy_view = config.derive_view(user_supplied_view)\n               def my_wrapper(context, request):\n                   do_something_that_mutates(request)\n                   return proxy_view(context, request)\n               config.add_view(my_wrapper)\n\n        The ``view`` object provided should be one of the following:\n\n        - A function or another non-class callable object that accepts\n          a :term:`request` as a single positional argument and which\n          returns a :term:`response` object.\n\n        - A function or other non-class callable object that accepts\n          two positional arguments, ``context, request`` and which\n          returns a :term:`response` object.\n\n        - A class which accepts a single positional argument in its\n          constructor named ``request``, and which has a ``__call__``\n          method that accepts no arguments that returns a\n          :term:`response` object.\n\n        - A class which accepts two positional arguments named\n          ``context, request``, and which has a ``__call__`` method\n          that accepts no arguments that returns a :term:`response`\n          object.\n\n        - A :term:`dotted Python name` which refers to any of the\n          kinds of objects above.\n\n        This API returns a callable which accepts the arguments\n        ``context, request`` and which returns the result of calling\n        the provided ``view`` object.\n\n        The ``attr`` keyword argument is most useful when the view\n        object is a class.  It names the method that should be used as\n        the callable.  If ``attr`` is not provided, the attribute\n        effectively defaults to ``__call__``.  See\n        :ref:`class_as_view` for more information.\n\n        The ``renderer`` keyword argument should be a renderer\n        name. If supplied, it will cause the returned callable to use\n        a :term:`renderer` to convert the user-supplied view result to\n        a :term:`response` object.  If a ``renderer`` argument is not\n        supplied, the user-supplied view must itself return a\n        :term:`response` object.\"\"\"\n        return self._derive_view(view, attr=attr, renderer=renderer)"
    },
    {
      "chunk_id": 662,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def _derive_view(\n        self,\n        view,\n        permission=None,\n        predicates=(),\n        attr=None,\n        renderer=None,\n        wrapper_viewname=None,\n        viewname=None,\n        accept=None,\n        order=MAX_ORDER,\n        phash=DEFAULT_PHASH,\n        decorator=None,\n        route_name=None,\n        mapper=None,\n        http_cache=None,\n        context=None,\n        require_csrf=None,\n        exception_only=False,\n        extra_options=None,\n    ):\n        view = self.maybe_dotted(view)\n        mapper = self.maybe_dotted(mapper)\n        if isinstance(renderer, str):\n            renderer = renderers.RendererHelper(\n                name=renderer, package=self.package, registry=self.registry\n            )\n        if renderer is None:\n            if self.registry.queryUtility(IRendererFactory) is not None:\n                renderer = renderers.RendererHelper(\n                    name=None, package=self.package, registry=self.registry\n                )\n\n        options = dict(\n            view=view,\n            context=context,\n            permission=permission,\n            attr=attr,\n            renderer=renderer,\n            wrapper=wrapper_viewname,\n            name=viewname,\n            accept=accept,\n            mapper=mapper,\n            decorator=decorator,\n            http_cache=http_cache,\n            require_csrf=require_csrf,\n            route_name=route_name,\n        )\n        if extra_options:\n            options.update(extra_options)\n\n        info = ViewDeriverInfo(\n            view=view,\n            registry=self.registry,\n            package=self.package,\n            predicates=predicates,\n            exception_only=exception_only,\n            options=options,\n        )\n\n        info.order = order\n        info.phash = phash\n\n        return self._apply_view_derivers(info)\n\n    @viewdefaults\n    @action_method\n    def add_forbidden_view(\n        self,\n        view=None,\n        attr=None,\n        renderer=None,\n        wrapper=None,\n        route_name=None,\n        request_type=None,\n        request_method=None,\n        request_param=None,\n        containment=None,\n        xhr=None,\n        accept=None,\n        header=None,\n        path_info=None,\n        custom_predicates=(),\n        decorator=None,\n        mapper=None,\n        match_param=None,\n        **view_options,\n    ):\n        \"\"\"Add a forbidden view to the current configuration state.  The\n        view will be called when Pyramid or application code raises a\n        :exc:`pyramid.httpexceptions.HTTPForbidden` exception and the set of\n        circumstances implied by the predicates provided are matched.  The\n        simplest example is:\n\n          .. code-block:: python\n\n            def forbidden(request):\n                return Response('Forbidden', status='403 Forbidden')\n\n            config.add_forbidden_view(forbidden)\n\n        If ``view`` argument is not provided, the view callable defaults to\n        :func:`~pyramid.httpexceptions.default_exceptionresponse_view`.\n\n        All arguments have the same meaning as\n        :meth:`pyramid.config.Configurator.add_view` and each predicate\n        argument restricts the set of circumstances under which this forbidden\n        view will be invoked.  Unlike\n        :meth:`pyramid.config.Configurator.add_view`, this method will raise\n        an exception if passed ``name``, ``permission``, ``require_csrf``,\n        ``context``, ``for_``, or ``exception_only`` keyword arguments. These\n        argument values make no sense in the context of a forbidden\n        :term:`exception view`.\n\n        .. versionadded:: 1.3\n\n        .. versionchanged:: 1.8\n\n           The view is created using ``exception_only=True``.\n        \"\"\"\n        for arg in (\n            'name',\n            'permission',\n            'context',\n            'for_',\n            'require_csrf',\n            'exception_only',\n        ):\n            if arg in view_options:\n                raise ConfigurationError(\n                    '%s may not be used as an argument to add_forbidden_view'\n                    % (arg,)\n                )\n\n        if view is None:\n            view = default_exceptionresponse_view\n\n        settings = dict(\n            view=view,\n            context=HTTPForbidden,\n            exception_only=True,\n            wrapper=wrapper,\n            request_type=request_type,\n            request_method=request_method,\n            request_param=request_param,\n            containment=containment,\n            xhr=xhr,\n            accept=accept,\n            header=header,\n            path_info=path_info,\n            custom_predicates=custom_predicates,\n            decorator=decorator,\n            mapper=mapper,\n            match_param=match_param,\n            route_name=route_name,\n            permission=NO_PERMISSION_REQUIRED,\n            require_csrf=False,\n            attr=attr,\n            renderer=renderer,\n        )\n        settings.update(view_options)\n        return self.add_view(**settings)\n\n    set_forbidden_view = add_forbidden_view  # deprecated sorta-bw-compat alias\n\n    @viewdefaults\n    @action_method\n    def add_notfound_view(\n        self,\n        view=None,\n        attr=None,\n        renderer=None,\n        wrapper=None,\n        route_name=None,\n        request_type=None,\n        request_method=None,\n        request_param=None,\n        containment=None,\n        xhr=None,\n        accept=None,\n        header=None,\n        path_info=None,\n        custom_predicates=(),\n        decorator=None,\n        mapper=None,\n        match_param=None,\n        append_slash=False,\n        **view_options,\n    ):\n        \"\"\"Add a default :term:`Not Found View` to the current configuration\n        state. The view will be called when Pyramid or application code raises\n        an :exc:`pyramid.httpexceptions.HTTPNotFound` exception (e.g., when a\n        view cannot be found for the request).  The simplest example is:\n\n          .. code-block:: python\n\n            def notfound(request):\n                return Response('Not Found', status='404 Not Found')\n\n            config.add_notfound_view(notfound)\n\n        If ``view`` argument is not provided, the view callable defaults to\n        :func:`~pyramid.httpexceptions.default_exceptionresponse_view`.\n\n        All arguments except ``append_slash`` have the same meaning as\n        :meth:`pyramid.config.Configurator.add_view` and each predicate\n        argument restricts the set of circumstances under which this notfound\n        view will be invoked.  Unlike\n        :meth:`pyramid.config.Configurator.add_view`, this method will raise\n        an exception if passed ``name``, ``permission``, ``require_csrf``,\n        ``context``, ``for_``, or ``exception_only`` keyword arguments. These\n        argument values make no sense in the context of a Not Found View.\n\n        If ``append_slash`` is ``True``, when this Not Found View is invoked,\n        and the current path info does not end in a slash, the notfound logic\n        will attempt to find a :term:`route` that matches the request's path\n        info suffixed with a slash.  If such a route exists, Pyramid will\n        issue a redirect to the URL implied by the route; if it does not,\n        Pyramid will return the result of the view callable provided as\n        ``view``, as normal.\n\n        If the argument provided as ``append_slash`` is not a boolean but\n        instead implements :class:`~pyramid.interfaces.IResponse`, the\n        append_slash logic will behave as if ``append_slash=True`` was passed,\n        but the provided class will be used as the response class instead of\n        the default :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect`\n        response class when a redirect is performed. For example:\n\n          .. code-block:: python\n\n            from pyramid.httpexceptions import HTTPMovedPermanently\n            config.add_notfound_view(append_slash=HTTPMovedPermanently)\n\n        The above means that a redirect to a slash-appended route will be\n        attempted, but instead of\n        :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect`\n        being used, :class:`~pyramid.httpexceptions.HTTPMovedPermanently will\n        be used` for the redirect response if a slash-appended route is found.\n\n        :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect` class is used\n        as default response, which is equivalent to\n        :class:`~pyramid.httpexceptions.HTTPFound` with addition of redirecting\n        with the same HTTP method (useful when doing POST requests).\n\n        .. versionadded:: 1.3\n\n        .. versionchanged:: 1.6\n\n           The ``append_slash`` argument was modified to allow any object that\n           implements the ``IResponse`` interface to specify the response class\n           used when a redirect is performed.\n\n        .. versionchanged:: 1.8\n\n           The view is created using ``exception_only=True``.\n\n        .. versionchanged: 1.10\n\n           Default response was changed from\n           :class:`~pyramid.httpexceptions.HTTPFound`\n           to :class:`~pyramid.httpexceptions.HTTPTemporaryRedirect`.\n\n        \"\"\"\n        for arg in (\n            'name',\n            'permission',\n            'context',\n            'for_',\n            'require_csrf',\n            'exception_only',\n        ):\n            if arg in view_options:\n                raise ConfigurationError(\n                    '%s may not be used as an argument to add_notfound_view'\n                    % (arg,)\n                )\n\n        if view is None:\n            view = default_exceptionresponse_view\n\n        settings = dict(\n            view=view,\n            context=HTTPNotFound,\n            exception_only=True,\n            wrapper=wrapper,\n            request_type=request_type,\n            request_method=request_method,\n            request_param=request_param,\n            containment=containment,\n            xhr=xhr,\n            accept=accept,\n            header=header,\n            path_info=path_info,\n            custom_predicates=custom_predicates,\n            decorator=decorator,\n            mapper=mapper,\n            match_param=match_param,\n            route_name=route_name,\n            permission=NO_PERMISSION_REQUIRED,\n            require_csrf=False,\n        )\n        settings.update(view_options)\n        if append_slash:\n            view = self._derive_view(view, attr=attr, renderer=renderer)\n            if IResponse.implementedBy(append_slash):\n                view = AppendSlashNotFoundViewFactory(\n                    view, redirect_class=append_slash\n                )\n            else:\n                view = AppendSlashNotFoundViewFactory(view)\n            settings['view'] = view\n        else:\n            settings['attr'] = attr\n            settings['renderer'] = renderer\n        return self.add_view(**settings)\n\n    set_notfound_view = add_notfound_view  # deprecated sorta-bw-compat alias\n\n    @viewdefaults\n    @action_method\n    def add_exception_view(\n        self,\n        view=None,\n        context=None,\n        **view_options,\n    ):\n        \"\"\"Add an :term:`exception view` for the specified ``exception`` to\n        the current configuration state. The view will be called when Pyramid\n        or application code raises the given exception.\n\n        This method accepts almost all of the same arguments as\n        :meth:`pyramid.config.Configurator.add_view` except for ``name``,\n        ``permission``, ``for_``, ``require_csrf``, and ``exception_only``.\n\n        By default, this method will set ``context=Exception``, thus\n        registering for most default Python exceptions. Any subclass of\n        ``Exception`` may be specified.\n\n        .. versionadded:: 1.8\n        \"\"\"\n        for arg in (\n            'name',\n            'for_',\n            'exception_only',\n            'require_csrf',\n            'permission',\n        ):\n            if arg in view_options:\n                raise ConfigurationError(\n                    '%s may not be used as an argument to add_exception_view'\n                    % (arg,)\n                )\n        if context is None:\n            context = Exception\n        view_options.update(\n            dict(\n                view=view,\n                context=context,\n                exception_only=True,\n                permission=NO_PERMISSION_REQUIRED,\n                require_csrf=False,\n            )\n        )\n        return self.add_view(**view_options)\n\n    @action_method\n    def set_view_mapper(self, mapper):\n        \"\"\"\n        Setting a :term:`view mapper` makes it possible to make use of\n        :term:`view callable` objects which implement different call\n        signatures than the ones supported by :app:`Pyramid` as described in\n        its narrative documentation.\n\n        The ``mapper`` argument should be an object implementing\n        :class:`pyramid.interfaces.IViewMapperFactory` or a :term:`dotted\n        Python name` to such an object.  The provided ``mapper`` will become\n        the default view mapper to be used by all subsequent :term:`view\n        configuration` registrations.\n\n        .. seealso::\n\n            See also :ref:`using_a_view_mapper`.\n\n        .. note::\n\n           Using the ``default_view_mapper`` argument to the\n           :class:`pyramid.config.Configurator` constructor\n           can be used to achieve the same purpose.\n        \"\"\"\n        mapper = self.maybe_dotted(mapper)\n\n        def register():\n            self.registry.registerUtility(mapper, IViewMapperFactory)\n\n        intr = self.introspectable(\n            'view mappers',\n            IViewMapperFactory,\n            self.object_description(mapper),\n            'default view mapper',\n        )\n        intr['mapper'] = mapper\n        self.action(\n            IViewMapperFactory,\n            register,\n            order=PHASE1_CONFIG,\n            introspectables=(intr,),\n        )\n\n    @action_method\n    def add_static_view(self, name, path, **kw):\n        \"\"\"Add a view used to render static assets such as images\n        and CSS files.\n\n        The ``name`` argument is a string representing an\n        application-relative local URL prefix.  It may alternately be a full\n        URL.\n\n        The ``path`` argument is the path on disk where the static files\n        reside.  This can be an absolute path, a package-relative path, or a\n        :term:`asset specification`.\n\n        The ``cache_max_age`` keyword argument is input to set the\n        ``Expires`` and ``Cache-Control`` headers for static assets served.\n        Note that this argument has no effect when the ``name`` is a *url\n        prefix*.  By default, this argument is ``None``, meaning that no\n        particular Expires or Cache-Control headers are set in the response.\n\n        The ``content_encodings`` keyword argument is a list of alternative\n        file encodings supported in the ``Accept-Encoding`` HTTP Header.\n        Alternative files are found using file extensions defined in\n        :attr:`mimetypes.encodings_map`. An encoded asset will be returned\n        with the ``Content-Encoding`` header set to the selected encoding.\n        If the asset contains alternative encodings then the\n        ``Accept-Encoding`` value will be added to the response's ``Vary``\n        header. By default, the list is empty and no alternatives will be\n        supported.\n\n        The ``permission`` keyword argument is used to specify the\n        :term:`permission` required by a user to execute the static view.  By\n        default, it is the string\n        :data:`pyramid.security.NO_PERMISSION_REQUIRED`, a special sentinel\n        which indicates that, even if a :term:`default permission` exists for\n        the current application, the static view should be renderered to\n        completely anonymous users.  This default value is permissive\n        because, in most web apps, static assets seldom need protection from\n        viewing.  If ``permission`` is specified, the security checking will\n        be performed against the default root factory ACL.\n\n        Any other keyword arguments sent to ``add_static_view`` are passed on\n        to :meth:`pyramid.config.Configurator.add_route` (e.g. ``factory``,\n        perhaps to define a custom factory with a custom ACL for this static\n        view).\n\n        *Usage*\n\n        The ``add_static_view`` function is typically used in conjunction\n        with the :meth:`pyramid.request.Request.static_url` method.\n        ``add_static_view`` adds a view which renders a static asset when\n        some URL is visited; :meth:`pyramid.request.Request.static_url`\n        generates a URL to that asset.\n\n        The ``name`` argument to ``add_static_view`` is usually a simple URL\n        prefix (e.g. ``'images'``).  When this is the case, the\n        :meth:`pyramid.request.Request.static_url` API will generate a URL\n        which points to a Pyramid view, which will serve up a set of assets\n        that live in the package itself. For example:\n\n        .. code-block:: python\n\n           add_static_view('images', 'mypackage:images/')\n\n        Code that registers such a view can generate URLs to the view via\n        :meth:`pyramid.request.Request.static_url`:\n\n        .. code-block:: python\n\n           request.static_url('mypackage:images/logo.png')\n\n        When ``add_static_view`` is called with a ``name`` argument\n        that represents a URL prefix, as it is above, subsequent calls to\n        :meth:`pyramid.request.Request.static_url` with paths that start with\n        the ``path`` argument passed to ``add_static_view`` will generate a\n        URL something like ``http://<Pyramid app URL>/images/logo.png``,\n        which will cause the ``logo.png`` file in the ``images`` subdirectory\n        of the ``mypackage`` package to be served.\n\n        ``add_static_view`` can alternately be used with a ``name`` argument\n        which is a *URL*, causing static assets to be served from an external\n        webserver.  This happens when the ``name`` argument is a fully\n        qualified URL (e.g. starts with ``http://`` or similar).  In this\n        mode, the ``name`` is used as the prefix of the full URL when\n        generating a URL using :meth:`pyramid.request.Request.static_url`.\n        Furthermore, if a protocol-relative URL (e.g. ``//example.com/images``)\n        is used as the ``name`` argument, the generated URL will use the\n        protocol of the request (http or https, respectively).\n\n        For example, if ``add_static_view`` is called like so:\n\n        .. code-block:: python\n\n           add_static_view('http://example.com/images', 'mypackage:images/')\n\n        Subsequently, the URLs generated by\n        :meth:`pyramid.request.Request.static_url` for that static view will\n        be prefixed with ``http://example.com/images`` (the external webserver\n        listening on ``example.com`` must be itself configured to respond\n        properly to such a request.):\n\n        .. code-block:: python\n\n           static_url('mypackage:images/logo.png', request)\n\n        See :ref:`static_assets_section` for more information.\n\n        .. versionchanged:: 2.0\n\n           Added the ``content_encodings`` argument.\n\n        \"\"\"\n        spec = self._make_spec(path)\n        info = self._get_static_info()\n        info.add(self, name, spec, **kw)\n\n    def add_cache_buster(self, path, cachebust, explicit=False):\n        \"\"\"\n        Add a cache buster to a set of files on disk.\n\n        The ``path`` should be the path on disk where the static files\n        reside.  This can be an absolute path, a package-relative path, or a\n        :term:`asset specification`.\n\n        The ``cachebust`` argument may be set to cause\n        :meth:`~pyramid.request.Request.static_url` to use cache busting when\n        generating URLs. See :ref:`cache_busting` for general information\n        about cache busting. The value of the ``cachebust`` argument must\n        be an object which implements\n        :class:`~pyramid.interfaces.ICacheBuster`.\n\n        If ``explicit`` is set to ``True`` then the ``path`` for the cache\n        buster will be matched based on the ``rawspec`` instead of the\n        ``pathspec`` as defined in the\n        :class:`~pyramid.interfaces.ICacheBuster` interface.\n        Default: ``False``.\n\n        .. versionadded:: 1.6\n\n        \"\"\"\n        spec = self._make_spec(path)\n        info = self._get_static_info()\n        info.add_cache_buster(self, spec, cachebust, explicit=explicit)\n\n    def _get_static_info(self):\n        info = self.registry.queryUtility(IStaticURLInfo)\n        if info is None:\n            info = StaticURLInfo()\n            self.registry.registerUtility(info, IStaticURLInfo)\n        return info"
    },
    {
      "chunk_id": 663,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def isexception(o):\n    if IInterface.providedBy(o):\n        if IException.isEqualOrExtendedBy(o):\n            return True\n    return isinstance(o, Exception) or (\n        inspect.isclass(o) and (issubclass(o, Exception))\n    )"
    },
    {
      "chunk_id": 664,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/views.py",
      "content": "def runtime_exc_view(view, excview):\n    def wrapper_view(context, request):\n        if getattr(request, 'exception', None):\n            return excview(context, request)\n        return view(context, request)\n\n    wrapper_view.__wraps__ = wrapper_view\n    wrapper_view.__original_view__ = getattr(view, '__original_view__', view"
    },
    {
      "chunk_id": 665,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "from hashlib import sha256\nfrom webob.acceptparse import Accept\n\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import PHASE1_CONFIG, IPredicateList\nfrom pyramid.predicates import Notted\nfrom pyramid.registry import predvalseq\nfrom pyramid.util import TopologicalSorter, bytes_, is_nonstr_iter\n\nMAX_ORDER = 1 << 30\nDEFAULT_PHASH = sha256().hexdigest()"
    },
    {
      "chunk_id": 666,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "class PredicateConfiguratorMixin:\n    def get_predlist(self, name):\n        predlist = self.registry.queryUtility(IPredicateList, name=name)\n        if predlist is None:\n            predlist = PredicateList()\n            self.registry.registerUtility(predlist, IPredicateList, name=name)\n        return predlist\n\n    def _add_predicate(\n        self, type, name, factory, weighs_more_than=None, weighs_less_than=None\n    ):\n        factory = self.maybe_dotted(factory)\n        discriminator = ('%s option' % type, name)\n        intr = self.introspectable(\n            '%s predicates' % type,\n            discriminator,\n            f'{type} predicate named {name}',\n            '%s predicate' % type,\n        )\n        intr['name'] = name\n        intr['factory'] = factory\n        intr['weighs_more_than'] = weighs_more_than\n        intr['weighs_less_than'] = weighs_less_than\n\n        def register():\n            predlist = self.get_predlist(type)\n            predlist.add(\n                name,\n                factory,\n                weighs_more_than=weighs_more_than,\n                weighs_less_than=weighs_less_than,\n            )\n\n        self.action(\n            discriminator,\n            register,\n            introspectables=(intr,),\n            order=PHASE1_CONFIG,\n        )  # must be registered early"
    },
    {
      "chunk_id": 667,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "class not_:\n    \"\"\"\n\n    You can invert the meaning of any predicate value by wrapping it in a call\n    to :class:`pyramid.config.not_`.\n\n    .. code-block:: python\n       :linenos:\n\n       from pyramid.config import not_\n\n       config.add_view(\n           'mypackage.views.my_view',\n           route_name='ok',\n           request_method=not_('POST')\n           )\n\n    The above example will ensure that the view is called if the request method\n    is *not* ``POST``, at least if no other view is more specific.\n\n    This technique of wrapping a predicate value in ``not_`` can be used\n    anywhere predicate values are accepted:\n\n    - :meth:`pyramid.config.Configurator.add_view`\n\n    - :meth:`pyramid.config.Configurator.add_route`\n\n    - :meth:`pyramid.config.Configurator.add_subscriber`\n\n    - :meth:`pyramid.view.view_config`\n\n    - :meth:`pyramid.events.subscriber`\n\n    .. versionadded:: 1.5\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 668,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "class PredicateInfo:\n    def __init__(self, package, registry, settings, maybe_dotted):\n        self.package = package\n        self.registry = registry\n        self.settings = settings\n        self.maybe_dotted = maybe_dotted"
    },
    {
      "chunk_id": 669,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "class PredicateList:\n    def __init__(self):\n        self.sorter = TopologicalSorter()\n        self.last_added = None\n\n    def add(self, name, factory, weighs_more_than=None, weighs_less_than=None):\n        self.last_added = name\n        self.sorter.add(\n            name, factory, after=weighs_more_than, before=weighs_less_than\n        )\n\n    def names(self):\n        return self.sorter.names\n\n    def make(self, config, **kw):\n        ordered = self.sorter.sorted()\n        phash = sha256()\n        weights = []\n        preds = []\n        info = PredicateInfo(\n            package=config.package,\n            registry=config.registry,\n            settings=config.get_settings(),\n            maybe_dotted=config.maybe_dotted,\n        )\n        for n, (name, predicate_factory) in enumerate(ordered):\n            vals = kw.pop(name, None)\n            if vals is None:\n                continue\n            if not isinstance(vals, predvalseq):\n                vals = (vals,)\n            for val in vals:\n                realval = val\n                notted = False\n                if isinstance(val, not_):\n                    realval = val.value\n                    notted = True\n                pred = predicate_factory(realval, info)\n                if notted:\n                    pred = Notted(pred)\n                hashes = pred.phash()\n                if not is_nonstr_iter(hashes):\n                    hashes = [hashes]\n                for h in hashes:\n                    phash.update(bytes_(h))\n                weights.append(1 << n + 1)\n                preds.append(pred)\n        if kw:\n            from difflib import get_close_matches\n\n            closest = []\n            names = [name for name, _ in ordered]\n            for name in kw:\n                closest.extend(get_close_matches(name, names, 3))\n\n            raise ConfigurationError(\n                'Unknown predicate values: %r (did you mean %s)'\n                % (kw, ','.join(closest))\n            )\n        score = 0\n        for bit in weights:\n            score = score | bit\n        order = (MAX_ORDER - score) // (len(preds) + 1)\n\n        return order, preds, phash.hexdigest()"
    },
    {
      "chunk_id": 670,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "def normalize_accept_offer(offer):\n    return str(Accept.parse_offer(offer))"
    },
    {
      "chunk_id": 671,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/predicates.py",
      "content": "def sort_accept_offers(offers, order=None):\n    \"\"\"\n    Sort a list of offers by preference.\n\n    For a given ``type/subtype`` category of offers, this algorithm will\n    always sort offers with params higher than the bare offer.\n\n    :param offers: A list of offers to be sorted.\n    :param order: A weighted list of offers where items closer to the start of\n                  the list will be a preferred over items closer to the end.\n    :return: A list of offers sorted first by specificity (higher to lower)\n             then by ``order``.\n\n    \"\"\"\n    if order is None:\n        order = []\n\n    max_weight = len(offers)\n\n    def find_order_index(value, default=None):\n        return next((i for i, x in enumerate(order) if x == value), default)\n\n    def offer_sort_key(value):\n        parsed = Accept.parse_offer(value)\n\n        type_w = find_order_index(\n            parsed.type + '/' + parsed.subtype, max_weight\n        )\n\n        if parsed.params:\n            param_w = find_order_index(value, max_weight)\n\n        else:\n            param_w = max_weight + 1\n\n        return (type_w, param_w)\n\n    return sorted(offers, key=offer_sort_key)"
    },
    {
      "chunk_id": 672,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "import contextlib\nfrom urllib.parse import urlparse\nimport warnings\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.config.predicates import normalize_accept_offer, predvalseq\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import (\n    PHASE2_CONFIG,\n    IRequest,\n    IRouteRequest,\n    IRoutesMapper,\n)\nimport pyramid.predicates\nfrom pyramid.request import route_request_iface\nfrom pyramid.urldispatch import RoutesMapper\nfrom pyramid.util import as_sorted_tuple, is_nonstr_iter"
    },
    {
      "chunk_id": 673,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "class RoutesConfiguratorMixin:\n    \"\"\"Mixin class for configuring routes in Pyramid.\"\"\"\n\n    def __init__(self):\n        self.route_prefix = None\n\n    @action_method\n    def add_route(\n        self,\n        name,\n        pattern=None,\n        factory=None,\n        for_=None,\n        header=None,\n        xhr=None,\n        accept=None,\n        path_info=None,\n        request_method=None,\n        request_param=None,\n        traverse=None,\n        custom_predicates=(),\n        use_global_views=False,\n        path=None,\n        pregenerator=None,\n        static=False,\n        inherit_slash=None,\n        **predicates,\n    ):\n        \"\"\"Add a :term:`route configuration` to the current configuration\n        state.  Arguments to ``add_route`` are divided into *predicate*\n        and *non-predicate* types.  :term:`Route predicate` arguments\n        narrow the circumstances in which a route will match a\n        request; non-predicate arguments are informational.\n        ...\n        \"\"\"\n        # Function implementation..."
    },
    {
      "chunk_id": 674,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "@action_method\n    def add_route_predicate(\n        self, name, factory, weighs_more_than=None, weighs_less_than=None\n    ):\n        \"\"\"Adds a route predicate factory.  The view predicate can later be\n        named as a keyword argument to\n        :meth:`pyramid.config.Configurator.add_route`.\n        ...\n        \"\"\"\n        # Function implementation..."
    },
    {
      "chunk_id": 675,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "def add_default_route_predicates(self):\n        p = pyramid.predicates\n        for name, factory in (\n            ('xhr', p.XHRPredicate),\n            ('request_method', p.RequestMethodPredicate),\n            ('path_info', p.PathInfoPredicate),\n            ('request_param', p.RequestParamPredicate),\n            ('header', p.HeaderPredicate),\n            ('accept', p.AcceptPredicate),\n            ('is_authenticated', p.IsAuthenticatedPredicate),\n            ('effective_principals', p.EffectivePrincipalsPredicate),\n            ('custom', p.CustomPredicate),\n            ('traverse', p.TraversePredicate),\n        ):\n            self.add_route_predicate(name, factory)"
    },
    {
      "chunk_id": 676,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "def get_routes_mapper(self):\n        \"\"\"Return the :term:`routes mapper` object associated with\n        this configurator's :term:`registry`.\"\"\"\n        # Function implementation..."
    },
    {
      "chunk_id": 677,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/routes.py",
      "content": "@contextlib.contextmanager\n    def route_prefix_context(self, route_prefix):\n        \"\"\"\n        Return this configurator with a :term:`route prefix` temporarily set.\n        ...\n        \"\"\"\n        # Function implementation..."
    },
    {
      "chunk_id": 678,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "from functools import update_wrapper\nfrom webob import Response as WebobResponse\nfrom zope.interface import Interface\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.interfaces import IResourceURL, IResponse, ITraverser\nfrom pyramid.util import takes_one_arg"
    },
    {
      "chunk_id": 679,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "class AdaptersConfiguratorMixin:\n    \"\"\"AdaptersConfiguratorMixin class for managing adapters and subscribers.\"\"\"\n\n    def __init__(self):\n        # Initialization code here\n        pass"
    },
    {
      "chunk_id": 680,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "@action_method\n    def add_subscriber(self, subscriber, iface=None, **predicates):\n        \"\"\"Add an event :term:`subscriber` for the event stream\n        implied by the supplied ``iface`` interface.\n        ...\n        \"\"\"\n        # Method implementation here"
    },
    {
      "chunk_id": 681,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "def _derive_predicate(self, predicate):\n        # Method implementation here"
    },
    {
      "chunk_id": 682,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "def _derive_subscriber(self, subscriber, predicates):\n        # Method implementation here"
    },
    {
      "chunk_id": 683,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "@action_method\n    def add_subscriber_predicate(\n        self, name, factory, weighs_more_than=None, weighs_less_than=None\n    ):\n        \"\"\"Adds a subscriber predicate factory.\"\"\"\n        # Method implementation here"
    },
    {
      "chunk_id": 684,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "@action_method\n    def add_response_adapter(self, adapter, type_or_iface):\n        \"\"\"When an object of type (or interface) ``type_or_iface`` is\n        returned from a view callable, Pyramid will use the adapter\n        ...\n        \"\"\"\n        # Method implementation here"
    },
    {
      "chunk_id": 685,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "def add_default_response_adapters(self):\n        # cope with WebOb response objects that aren't decorated with IResponse\n        self.add_response_adapter(None, WebobResponse)"
    },
    {
      "chunk_id": 686,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "@action_method\n    def add_traverser(self, adapter, iface=None):\n        \"\"\"The superdefault :term:`traversal` algorithm that :app:`Pyramid` uses\n        ...\n        \"\"\"\n        # Method implementation here"
    },
    {
      "chunk_id": 687,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "@action_method\n    def add_resource_url_adapter(self, adapter, resource_iface=None):\n        \"\"\"When you add a traverser as described in\n        ...\n        \"\"\"\n        # Method implementation here"
    },
    {
      "chunk_id": 688,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/adapters.py",
      "content": "def eventonly(callee):\n    # we do not count a function as eventonly if it accepts *args\n    return takes_one_arg(callee, argname='event', allow_varargs=False)"
    },
    {
      "chunk_id": 689,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/settings.py",
      "content": "import os"
    },
    {
      "chunk_id": 690,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/settings.py",
      "content": "from pyramid.settings import asbool, aslist"
    },
    {
      "chunk_id": 691,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/settings.py",
      "content": "class SettingsConfiguratorMixin:\n    def _set_settings(self, mapping):\n        if mapping is None:\n            mapping = {}\n        settings = Settings(mapping)\n        self.registry.settings = settings\n        return settings\n\n    def add_settings(self, settings=None, **kw):\n        \"\"\"Augment the :term:`deployment settings` with one or more\n        key/value pairs.\n\n        You may pass a dictionary::\n\n           config.add_settings({'external_uri':'http://example.com'})\n\n        Or a set of key/value pairs::\n\n           config.add_settings(external_uri='http://example.com')\n\n        This function is useful when you need to test code that accesses the\n        :attr:`pyramid.registry.Registry.settings` API (or the\n        :meth:`pyramid.config.Configurator.get_settings` API) and\n        which uses values from that API.\n        \"\"\"\n        if settings is None:\n            settings = {}\n        utility = self.registry.settings\n        if utility is None:\n            utility = self._set_settings(settings)\n        utility.update(settings)\n        utility.update(kw)\n\n    def get_settings(self):\n        \"\"\"\n        Return a :term:`deployment settings` object for the current\n        application.  A deployment settings object is a dictionary-like\n        object that contains key/value pairs based on the dictionary passed\n        as the ``settings`` argument to the\n        :class:`pyramid.config.Configurator` constructor.\n\n        .. note:: the :attr:`pyramid.registry.Registry.settings` API\n           performs the same duty.\n        \"\"\"\n        return self.registry.settings"
    },
    {
      "chunk_id": 692,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/settings.py",
      "content": "def Settings(d=None, _environ_=os.environ, **kw):\n    \"\"\"Deployment settings.  Update application settings (usually\n    from PasteDeploy keywords) with framework-specific key/value pairs\n    (e.g. find ``PYRAMID_DEBUG_AUTHORIZATION`` in os.environ and jam into\n    keyword args).\"\"\"\n    if d is None:\n        d = {}\n    d = dict(d)\n    d.update(**kw)\n\n    eget = _environ_.get\n\n    def expand_key(key):\n        keys = [key]\n        if not key.startswith('pyramid.'):\n            keys.append('pyramid.' + key)\n        return keys\n\n    def S(settings_key, env_key=None, type_=str, default=False):\n        value = default\n        keys = expand_key(settings_key)\n        for key in keys:\n            value = d.get(key, value)\n        if env_key:\n            value = eget(env_key, value)\n        value = type_(value)\n        d.update({k: value for k in keys})\n\n    def O(settings_key, override_key):  # noqa: E743, E741\n        for key in expand_key(settings_key):\n            d[key] = d[key] or d[override_key]\n\n    S('debug_all', 'PYRAMID_DEBUG_ALL', asbool)\n    S('debug_authorization', 'PYRAMID_DEBUG_AUTHORIZATION', asbool)\n    O('debug_authorization', 'debug_all')\n    S('debug_notfound', 'PYRAMID_DEBUG_NOTFOUND', asbool)\n    O('debug_notfound', 'debug_all')\n    S('debug_routematch', 'PYRAMID_DEBUG_ROUTEMATCH', asbool)\n    O('debug_routematch', 'debug_all')\n    S('debug_templates', 'PYRAMID_DEBUG_TEMPLATES', asbool)\n    O('debug_templates', 'debug_all')\n\n    S('reload_all', 'PYRAMID_RELOAD_ALL', asbool)\n    S('reload_templates', 'PYRAMID_RELOAD_TEMPLATES', asbool)\n    O('reload_templates', 'reload_all')\n    S('reload_assets', 'PYRAMID_RELOAD_ASSETS', asbool)\n    O('reload_assets', 'reload_all')\n    S('reload_resources', 'PYRAMID_RELOAD_RESOURCES', asbool)\n    O('reload_resources', 'reload_all')\n    # reload_resources is an older alias for reload_assets\n    for k in expand_key('reload_assets') + expand_key('reload_resources'):\n        d[k] = d['reload_assets'] or d['reload_resources']\n\n    S('default_locale_name', 'PYRAMID_DEFAULT_LOCALE_NAME', str, 'en')\n    S('prevent_http_cache', 'PYRAMID_PREVENT_HTTP_CACHE', asbool)\n    S('prevent_cachebust', 'PYRAMID_PREVENT_CACHEBUST', asbool)\n    S('csrf_trusted_origins', 'PYRAMID_CSRF_TRUSTED_ORIGINS', aslist, [])\n\n    return d"
    },
    {
      "chunk_id": 693,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "import os\nimport pkg_resources\nimport sys\nfrom zope.interface import implementer\n\nfrom pyramid.config.actions import action_method\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import PHASE1_CONFIG, IPackageOverrides\nfrom pyramid.threadlocal import get_current_registry"
    },
    {
      "chunk_id": 694,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class OverrideProvider(pkg_resources.DefaultProvider):\n    def __init__(self, module):\n        pkg_resources.DefaultProvider.__init__(self, module)\n        self.module_name = module.__name__"
    },
    {
      "chunk_id": 695,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def _get_overrides(self):\n        reg = get_current_registry()\n        overrides = reg.queryUtility(IPackageOverrides, self.module_name)\n        return overrides"
    },
    {
      "chunk_id": 696,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_resource_filename(self, manager, resource_name):\n        \"\"\"Return a true filesystem path for resource_name,\n        co-ordinating the extraction with manager, if the resource\n        must be unpacked to the filesystem.\n        \"\"\"\n        overrides = self._get_overrides()\n        if overrides is not None:\n            filename = overrides.get_filename(resource_name)\n            if filename is not None:\n                return filename\n        return pkg_resources.DefaultProvider.get_resource_filename(\n            self, manager, resource_name\n        )"
    },
    {
      "chunk_id": 697,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_resource_stream(self, manager, resource_name):\n        \"\"\"Return a readable file-like object for resource_name.\"\"\"\n        overrides = self._get_overrides()\n        if overrides is not None:\n            stream = overrides.get_stream(resource_name)\n            if stream is not None:\n                return stream\n        return pkg_resources.DefaultProvider.get_resource_stream(\n            self, manager, resource_name\n        )"
    },
    {
      "chunk_id": 698,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_resource_string(self, manager, resource_name):\n        \"\"\"Return a string containing the contents of resource_name.\"\"\"\n        overrides = self._get_overrides()\n        if overrides is not None:\n            string = overrides.get_string(resource_name)\n            if string is not None:\n                return string\n        return pkg_resources.DefaultProvider.get_resource_string(\n            self, manager, resource_name\n        )"
    },
    {
      "chunk_id": 699,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def has_resource(self, resource_name):\n        overrides = self._get_overrides()\n        if overrides is not None:\n            result = overrides.has_resource(resource_name)\n            if result is not None:\n                return result\n        return pkg_resources.DefaultProvider.has_resource(self, resource_name)"
    },
    {
      "chunk_id": 700,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def resource_isdir(self, resource_name):\n        overrides = self._get_overrides()\n        if overrides is not None:\n            result = overrides.isdir(resource_name)\n            if result is not None:\n                return result\n        return pkg_resources.DefaultProvider.resource_isdir(\n            self, resource_name\n        )"
    },
    {
      "chunk_id": 701,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def resource_listdir(self, resource_name):\n        overrides = self._get_overrides()\n        if overrides is not None:\n            result = overrides.listdir(resource_name)\n            if result is not None:\n                return result\n        return pkg_resources.DefaultProvider.resource_listdir(\n            self, resource_name\n        )"
    },
    {
      "chunk_id": 702,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "@implementer(IPackageOverrides)\nclass PackageOverrides:\n    # pkg_resources arg in kw args below for testing\n    def __init__(self, package, pkg_resources=pkg_resources):\n        loader = self._real_loader = getattr(package, '__loader__', None)\n        if isinstance(loader, self.__class__):\n            self._real_loader = None\n        package.__loader__ = self\n        pkg_resources.register_loader_type(self.__class__, OverrideProvider)\n        self.overrides = []\n        self.overridden_package_name = package.__name__"
    },
    {
      "chunk_id": 703,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def insert(self, path, source):\n        if not path or path.endswith('/'):\n            override = DirectoryOverride(path, source)\n        else:\n            override = FileOverride(path, source)\n        self.overrides.insert(0, override)\n        return override"
    },
    {
      "chunk_id": 704,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def filtered_sources(self, resource_name):\n        for override in self.overrides:\n            o = override(resource_name)\n            if o is not None:\n                yield o"
    },
    {
      "chunk_id": 705,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_filename(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            result = source.get_filename(path)\n            if result is not None:\n                return result"
    },
    {
      "chunk_id": 706,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_stream(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            result = source.get_stream(path)\n            if result is not None:\n                return result"
    },
    {
      "chunk_id": 707,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_string(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            result = source.get_string(path)\n            if result is not None:\n                return result"
    },
    {
      "chunk_id": 708,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def has_resource(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            if source.exists(path):\n                return True"
    },
    {
      "chunk_id": 709,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def isdir(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            result = source.isdir(path)\n            if result is not None:\n                return result"
    },
    {
      "chunk_id": 710,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def listdir(self, resource_name):\n        for source, path in self.filtered_sources(resource_name):\n            result = source.listdir(path)\n            if result is not None:\n                return result"
    },
    {
      "chunk_id": 711,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "@property\n    def real_loader(self):\n        if self._real_loader is None:\n            raise NotImplementedError()\n        return self._real_loader"
    },
    {
      "chunk_id": 712,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_data(self, path):\n        \"\"\"See IPEP302Loader.\"\"\"\n        return self.real_loader.get_data(path)"
    },
    {
      "chunk_id": 713,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def is_package(self, fullname):\n        \"\"\"See IPEP302Loader.\"\"\"\n        return self.real_loader.is_package(fullname)"
    },
    {
      "chunk_id": 714,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_code(self, fullname):\n        \"\"\"See IPEP302Loader.\"\"\"\n        return self.real_loader.get_code(fullname)"
    },
    {
      "chunk_id": 715,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_source(self, fullname):\n        \"\"\"See IPEP302Loader.\"\"\"\n        return self.real_loader.get_source(fullname)"
    },
    {
      "chunk_id": 716,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class DirectoryOverride:\n    def __init__(self, path, source):\n        self.path = path\n        self.pathlen = len(self.path)\n        self.source = source"
    },
    {
      "chunk_id": 717,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def __call__(self, resource_name):\n        if resource_name.startswith(self.path):\n            new_path = resource_name[self.pathlen :]\n            return self.source, new_path"
    },
    {
      "chunk_id": 718,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class FileOverride:\n    def __init__(self, path, source):\n        self.path = path\n        self.source = source"
    },
    {
      "chunk_id": 719,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def __call__(self, resource_name):\n        if resource_name == self.path:\n            return self.source, ''"
    },
    {
      "chunk_id": 720,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class PackageAssetSource:\n    \"\"\"\n    An asset source relative to a package.\n\n    If this asset source is a file, then we expect the ``prefix`` to point\n    to the new name of the file, and the incoming ``resource_name`` will be\n    the empty string, as returned by the ``FileOverride``.\n\n    \"\"\"\n\n    def __init__(self, package, prefix):\n        self.package = package\n        if hasattr(package, '__name__'):\n            self.pkg_name = package.__name__\n        else:\n            self.pkg_name = package\n        self.prefix = prefix"
    },
    {
      "chunk_id": 721,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_path(self, resource_name):\n        return f'{self.prefix}{resource_name}'"
    },
    {
      "chunk_id": 722,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_filename(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return pkg_resources.resource_filename(self.pkg_name, path)"
    },
    {
      "chunk_id": 723,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_stream(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return pkg_resources.resource_stream(self.pkg_name, path)"
    },
    {
      "chunk_id": 724,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_string(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return pkg_resources.resource_string(self.pkg_name, path)"
    },
    {
      "chunk_id": 725,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def exists(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return True"
    },
    {
      "chunk_id": 726,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def isdir(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return pkg_resources.resource_isdir(self.pkg_name, path)"
    },
    {
      "chunk_id": 727,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def listdir(self, resource_name):\n        path = self.get_path(resource_name)\n        if pkg_resources.resource_exists(self.pkg_name, path):\n            return pkg_resources.resource_listdir(self.pkg_name, path)"
    },
    {
      "chunk_id": 728,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class FSAssetSource:\n    \"\"\"\n    An asset source relative to a path in the filesystem.\n\n    \"\"\"\n\n    def __init__(self, prefix):\n        self.prefix = prefix"
    },
    {
      "chunk_id": 729,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_path(self, resource_name):\n        if resource_name:\n            path = os.path.join(self.prefix, resource_name)\n        else:\n            path = self.prefix\n        return path"
    },
    {
      "chunk_id": 730,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_filename(self, resource_name):\n        path = self.get_path(resource_name)\n        if os.path.exists(path):\n            return path"
    },
    {
      "chunk_id": 731,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_stream(self, resource_name):\n        path = self.get_filename(resource_name)\n        if path is not None:\n            return open(path, 'rb')"
    },
    {
      "chunk_id": 732,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def get_string(self, resource_name):\n        stream = self.get_stream(resource_name)\n        if stream is not None:\n            with stream:\n                return stream.read()"
    },
    {
      "chunk_id": 733,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def exists(self, resource_name):\n        path = self.get_filename(resource_name)\n        if path is not None:\n            return True"
    },
    {
      "chunk_id": 734,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def isdir(self, resource_name):\n        path = self.get_filename(resource_name)\n        if path is not None:\n            return os.path.isdir(path)"
    },
    {
      "chunk_id": 735,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "def listdir(self, resource_name):\n        path = self.get_filename(resource_name)\n        if path is not None:\n            return os.listdir(path)"
    },
    {
      "chunk_id": 736,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "class AssetsConfiguratorMixin:\n    def _override(\n        self, package, path, override_source, PackageOverrides=PackageOverrides\n    ):\n        pkg_name = package.__name__\n        override = self.registry.queryUtility(IPackageOverrides, name=pkg_name)\n        if override is None:\n            override = PackageOverrides(package)\n            self.registry.registerUtility(\n                override, IPackageOverrides, name=pkg_name\n            )\n        override.insert(path, override_source)"
    },
    {
      "chunk_id": 737,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/assets.py",
      "content": "@action_method\n    def override_asset(self, to_override, override_with, _override=None):\n        \"\"\"Add a :app:`Pyramid` asset override to the current\n        configuration state.\n\n        ``to_override`` is an :term:`asset specification` to the\n        asset being overridden.\n\n        ``override_with`` is an :term:`asset specification` to the\n        asset that is performing the override. This may also be an absolute\n        path.\n\n        See :ref:`assets_chapter` for more\n        information about asset overrides.\"\"\"\n        if to_override == override_with:\n            raise ConfigurationError(\n                'You cannot override an asset with itself'\n            )\n\n        package = to_override\n        path = ''\n        if ':' in to_override:\n            package, path = to_override.split(':', 1)\n\n        overridden_isdir = path == '' or path.endswith('/')\n\n        if os.path.isabs(override_with):\n            override_source = FSAssetSource(override_with)\n            if not os.path.exists(override_with):\n                raise ConfigurationError(\n                    'Cannot override asset with an absolute path that does '\n                    'not exist'\n                )\n            override_isdir = os.path.isdir(override_with)\n            override_package = None\n            override_prefix = override_with\n        else:\n            override_package = override_with\n            override_prefix = ''\n            if ':' in override_with:\n                override_package, override_prefix = override_with.split(':', 1)\n\n            __import__(override_package)\n            to_package = sys.modules[override_package]\n            override_source = PackageAssetSource(to_package, override_prefix)\n\n            override_isdir = override_prefix == '' or override_with.endswith(\n                '/'\n            )\n\n        if overridden_isdir and (not override_isdir):\n            raise ConfigurationError(\n                'A directory cannot be overridden with a file (put a '\n                'slash at the end of override_with if necessary)'\n            )\n\n        if (not overridden_isdir) and override_isdir:\n            raise ConfigurationError(\n                'A file cannot be overridden with a directory (put a '\n                'slash at the end of to_override if necessary)'\n            )\n\n        override = _override or self._override  # test jig\n\n        def register():\n            __import__(package)\n            from_package = sys.modules[package]\n            override(from_package, path, override_source)\n\n        intr = self.introspectable(\n            'asset overrides',\n            (package, override_package, path, override_prefix),\n            f'{to_override} -> {override_with}',\n            'asset override',\n        )\n        intr['to_override'] = to_override\n        intr['override_with'] = override_with\n        self.action(\n            None, register, introspectables=(intr,), order=PHASE1_CONFIG\n        )\n\n    override_resource = override_asset  # bw compat"
    },
    {
      "chunk_id": 738,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "import functools\nimport itertools\nimport operator\nimport sys\nimport traceback\nfrom zope.interface import implementer\n\nfrom pyramid.exceptions import (\n    ConfigurationConflictError,\n    ConfigurationError,\n    ConfigurationExecutionError,\n)\nfrom pyramid.interfaces import IActionInfo\nfrom pyramid.registry import undefer\nfrom pyramid.util import is_nonstr_iter, reraise"
    },
    {
      "chunk_id": 739,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "class ActionConfiguratorMixin:\n    @property\n    def action_info(self):\n        info = self.info  # usually a ZCML action (ParserInfo) if self.info\n        if not info:\n            # Try to provide more accurate info for conflict reports\n            if self._ainfo:\n                info = self._ainfo[0]\n            else:\n                info = ActionInfo(None, 0, '', '')\n        return info\n\n    def action(\n        self,\n        discriminator,\n        callable=None,\n        args=(),\n        kw=None,\n        order=0,\n        introspectables=(),\n        **extra,\n    ):\n        \"\"\"Register an action which will be executed when\n        :meth:`pyramid.config.Configurator.commit` is called (or executed\n        immediately if ``autocommit`` is ``True``).\n\n        .. warning:: This method is typically only used by :app:`Pyramid`\n           framework extension authors, not by :app:`Pyramid` application\n           developers.\n\n        The ``discriminator`` uniquely identifies the action.  It must be\n        given, but it can be ``None``, to indicate that the action never\n        conflicts.  It must be a hashable value.\n\n        The ``callable`` is a callable object which performs the task\n        associated with the action when the action is executed.  It is\n        optional.\n\n        ``args`` and ``kw`` are tuple and dict objects respectively, which\n        are passed to ``callable`` when this action is executed.  Both are\n        optional.\n\n        ``order`` is a grouping mechanism; an action with a lower order will\n        be executed before an action with a higher order (has no effect when\n        autocommit is ``True``).\n\n        ``introspectables`` is a sequence of :term:`introspectable` objects\n        (or the empty sequence if no introspectable objects are associated\n        with this action).  If this configurator's ``introspection``\n        attribute is ``False``, these introspectables will be ignored.\n\n        ``extra`` provides a facility for inserting extra keys and values\n        into an action dictionary.\n        \"\"\"\n        # catch nonhashable discriminators here; most unit tests use\n        # autocommit=False, which won't catch unhashable discriminators\n        assert hash(discriminator)\n\n        if kw is None:\n            kw = {}\n\n        autocommit = self.autocommit\n        action_info = self.action_info\n\n        if not self.introspection:\n            # if we're not introspecting, ignore any introspectables passed\n            # to us\n            introspectables = ()\n\n        if autocommit:\n            # callables can depend on the side effects of resolving a\n            # deferred discriminator\n            self.begin()\n            try:\n                undefer(discriminator)\n                if callable is not None:\n                    callable(*args, **kw)\n                for introspectable in introspectables:\n                    introspectable.register(self.introspector, action_info)\n            finally:\n                self.end()\n\n        else:\n            action = extra\n            action.update(\n                dict(\n                    discriminator=discriminator,\n                    callable=callable,\n                    args=args,\n                    kw=kw,\n                    order=order,\n                    info=action_info,\n                    includepath=self.includepath,\n                    introspectables=introspectables,\n                )\n            )\n            self.action_state.action(**action)\n\n    def _get_action_state(self):\n        registry = self.registry\n        try:\n            state = registry.action_state\n        except AttributeError:\n            state = ActionState()\n            registry.action_state = state\n        return state\n\n    def _set_action_state(self, state):\n        self.registry.action_state = state\n\n    action_state = property(_get_action_state, _set_action_state)\n\n    _ctx = action_state  # bw compat\n\n    def commit(self):\n        \"\"\"\n        Commit any pending configuration actions. If a configuration\n        conflict is detected in the pending configuration actions, this method\n        will raise a :exc:`ConfigurationConflictError`; within the traceback\n        of this error will be information about the source of the conflict,\n        usually including file names and line numbers of the cause of the\n        configuration conflicts.\n\n        .. warning::\n           You should think very carefully before manually invoking\n           ``commit()``. Especially not as part of any reusable configuration\n           methods. Normally it should only be done by an application author at\n           the end of configuration in order to override certain aspects of an\n           addon.\n\n        \"\"\"\n        self.begin()\n        try:\n            self.action_state.execute_actions(introspector=self.introspector)\n        finally:\n            self.end()\n        self.action_state = ActionState()  # old actions have been processed"
    },
    {
      "chunk_id": 740,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "class ActionState:\n    def __init__(self):\n        # NB \"actions\" is an API, dep'd upon by pyramid_zcml's load_zcml func\n        self.actions = []\n        self._seen_files = set()\n\n    def processSpec(self, spec):\n        \"\"\"Check whether a callable needs to be processed.  The ``spec``\n        refers to a unique identifier for the callable.\n\n        Return True if processing is needed and False otherwise. If\n        the callable needs to be processed, it will be marked as\n        processed, assuming that the caller will process the callable if\n        it needs to be processed.\n        \"\"\"\n        if spec in self._seen_files:\n            return False\n        self._seen_files.add(spec)\n        return True\n\n    def action(\n        self,\n        discriminator,\n        callable=None,\n        args=(),\n        kw=None,\n        order=0,\n        includepath=(),\n        info=None,\n        introspectables=(),\n        **extra,\n    ):\n        \"\"\"Add an action with the given discriminator, callable, and\n        arguments\"\"\"\n        if kw is None:\n            kw = {}\n        action = extra\n        action.update(\n            dict(\n                discriminator=discriminator,\n                callable=callable,\n                args=args,\n                kw=kw,\n                includepath=includepath,\n                info=info,\n                order=order,\n                introspectables=introspectables,\n            )\n        )\n        self.actions.append(action)\n\n    def execute_actions(self, clear=True, introspector=None):\n        \"\"\"Execute the configuration actions\n\n        This calls the action callables after resolving conflicts\n\n        For example:\n\n        >>> output = []\n        >>> def f(*a, **k):\n        ...    output.append(('f', a, k))\n        >>> context = ActionState()\n        >>> context.actions = [\n        ...   (1, f, (1,)),\n        ...   (1, f, (11,), {}, ('x', )),\n        ...   (2, f, (2,)),\n        ...   ]\n        >>> context.execute_actions()\n        >>> output\n        [('f', (1,), {}), ('f', (2,), {})]\n\n        If the action raises an error, we convert it to a\n        ConfigurationExecutionError.\n\n        >>> output = []\n        >>> def bad():\n        ...    bad.xxx\n        >>> context.actions = [\n        ...   (1, f, (1,)),\n        ...   (1, f, (11,), {}, ('x', )),\n        ...   (2, f, (2,)),\n        ...   (3, bad, (), {}, (), 'oops')\n        ...   ]\n        >>> try:\n        ...    v = context.execute_actions()\n        ... except ConfigurationExecutionError, v:\n        ...    pass\n        >>> print(v)\n        exceptions.AttributeError: 'function' object has no attribute 'xxx'\n          in:\n          oops\n\n        Note that actions executed before the error still have an effect:\n\n        >>> output\n        [('f', (1,), {}), ('f', (2,), {})]\n\n        The execution is re-entrant such that actions may be added by other\n        actions with the one caveat that the order of any added actions must\n        be equal to or larger than the current action.\n\n        >>> output = []\n        >>> def f(*a, **k):\n        ...   output.append(('f', a, k))\n        ...   context.actions.append((3, g, (8,), {}))\n        >>> def g(*a, **k):\n        ...    output.append(('g', a, k))\n        >>> context.actions = [\n        ...   (1, f, (1,)),\n        ...   ]\n        >>> context.execute_actions()\n        >>> output\n        [('f', (1,), {}), ('g', (8,), {})]\n\n        \"\"\"\n        try:\n            all_actions = []\n            executed_actions = []\n            action_iter = iter([])\n            conflict_state = ConflictResolverState()\n\n            while True:\n                # We clear the actions list prior to execution so if there\n                # are some new actions then we add them to the mix and resolve\n                # conflicts again. This orders the new actions as well as\n                # ensures that the previously executed actions have no new\n                # conflicts.\n                if self.actions:\n                    all_actions.extend(self.actions)\n                    action_iter = resolveConflicts(\n                        self.actions, state=conflict_state\n                    )\n                    self.actions = []\n\n                action = next(action_iter, None)\n                if action is None:\n                    # we are done!\n                    break\n\n                callable = action['callable']\n                args = action['args']\n                kw = action['kw']\n                info = action['info']\n                # we use \"get\" below in case an action was added via a ZCML\n                # directive that did not know about introspectables\n                introspectables = action.get('introspectables', ())\n\n                try:\n                    if callable is not None:\n                        callable(*args, **kw)\n                except Exception:\n                    t, v, tb = sys.exc_info()\n                    try:\n                        reraise(\n                            ConfigurationExecutionError,\n                            ConfigurationExecutionError(t, v, info),\n                            tb,\n                        )\n                    finally:\n                        del t, v, tb\n\n                if introspector is not None:\n                    for introspectable in introspectables:\n                        introspectable.register(introspector, info)\n\n                executed_actions.append(action)\n\n            self.actions = all_actions\n            return executed_actions\n\n        finally:\n            if clear:\n                self.actions = []"
    },
    {
      "chunk_id": 741,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "class ConflictResolverState:\n    def __init__(self):\n        # keep a set of resolved discriminators to test against to ensure\n        # that a new action does not conflict with something already executed\n        self.resolved_ainfos = {}\n\n        # actions left over from a previous iteration\n        self.remaining_actions = []\n\n        # after executing an action we memoize its order to avoid any new\n        # actions sending us backward\n        self.min_order = None\n\n        # unique tracks the index of the action so we need it to increase\n        # monotonically across invocations to resolveConflicts\n        self.start = 0"
    },
    {
      "chunk_id": 742,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "def resolveConflicts(actions, state=None):\n    \"\"\"Resolve conflicting actions\n\n    Given an actions list, identify and try to resolve conflicting actions.\n    Actions conflict if they have the same non-None discriminator.\n\n    Conflicting actions can be resolved if the include path of one of\n    the actions is a prefix of the includepaths of the other\n    conflicting actions and is unequal to the include paths in the\n    other conflicting actions.\n\n    Actions are resolved on a per-order basis because some discriminators\n    cannot be computed until earlier actions have executed. An action in an\n    earlier order may execute successfully only to find out later that it was\n    overridden by another action with a smaller include path. This will result\n    in a conflict as there is no way to revert the original action.\n\n    ``state`` may be an instance of ``ConflictResolverState`` that\n    can be used to resume execution and resolve the new actions against the\n    list of executed actions from a previous call.\n\n    \"\"\"\n    if state is None:\n        state = ConflictResolverState()\n\n    # pick up where we left off last time, but track the new actions as well\n    state.remaining_actions.extend(normalize_actions(actions))\n    actions = state.remaining_actions\n\n    def orderandpos(v):\n        n, v = v\n        return (v['order'] or 0, n)\n\n    def orderonly(v):\n        n, v = v\n        return v['order'] or 0\n\n    sactions = sorted(enumerate(actions, start=state.start), key=orderandpos)\n    for order, actiongroup in itertools.groupby(sactions, orderonly):\n        # \"order\" is an integer grouping. Actions in a lower order will be\n        # executed before actions in a higher order.  All of the actions in\n        # one grouping will be executed (its callable, if any will be called)\n        # before any of the actions in the next.\n        output = []\n        unique = {}\n\n        # error out if we went backward in order\n        if state.min_order is not None and order < state.min_order:\n            r = [\n                'Actions were added to order={} after execution had moved '\n                'on to order={}. Conflicting actions: '.format(\n                    order, state.min_order\n                )\n            ]\n            for i, action in actiongroup:\n                for line in str(action['info']).rstrip().split('\\n'):\n                    r.append(\"  \" + line)\n            raise ConfigurationError('\\n'.join(r))\n\n        for i, action in actiongroup:\n            # Within an order, actions are executed sequentially based on\n            # original action ordering (\"i\").\n\n            # \"ainfo\" is a tuple of (i, action) where \"i\" is an integer\n            # expressing the relative position of this action in the action\n            # list being resolved, and \"action\" is an action dictionary.  The\n            # purpose of an ainfo is to associate an \"i\" with a particular\n            # action; \"i\" exists for sorting after conflict resolution.\n            ainfo = (i, action)\n\n            # wait to defer discriminators until we are on their order because\n            # the discriminator may depend on state from a previous order\n            discriminator = undefer(action['discriminator'])\n            action['discriminator'] = discriminator\n\n            if discriminator is None:\n                # The discriminator is None, so this action can never conflict.\n                # We can add it directly to the result.\n                output.append(ainfo)\n                continue\n\n            L = unique.setdefault(discriminator, [])\n            L.append(ainfo)\n\n        # Check for conflicts\n        conflicts = {}\n        for discriminator, ainfos in unique.items():\n            # We use (includepath, i) as a sort key because we need to\n            # sort the actions by the paths so that the shortest path with a\n            # given prefix comes first.  The \"first\" action is the one with the\n            # shortest include path.  We break sorting ties using \"i\".\n            def bypath(ainfo):\n                path, i = ainfo[1]['includepath'], ainfo[0]\n                return path, order, i\n\n            ainfos.sort(key=bypath)\n            ainfo, rest = ainfos[0], ainfos[1:]\n            _, action = ainfo\n\n            # ensure this new action does not conflict with a previously\n            # resolved action from an earlier order / invocation\n            prev_ainfo = state.resolved_ainfos.get(discriminator)\n            if prev_ainfo is not None:\n                _, paction = prev_ainfo\n                basepath, baseinfo = paction['includepath'], paction['info']\n                includepath = action['includepath']\n                # if the new action conflicts with the resolved action then\n                # note the conflict, otherwise drop the action as it's\n                # effectively overriden by the previous action\n                if (\n                    includepath[: len(basepath)] != basepath\n                    or includepath == basepath\n                ):\n                    L = conflicts.setdefault(discriminator, [baseinfo])\n                    L.append(action['info'])\n\n            else:\n                output.append(ainfo)\n\n            basepath, baseinfo = action['includepath'], action['info']\n            for _, action in rest:\n                includepath = action['includepath']\n                # Test whether path is a prefix of opath\n                if (\n                    includepath[: len(basepath)] != basepath\n                    or includepath == basepath  # not a prefix\n                ):\n                    L = conflicts.setdefault(discriminator, [baseinfo])\n                    L.append(action['info'])\n\n        if conflicts:\n            raise ConfigurationConflictError(conflicts)\n\n        # sort resolved actions by \"i\" and yield them one by one\n        for i, action in sorted(output, key=operator.itemgetter(0)):\n            # do not memoize the order until we resolve an action inside it\n            state.min_order = action['order']\n            state.start = i + 1\n            state.remaining_actions.remove(action)\n            state.resolved_ainfos[action['discriminator']] = (i, action)\n            yield action"
    },
    {
      "chunk_id": 743,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "def normalize_actions(actions):\n    \"\"\"Convert old-style tuple actions to new-style dicts.\"\"\"\n    result = []\n    for v in actions:\n        if not isinstance(v, dict):\n            v = expand_action_tuple(*v)\n        result.append(v)\n    return result"
    },
    {
      "chunk_id": 744,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "def expand_action_tuple(\n    discriminator,\n    callable=None,\n    args=(),\n    kw=None,\n    includepath=(),\n    info=None,\n    order=0,\n    introspectables=(),\n):\n    if kw is None:\n        kw = {}\n    return dict(\n        discriminator=discriminator,\n        callable=callable,\n        args=args,\n        kw=kw,\n        includepath=includepath,\n        info=info,\n        order=order,\n        introspectables=introspectables,\n    )"
    },
    {
      "chunk_id": 745,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "@implementer(IActionInfo)\nclass ActionInfo:\n    def __init__(self, file, line, function, src):\n        self.file = file\n        self.line = line\n        self.function = function\n        self.src = src\n\n    def __str__(self):\n        srclines = self.src.split('\\n')\n        src = '\\n'.join('    %s' % x for x in srclines)\n        return f'Line {self.line} of file {self.file}:\\n{src}'"
    },
    {
      "chunk_id": 746,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/actions.py",
      "content": "def action_method(wrapped):\n    \"\"\"Wrapper to provide the right conflict info report data when a method\n    that calls Configurator.action calls another that does the same.  Not a\n    documented API but used by some external systems.\"\"\"\n\n    def wrapper(self, *arg, **kw):\n        if self._ainfo is None:\n            self._ainfo = []\n        info = kw.pop('_info', None)\n        # backframes for outer decorators to actionmethods\n        backframes = kw.pop('_backframes', 0) + 2\n        if is_nonstr_iter(info) and len(info) == 4:\n            # _info permitted as extract_stack tuple\n            info = ActionInfo(*info)\n        if info is None:\n            try:\n                f = traceback.extract_stack(limit=4)\n                info = ActionInfo(*f[-backframes])\n            except Exception:  # pragma: no cover\n                info = ActionInfo(None, 0, '', '')\n        self._ainfo.append(info)\n        try:\n            result = wrapped(self, *arg, **kw)\n        finally:\n            self._ainfo.pop()\n        return result\n\n    if hasattr(wrapped, '__name__'):\n        functools.update_wrapper(wrapper, wrapped)\n    wrapper.__docobj__ = wrapped\n    return wrapper"
    },
    {
      "chunk_id": 747,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/i18n.py",
      "content": "from pyramid.config.actions import action_method\nfrom pyramid.exceptions import ConfigurationError\nfrom pyramid.interfaces import ILocaleNegotiator, ITranslationDirectories\nfrom pyramid.path import AssetResolver"
    },
    {
      "chunk_id": 748,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/i18n.py",
      "content": "class I18NConfiguratorMixin:\n    @action_method\n    def set_locale_negotiator(self, negotiator):\n        \"\"\"\n        Set the :term:`locale negotiator` for this application.  The\n        :term:`locale negotiator` is a callable which accepts a\n        :term:`request` object and which returns a :term:`locale\n        name`.  The ``negotiator`` argument should be the locale\n        negotiator implementation or a :term:`dotted Python name`\n        which refers to such an implementation.\n\n        Later calls to this method override earlier calls; there can\n        be only one locale negotiator active at a time within an\n        application.  See :ref:`activating_translation` for more\n        information.\n\n        .. note::\n\n           Using the ``locale_negotiator`` argument to the\n           :class:`pyramid.config.Configurator` constructor can be used to\n           achieve the same purpose.\n        \"\"\"\n\n        def register():\n            self._set_locale_negotiator(negotiator)\n\n        intr = self.introspectable(\n            'locale negotiator',\n            None,\n            self.object_description(negotiator),\n            'locale negotiator',\n        )\n        intr['negotiator'] = negotiator\n        self.action(ILocaleNegotiator, register, introspectables=(intr,))\n\n    def _set_locale_negotiator(self, negotiator):\n        locale_negotiator = self.maybe_dotted(negotiator)\n        self.registry.registerUtility(locale_negotiator, ILocaleNegotiator)"
    },
    {
      "chunk_id": 749,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/i18n.py",
      "content": "@action_method\n    def add_translation_dirs(self, *specs, **kw):\n        \"\"\"Add one or more :term:`translation directory` paths to the\n        current configuration state.  The ``specs`` argument is a\n        sequence that may contain absolute directory paths\n        (e.g. ``/usr/share/locale``) or :term:`asset specification`\n        names naming a directory path (e.g. ``some.package:locale``)\n        or a combination of the two.\n\n        Example:\n\n        .. code-block:: python\n\n           config.add_translation_dirs('/usr/share/locale',\n                                       'some.package:locale')\n\n        The translation directories are defined as a list in which\n        translations defined later have precedence over translations defined\n        earlier.\n\n        By default, consecutive calls to ``add_translation_dirs`` will add\n        directories to the start of the list. This means later calls to\n        ``add_translation_dirs`` will have their translations trumped by\n        earlier calls. If you explicitly need this call to trump an earlier\n        call then you may set ``override`` to ``True``.\n\n        If multiple specs are provided in a single call to\n        ``add_translation_dirs``, the directories will be inserted in the\n        order they're provided (earlier items are trumped by later items).\n\n        .. versionchanged:: 1.8\n\n           The ``override`` parameter was added to allow a later call\n           to ``add_translation_dirs`` to override an earlier call, inserting\n           folders at the beginning of the translation directory list.\n\n        \"\"\"\n        introspectables = []\n        override = kw.pop('override', False)\n        if kw:\n            raise TypeError('invalid keyword arguments: %s', sorted(kw.keys()))\n\n        def register():\n            directories = []\n            resolver = AssetResolver(self.package_name)\n\n            # defer spec resolution until register to allow for asset\n            # overrides to take place in an earlier config phase\n            for spec in specs:\n                # the trailing slash helps match asset overrides for folders\n                if not spec.endswith('/'):\n                    spec += '/'\n                asset = resolver.resolve(spec)\n                directory = asset.abspath()\n                if not asset.isdir():\n                    raise ConfigurationError(\n                        '\"%s\" is not a directory' % directory\n                    )\n                intr = self.introspectable(\n                    'translation directories',\n                    directory,\n                    spec,\n                    'translation directory',\n                )\n                intr['directory'] = directory\n                intr['spec'] = spec\n                introspectables.append(intr)\n                directories.append(directory)\n\n            tdirs = self.registry.queryUtility(ITranslationDirectories)\n            if tdirs is None:\n                tdirs = []\n                self.registry.registerUtility(tdirs, ITranslationDirectories)\n            if override:\n                tdirs.extend(directories)\n            else:\n                for directory in reversed(directories):\n                    tdirs.insert(0, directory)\n\n        self.action(None, register, introspectables=introspectables)"
    },
    {
      "chunk_id": 750,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/rendering.py",
      "content": "from pyramid import renderers\nfrom pyramid.config.actions import action_method\nfrom pyramid.interfaces import PHASE1_CONFIG, IRendererFactory\n\nDEFAULT_RENDERERS = (\n    ('json', renderers.json_renderer_factory),\n    ('string', renderers.string_renderer_factory),\n)"
    },
    {
      "chunk_id": 751,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/rendering.py",
      "content": "class RenderingConfiguratorMixin:\n    def add_default_renderers(self):\n        for name, renderer in DEFAULT_RENDERERS:\n            self.add_renderer(name, renderer)\n\n    @action_method\n    def add_renderer(self, name, factory):\n        \"\"\"\n        Add a :app:`Pyramid` :term:`renderer` factory to the\n        current configuration state.\n\n        The ``name`` argument is the renderer name.  Use ``None`` to\n        represent the default renderer (a renderer which will be used for all\n        views unless they name another renderer specifically).\n\n        The ``factory`` argument is Python reference to an\n        implementation of a :term:`renderer` factory or a\n        :term:`dotted Python name` to same.\n        \"\"\"\n        factory = self.maybe_dotted(factory)\n        # if name is None or the empty string, we're trying to register\n        # a default renderer, but registerUtility is too dumb to accept None\n        # as a name\n        if not name:\n            name = ''\n\n        def register():\n            self.registry.registerUtility(factory, IRendererFactory, name=name)\n\n        intr = self.introspectable(\n            'renderer factories',\n            name,\n            self.object_description(factory),\n            'renderer factory',\n        )\n        intr['factory'] = factory\n        intr['name'] = name\n        # we need to register renderers early (in phase 1) because they are\n        # used during view configuration (which happens in phase 3)\n        self.action(\n            (IRendererFactory, name),\n            register,\n            order=PHASE1_CONFIG,\n            introspectables=(intr,),\n        )"
    },
    {
      "chunk_id": 752,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/zca.py",
      "content": "from pyramid.threadlocal import get_current_registry"
    },
    {
      "chunk_id": 753,
      "source": "__internal__/data_repo/pyramid/src/pyramid/config/zca.py",
      "content": "class ZCAConfiguratorMixin:\n    def hook_zca(self):\n        \"\"\"Call :func:`zope.component.getSiteManager.sethook` with the\n        argument :data:`pyramid.threadlocal.get_current_registry`, causing\n        the :term:`Zope Component Architecture` 'global' APIs such as\n        :func:`zope.component.getSiteManager`,\n        :func:`zope.component.getAdapter` and others to use the\n        :app:`Pyramid` :term:`application registry` rather than the Zope\n        'global' registry.\"\"\"\n        from zope.component import getSiteManager\n\n        getSiteManager.sethook(get_current_registry)\n\n    def unhook_zca(self):\n        \"\"\"Call :func:`zope.component.getSiteManager.reset` to undo the\n        action of :meth:`pyramid.config.Configurator.hook_zca`.\"\"\"\n        from zope.component import getSiteManager\n\n        getSiteManager.reset()"
    },
    {
      "chunk_id": 754,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "import argparse\nimport fnmatch\nimport re\nimport sys\nimport textwrap\nfrom zope.interface import Interface\n\nfrom pyramid.config import not_\nfrom pyramid.interfaces import IRouteRequest\nfrom pyramid.paster import bootstrap\nfrom pyramid.scripts.common import get_config_loader, parse_vars\nfrom pyramid.static import static_view\nfrom pyramid.view import _find_views\n\nPAD = 3\nANY_KEY = '*'\nUNKNOWN_KEY = '<unknown>'"
    },
    {
      "chunk_id": 755,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def main(argv=sys.argv, quiet=False):\n    command = PRoutesCommand(argv, quiet)\n    return command.run()"
    },
    {
      "chunk_id": 756,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def _get_pattern(route):\n    pattern = route.pattern\n\n    if not pattern.startswith('/'):\n        pattern = '/%s' % pattern\n    return pattern"
    },
    {
      "chunk_id": 757,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def _get_print_format(fmt, max_name, max_pattern, max_view, max_method):\n    print_fmt = ''\n    max_map = {\n        'name': max_name,\n        'pattern': max_pattern,\n        'view': max_view,\n        'method': max_method,\n    }\n    sizes = []\n\n    for index, col in enumerate(fmt):\n        size = max_map[col] + PAD\n        print_fmt += f'{{{{{col}: <{{{index}}}}}}} '\n        sizes.append(size)\n\n    return print_fmt.format(*sizes)"
    },
    {
      "chunk_id": 758,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def _get_request_methods(route_request_methods, view_request_methods):\n    excludes = set()\n\n    if route_request_methods:\n        route_request_methods = set(route_request_methods)\n\n    if view_request_methods:\n        view_request_methods = set(view_request_methods)\n\n        for method in view_request_methods.copy():\n            if method.startswith('!'):\n                view_request_methods.remove(method)\n                excludes.add(method[1:])\n\n    has_route_methods = route_request_methods is not None\n    has_view_methods = len(view_request_methods) > 0\n    has_methods = has_route_methods or has_view_methods\n\n    if has_route_methods is False and has_view_methods is False:\n        request_methods = [ANY_KEY]\n    elif has_route_methods is False and has_view_methods is True:\n        request_methods = view_request_methods\n    elif has_route_methods is True and has_view_methods is False:\n        request_methods = route_request_methods\n    else:\n        request_methods = route_request_methods.intersection(\n            view_request_methods\n        )\n\n    request_methods = set(request_methods).difference(excludes)\n\n    if has_methods and not request_methods:\n        request_methods = '<route mismatch>'\n    elif request_methods:\n        if excludes and request_methods == {ANY_KEY}:\n            for exclude in excludes:\n                request_methods.add('!%s' % exclude)\n\n        request_methods = ','.join(sorted(request_methods))\n\n    return request_methods"
    },
    {
      "chunk_id": 759,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def _get_view_module(view_callable):\n    if view_callable is None:\n        return UNKNOWN_KEY\n\n    if hasattr(view_callable, '__name__'):\n        if hasattr(view_callable, '__original_view__'):\n            original_view = view_callable.__original_view__\n        else:\n            original_view = None\n\n        if isinstance(original_view, static_view):\n            if original_view.package_name is not None:\n                return '{}:{}'.format(\n                    original_view.package_name,\n                    original_view.docroot,\n                )\n            else:\n                return original_view.docroot\n        else:\n            view_name = view_callable.__name__\n    else:\n        view_name = str(view_callable)\n\n    view_module = f'{view_callable.__module__}.{view_name}'\n\n    if view_module == 'pyramid.router.decorator':\n        view_module = '<wsgiapp>'\n\n    return view_module"
    },
    {
      "chunk_id": 760,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def get_route_data(route, registry):\n    pattern = _get_pattern(route)\n\n    request_iface = registry.queryUtility(IRouteRequest, name=route.name)\n\n    route_request_methods = None\n    view_request_methods_order = []\n    view_request_methods = {}\n    view_callable = None\n\n    route_intr = registry.introspector.get('routes', route.name)\n\n    if request_iface is None:\n        return [(route.name, _get_pattern(route), UNKNOWN_KEY, ANY_KEY)]\n\n    view_callables = _find_views(registry, request_iface, Interface, '')\n    if view_callables:\n        view_callable = view_callables[0]\n    else:\n        view_callable = None\n    view_module = _get_view_module(view_callable)\n\n    if route_intr is None:\n        view_request_methods[view_module] = []\n        view_request_methods_order.append(view_module)\n    else:\n        if route_intr.get('static', False) is True:\n            return [\n                (route.name, route_intr['external_url'], UNKNOWN_KEY, ANY_KEY)\n            ]\n\n        route_request_methods = route_intr['request_methods']\n        view_intr = registry.introspector.related(route_intr)\n\n        if view_intr:\n            for view in view_intr:\n                request_method = view.get('request_methods')\n\n                if request_method is not None:\n                    if view.get('attr') is not None:\n                        view_callable = getattr(view['callable'], view['attr'])\n                        view_module = '{}.{}'.format(\n                            _get_view_module(view['callable']),\n                            view['attr'],\n                        )\n                    else:\n                        view_callable = view['callable']\n                        view_module = _get_view_module(view_callable)\n\n                    if view_module not in view_request_methods:\n                        view_request_methods[view_module] = []\n                        view_request_methods_order.append(view_module)\n\n                    if isinstance(request_method, str):\n                        request_method = (request_method,)\n                    elif isinstance(request_method, not_):\n                        request_method = ('!%s' % request_method.value,)\n\n                    view_request_methods[view_module].extend(request_method)\n                else:\n                    if view_module not in view_request_methods:\n                        view_request_methods[view_module] = []\n                        view_request_methods_order.append(view_module)\n\n        else:\n            view_request_methods[view_module] = []\n            view_request_methods_order.append(view_module)\n\n    final_routes = []\n\n    for view_module in view_request_methods_order:\n        methods = view_request_methods[view_module]\n        request_methods = _get_request_methods(route_request_methods, methods)\n\n        final_routes.append(\n            (route.name, pattern, view_module, request_methods)\n        )\n\n    return final_routes"
    },
    {
      "chunk_id": 761,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "class PRoutesCommand:\n    description = \"\"\"\\\n    Print all URL dispatch routes used by a Pyramid application in the\n    order in which they are evaluated.  Each route includes the name of the\n    route, the pattern of the route, and the view callable which will be\n    invoked when the route is matched.\n\n    This command accepts one positional argument named 'config_uri'.  It\n    specifies the PasteDeploy config file to use for the interactive\n    shell. The format is 'inifile#name'. If the name is left off, 'main'\n    will be assumed.  Example: 'proutes myapp.ini'.\n\n    \"\"\"\n    script_name = 'proutes'\n    bootstrap = staticmethod(bootstrap)  # testing\n    get_config_loader = staticmethod(get_config_loader)  # testing\n    stdout = sys.stdout\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-g',\n        '--glob',\n        action='store',\n        dest='glob',\n        default='',\n        help='Display routes matching glob pattern',\n    )\n\n    parser.add_argument(\n        '-f',\n        '--format',\n        action='store',\n        dest='format',\n        default='',\n        help=(\n            'Choose which columns to display, this will '\n            'override the format key in the [proutes] ini '\n            'section'\n        ),\n    )\n\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=(\n            \"Variables required by the config file. For example, \"\n            \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n            \"passed here.\"\n        ),\n    )"
    },
    {
      "chunk_id": 762,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def __init__(self, argv, quiet=False):\n        self.args = self.parser.parse_args(argv[1:])\n        self.quiet = quiet\n        self.available_formats = ['name', 'pattern', 'view', 'method']\n        self.column_format = self.available_formats"
    },
    {
      "chunk_id": 763,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def validate_formats(self, formats):\n        invalid_formats = []\n        for fmt in formats:\n            if fmt not in self.available_formats:\n                invalid_formats.append(fmt)\n\n        msg = 'You provided invalid formats %s. Available formats are %s'\n\n        if invalid_formats:\n            msg = msg % (invalid_formats, self.available_formats)\n            self.out(msg)\n            return False\n\n        return True"
    },
    {
      "chunk_id": 764,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def proutes_file_config(self, loader, global_conf=None):\n        settings = loader.get_settings('proutes', global_conf)\n        format = settings.get('format')\n        if format:\n            cols = re.split(r'[,|\\s\\n]+', format)\n            self.column_format = [x.strip() for x in cols]"
    },
    {
      "chunk_id": 765,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if not self.quiet:\n            print(msg)"
    },
    {
      "chunk_id": 766,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def _get_mapper(self, registry):\n        from pyramid.config import Configurator\n\n        config = Configurator(registry=registry)\n        return config.get_routes_mapper()"
    },
    {
      "chunk_id": 767,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "def run(self, quiet=False):\n        if not self.args.config_uri:\n            self.out('requires a config file argument')\n            return 2\n\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        loader = self.get_config_loader(config_uri)\n        loader.setup_logging(config_vars)\n        self.proutes_file_config(loader, config_vars)\n\n        env = self.bootstrap(config_uri, options=config_vars)\n        registry = env['registry']\n        mapper = self._get_mapper(registry)\n\n        if self.args.format:\n            columns = self.args.format.split(',')\n            self.column_format = [x.strip() for x in columns]\n\n        is_valid = self.validate_formats(self.column_format)\n\n        if is_valid is False:\n            return 2\n\n        if mapper is None:\n            return 0\n\n        max_name = len('Name')\n        max_pattern = len('Pattern')\n        max_view = len('View')\n        max_method = len('Method')\n\n        routes = mapper.get_routes(include_static=True)\n\n        if len(routes) == 0:\n            return 0\n\n        mapped_routes = [\n            {\n                'name': 'Name',\n                'pattern': 'Pattern',\n                'view': 'View',\n                'method': 'Method',\n            },\n            {\n                'name': '----',\n                'pattern': '-------',\n                'view': '----',\n                'method': '------',\n            },\n        ]\n\n        for route in routes:\n            route_data = get_route_data(route, registry)\n\n            for name, pattern, view, method in route_data:\n                if self.args.glob:\n                    match = fnmatch.fnmatch(\n                        name, self.args.glob\n                    ) or fnmatch.fnmatch(pattern, self.args.glob)\n                    if not match:\n                        continue\n\n                if len(name) > max_name:\n                    max_name = len(name)\n\n                if len(pattern) > max_pattern:\n                    max_pattern = len(pattern)\n\n                if len(view) > max_view:\n                    max_view = len(view)\n\n                if len(method) > max_method:\n                    max_method = len(method)\n\n                mapped_routes.append(\n                    {\n                        'name': name,\n                        'pattern': pattern,\n                        'view': view,\n                        'method': method,\n                    }\n                )\n\n        fmt = _get_print_format(\n            self.column_format, max_name, max_pattern, max_view, max_method\n        )\n\n        for route in mapped_routes:\n            self.out(fmt.format(**route))\n\n        return 0"
    },
    {
      "chunk_id": 768,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/proutes.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 769,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 770,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 771,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 772,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 773,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 774,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pdistreport.py",
      "content": "import argparse\nimport importlib.metadata\nfrom operator import itemgetter\nimport platform\nimport sys"
    },
    {
      "chunk_id": 775,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pdistreport.py",
      "content": "def out(*args):  # pragma: no cover\n    for arg in args:\n        sys.stdout.write(arg)\n        sys.stdout.write(' ')\n    sys.stdout.write('\\n')"
    },
    {
      "chunk_id": 776,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pdistreport.py",
      "content": "def get_parser():\n    parser = argparse.ArgumentParser(\n        description=\"Show Python distribution versions and locations in use\"\n    )\n    return parser"
    },
    {
      "chunk_id": 777,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pdistreport.py",
      "content": "def main(\n    argv=sys.argv,\n    importlib_metadata=importlib.metadata,\n    platform=platform.platform,\n    out=out,\n):\n    # all args except argv are for unit testing purposes only\n    parser = get_parser()\n    parser.parse_args(argv[1:])\n    packages = []\n    for distribution in importlib_metadata.distributions():\n        name = distribution.metadata['Name']\n        packages.append(\n            {\n                'version': distribution.version,\n                'lowername': name.lower(),\n                'name': name,\n                'summary': distribution.metadata.get('Summary'),\n            }\n        )\n    packages = sorted(packages, key=itemgetter('lowername'))\n    pyramid_version = importlib_metadata.distribution('pyramid').version\n    plat = platform()\n    out('Pyramid version:', pyramid_version)\n    out('Platform:', plat)\n    out('Packages:')\n    for package in packages:\n        out(' ', package['name'], package['version'])\n        out('   ', package['summary'])"
    },
    {
      "chunk_id": 778,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pdistreport.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 779,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "import argparse\nfrom code import interact\nfrom contextlib import contextmanager\nimport importlib.metadata\nimport os\nimport sys\nimport textwrap\n\nfrom pyramid.paster import bootstrap\nfrom pyramid.scripts.common import get_config_loader, parse_vars\nfrom pyramid.settings import aslist\nfrom pyramid.util import DottedNameResolver, make_contextmanager"
    },
    {
      "chunk_id": 780,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def main(argv=sys.argv, quiet=False):\n    command = PShellCommand(argv, quiet)\n    return command.run()"
    },
    {
      "chunk_id": 781,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def python_shell_runner(env, help, interact=interact):\n    cprt = 'Type \"help\" for more information.'\n    banner = f\"Python {sys.version} on {sys.platform}\\n{cprt}\"\n    banner += '\\n\\n' + help + '\\n'\n    interact(banner, local=env)"
    },
    {
      "chunk_id": 782,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "class PShellCommand:\n    description = \"\"\"\\\n    Open an interactive shell with a Pyramid app loaded.  This command\n    accepts one positional argument named \"config_uri\" which specifies the\n    PasteDeploy config file to use for the interactive shell. The format is\n    \"inifile#name\". If the name is left off, the Pyramid default application\n    will be assumed.  Example: \"pshell myapp.ini#main\".\n\n    If you do not point the loader directly at the section of the ini file\n    containing your Pyramid application, the command will attempt to\n    find the app for you. If you are loading a pipeline that contains more\n    than one Pyramid application within it, the loader will use the\n    last one.\n    \"\"\"\n    script_name = 'pshell'\n    bootstrap = staticmethod(bootstrap)  # for testing\n    get_config_loader = staticmethod(get_config_loader)  # for testing\n    importlib_metadata = importlib.metadata  # for testing\n\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-p',\n        '--python-shell',\n        action='store',\n        dest='python_shell',\n        default='',\n        help=(\n            'Select the shell to use. A list of possible '\n            'shells is available using the --list-shells '\n            'option.'\n        ),\n    )\n    parser.add_argument(\n        '-l',\n        '--list-shells',\n        dest='list',\n        action='store_true',\n        help='List all available shells.',\n    )\n    parser.add_argument(\n        '--setup',\n        dest='setup',\n        help=(\n            \"A callable that will be passed the environment \"\n            \"before it is made available to the shell. This \"\n            \"option will override the 'setup' key in the \"\n            \"[pshell] ini section.\"\n        ),\n    )\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=\"Variables required by the config file. For example, \"\n        \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n        \"passed here.\",\n    )\n\n    default_runner = python_shell_runner  # testing\n\n    loaded_objects = {}\n    object_help = {}\n    preferred_shells = []\n    setup = None\n    pystartup = os.environ.get('PYTHONSTARTUP')\n    resolver = DottedNameResolver(None)\n\n    def __init__(self, argv, quiet=False):\n        self.quiet = quiet\n        self.args = self.parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 783,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def pshell_file_config(self, loader, defaults):\n        settings = loader.get_settings('pshell', defaults)\n        self.loaded_objects = {}\n        self.object_help = {}\n        self.setup = None\n        for k, v in settings.items():\n            if k == 'setup':\n                self.setup = v\n            elif k == 'default_shell':\n                self.preferred_shells = [x.lower() for x in aslist(v)]\n            else:\n                self.loaded_objects[k] = self.resolver.maybe_resolve(v)\n                self.object_help[k] = v"
    },
    {
      "chunk_id": 784,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if not self.quiet:\n            print(msg)"
    },
    {
      "chunk_id": 785,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def run(self, shell=None):\n        if self.args.list:\n            return self.show_shells()\n        if not self.args.config_uri:\n            self.out('Requires a config file argument')\n            return 2\n\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        loader = self.get_config_loader(config_uri)\n        loader.setup_logging(config_vars)\n        self.pshell_file_config(loader, config_vars)\n\n        self.env = self.bootstrap(config_uri, options=config_vars)\n\n        # remove the closer from the env\n        self.closer = self.env.pop('closer')\n\n        try:\n            if shell is None:\n                try:\n                    shell = self.make_shell()\n                except ValueError as e:\n                    self.out(str(e))\n                    return 1\n\n            with self.setup_env():\n                shell(self.env, self.help)\n\n        finally:\n            self.closer()"
    },
    {
      "chunk_id": 786,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "@contextmanager\n    def setup_env(self):\n        # setup help text for default environment\n        env = self.env\n        env_help = dict(env)\n        env_help['app'] = 'The WSGI application.'\n        env_help['root'] = 'Root of the default resource tree.'\n        env_help['registry'] = 'Active Pyramid registry.'\n        env_help['request'] = 'Active request object.'\n        env_help['root_factory'] = (\n            'Default root factory used to create `root`.'\n        )\n\n        # load the pshell section of the ini file\n        env.update(self.loaded_objects)\n\n        # eliminate duplicates from env, allowing custom vars to override\n        for k in self.loaded_objects:\n            if k in env_help:\n                del env_help[k]\n\n        # override use_script with command-line options\n        if self.args.setup:\n            self.setup = self.args.setup\n\n        if self.setup:\n            # call the setup callable\n            self.setup = self.resolver.maybe_resolve(self.setup)\n\n        # store the env before muddling it with the script\n        orig_env = env.copy()\n        setup_manager = make_contextmanager(self.setup)\n        with setup_manager(env):\n            # remove any objects from default help that were overidden\n            for k, v in env.items():\n                if k not in orig_env or v is not orig_env[k]:\n                    if getattr(v, '__doc__', False):\n                        env_help[k] = v.__doc__.replace(\"\\n\", \" \")\n                    else:\n                        env_help[k] = v\n            del orig_env\n\n            # generate help text\n            help = ''\n            if env_help:\n                help += 'Environment:'\n                for var in sorted(env_help.keys()):\n                    help += '\\n  %-12s %s' % (var, env_help[var])\n\n            if self.object_help:\n                help += '\\n\\nCustom Variables:'\n                for var in sorted(self.object_help.keys()):\n                    help += '\\n  %-12s %s' % (var, self.object_help[var])\n\n            if self.pystartup and os.path.isfile(self.pystartup):\n                with open(self.pystartup, 'rb') as fp:\n                    exec(fp.read().decode('utf-8'), env)\n                if '__builtins__' in env:\n                    del env['__builtins__']\n\n            self.help = help.strip()\n            yield"
    },
    {
      "chunk_id": 787,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def show_shells(self):\n        shells = self.find_all_shells()\n        sorted_names = sorted(shells.keys(), key=lambda x: x.lower())\n\n        self.out('Available shells:')\n        for name in sorted_names:\n            self.out(f'  {name}')\n        return 0"
    },
    {
      "chunk_id": 788,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def find_all_shells(self):\n        importlib_metadata = self.importlib_metadata\n\n        shells = {}\n        eps = importlib_metadata.entry_points()\n        if hasattr(eps, 'select'):\n            eps = eps.select(group='pyramid.pshell_runner')\n        else:  # pragma: no cover\n            # fallback for py38 and py39\n            eps = eps.get('pyramid.pshell_runner')\n        for ep in eps:\n            name = ep.name\n            shell_factory = ep.load()\n            shells[name] = shell_factory\n        return shells"
    },
    {
      "chunk_id": 789,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "def make_shell(self):\n        shells = self.find_all_shells()\n\n        shell = None\n        user_shell = self.args.python_shell.lower()\n\n        if not user_shell:\n            preferred_shells = self.preferred_shells\n            if not preferred_shells:\n                # by default prioritize all shells above python\n                preferred_shells = [k for k in shells.keys() if k != 'python']\n            max_weight = len(preferred_shells)\n\n            def order(x):\n                # invert weight to reverse sort the list\n                # (closer to the front is higher priority)\n                try:\n                    return preferred_shells.index(x[0].lower()) - max_weight\n                except ValueError:\n                    return 1\n\n            sorted_shells = sorted(shells.items(), key=order)\n\n            if len(sorted_shells) > 0:\n                shell = sorted_shells[0][1]\n\n        else:\n            runner = shells.get(user_shell)\n\n            if runner is not None:\n                shell = runner\n\n            if shell is None:\n                raise ValueError(\n                    'could not find a shell named \"%s\"' % user_shell\n                )\n\n        if shell is None:\n            # should never happen, but just incase entry points are borked\n            shell = self.default_runner\n\n        return shell"
    },
    {
      "chunk_id": 790,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pshell.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 791,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/common.py",
      "content": "import plaster"
    },
    {
      "chunk_id": 792,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/common.py",
      "content": "def parse_vars(args):\n    \"\"\"\n    Given variables like ``['a=b', 'c=d']`` turns it into ``{'a':\n    'b', 'c': 'd'}``\n    \"\"\"\n    result = {}\n    for arg in args:\n        if '=' not in arg:\n            raise ValueError('Variable assignment %r invalid (no \"=\")' % arg)\n        name, value = arg.split('=', 1)\n        result[name] = value\n    return result"
    },
    {
      "chunk_id": 793,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/common.py",
      "content": "def get_config_loader(config_uri):\n    \"\"\"\n    Find a ``plaster.ILoader`` object supporting the \"wsgi\" protocol.\n\n    \"\"\"\n    return plaster.get_loader(config_uri, protocols=['wsgi'])"
    },
    {
      "chunk_id": 794,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "import argparse\nimport base64\nimport sys\nimport textwrap\nfrom urllib.parse import unquote\n\nfrom pyramid.request import Request\nfrom pyramid.scripts.common import get_config_loader, parse_vars"
    },
    {
      "chunk_id": 795,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "def main(argv=sys.argv, quiet=False):\n    command = PRequestCommand(argv, quiet)\n    return command.run()"
    },
    {
      "chunk_id": 796,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "class PRequestCommand:\n    description = \"\"\"\\\n    Submit a HTTP request to a web application.\n\n    This command makes an artificial request to a web application that uses a\n    PasteDeploy (.ini) configuration file for the server and application.\n\n    Use \"prequest config.ini /path\" to request \"/path\".\n\n    Use \"prequest --method=POST config.ini /path < data\" to do a POST with\n    the given request body.\n\n    Use \"prequest --method=PUT config.ini /path < data\" to do a\n    PUT with the given request body.\n\n    Use \"prequest --method=PATCH config.ini /path < data\" to do a\n    PATCH with the given request body.\n\n    Use \"prequest --method=OPTIONS config.ini /path\" to do an\n    OPTIONS request.\n\n    Use \"prequest --method=PROPFIND config.ini /path\" to do a\n    PROPFIND request.\n\n    If the path is relative (doesn't begin with \"/\") it is interpreted as\n    relative to \"/\".  The path passed to this script should be URL-quoted.\n    The path can be succeeded with a query string (e.g. '/path?a=1&=b2').\n\n    The variable \"environ['paste.command_request']\" will be set to \"True\" in\n    the request's WSGI environment, so your application can distinguish these\n    calls from normal requests.\n    \"\"\"\n    script_name = 'prequest'\n\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-n',\n        '--app-name',\n        dest='app_name',\n        metavar='NAME',\n        help=(\n            \"Load the named application from the config file (default 'main')\"\n        ),\n    )\n    parser.add_argument(\n        '--header',\n        dest='headers',\n        metavar='NAME:VALUE',\n        action='append',\n        help=(\n            \"Header to add to request (you can use this option multiple times)\"\n        ),\n    )\n    parser.add_argument(\n        '-d',\n        '--display-headers',\n        dest='display_headers',\n        action='store_true',\n        help='Display status and headers before the response body',\n    )\n    parser.add_argument(\n        '-m',\n        '--method',\n        dest='method',\n        choices=[\n            'GET',\n            'HEAD',\n            'POST',\n            'PUT',\n            'PATCH',\n            'DELETE',\n            'PROPFIND',\n            'OPTIONS',\n        ],\n        help='Request method type (GET, POST, PUT, PATCH, DELETE, '\n        'PROPFIND, OPTIONS)',\n    )\n    parser.add_argument(\n        '-l',\n        '--login',\n        dest='login',\n        help='HTTP basic auth username:password pair',\n    )\n\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n\n    parser.add_argument(\n        'path_info', nargs='?', default=None, help='The path of the request.'\n    )\n\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=\"Variables required by the config file. For example, \"\n        \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n        \"passed here.\",\n    )\n\n    _get_config_loader = staticmethod(get_config_loader)\n    stdin = sys.stdin"
    },
    {
      "chunk_id": 797,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "def __init__(self, argv, quiet=False):\n        self.quiet = quiet\n        self.args = self.parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 798,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if not self.quiet:\n            print(msg)"
    },
    {
      "chunk_id": 799,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "def run(self):\n        if not self.args.config_uri or not self.args.path_info:\n            self.out('You must provide at least two arguments')\n            return 2\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        path = self.args.path_info\n\n        loader = self._get_config_loader(config_uri)\n        loader.setup_logging(config_vars)\n\n        app = loader.get_wsgi_app(self.args.app_name, config_vars)\n\n        if not path.startswith('/'):\n            path = '/' + path\n\n        try:\n            path, qs = path.split('?', 1)\n        except ValueError:\n            qs = ''\n\n        path = unquote(path)\n\n        headers = {}\n        if self.args.login:\n            enc = base64.b64encode(self.args.login.encode('ascii'))\n            headers['Authorization'] = 'Basic ' + enc.decode('ascii')\n\n        if self.args.headers:\n            for item in self.args.headers:\n                if ':' not in item:\n                    self.out(\n                        \"Bad --header=%s option, value must be in the form \"\n                        \"'name:value'\" % item\n                    )\n                    return 2\n                name, value = item.split(':', 1)\n                headers[name] = value.strip()\n\n        request_method = (self.args.method or 'GET').upper()\n\n        environ = {\n            'REQUEST_METHOD': request_method,\n            'SCRIPT_NAME': '',  # may be empty if app is at the root\n            'PATH_INFO': path,\n            'SERVER_NAME': 'localhost',  # always mandatory\n            'SERVER_PORT': '80',  # always mandatory\n            'SERVER_PROTOCOL': 'HTTP/1.0',\n            'CONTENT_TYPE': 'text/plain',\n            'REMOTE_ADDR': '127.0.0.1',\n            'wsgi.run_once': True,\n            'wsgi.multithread': False,\n            'wsgi.multiprocess': False,\n            'wsgi.errors': sys.stderr,\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'QUERY_STRING': qs,\n            'HTTP_ACCEPT': 'text/plain;q=1.0, */*;q=0.1',\n            'paste.command_request': True,\n        }\n\n        if request_method in ('POST', 'PUT', 'PATCH'):\n            environ['wsgi.input'] = self.stdin\n            environ['CONTENT_LENGTH'] = '-1'\n\n        for name, value in headers.items():\n            if name.lower() == 'content-type':\n                name = 'CONTENT_TYPE'\n            else:\n                name = 'HTTP_' + name.upper().replace('-', '_')\n            environ[name] = value\n\n        request = Request.blank(path, environ=environ)\n        response = request.get_response(app)\n        if self.args.display_headers:\n            self.out(response.status)\n            for name, value in response.headerlist:\n                self.out(f'{name}: {value}')\n        if response.charset:\n            self.out(response.ubody)\n        else:\n            self.out(response.body)\n        return 0"
    },
    {
      "chunk_id": 800,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/prequest.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 801,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "import argparse\nimport hupper\nimport os\nimport re\nimport sys\nimport textwrap\nimport threading\nimport time\nimport webbrowser\n\nfrom pyramid.path import AssetResolver\nfrom pyramid.scripts.common import get_config_loader, parse_vars\nfrom pyramid.settings import aslist"
    },
    {
      "chunk_id": 802,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def main(argv=sys.argv, quiet=False, original_ignore_files=None):\n    command = PServeCommand(\n        argv, quiet=quiet, original_ignore_files=original_ignore_files\n    )\n    return command.run()"
    },
    {
      "chunk_id": 803,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "class PServeCommand:\n    description = \"\"\"\\\n    This command serves a web application that uses a PasteDeploy\n    configuration file for the server and application.\n\n    You can also include variable assignments like 'http_port=8080'\n    and then use %(http_port)s in your config files.\n    \"\"\"\n    script_name = 'pserve'\n    default_verbosity = 1\n\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-n',\n        '--app-name',\n        dest='app_name',\n        metavar='NAME',\n        help=\"Load the named application (default main)\",\n    )\n    parser.add_argument(\n        '-s',\n        '--server',\n        dest='server',\n        metavar='SERVER_TYPE',\n        help=\"Use the named server.\",\n    )\n    parser.add_argument(\n        '--server-name',\n        dest='server_name',\n        metavar='SECTION_NAME',\n        help=(\n            \"Use the named server as defined in the configuration file \"\n            \"(default: main)\"\n        ),\n    )\n    parser.add_argument(\n        '--reload',\n        dest='reload',\n        action='store_true',\n        help=\"Use auto-restart file monitor\",\n    )\n    parser.add_argument(\n        '--reload-interval',\n        dest='reload_interval',\n        default=1,\n        help=(\n            \"Seconds between checking files (low number can cause \"\n            \"significant CPU usage)\"\n        ),\n    )\n    parser.add_argument(\n        '-b',\n        '--browser',\n        dest='browser',\n        action='store_true',\n        help=(\n            \"Open a web browser to the server url. The server url is \"\n            \"determined from the 'open_url' setting in the 'pserve' \"\n            \"section of the configuration file.\"\n        ),\n    )\n    parser.add_argument(\n        '-v',\n        '--verbose',\n        default=default_verbosity,\n        dest='verbose',\n        action='count',\n        help=\"Set verbose level (default \" + str(default_verbosity) + \")\",\n    )\n    parser.add_argument(\n        '-q',\n        '--quiet',\n        action='store_const',\n        const=0,\n        dest='verbose',\n        help=\"Suppress verbose output\",\n    )\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=\"Variables required by the config file. For example, \"\n        \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n        \"passed here.\",\n    )\n\n    _get_config_loader = staticmethod(get_config_loader)  # for testing\n\n    open_url = None\n\n    _scheme_re = re.compile(r'^[a-z][a-z]+:', re.I)\n\n    def __init__(self, argv, quiet=False, original_ignore_files=None):\n        self.args = self.parser.parse_args(argv[1:])\n        if quiet:\n            self.args.verbose = 0\n        if self.args.reload:\n            self.worker_kwargs = {'argv': argv, \"quiet\": quiet}\n        self.watch_files = set()\n        self.ignore_files = set()\n        self.original_ignore_files = original_ignore_files"
    },
    {
      "chunk_id": 804,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if self.args.verbose > 0:\n            print(msg, file=sys.stderr)"
    },
    {
      "chunk_id": 805,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def get_config_path(self, loader):\n        return os.path.abspath(loader.uri.path)"
    },
    {
      "chunk_id": 806,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def pserve_file_config(self, loader, global_conf=None):\n        settings = loader.get_settings('pserve', global_conf)\n        config_path = self.get_config_path(loader)\n        here = os.path.dirname(config_path)\n        watch_files = aslist(settings.get('watch_files', ''), flatten=False)\n        self.ignore_files = set(\n            aslist(settings.get('ignore_files', ''), flatten=False)\n        )\n\n        # track file paths relative to the ini file\n        resolver = AssetResolver(package=None)\n        for file in watch_files:\n            if ':' in file:\n                file = resolver.resolve(file).abspath()\n            elif not os.path.isabs(file):\n                file = os.path.join(here, file)\n            self.watch_files.add(os.path.abspath(file))\n\n        # attempt to determine the url of the server\n        open_url = settings.get('open_url')\n        if open_url:\n            self.open_url = open_url"
    },
    {
      "chunk_id": 807,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def guess_server_url(self, loader, server_name, global_conf=None):\n        server_name = server_name or 'main'\n        settings = loader.get_settings('server:' + server_name, global_conf)\n        if 'port' in settings:\n            return 'http://127.0.0.1:{port}'.format(**settings)"
    },
    {
      "chunk_id": 808,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def run(self):  # pragma: no cover\n        if not self.args.config_uri:\n            self.out('You must give a config file')\n            return 2\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        app_spec = self.args.config_uri\n        app_name = self.args.app_name\n\n        loader = self._get_config_loader(config_uri)\n\n        # setup logging only in the worker process incase the logging config\n        # opens files which should not be opened by multiple processes at once\n        if not self.args.reload or hupper.is_active():\n            loader.setup_logging(config_vars)\n\n        self.pserve_file_config(loader, global_conf=config_vars)\n\n        server_name = self.args.server_name\n        if self.args.server:\n            server_spec = 'egg:pyramid'\n            assert server_name is None\n            server_name = self.args.server\n        else:\n            server_spec = app_spec\n\n        server_loader = loader\n        if server_spec != app_spec:\n            server_loader = self.get_config_loader(server_spec)\n\n        # do not open the browser on each reload so check hupper first\n        if self.args.browser and not hupper.is_active():\n            url = self.open_url\n\n            if not url:\n                url = self.guess_server_url(\n                    server_loader, server_name, config_vars\n                )\n\n            if not url:\n                self.out(\n                    'WARNING: could not determine the server\\'s url to '\n                    'open the browser. To fix this set the \"open_url\" '\n                    'setting in the [pserve] section of the '\n                    'configuration file.'\n                )\n\n            else:\n\n                def open_browser():\n                    time.sleep(1)\n                    webbrowser.open(url)\n\n                t = threading.Thread(target=open_browser)\n                t.daemon = True\n                t.start()\n\n        if self.args.reload and not hupper.is_active():\n            if self.args.verbose > 1:\n                self.out('Running reloading file monitor')\n            self.worker_kwargs['original_ignore_files'] = self.ignore_files\n            hupper.start_reloader(\n                'pyramid.scripts.pserve.main',\n                reload_interval=int(self.args.reload_interval),\n                verbose=self.args.verbose,\n                worker_kwargs=self.worker_kwargs,\n                ignore_files=self.ignore_files,\n            )\n            return 0\n\n        config_path = self.get_config_path(loader)\n        self.watch_files.add(config_path)\n\n        server_path = self.get_config_path(server_loader)\n        self.watch_files.add(server_path)\n\n        if hupper.is_active():\n            reloader = hupper.get_reloader()\n            reloader.watch_files(list(self.watch_files))\n\n        if (\n            self.original_ignore_files is not None\n            and self.original_ignore_files != self.ignore_files\n        ):\n            self.out(\n                'A change to \"ignore_files\" was detected but it will not take'\n                ' effect until pserve is restarted.'\n            )\n\n        server = server_loader.get_wsgi_server(server_name, config_vars)\n\n        app = loader.get_wsgi_app(app_name, config_vars)\n\n        if self.args.verbose > 0:\n            if hasattr(os, 'getpid'):\n                msg = 'Starting server in PID %i.' % os.getpid()\n            else:\n                msg = 'Starting server.'\n            self.out(msg)\n\n        try:\n            server(app)\n        except (SystemExit, KeyboardInterrupt) as e:\n            if self.args.verbose > 1:\n                raise\n            if str(e):\n                msg = ' ' + str(e)\n            else:\n                msg = ''\n            self.out('Exiting%s (-v to see traceback)' % msg)"
    },
    {
      "chunk_id": 809,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def wsgiref_server_runner(wsgi_app, global_conf, **kw):  # pragma: no cover\n    from wsgiref.simple_server import make_server\n\n    host = kw.get('host', '0.0.0.0')\n    port = int(kw.get('port', 8080))\n    server = make_server(host, port, wsgi_app)\n    print(f'Starting HTTP server on http://{host}:{port}', file=sys.stderr)\n    server.serve_forever()"
    },
    {
      "chunk_id": 810,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "def cherrypy_server_runner(\n    app,\n    global_conf=None,\n    host='127.0.0.1',\n    port=None,\n    ssl_pem=None,\n    protocol_version=None,\n    numthreads=None,\n    server_name=None,\n    max=None,\n    request_queue_size=None,\n    timeout=None,\n):  # pragma: no cover\n    \"\"\"\n    Entry point for CherryPy's WSGI server\n\n    Serves the specified WSGI app via CherryPyWSGIServer.\n\n    ``app``\n\n        The WSGI 'application callable'; multiple WSGI applications\n        may be passed as (script_name, callable) pairs.\n\n    ``host``\n\n        This is the ipaddress to bind to (or a hostname if your\n        nameserver is properly configured).  This defaults to\n        127.0.0.1, which is not a public interface.\n\n    ``port``\n\n        The port to run on, defaults to 8080 for HTTP, or 4443 for\n        HTTPS. This can be a string or an integer value.\n\n    ``ssl_pem``\n\n        This an optional SSL certificate file (via OpenSSL) You can\n        generate a self-signed test PEM certificate file as follows:\n\n            $ openssl genrsa 1024 > host.key\n            $ chmod 400 host.key\n            $ openssl req -new -x509 -nodes -sha1 -days 365  \\\\\n                          -key host.key > host.cert\n            $ cat host.cert host.key > host.pem\n            $ chmod 400 host.pem\n\n    ``protocol_version``\n\n        The protocol used by the server, by default ``HTTP/1.1``.\n\n    ``numthreads``\n\n        The number of worker threads to create.\n\n    ``server_name``\n\n        The string to set for WSGI's SERVER_NAME environ entry.\n\n    ``max``\n\n        The maximum number of queued requests. (defaults to -1 = no\n        limit).\n\n    ``request_queue_size``\n\n        The 'backlog' argument to socket.listen(); specifies the\n        maximum number of queued connections.\n\n    ``timeout``\n\n        The timeout in seconds for accepted connections.\n    \"\"\"\n    is_ssl = False\n    if ssl_pem:\n        port = port or 4443\n        is_ssl = True\n\n    if not port:\n        if ':' in host:\n            host, port = host.split(':', 1)\n        else:\n            port = 8080\n    bind_addr = (host, int(port))\n\n    kwargs = {}\n    for var_name in ('numthreads', 'max', 'request_queue_size', 'timeout'):\n        var = locals()[var_name]\n        if var is not None:\n            kwargs[var_name] = int(var)\n\n    try:\n        from cheroot.wsgi import Server as WSGIServer\n    except ImportError:\n        from cherrypy.wsgiserver import CherryPyWSGIServer as WSGIServer\n\n    server = WSGIServer(bind_addr, app, server_name=server_name, **kwargs)\n    if ssl_pem is not None:\n        # creates wsgiserver.ssl_builtin as side-effect\n        try:\n            from cheroot.server import get_ssl_adapter_class\n            from cheroot.ssl.builtin import BuiltinSSLAdapter\n        except ImportError:\n            from cherrypy.wsgiserver import get_ssl_adapter_class\n            from cherrypy.wsgiserver.ssl_builtin import BuiltinSSLAdapter\n        get_ssl_adapter_class()\n        server.ssl_adapter = BuiltinSSLAdapter(ssl_pem, ssl_pem)\n\n    if protocol_version:\n        server.protocol = protocol_version\n\n    try:\n        protocol = is_ssl and 'https' or 'http'\n        if host == '0.0.0.0':\n            print(\n                'serving on 0.0.0.0:%s view at %s://127.0.0.1:%s'\n                % (port, protocol, port),\n                file=sys.stderr,\n            )\n        else:\n            print(\n                f'serving on {protocol}://{host}:{port}',\n                file=sys.stderr,\n            )\n        server.start()\n    except (KeyboardInterrupt, SystemExit):\n        server.stop()\n\n    return server"
    },
    {
      "chunk_id": 811,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pserve.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 812,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "import argparse\nimport sys\nimport textwrap\n\nfrom pyramid.interfaces import ITweens\nfrom pyramid.paster import bootstrap, setup_logging\nfrom pyramid.scripts.common import parse_vars\nfrom pyramid.tweens import INGRESS, MAIN"
    },
    {
      "chunk_id": 813,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "def main(argv=sys.argv, quiet=False):\n    command = PTweensCommand(argv, quiet)\n    return command.run()"
    },
    {
      "chunk_id": 814,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "class PTweensCommand:\n    description = \"\"\"\\\n    Print all implicit and explicit tween objects used by a Pyramid\n    application.  The handler output includes whether the system is using an\n    explicit tweens ordering (will be true when the \"pyramid.tweens\"\n    deployment setting is used) or an implicit tweens ordering (will be true\n    when the \"pyramid.tweens\" deployment setting is *not* used).\n\n    This command accepts one positional argument named \"config_uri\" which\n    specifies the PasteDeploy config file to use for the interactive\n    shell. The format is \"inifile#name\". If the name is left off, \"main\"\n    will be assumed.  Example: \"ptweens myapp.ini#main\".\n\n    \"\"\"\n    script_name = 'ptweens'\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=\"Variables required by the config file. For example, \"\n        \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n        \"passed here.\",\n    )\n\n    stdout = sys.stdout\n    bootstrap = staticmethod(bootstrap)  # testing\n    setup_logging = staticmethod(setup_logging)  # testing\n\n    def __init__(self, argv, quiet=False):\n        self.quiet = quiet\n        self.args = self.parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 815,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "def _get_tweens(self, registry):\n        from pyramid.config import Configurator\n\n        config = Configurator(registry=registry)\n        return config.registry.queryUtility(ITweens)"
    },
    {
      "chunk_id": 816,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if not self.quiet:\n            print(msg)"
    },
    {
      "chunk_id": 817,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "def show_chain(self, chain):\n        fmt = '%-10s  %-65s'\n        self.out(fmt % ('Position', 'Name'))\n        self.out(fmt % ('-' * len('Position'), '-' * len('Name')))\n        self.out(fmt % ('-', INGRESS))\n        for pos, (name, _) in enumerate(chain):\n            self.out(fmt % (pos, name))\n        self.out(fmt % ('-', MAIN))"
    },
    {
      "chunk_id": 818,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "def run(self):\n        if not self.args.config_uri:\n            self.out('Requires a config file argument')\n            return 2\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        self.setup_logging(config_uri, global_conf=config_vars)\n        env = self.bootstrap(config_uri, options=config_vars)\n        registry = env['registry']\n        tweens = self._get_tweens(registry)\n        if tweens is not None:\n            explicit = tweens.explicit\n            if explicit:\n                self.out(\n                    '\"pyramid.tweens\" config value set '\n                    '(explicitly ordered tweens used)'\n                )\n                self.out('')\n                self.out('Explicit Tween Chain (used)')\n                self.out('')\n                self.show_chain(tweens.explicit)\n                self.out('')\n                self.out('Implicit Tween Chain (not used)')\n                self.out('')\n                self.show_chain(tweens.implicit())\n            else:\n                self.out(\n                    '\"pyramid.tweens\" config value NOT set '\n                    '(implicitly ordered tweens used)'\n                )\n                self.out('')\n                self.out('Implicit Tween Chain')\n                self.out('')\n                self.show_chain(tweens.implicit())\n        return 0"
    },
    {
      "chunk_id": 819,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/ptweens.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 820,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "import argparse\nimport sys\nimport textwrap\n\nfrom pyramid.interfaces import IMultiView\nfrom pyramid.paster import bootstrap, setup_logging\nfrom pyramid.request import Request\nfrom pyramid.scripts.common import parse_vars\nfrom pyramid.view import _find_views"
    },
    {
      "chunk_id": 821,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def main(argv=sys.argv, quiet=False):\n    command = PViewsCommand(argv, quiet)\n    return command.run()"
    },
    {
      "chunk_id": 822,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "class PViewsCommand:\n    description = \"\"\"\\\n    Print, for a given URL, the views that might match. Underneath each\n    potentially matching route, list the predicates required. Underneath\n    each route+predicate set, print each view that might match and its\n    predicates.\n\n    This command accepts two positional arguments: 'config_uri' specifies the\n    PasteDeploy config file to use for the interactive shell. The format is\n    'inifile#name'. If the name is left off, 'main' will be assumed.  'url'\n    specifies the path info portion of a URL that will be used to find\n    matching views.  Example: 'proutes myapp.ini#main /url'\n    \"\"\"\n    script_name = 'pviews'\n    stdout = sys.stdout\n\n    parser = argparse.ArgumentParser(\n        description=textwrap.dedent(description),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        'config_uri',\n        nargs='?',\n        default=None,\n        help='The URI to the configuration file.',\n    )\n\n    parser.add_argument(\n        'url',\n        nargs='?',\n        default=None,\n        help='The path info portion of the URL.',\n    )\n    parser.add_argument(\n        'config_vars',\n        nargs='*',\n        default=(),\n        help=\"Variables required by the config file. For example, \"\n        \"`http_port=%%(http_port)s` would expect `http_port=8080` to be \"\n        \"passed here.\",\n    )\n\n    bootstrap = staticmethod(bootstrap)  # testing\n    setup_logging = staticmethod(setup_logging)  # testing\n\n    def __init__(self, argv, quiet=False):\n        self.quiet = quiet\n        self.args = self.parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 823,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def out(self, msg):  # pragma: no cover\n        if not self.quiet:\n            print(msg)"
    },
    {
      "chunk_id": 824,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def _find_multi_routes(self, mapper, request):\n        infos = []\n        path = request.path_info\n        # find all routes that match path, regardless of predicates\n        for route in mapper.get_routes():\n            match = route.match(path)\n            if match is not None:\n                info = {'match': match, 'route': route}\n                infos.append(info)\n        return infos"
    },
    {
      "chunk_id": 825,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def _find_view(self, request):\n        \"\"\"\n        Accept ``url`` and ``registry``; create a :term:`request` and\n        find a :app:`Pyramid` view based on introspection of :term:`view\n        configuration` within the application registry; return the view.\n        \"\"\"\n        from zope.interface import implementer, providedBy\n\n        from pyramid.interfaces import (\n            IRequest,\n            IRootFactory,\n            IRouteRequest,\n            IRoutesMapper,\n            ITraverser,\n        )\n        from pyramid.traversal import DefaultRootFactory, ResourceTreeTraverser\n\n        registry = request.registry\n        q = registry.queryUtility\n        root_factory = q(IRootFactory, default=DefaultRootFactory)\n        routes_mapper = q(IRoutesMapper)\n\n        adapters = registry.adapters\n\n        @implementer(IMultiView)\n        class RoutesMultiView:\n            def __init__(self, infos, context_iface, root_factory, request):\n                self.views = []\n                for info in infos:\n                    match, route = info['match'], info['route']\n                    if route is not None:\n                        request_iface = registry.queryUtility(\n                            IRouteRequest, name=route.name, default=IRequest\n                        )\n                        views = _find_views(\n                            request.registry, request_iface, context_iface, ''\n                        )\n                        if not views:\n                            continue\n                        view = views[0]\n                        view.__request_attrs__ = {}\n                        view.__request_attrs__['matchdict'] = match\n                        view.__request_attrs__['matched_route'] = route\n                        root_factory = route.factory or root_factory\n                        root = root_factory(request)\n                        traverser = adapters.queryAdapter(root, ITraverser)\n                        if traverser is None:\n                            traverser = ResourceTreeTraverser(root)\n                        tdict = traverser(request)\n                        view.__request_attrs__.update(tdict)\n                        if not hasattr(view, '__view_attr__'):\n                            view.__view_attr__ = ''\n                        self.views.append((None, view, None))\n\n        context = None\n        routes_multiview = None\n        attrs = request.__dict__\n        request_iface = IRequest\n\n        # find the root object\n        if routes_mapper is not None:\n            infos = self._find_multi_routes(routes_mapper, request)\n            if len(infos) == 1:\n                info = infos[0]\n                match, route = info['match'], info['route']\n                if route is not None:\n                    attrs['matchdict'] = match\n                    attrs['matched_route'] = route\n                    request.environ['bfg.routes.matchdict'] = match\n                    request_iface = registry.queryUtility(\n                        IRouteRequest, name=route.name, default=IRequest\n                    )\n                    root_factory = route.factory or root_factory\n            if len(infos) > 1:\n                routes_multiview = infos\n\n        root = root_factory(request)\n        attrs['root'] = root\n\n        # find a context\n        traverser = adapters.queryAdapter(root, ITraverser)\n        if traverser is None:\n            traverser = ResourceTreeTraverser(root)\n        tdict = traverser(request)\n        context, view_name = (tdict['context'], tdict['view_name'])\n\n        attrs.update(tdict)\n\n        # find a view callable\n        context_iface = providedBy(context)\n        if routes_multiview is None:\n            views = _find_views(\n                request.registry, request_iface, context_iface, view_name\n            )\n            if views:\n                view = views[0]\n            else:\n                view = None\n        else:\n            view = RoutesMultiView(infos, context_iface, root_factory, request)\n\n        # routes are not registered with a view name\n        if view is None:\n            views = _find_views(\n                request.registry, request_iface, context_iface, ''\n            )\n            if views:\n                view = views[0]\n            else:\n                view = None\n            # we don't want a multiview here\n            if IMultiView.providedBy(view):\n                view = None\n\n        if view is not None:\n            view.__request_attrs__ = attrs\n\n        return view"
    },
    {
      "chunk_id": 826,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def output_route_attrs(self, attrs, indent):\n        route = attrs['matched_route']\n        self.out(f\"{indent}route name: {route.name}\")\n        self.out(f\"{indent}route pattern: {route.pattern}\")\n        self.out(f\"{indent}route path: {route.path}\")\n        self.out(\"{}subpath: {}\".format(indent, '/'.join(attrs['subpath'])))\n        predicates = ', '.join([p.text() for p in route.predicates])\n        if predicates != '':\n            self.out(f\"{indent}route predicates ({predicates})\")"
    },
    {
      "chunk_id": 827,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def output_view_info(self, view_wrapper, level=1):\n        indent = \"    \" * level\n        name = getattr(view_wrapper, '__name__', '')\n        module = getattr(view_wrapper, '__module__', '')\n        attr = getattr(view_wrapper, '__view_attr__', None)\n        request_attrs = getattr(view_wrapper, '__request_attrs__', {})\n        if attr is not None:\n            view_callable = f\"{module}.{name}.{attr}\"\n        else:\n            attr = view_wrapper.__class__.__name__\n            if attr == 'function':\n                attr = name\n            view_callable = f\"{module}.{attr}\"\n        self.out('')\n        if 'matched_route' in request_attrs:\n            self.out(\"%sRoute:\" % indent)\n            self.out(\"%s------\" % indent)\n            self.output_route_attrs(request_attrs, indent)\n            permission = getattr(view_wrapper, '__permission__', None)\n            if not IMultiView.providedBy(view_wrapper):\n                # single view for this route, so repeat call without route data\n                del request_attrs['matched_route']\n                self.output_view_info(view_wrapper, level + 1)\n        else:\n            self.out(\"%sView:\" % indent)\n            self.out(\"%s-----\" % indent)\n            self.out(f\"{indent}{view_callable}\")\n            permission = getattr(view_wrapper, '__permission__', None)\n            if permission is not None:\n                self.out(f\"{indent}required permission = {permission}\")\n            predicates = getattr(view_wrapper, '__predicates__', None)\n            if predicates is not None:\n                predicate_text = ', '.join([p.text() for p in predicates])\n                self.out(f\"{indent}view predicates ({predicate_text})\")"
    },
    {
      "chunk_id": 828,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "def run(self):\n        if not self.args.config_uri or not self.args.url:\n            self.out('Command requires a config file arg and a url arg')\n            return 2\n        config_uri = self.args.config_uri\n        config_vars = parse_vars(self.args.config_vars)\n        config_vars.setdefault('__script__', self.script_name)\n        url = self.args.url\n\n        self.setup_logging(config_uri, global_conf=config_vars)\n\n        if not url.startswith('/'):\n            url = '/%s' % url\n        request = Request.blank(url)\n        env = self.bootstrap(config_uri, options=config_vars, request=request)\n        view = self._find_view(request)\n        self.out('')\n        self.out(\"URL = %s\" % url)\n        self.out('')\n        if view is not None:\n            self.out(\"    context: %s\" % view.__request_attrs__['context'])\n            self.out(\"    view name: %s\" % view.__request_attrs__['view_name'])\n        if IMultiView.providedBy(view):\n            for dummy, view_wrapper, dummy in view.views:\n                self.output_view_info(view_wrapper)\n                if IMultiView.providedBy(view_wrapper):\n                    for dummy, mv_view_wrapper, dummy in view_wrapper.views:\n                        self.output_view_info(mv_view_wrapper, level=2)\n        else:\n            if view is not None:\n                self.output_view_info(view)\n            else:\n                self.out(\"    Not found.\")\n        self.out('')\n        env['closer']()\n        return 0"
    },
    {
      "chunk_id": 829,
      "source": "__internal__/data_repo/pyramid/src/pyramid/scripts/pviews.py",
      "content": "if __name__ == '__main__':  # pragma: no cover\n    sys.exit(main() or 0)"
    },
    {
      "chunk_id": 830,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "import sys\nimport os\nimport datetime\nimport warnings\n\nwarnings.simplefilter('ignore', DeprecationWarning)\n\nimport pkg_resources\nimport pylons_sphinx_themes\n\n# skip raw nodes\nfrom sphinx.writers.text import TextTranslator\nfrom sphinx.writers.latex import LaTeXTranslator\n\nfrom docutils import nodes\nfrom docutils import utils\nfrom docutils.parsers.rst import Directive"
    },
    {
      "chunk_id": 831,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "def raw(*arg):\n    raise nodes.SkipNode\nTextTranslator.visit_raw = raw"
    },
    {
      "chunk_id": 832,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "def nothing(*arg):\n    pass\nLaTeXTranslator.visit_inline = nothing\nLaTeXTranslator.depart_inline = nothing"
    },
    {
      "chunk_id": 833,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "book = os.environ.get('BOOK')"
    },
    {
      "chunk_id": 834,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "extensions = [\n    'repoze.sphinx.autointerface',\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.viewcode',\n    'sphinxcontrib.autoprogram',\n    'sphinx_copybutton',\n    # enable pylons_sphinx_latesturl when this branch is no longer \"latest\"\n    # 'pylons_sphinx_latesturl',\n]"
    },
    {
      "chunk_id": 835,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "intersphinx_mapping = {\n    'colander': ('https://docs.pylonsproject.org/projects/colander/en/latest/', None),\n    'cookbook': ('https://docs.pylonsproject.org/projects/pyramid_cookbook/en/latest/', None),\n    'deform': ('https://docs.pylonsproject.org/projects/deform/en/latest/', None),\n    'jinja2': ('https://docs.pylonsproject.org/projects/pyramid_jinja2/en/latest/', None),\n    'pylonswebframework': ('https://docs.pylonsproject.org/projects/pylons-webframework/en/latest/', None),\n    'python': ('https://docs.python.org/3/', None),\n    'pytest': ('https://docs.pytest.org/en/latest/', None),\n    'sqla': ('https://docs.sqlalchemy.org/en/latest/', None),\n    'tm': ('https://docs.pylonsproject.org/projects/pyramid_tm/en/latest/', None),\n    'toolbar': ('https://docs.pylonsproject.org/projects/pyramid_debugtoolbar/en/latest/', None),\n    'transaction': ('https://transaction.readthedocs.io/en/latest/', None),\n    'tutorials': ('https://docs.pylonsproject.org/projects/pyramid_tutorials/en/latest/', None),\n    'venusian': ('https://docs.pylonsproject.org/projects/venusian/en/latest/', None),\n    'webtest': ('https://docs.pylonsproject.org/projects/webtest/en/latest/', None),\n    'webob': ('https://docs.pylonsproject.org/projects/webob/en/latest/', None),\n    'zcml': (\n    'https://docs.pylonsproject.org/projects/pyramid_zcml/en/latest/', None),\n}"
    },
    {
      "chunk_id": 836,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "templates_path = ['_templates']"
    },
    {
      "chunk_id": 837,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "source_suffix = '.rst'"
    },
    {
      "chunk_id": 838,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "master_doc = 'index'"
    },
    {
      "chunk_id": 839,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "project = 'The Pyramid Web Framework'\nthisyear = datetime.datetime.now().year\ncopyright = '2008-%s, Agendaless Consulting' % thisyear"
    },
    {
      "chunk_id": 840,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "version = pkg_resources.get_distribution('pyramid').version"
    },
    {
      "chunk_id": 841,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "release = version"
    },
    {
      "chunk_id": 842,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "today_fmt = '%B %d, %Y'"
    },
    {
      "chunk_id": 843,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "exclude_patterns = ['_themes/README.rst', ]"
    },
    {
      "chunk_id": 844,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "add_module_names = False"
    },
    {
      "chunk_id": 845,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "if book:\n    pygments_style = 'bw'"
    },
    {
      "chunk_id": 846,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "html_theme = 'pyramid'\nhtml_theme_path = pylons_sphinx_themes.get_html_themes_path()\nhtml_theme_options = dict(\n    github_url='https://github.com/Pylons/pyramid',\n    in_progress='true',\n    outdated='false',\n)"
    },
    {
      "chunk_id": 847,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "html_sidebars = {'**': [\n    'localtoc.html',\n    'ethicalads.html',\n    'relations.html',\n    'sourcelink.html',\n    'searchbox.html',\n]}"
    },
    {
      "chunk_id": 848,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "html_title = 'The Pyramid Web Framework v%s' % release"
    },
    {
      "chunk_id": 849,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "html_last_updated_fmt = '%b %d, %Y'"
    },
    {
      "chunk_id": 850,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "smartquotes = False"
    },
    {
      "chunk_id": 851,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "htmlhelp_basename = 'pyramid'"
    },
    {
      "chunk_id": 852,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_engine = 'xelatex'\nlatex_use_xindy = False"
    },
    {
      "chunk_id": 853,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_paper_size = 'letter'"
    },
    {
      "chunk_id": 854,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_font_size = '10pt'"
    },
    {
      "chunk_id": 855,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_additional_files = [\n    '_static/latex-note.png',\n    '_static/latex-warning.png',\n]"
    },
    {
      "chunk_id": 856,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_documents = [\n  ('latexindex', 'pyramid.tex',\n   'The Pyramid Web Framework',\n   'Chris McDonough', 'manual'),\n]"
    },
    {
      "chunk_id": 857,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_toplevel_sectioning = \"section\""
    },
    {
      "chunk_id": 858,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_domain_indices = False"
    },
    {
      "chunk_id": 859,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "_PREAMBLE = r\"\"\"\n\\usepackage[]{geometry}\n\\geometry{bindingoffset=0.45in,textheight=7.25in,hdivide={0.5in,*,0.75in},vdivide={1in,7.25in,1in},papersize={7.5in,9.25in}}\n\n%XeLaTeX packages\n\\usepackage{xltxtra}\n\\usepackage{fontspec} %Font package\n\\usepackage{xunicode}\n\n%Select fonts\n\\setmainfont[Mapping=tex-text]{nimbusserif}\n\\setsansfont[Mapping=tex-text]{nimbussans}\n\\setmonofont{nimbusmono}\n\n\\hypersetup{\n    colorlinks=true,\n    linkcolor=black,\n    citecolor=black,\n    filecolor=black,\n    urlcolor=black\n}\n\\fvset{frame=single,xleftmargin=9pt,numbersep=4pt}\n\n\\pagestyle{fancy}\n\n% header and footer styles\n\\renewcommand{\\chaptermark}[1]%\n  {\\markboth{\\MakeUppercase{\\thechapter.\\ #1}}{}\n  }\n\\renewcommand{\\sectionmark}[1]%\n  {\\markright{\\MakeUppercase{\\thesection.\\ #1}}\n  }\n\n% defaults for fancy style\n\\renewcommand{\\headrulewidth}{0pt}\n\\renewcommand{\\footrulewidth}{0pt}\n\\fancyhf{}\n\\fancyfoot[C]{\\thepage}\n\n% plain style\n\\fancypagestyle{plain}{\n  \\renewcommand{\\headrulewidth}{0pt} % ho header line\n  \\renewcommand{\\footrulewidth}{0pt}% no footer line\n  \\fancyhf{} % empty header and footer\n  \\fancyfoot[C]{\\thepage}\n}\n\n% title page styles\n\\makeatletter\n\\def\\@subtitle{\\relax}\n\\newcommand{\\subtitle}[1]{\\gdef\\@subtitle{#1}}\n\\renewcommand{\\maketitle}{\n  \\begin{titlepage}\n    {\\rm\\Huge\\@title\\par}\n    {\\em\\large\\py@release\\releaseinfo\\par}\n    \\if\\@subtitle\\relax\\else\\large\\@subtitle\\par\\fi\n    {\\large\\@author\\par}\n  \\end{titlepage}\n}\n\\makeatother\n\n% Redefine link and title colors\n\\definecolor{TitleColor}{rgb}{0,0,0}\n\\definecolor{InnerLinkColor}{rgb}{0.208,0.374,0.486}\n\\definecolor{OuterLinkColor}{rgb}{0.216,0.439,0.388}\n% Redefine these colors to something not white if you want to have colored\n% background and border for code examples.\n\\definecolor{VerbatimColor}{rgb}{1,1,1}\n\\definecolor{VerbatimBorderColor}{rgb}{1,1,1}\n\n% icons in note and warning boxes\n\\usepackage{ifthen}\n\n% Keep a copy of the original sphinxadmonition environment\n\\let\\origbeginadmon\\sphinxadmonition\n\\let\\origendadmon\\endsphinxadmonition\n\n% Redefine the sphinxadmonition environment so we can add our own code to it\n\\renewenvironment{sphinxadmonition}[2]{%\n  \\origbeginadmon{#1}{}% equivalent to original \\begin{sphinxadmonition}{#1}{#2}\n  % load graphics\n  \\ifthenelse{\\equal{#1}{warning}}{\\includegraphics{latex-warning.png}}{}\n  \\ifthenelse{\\equal{#1}{note}}{\\includegraphics{latex-note.png}}{}\n  % etc.\n  }{%\n\\origendadmon % equivalent to original \\end{sphinxadmonition}\n}\n\n% try to prevent code-block boxes from splitting across pages\n\\sloppy\n\\widowpenalty=300\n\\clubpenalty=300\n\\setlength{\\parskip}{3ex plus 2ex minus 2ex}\n\n% suppress page numbers on pages showing part title\n\\makeatletter\n\\let\\sv@endpart\\@endpart\n\\def\\@endpart{\\thispagestyle{empty}\\sv@endpart}\n\\makeatother\n\n% prevent page numbers in TOC (reset to fancy by frontmatter directive)\n\\pagestyle{empty}\n\"\"\""
    },
    {
      "chunk_id": 860,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "latex_elements = {\n    'preamble': _PREAMBLE,\n    'releasename': 'Version',\n    'title': r'The Pyramid Web Framework',\n}"
    },
    {
      "chunk_id": 861,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "class FrontMatter(Directive):\n    def run(self):\n        return [nodes.raw(\n            '',\n            format='latex')]"
    },
    {
      "chunk_id": 862,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "class MainMatter(Directive):\n    def run(self):\n        return [nodes.raw(\n            '',\n            format='latex')]"
    },
    {
      "chunk_id": 863,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "class BackMatter(Directive):\n    def run(self):\n        return [nodes.raw(\n            '',\n            format='latex')]"
    },
    {
      "chunk_id": 864,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "def app_role(role, rawtext, text, lineno, inliner, options={}, content=[]):\n    \"\"\"custom role for :app: marker, does nothing in particular except allow\n    :app:`Pyramid` to work (for later search and replace).\"\"\"\n    if 'class' in options:\n        assert 'classes' not in options\n        options['classes'] = options['class']\n        del options['class']\n    return [nodes.inline(rawtext, utils.unescape(text), **options)], []"
    },
    {
      "chunk_id": 865,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "def setup(app):\n    app.add_role('app', app_role)\n    app.add_directive('frontmatter', FrontMatter)\n    app.add_directive('mainmatter', MainMatter)\n    app.add_directive('backmatter', BackMatter)"
    },
    {
      "chunk_id": 866,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_title = 'The Pyramid Web Framework, Version %s' \\\n             % release\nepub_author = 'Chris McDonough'\nepub_publisher = 'Agendaless Consulting'\nepub_copyright = '2008-%d' % thisyear"
    },
    {
      "chunk_id": 867,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_language = 'en'"
    },
    {
      "chunk_id": 868,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_scheme = 'ISBN'"
    },
    {
      "chunk_id": 869,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_identifier = '0615445675'"
    },
    {
      "chunk_id": 870,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_uid = 'The Pyramid Web Framework, Version %s' \\\n           % release"
    },
    {
      "chunk_id": 871,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',\n    '_static/jquery.js', '_static/searchtools.js', '_static/underscore.js',\n    '_static/basic.css', 'search.html', '_static/websupport.js']"
    },
    {
      "chunk_id": 872,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "epub_tocdepth = 3"
    },
    {
      "chunk_id": 873,
      "source": "__internal__/data_repo/pyramid/docs/conf.py",
      "content": "linkcheck_ignore = [\n    r'http://localhost:\\d+',\n    r'http://localhost',\n    r'https://web.libera.chat/#pyramid',  # JavaScript \"anchor\"\n]"
    },
    {
      "chunk_id": 874,
      "source": "__internal__/data_repo/pyramid/docs/coversizing.py",
      "content": "# see https://www.createspace.com/Products/Book/#content4\n# https://www.createspace.com/Help/Index.jsp?orgId=00D300000001Sh9&id=50170000000I7be"
    },
    {
      "chunk_id": 875,
      "source": "__internal__/data_repo/pyramid/docs/coversizing.py",
      "content": "page_count = 600\nbleed = .125\nspine_width = .002252 * page_count\ntrim_width = 7.5\ntrim_height = 9.25\nmin_cover_width = bleed + trim_width + spine_width + trim_width + bleed\nmin_cover_height = bleed + trim_height + bleed"
    },
    {
      "chunk_id": 876,
      "source": "__internal__/data_repo/pyramid/docs/coversizing.py",
      "content": "print \"spine width \", spine_width, \"inches\"\nprint \"min cover width \", min_cover_width, \"inches\"\nprint \"min cover height \", min_cover_height, \"inches\""
    },
    {
      "chunk_id": 877,
      "source": "__internal__/data_repo/pyramid/docs/coversizing.py",
      "content": "print \"barcode placeholder width: 2 inches\"\nprint \"barcode placeholder height: 1.2 inches\"\nprint \"bottom of barcode must be .25 inches from bottom trim line of cover\"\nprint \"right side of barcode must be .25 inches to left of spine\""
    },
    {
      "chunk_id": 878,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 879,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{name}')\n        config.add_route('hello_json', 'hello.json')\n        config.add_static_view(name='static', path='static')\n        config.include('pyramid_jinja2')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 880,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 881,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/views.py",
      "content": "@view_defaults(route_name='hello')\nclass HelloWorldViews:\n    def __init__(self, request):\n        self.request = request\n        # Our templates can now say {{ view.name }}\n        self.name = request.matchdict['name']"
    },
    {
      "chunk_id": 882,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/views.py",
      "content": "# Retrieving /howdy/amy the first time\n    @view_config(renderer='hello.jinja2')\n    def hello_view(self):\n        return dict()"
    },
    {
      "chunk_id": 883,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/views.py",
      "content": "# Posting to /howdy/amy via the \"Edit\" submit button\n    @view_config(request_param='form.edit', renderer='edit.jinja2')\n    def edit_view(self):\n        print('Edited')\n        return dict()"
    },
    {
      "chunk_id": 884,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/view_classes/views.py",
      "content": "# Posting to /howdy/amy via the \"Delete\" submit button\n    @view_config(request_param='form.delete', renderer='delete.jinja2')\n    def delete_view(self):\n        print('Deleted')\n        return dict()"
    },
    {
      "chunk_id": 885,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 886,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('home', '/')\n        config.add_route('hello', '/howdy')\n        config.add_route('redirect', '/goto')\n        config.add_route('exception', '/problem')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 887,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/views.py",
      "content": "from html import escape\n\nfrom pyramid.httpexceptions import HTTPFound\nfrom pyramid.response import Response\nfrom pyramid.view import view_config"
    },
    {
      "chunk_id": 888,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/views.py",
      "content": "@view_config(route_name='home')\ndef home_view(request):\n    return Response('<p>Visit <a href=\"/howdy?name=lisa\">hello</a></p>')"
    },
    {
      "chunk_id": 889,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/views.py",
      "content": "@view_config(route_name='hello')\ndef hello_view(request):\n    name = request.params.get('name', 'No Name')\n    body = '<p>Hi %s, this <a href=\"/goto\">redirects</a></p>'\n    return Response(body % escape(name))"
    },
    {
      "chunk_id": 890,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/views.py",
      "content": "@view_config(route_name='redirect')\ndef redirect_view(request):\n    return HTTPFound(location=\"/problem\")"
    },
    {
      "chunk_id": 891,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/views/views.py",
      "content": "@view_config(route_name='exception')\ndef exception_view(request):\n    raise Exception()"
    },
    {
      "chunk_id": 892,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/json/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 893,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/json/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{name}')\n        config.add_route('hello_json', 'hello.json')\n        config.add_static_view(name='static', path='static')\n        config.include('pyramid_jinja2')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 894,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/json/views.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 895,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/json/views.py",
      "content": "@view_config(route_name='hello', renderer='hello_world.jinja2')\ndef hello_world(request):\n    return dict(name=request.matchdict['name'])"
    },
    {
      "chunk_id": 896,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/json/views.py",
      "content": "@view_config(route_name='hello_json', renderer='json')\ndef hello_json(request):\n    return [1, 2, 3]"
    },
    {
      "chunk_id": 897,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/setup.py",
      "content": "import os\n\nfrom setuptools import setup, find_packages\n\nhere = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()\n\nrequires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n]\n\ntests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 898,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/setup.py",
      "content": "setup(\n    name='hello_world',\n    version='0.0',\n    description='hello_world',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = hello_world:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 899,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 900,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 901,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 902,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 903,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 904,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/notfound.py",
      "content": "@notfound_view_config(renderer='hello_world:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 905,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/default.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 906,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/default.py",
      "content": "import logging\nlog = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 907,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/logging/hello_world/views/default.py",
      "content": "@view_config(route_name='home', renderer='hello_world:templates/mytemplate.jinja2')\ndef my_view(request):\n    log.debug('Some Message')\n    return {'project': 'hello_world'}"
    },
    {
      "chunk_id": 908,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "import os"
    },
    {
      "chunk_id": 909,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "from setuptools import setup, find_packages"
    },
    {
      "chunk_id": 910,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "here = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()"
    },
    {
      "chunk_id": 911,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "requires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n]"
    },
    {
      "chunk_id": 912,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "tests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 913,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/setup.py",
      "content": "setup(\n    name='hello_world',\n    version='0.0',\n    description='hello_world',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = hello_world:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 914,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 915,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 916,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 917,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 918,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 919,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/views/notfound.py",
      "content": "@notfound_view_config(renderer='hello_world:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 920,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/views/default.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 921,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/package/hello_world/views/default.py",
      "content": "@view_config(route_name='home', renderer='hello_world:templates/mytemplate.jinja2')\ndef my_view(request):\n    return {'project': 'hello_world'}"
    },
    {
      "chunk_id": 922,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/requests/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 923,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/requests/app.py",
      "content": "def hello_world(request):\n    # Some parameters from a request such as /?name=lisa\n    url = request.url\n    name = request.params.get('name', 'No Name Provided')\n\n    body = 'URL %s with name: %s' % (url, name)\n    return Response(\n        content_type=\"text/plain\",\n        body=body\n    )"
    },
    {
      "chunk_id": 924,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/requests/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/')\n        config.add_view(hello_world, route_name='hello')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 925,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "import os"
    },
    {
      "chunk_id": 926,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "from setuptools import setup, find_packages"
    },
    {
      "chunk_id": 927,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "here = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()"
    },
    {
      "chunk_id": 928,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "requires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n    'alembic',\n    'pyramid_retry',\n    'pyramid_tm',\n    'SQLAlchemy',\n    'transaction',\n    'zope.sqlalchemy',\n]"
    },
    {
      "chunk_id": 929,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "tests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 930,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/setup.py",
      "content": "setup(\n    name='sqla_demo',\n    version='0.0',\n    description='sqla_demo',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = sqla_demo:main',\n        ],\n        'console_scripts': [\n            'initialize_sqla_demo_db=sqla_demo.scripts.initialize_db:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 931,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 932,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 933,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 934,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 935,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 936,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 937,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 938,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/notfound.py",
      "content": "@notfound_view_config(renderer='sqla_demo:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 939,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/default.py",
      "content": "from pyramid.view import view_config\nfrom pyramid.response import Response\nfrom sqlalchemy.exc import SQLAlchemyError\n\nfrom .. import models"
    },
    {
      "chunk_id": 940,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/default.py",
      "content": "@view_config(route_name='home', renderer='sqla_demo:templates/mytemplate.jinja2')\ndef my_view(request):\n    try:\n        query = request.dbsession.query(models.MyModel)\n        one = query.filter(models.MyModel.name == 'one').one()\n    except SQLAlchemyError:\n        return Response(db_err_msg, content_type='text/plain', status=500)\n    return {'one': one, 'project': 'sqla_demo'}"
    },
    {
      "chunk_id": 941,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/views/default.py",
      "content": "db_err_msg = \"\"\"\\\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for descriptions and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n\nAfter you fix the problem, please restart the Pyramid application to\ntry it again.\n\"\"\""
    },
    {
      "chunk_id": 942,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .mymodel import MyModel  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 943,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 944,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 945,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 946,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('sqla_demo.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 947,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/meta.py",
      "content": "from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.schema import MetaData"
    },
    {
      "chunk_id": 948,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/meta.py",
      "content": "# Recommended naming convention used by Alembic, as various different database\n# providers will autogenerate vastly different names making migrations more\n# difficult. See: https://alembic.sqlalchemy.org/en/latest/naming.html\nNAMING_CONVENTION = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\"\n}"
    },
    {
      "chunk_id": 949,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/meta.py",
      "content": "metadata = MetaData(naming_convention=NAMING_CONVENTION)\nBase = declarative_base(metadata=metadata)"
    },
    {
      "chunk_id": 950,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/mymodel.py",
      "content": "from sqlalchemy import (\n    Column,\n    Index,\n    Integer,\n    Text,\n)\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 951,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/mymodel.py",
      "content": "class MyModel(Base):\n    \"\"\"MyModel represents a model in the database.\"\"\"\n    \n    __tablename__ = 'models'\n    id = Column(Integer, primary_key=True)\n    name = Column(Text)\n    value = Column(Integer)"
    },
    {
      "chunk_id": 952,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/models/mymodel.py",
      "content": "Index('my_index', MyModel.name, unique=True, mysql_length=255)"
    },
    {
      "chunk_id": 953,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 954,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom sqla_demo.models.meta import Base"
    },
    {
      "chunk_id": 955,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 956,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 957,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 958,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 959,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 960,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 961,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 962,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 963,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 964,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 965,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    model = models.mymodel.MyModel(name='one', value=1)\n    dbsession.add(model)"
    },
    {
      "chunk_id": 966,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 967,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sqla_demo/sqla_demo/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 968,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/hello_world/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 969,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/hello_world/app.py",
      "content": "def hello_world(request):\n    return Response('Hello World!')"
    },
    {
      "chunk_id": 970,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/hello_world/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/')\n        config.add_view(hello_world, route_name='hello')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 971,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/static_assets/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 972,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/static_assets/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{name}')\n        config.add_static_view(name='static', path='static')\n        config.include('pyramid_jinja2')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 973,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/static_assets/views.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 974,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/static_assets/views.py",
      "content": "@view_config(route_name='hello', renderer='hello_world.jinja2')\ndef hello_world(request):\n    return dict(name=request.matchdict['name'])"
    },
    {
      "chunk_id": 975,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/templating/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 976,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/templating/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{name}')\n        config.include('pyramid_chameleon')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 977,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/templating/views.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 978,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/templating/views.py",
      "content": "@view_config(route_name='hello', renderer='hello_world.pt')\ndef hello_world(request):\n    return dict(name=request.matchdict['name'])"
    },
    {
      "chunk_id": 979,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/jinja2/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 980,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/jinja2/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{name}')\n        config.include('pyramid_jinja2')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 981,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/jinja2/views.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 982,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/jinja2/views.py",
      "content": "@view_config(route_name='hello', renderer='hello_world.jinja2')\ndef hello_world(request):\n    return dict(name=request.matchdict['name'])"
    },
    {
      "chunk_id": 983,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "import os"
    },
    {
      "chunk_id": 984,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "from setuptools import setup, find_packages"
    },
    {
      "chunk_id": 985,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "here = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()"
    },
    {
      "chunk_id": 986,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "requires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n]"
    },
    {
      "chunk_id": 987,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "tests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 988,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/setup.py",
      "content": "setup(\n    name='hello_world',\n    version='0.0',\n    description='hello_world',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = hello_world:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 989,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.session import SignedCookieSessionFactory"
    },
    {
      "chunk_id": 990,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        my_session_factory = SignedCookieSessionFactory('itsaseekreet')\n        config.set_session_factory(my_session_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 991,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 992,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 993,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 994,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/notfound.py",
      "content": "@notfound_view_config(renderer='hello_world:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 995,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/default.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 996,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/default.py",
      "content": "import logging\nlog = logging.getLogger(__name__)"
    },
    {
      "chunk_id": 997,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/sessions/hello_world/views/default.py",
      "content": "@view_config(route_name='home', renderer='hello_world:templates/mytemplate.jinja2')\ndef my_view(request):\n    log.debug('Some Message')\n    session = request.session\n    if 'counter' in session:\n        session['counter'] += 1\n    else:\n        session['counter'] = 0\n    return {'project': 'hello_world'}"
    },
    {
      "chunk_id": 998,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/routing/app.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator"
    },
    {
      "chunk_id": 999,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/routing/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/howdy/{first}/{last}')\n        config.scan('views')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 1000,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/routing/views.py",
      "content": "from pyramid.response import Response\nfrom pyramid.view import view_config"
    },
    {
      "chunk_id": 1001,
      "source": "__internal__/data_repo/pyramid/docs/quick_tour/routing/views.py",
      "content": "@view_config(route_name='hello')\ndef hello_world(request):\n    body = '<h1>Hi %(first)s %(last)s!</h1>' % request.matchdict\n    return Response(body)"
    },
    {
      "chunk_id": 1002,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1003,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1004,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1005,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1006,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1007,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1008,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1009,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    \"\"\"Test cases for the Tutorial Views.\"\"\"\n    \n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1010,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1011,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1012,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    \"\"\"Functional test cases for the Tutorial application.\"\"\"\n    \n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1013,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1014,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1015,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1016,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1017,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1018,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/view_classes/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1019,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1020,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/setup.py",
      "content": "requires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1021,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1022,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1023,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1024,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1025,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1026,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1027,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import home\n\n        request = testing.DummyRequest()\n        response = home(request)\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b'Visit', response.body)"
    },
    {
      "chunk_id": 1028,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import hello\n\n        request = testing.DummyRequest()\n        response = hello(request)\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b'Go back', response.body)"
    },
    {
      "chunk_id": 1029,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.Test"
    },
    {
      "chunk_id": 1030,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/views.py",
      "content": "from pyramid.response import Response\nfrom pyramid.view import view_config"
    },
    {
      "chunk_id": 1031,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/views.py",
      "content": "@view_config(route_name='home')\ndef home(request):\n    return Response('<body>Visit <a href=\"/howdy\">hello</a></body>')"
    },
    {
      "chunk_id": 1032,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/views/tutorial/views.py",
      "content": "@view_config(route_name='hello')\ndef hello(request):\n    return Response('<body>Go back <a href=\"/\">home</a></body>')"
    },
    {
      "chunk_id": 1033,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1034,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1035,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1036,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1037,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1038,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.add_route('hello_json', '/howdy.json')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1039,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1040,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1041,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1042,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1043,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1044,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1045,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1046,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/tests.py",
      "content": "def test_hello_json(self):\n        res = self.testapp.get('/howdy.json', status=200)\n        self.assertIn(b'{\"name\": \"Hello View\"}', res.body)\n        self.assertEqual(res.content_type, 'application/json')"
    },
    {
      "chunk_id": 1047,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1048,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1049,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1050,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/json/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    @view_config(route_name='hello_json', renderer='json')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1051,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1052,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/setup.py",
      "content": "# List of dependencies installed via `pip install -e .`\n# by virtue of the Setuptools `install_requires` value below.\nrequires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1053,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/setup.py",
      "content": "# List of dependencies installed via `pip install -e \".[dev]\"`\n# by virtue of the Setuptools `extras_require` value in the Python\n# dictionary below.\ndev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1054,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1055,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1056,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/__init__.py",
      "content": "def hello_world(request):\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1057,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('hello', '/')\n    config.add_view(hello_world, route_name='hello')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1058,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1059,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_hello_world(self):\n        from tutorial import hello_world\n\n        request = testing.DummyRequest()\n        response = hello_world(request)\n        self.assertEqual(response.status_code, 200)"
    },
    {
      "chunk_id": 1060,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/functional_testing/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)\n\n    def test_hello_world(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hello World!</h1>', res.body)"
    },
    {
      "chunk_id": 1061,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1062,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1063,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1064,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1065,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1066,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1067,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1068,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1069,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1070,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1071,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1072,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1073,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1074,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/views.py",
      "content": "import logging\nlog = logging.getLogger(__name__)\n\nfrom pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1075,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1076,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        log.debug('In home view')\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1077,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/logging/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        log.debug('In hello view')\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1078,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1079,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/setup.py",
      "content": "requires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1080,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n)"
    },
    {
      "chunk_id": 1081,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1082,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1083,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/__init__.py",
      "content": "def my_function(param):\n    return param * 2"
    },
    {
      "chunk_id": 1084,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/__init__.py",
      "content": "def another_function():\n    print(\"Hello, World!\")"
    },
    {
      "chunk_id": 1085,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/__init__.py",
      "content": "def yet_another_function(x, y):\n    return x + y"
    },
    {
      "chunk_id": 1086,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/app.py",
      "content": "from waitress import serve\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1087,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/app.py",
      "content": "def hello_world(request):\n    print('Incoming request')\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1088,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/package/tutorial/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/')\n        config.add_view(hello_world, route_name='hello')\n        app = config.make_wsgi_app()\n    serve(app, host='0.0.0.0', port=6543)"
    },
    {
      "chunk_id": 1089,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1090,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/setup.py",
      "content": "requires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1091,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n]"
    },
    {
      "chunk_id": 1092,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1093,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1094,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/tutorial/__init__.py",
      "content": "def hello_world(request):\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1095,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/debugtoolbar/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('hello', '/')\n    config.add_view(hello_world, route_name='hello')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1096,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1097,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/setup.py",
      "content": "requires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1098,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n]"
    },
    {
      "chunk_id": 1099,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1100,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1101,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/__init__.py",
      "content": "def hello_world(request):\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1102,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('hello', '/')\n    config.add_view(hello_world, route_name='hello')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1103,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1104,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1105,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/unit_testing/tutorial/tests.py",
      "content": "def test_hello_world(self):\n        from tutorial import hello_world\n\n        request = testing.DummyRequest()\n        response = hello_world(request)\n        self.assertEqual(response.status_code, 200)"
    },
    {
      "chunk_id": 1106,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1107,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/setup.py",
      "content": "# List of dependencies installed via `pip install -e .`\n# by virtue of the Setuptools `install_requires` value below.\nrequires = [\n    'pyramid',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1108,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1109,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1110,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/tutorial/__init__.py",
      "content": "def hello_world(request):\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1111,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/ini/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('hello', '/')\n    config.add_view(hello_world, route_name='hello')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1112,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1113,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1114,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1115,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1116,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1117,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.add_route('home', '/')\n    config.add_route('plain', '/plain')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1118,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1119,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual(response.status, '302 Found')\n\n    def test_plain_without_name(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.plain()\n        self.assertIn(b'No Name Provided', response.body)\n\n    def test_plain_with_name(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        request.GET['name'] = 'Jane Doe'\n        inst = TutorialViews(request)\n        response = inst.plain()\n        self.assertIn(b'Jane Doe', response.body)"
    },
    {
      "chunk_id": 1120,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)\n\n    def test_plain_without_name(self):\n        res = self.testapp.get('/plain', status=200)\n        self.assertIn(b'No Name Provided', res.body)\n\n    def test_plain_with_name(self):\n        res = self.testapp.get('/plain?name=Jane%20Doe', status=200)\n        self.assertIn(b'Jane Doe', res.body)"
    },
    {
      "chunk_id": 1121,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/views.py",
      "content": "from pyramid.httpexceptions import HTTPFound\nfrom pyramid.response import Response\nfrom pyramid.view import view_config"
    },
    {
      "chunk_id": 1122,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/views.py",
      "content": "class TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1123,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return HTTPFound(location='/plain')"
    },
    {
      "chunk_id": 1124,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/request_response/tutorial/views.py",
      "content": "@view_config(route_name='plain')\n    def plain(self):\n        name = self.request.params.get('name', 'No Name Provided')\n\n        body = 'URL %s with name: %s' % (self.request.url, name)\n        return Response(\n            content_type='text/plain',\n            body=body\n        )"
    },
    {
      "chunk_id": 1125,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/hello_world/app.py",
      "content": "from waitress import serve\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1126,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/hello_world/app.py",
      "content": "def hello_world(request):\n    print('Incoming request')\n    return Response('<body><h1>Hello World!</h1></body>')"
    },
    {
      "chunk_id": 1127,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/hello_world/app.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/')\n        config.add_view(hello_world, route_name='hello')\n        app = config.make_wsgi_app()\n    serve(app, host='0.0.0.0', port=6543)"
    },
    {
      "chunk_id": 1128,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1129,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1130,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1131,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1132,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1133,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.add_static_view(name='static', path='tutorial:static')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1134,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1135,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1136,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1137,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1138,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1139,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1140,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1141,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/tests.py",
      "content": "def test_css(self):\n        res = self.testapp.get('/static/app.css', status=200)\n        self.assertIn(b'body', res.body)"
    },
    {
      "chunk_id": 1142,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1143,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1144,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1145,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/static_assets/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1146,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1147,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1148,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1149,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1150,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1151,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1152,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1153,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1154,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import home\n\n        request = testing.DummyRequest()\n        response = home(request)\n        # Our view now returns data\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1155,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import hello\n\n        request = testing.DummyRequest()\n        response = hello(request)\n        # Our view now returns data\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1156,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1157,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1158,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1159,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/views.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 1160,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/views.py",
      "content": "@view_config(route_name='home', renderer='home.pt')\ndef home(request):\n    return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1161,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/templating/tutorial/views.py",
      "content": "@view_config(route_name='hello', renderer='home.pt')\ndef hello(request):\n    return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1162,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1163,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1164,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1165,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1166,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1167,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy/{first}/{last}')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1168,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1169,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    \"\"\"Test cases for the Tutorial Views.\"\"\"\n    \n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['page_title'])"
    },
    {
      "chunk_id": 1170,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    \"\"\"Functional test cases for the Tutorial application.\"\"\"\n    \n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)\n\n    def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'TutorialViews - Home View', res.body)"
    },
    {
      "chunk_id": 1171,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1172,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@view_defaults(route_name='hello')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request\n        self.view_name = 'TutorialViews'"
    },
    {
      "chunk_id": 1173,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@property\n    def full_name(self):\n        first = self.request.matchdict['first']\n        last = self.request.matchdict['last']\n        return first + ' ' + last"
    },
    {
      "chunk_id": 1174,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@view_config(route_name='home', renderer='home.pt')\n    def home(self):\n        return {'page_title': 'Home View'}"
    },
    {
      "chunk_id": 1175,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@view_config(renderer='hello.pt')\n    def hello(self):\n        return {'page_title': 'Hello View'}"
    },
    {
      "chunk_id": 1176,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@view_config(request_method='POST', renderer='edit.pt')\n    def edit(self):\n        new_name = self.request.params['new_name']\n        return {'page_title': 'Edit View', 'new_name': new_name}"
    },
    {
      "chunk_id": 1177,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/more_view_classes/tutorial/views.py",
      "content": "@view_config(request_method='POST', request_param='form.delete',\n                 renderer='delete.pt')\n    def delete(self):\n        print ('Deleted')\n        return {'page_title': 'Delete View'}"
    },
    {
      "chunk_id": 1178,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1179,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'pyramid_jinja2',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1180,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1181,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1182,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1183,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_jinja2')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1184,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1185,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    \"\"\"Test cases for the Tutorial Views.\"\"\"\n    \n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1186,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1187,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1188,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    \"\"\"Functional test cases for the Tutorial application.\"\"\"\n    \n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1189,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1190,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1191,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1192,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/views.py",
      "content": "@view_defaults(renderer='home.jinja2')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1193,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1194,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/jinja2/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1195,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1196,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1197,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1198,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1199,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.session import SignedCookieSessionFactory"
    },
    {
      "chunk_id": 1200,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    my_session_factory = SignedCookieSessionFactory(\n        'itsaseekreet')\n    config = Configurator(settings=settings,\n                          session_factory=my_session_factory)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1201,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1202,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    \"\"\"Test cases for the Tutorial Views.\"\"\"\n    \n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()"
    },
    {
      "chunk_id": 1203,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual('Home View', response['name'])"
    },
    {
      "chunk_id": 1204,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "def test_hello(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        inst = TutorialViews(request)\n        response = inst.hello()\n        self.assertEqual('Hello View', response['name'])"
    },
    {
      "chunk_id": 1205,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    \"\"\"Functional test cases for the Tutorial application.\"\"\"\n    \n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)"
    },
    {
      "chunk_id": 1206,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<h1>Hi Home View', res.body)"
    },
    {
      "chunk_id": 1207,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/tests.py",
      "content": "def test_hello(self):\n        res = self.testapp.get('/howdy', status=200)\n        self.assertIn(b'<h1>Hi Hello View', res.body)"
    },
    {
      "chunk_id": 1208,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1209,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1210,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/views.py",
      "content": "@property\n    def counter(self):\n        session = self.request.session\n        if 'counter' in session:\n            session['counter'] += 1\n        else:\n            session['counter'] = 1\n\n        return session['counter']"
    },
    {
      "chunk_id": 1211,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1212,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/sessions/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1213,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1214,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/setup.py",
      "content": "requires = [\n    'bcrypt',\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1215,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1216,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1217,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid.session import SignedCookieSessionFactory\n\nfrom .security import SecurityPolicy"
    },
    {
      "chunk_id": 1218,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    my_session_factory = SignedCookieSessionFactory('itsaseekreet')\n    config = Configurator(\n        settings=settings,\n        root_factory='.resources.Root',\n        session_factory=my_session_factory,\n    )\n    config.include('pyramid_chameleon')\n\n    config.set_security_policy(\n        SecurityPolicy(\n            secret=settings['tutorial.secret'],\n        ),\n    )\n\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.add_route('login', '/login')\n    config.add_route('logout', '/logout')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1219,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/resources.py",
      "content": "from pyramid.authorization import Allow, Everyone"
    },
    {
      "chunk_id": 1220,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/resources.py",
      "content": "class Root:\n    __acl__ = [(Allow, Everyone, 'view'),\n               (Allow, 'group:editors', 'edit')]\n\n    def __init__(self, request):\n        pass"
    },
    {
      "chunk_id": 1221,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "import bcrypt\nfrom pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.authorization import (\n    ACLHelper,\n    Authenticated,\n    Everyone,\n)"
    },
    {
      "chunk_id": 1222,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def hash_password(pw):\n    pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n    return pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1223,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def check_password(pw, hashed_pw):\n    expected_hash = hashed_pw.encode('utf8')\n    return bcrypt.checkpw(pw.encode('utf8'), expected_hash)"
    },
    {
      "chunk_id": 1224,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "USERS = {'editor': hash_password('editor'),\n         'viewer': hash_password('viewer')}\nGROUPS = {'editor': ['group:editors']}"
    },
    {
      "chunk_id": 1225,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "class SecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret=secret)\n        self.acl = ACLHelper()"
    },
    {
      "chunk_id": 1226,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is not None and identity['userid'] in USERS:\n            return identity"
    },
    {
      "chunk_id": 1227,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        identity = self.identity(request)\n        if identity is not None:\n            return identity['userid']"
    },
    {
      "chunk_id": 1228,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1229,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1230,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def permits(self, request, context, permission):\n        principals = self.effective_principals(request)\n        return self.acl.permits(context, principals, permission)"
    },
    {
      "chunk_id": 1231,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/security.py",
      "content": "def effective_principals(self, request):\n        principals = [Everyone]\n        userid = self.authenticated_userid(request)\n        if userid is not None:\n            principals += [Authenticated, 'u:' + userid]\n            principals += GROUPS.get(userid, [])\n        return principals"
    },
    {
      "chunk_id": 1232,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "from pyramid.httpexceptions import HTTPFound\nfrom pyramid.security import (\n    remember,\n    forget,\n)\n\nfrom pyramid.view import (\n    view_config,\n    view_defaults,\n    forbidden_view_config\n)\n\nfrom .security import (\n    USERS,\n    check_password\n)"
    },
    {
      "chunk_id": 1233,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request\n        self.logged_in = request.authenticated_userid"
    },
    {
      "chunk_id": 1234,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1235,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@view_config(route_name='hello', permission='edit')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1236,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@forbidden_view_config()\n    def forbidden(self):\n        request = self.request\n        session = request.session\n        if request.matched_route is not None:\n            session['came_from'] = {\n                'route_name': request.matched_route.name,\n                'route_kwargs': request.matchdict,\n            }\n            if request.authenticated_userid is not None:\n                session['message'] = (\n                    f'User {request.authenticated_userid} is not allowed '\n                    f'to see this resource.  Please log in as another user.'\n                )\n        else:\n            if 'came_from' in session:\n                del session['came_from']\n\n        return HTTPFound(request.route_url('login'))"
    },
    {
      "chunk_id": 1237,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@view_config(route_name='login', renderer='login.pt')\n    def login(self):\n        request = self.request\n        session = request.session\n        login_url = request.route_url('login')\n        came_from = session.get('came_from')\n        message = session.get('message', '')\n        login = ''\n        password = ''\n\n        if 'form.submitted' in request.params:\n            login = request.params['login']\n            password = request.params['password']\n            hashed_pw = USERS.get(login)\n            if hashed_pw and check_password(password, hashed_pw):\n                headers = remember(request, login)\n\n                if came_from is not None:\n                    return_to = request.route_url(\n                        came_from['route_name'], **came_from['route_kwargs'],\n                    )\n                else:\n                    return_to = request.route_url('home')\n\n                return HTTPFound(location=return_to, headers=headers)\n\n            message = 'Failed login'\n\n        return dict(\n            name='Login',\n            message=message,\n            url=request.application_url + '/login',\n            login=login,\n            password=password,\n        )"
    },
    {
      "chunk_id": 1238,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authorization/tutorial/views.py",
      "content": "@view_config(route_name='logout')\n    def logout(self):\n        request = self.request\n        headers = forget(request)\n        url = request.route_url('home')\n        return HTTPFound(location=url,\n                         headers=headers)"
    },
    {
      "chunk_id": 1239,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1240,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/setup.py",
      "content": "requires = [\n    'deform',\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1241,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1242,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1243,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1244,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('wiki_view', '/')\n    config.add_route('wikipage_add', '/add')\n    config.add_route('wikipage_view', '/{uid}')\n    config.add_route('wikipage_edit', '/{uid}/edit')\n    config.add_static_view('deform_static', 'deform:static/')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1245,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1246,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_home(self):\n        from .views import WikiViews\n\n        request = testing.DummyRequest()\n        inst = WikiViews(request)\n        response = inst.wiki_view()\n        self.assertEqual(len(response['pages']), 3)"
    },
    {
      "chunk_id": 1247,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from tutorial import main\n\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_home(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'<title>Wiki: View</title>', res.body)\n\n    def test_add_page(self):\n        res = self.testapp.get('/add', status=200)\n        self.assertIn(b'<h1>Wiki</h1>', res.body)\n\n    def test_edit_page(self):\n        res = self.testapp.get('/101/edit', status=200)\n        self.assertIn(b'<h1>Wiki</h1>', res.body)\n\n    def test_post_wiki(self):\n        self.testapp.post('/add', {\n            \"title\": \"New Title\",\n            \"body\": \"<p>New Body</p>\",\n            \"submit\": \"submit\"\n        }, status=302)\n\n        res = self.testapp.get('/103', status=200)\n        self.assertIn(b'<h1>New Title</h1>', res.body)\n        self.assertIn(b'<p>New Body</p>', res.body)\n\n    def test_edit_wiki(self):\n        self.testapp.post('/102/edit', {\n            \"title\": \"New Title\",\n            \"body\": \"<p>New Body</p>\",\n            \"submit\": \"submit\"\n        }, status=302)\n\n        res = self.testapp.get('/102', status=200)\n        self.assertIn(b'<h1>New Title</h1>', res.body)\n        self.assertIn(b'<p>New Body</p>', res.body)"
    },
    {
      "chunk_id": 1248,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "import colander\nimport deform.widget\n\nfrom pyramid.httpexceptions import HTTPFound\nfrom pyramid.view import view_config"
    },
    {
      "chunk_id": 1249,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "pages = {\n    '100': dict(uid='100', title='Page 100', body='<em>100</em>'),\n    '101': dict(uid='101', title='Page 101', body='<em>101</em>'),\n    '102': dict(uid='102', title='Page 102', body='<em>102</em>')\n}"
    },
    {
      "chunk_id": 1250,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "class WikiPage(colander.MappingSchema):\n    \"\"\"Schema for a wiki page.\"\"\"\n    title = colander.SchemaNode(colander.String())\n    body = colander.SchemaNode(\n        colander.String(),\n        widget=deform.widget.RichTextWidget()\n    )"
    },
    {
      "chunk_id": 1251,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "class WikiViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1252,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@property\n    def wiki_form(self):\n        schema = WikiPage()\n        return deform.Form(schema, buttons=('submit',))"
    },
    {
      "chunk_id": 1253,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@property\n    def reqts(self):\n        return self.wiki_form.get_widget_resources()"
    },
    {
      "chunk_id": 1254,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@view_config(route_name='wiki_view', renderer='wiki_view.pt')\n    def wiki_view(self):\n        return dict(pages=pages.values())"
    },
    {
      "chunk_id": 1255,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_add',\n                 renderer='wikipage_addedit.pt')\n    def wikipage_add(self):\n        form = self.wiki_form.render()\n\n        if 'submit' in self.request.params:\n            controls = self.request.POST.items()\n            try:\n                appstruct = self.wiki_form.validate(controls)\n            except deform.ValidationFailure as e:\n                # Form is NOT valid\n                return dict(form=e.render())\n\n            # Form is valid, make a new identifier and add to list\n            last_uid = int(sorted(pages.keys())[-1])\n            new_uid = str(last_uid + 1)\n            pages[new_uid] = dict(\n                uid=new_uid, title=appstruct['title'],\n                body=appstruct['body']\n            )\n\n            # Now visit new page\n            url = self.request.route_url('wikipage_view', uid=new_uid)\n            return HTTPFound(url)\n\n        return dict(form=form)"
    },
    {
      "chunk_id": 1256,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_view', renderer='wikipage_view.pt')\n    def wikipage_view(self):\n        uid = self.request.matchdict['uid']\n        page = pages[uid]\n        return dict(page=page)"
    },
    {
      "chunk_id": 1257,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/forms/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_edit',\n                 renderer='wikipage_addedit.pt')\n    def wikipage_edit(self):\n        uid = self.request.matchdict['uid']\n        page = pages[uid]\n\n        wiki_form = self.wiki_form\n\n        if 'submit' in self.request.params:\n            controls = self.request.POST.items()\n            try:\n                appstruct = wiki_form.validate(controls)\n            except deform.ValidationFailure as e:\n                return dict(page=page, form=e.render())\n\n            # Change the content and redirect to the view\n            page['title'] = appstruct['title']\n            page['body'] = appstruct['body']\n\n            url = self.request.route_url('wikipage_view',\n                                         uid=page['uid'])\n            return HTTPFound(url)\n\n        form = wiki_form.render(page)\n\n        return dict(page=page, form=form)"
    },
    {
      "chunk_id": 1258,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1259,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/setup.py",
      "content": "requires = [\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1260,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1261,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1262,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1263,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n    config.add_route('home', '/howdy/{first}/{last}')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1264,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/tests.py",
      "content": "import unittest\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1265,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/tests.py",
      "content": "class TutorialViewTests(unittest.TestCase):\n    \"\"\"Test cases for the TutorialView.\"\"\"\n    \n    def setUp(self):\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        testing.tearDown()\n\n    def test_home(self):\n        from .views import TutorialViews\n\n        request = testing.DummyRequest()\n        request.matchdict['first'] = 'First'\n        request.matchdict['last'] = 'Last'\n        inst = TutorialViews(request)\n        response = inst.home()\n        self.assertEqual(response['first'], 'First')\n        self.assertEqual(response['last'], 'Last')"
    },
    {
      "chunk_id": 1266,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/tests.py",
      "content": "class TutorialFunctionalTests(unittest.TestCase):\n    \"\"\"Functional test cases for the tutorial application.\"\"\"\n    \n    def setUp(self):\n        from tutorial import main\n        app = main({})\n        from webtest import TestApp\n\n        self.testapp = TestApp(app)\n\n    def test_home(self):\n        res = self.testapp.get('/howdy/Jane/Doe', status=200)\n        self.assertIn(b'Jane', res.body)\n        self.assertIn(b'Doe', res.body)"
    },
    {
      "chunk_id": 1267,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/views.py",
      "content": "from pyramid.view import (\n    view_config,\n    view_defaults\n)"
    },
    {
      "chunk_id": 1268,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1269,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/routing/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        first = self.request.matchdict['first']\n        last = self.request.matchdict['last']\n        return {\n            'name': 'Home View',\n            'first': first,\n            'last': last\n        }"
    },
    {
      "chunk_id": 1270,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/setup.py",
      "content": "import os"
    },
    {
      "chunk_id": 1271,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/setup.py",
      "content": "from setuptools import setup, find_packages"
    },
    {
      "chunk_id": 1272,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/setup.py",
      "content": "here = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()\n\nrequires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n]\n\ntests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 1273,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/setup.py",
      "content": "setup(\n    name='cc_starter',\n    version='0.0',\n    description='cc_starter',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = cc_starter:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1274,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1275,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1276,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 1277,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1278,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1279,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/views/notfound.py",
      "content": "@notfound_view_config(renderer='cc_starter:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1280,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/views/default.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 1281,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/cookiecutters/cc_starter/views/default.py",
      "content": "@view_config(route_name='home', renderer='cc_starter:templates/mytemplate.jinja2')\ndef my_view(request):\n    return {'project': 'cc_starter'}"
    },
    {
      "chunk_id": 1282,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1283,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/setup.py",
      "content": "requires = [\n    'deform',\n    'pyramid',\n    'pyramid_chameleon',\n    'pyramid_tm',\n    'sqlalchemy',\n    'waitress',\n    'zope.sqlalchemy',\n]"
    },
    {
      "chunk_id": 1284,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1285,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n        'console_scripts': [\n            'initialize_tutorial_db = tutorial.initialize_db:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1286,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\n\nfrom sqlalchemy import engine_from_config\n\nfrom .models import DBSession, Base"
    },
    {
      "chunk_id": 1287,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    engine = engine_from_config(settings, 'sqlalchemy.')\n    DBSession.configure(bind=engine)\n\n    config = Configurator(settings=settings,\n                          root_factory='tutorial.models.Root')\n    config.include('pyramid_chameleon')\n    config.add_route('wiki_view', '/')\n    config.add_route('wikipage_add', '/add')\n    config.add_route('wikipage_view', '/{uid}')\n    config.add_route('wikipage_edit', '/{uid}/edit')\n    config.add_static_view('deform_static', 'deform:static/')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1288,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/tests.py",
      "content": "import unittest\nimport transaction\n\nfrom pyramid import testing"
    },
    {
      "chunk_id": 1289,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/tests.py",
      "content": "def _initTestingDB():\n    from sqlalchemy import create_engine\n    from .models import (\n        DBSession,\n        Page,\n        Base\n        )\n    engine = create_engine('sqlite://')\n    Base.metadata.create_all(engine)\n    DBSession.configure(bind=engine)\n    with transaction.manager:\n        model = Page(title='FrontPage', body='This is the front page')\n        DBSession.add(model)\n    return DBSession"
    },
    {
      "chunk_id": 1290,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/tests.py",
      "content": "class WikiViewTests(unittest.TestCase):\n    def setUp(self):\n        self.session = _initTestingDB()\n        self.config = testing.setUp()\n\n    def tearDown(self):\n        self.session.remove()\n        testing.tearDown()\n\n    def test_wiki_view(self):\n        from tutorial.views import WikiViews\n\n        request = testing.DummyRequest()\n        inst = WikiViews(request)\n        response = inst.wiki_view()\n        self.assertEqual(response['title'], 'Wiki View')"
    },
    {
      "chunk_id": 1291,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/tests.py",
      "content": "class WikiFunctionalTests(unittest.TestCase):\n    def setUp(self):\n        from pyramid.paster import get_app\n        app = get_app('development.ini')\n        from webtest import TestApp\n        self.testapp = TestApp(app)\n\n    def tearDown(self):\n        from .models import DBSession\n        DBSession.remove()\n\n    def test_it(self):\n        res = self.testapp.get('/', status=200)\n        self.assertIn(b'Wiki: View', res.body)\n        res = self.testapp.get('/add', status=200)\n        self.assertIn(b'Add/Edit', res.body)"
    },
    {
      "chunk_id": 1292,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/initialize_db.py",
      "content": "import os\nimport sys\nimport transaction\n\nfrom sqlalchemy import engine_from_config\n\nfrom pyramid.paster import (\n    get_appsettings,\n    setup_logging,\n    )\n\nfrom .models import (\n    DBSession,\n    Page,\n    Base,\n    )"
    },
    {
      "chunk_id": 1293,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/initialize_db.py",
      "content": "def usage(argv):\n    cmd = os.path.basename(argv[0])\n    print('usage: %s <config_uri>\\n'\n          '(example: \"%s development.ini\")' % (cmd, cmd))\n    sys.exit(1)"
    },
    {
      "chunk_id": 1294,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    if len(argv) != 2:\n        usage(argv)\n    config_uri = argv[1]\n    setup_logging(config_uri)\n    settings = get_appsettings(config_uri)\n    engine = engine_from_config(settings, 'sqlalchemy.')\n    DBSession.configure(bind=engine)\n    Base.metadata.create_all(engine)\n    with transaction.manager:\n        model = Page(title='Root', body='<p>Root</p>')\n        DBSession.add(model)"
    },
    {
      "chunk_id": 1295,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/models.py",
      "content": "from pyramid.authorization import Allow, Everyone\n\nfrom sqlalchemy import (\n    Column,\n    Integer,\n    Text,\n    )\n\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom sqlalchemy.orm import (\n    scoped_session,\n    sessionmaker,\n    )\n\nfrom zope.sqlalchemy import register\n\nDBSession = scoped_session(sessionmaker())\nregister(DBSession)\nBase = declarative_base()"
    },
    {
      "chunk_id": 1296,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/models.py",
      "content": "class Page(Base):\n    __tablename__ = 'wikipages'\n    uid = Column(Integer, primary_key=True)\n    title = Column(Text, unique=True)\n    body = Column(Text)"
    },
    {
      "chunk_id": 1297,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/models.py",
      "content": "class Root:\n    __acl__ = [(Allow, Everyone, 'view'),\n               (Allow, 'group:editors', 'edit')]\n\n    def __init__(self, request):\n        pass"
    },
    {
      "chunk_id": 1298,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "import colander\nimport deform.widget\n\nfrom pyramid.httpexceptions import HTTPFound\nfrom pyramid.view import view_config\n\nfrom .models import DBSession, Page"
    },
    {
      "chunk_id": 1299,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "class WikiPage(colander.MappingSchema):\n    title = colander.SchemaNode(colander.String())\n    body = colander.SchemaNode(\n        colander.String(),\n        widget=deform.widget.RichTextWidget()\n    )"
    },
    {
      "chunk_id": 1300,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "class WikiViews:\n    def __init__(self, request):\n        self.request = request"
    },
    {
      "chunk_id": 1301,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@property\n    def wiki_form(self):\n        schema = WikiPage()\n        return deform.Form(schema, buttons=('submit',))"
    },
    {
      "chunk_id": 1302,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@property\n    def reqts(self):\n        return self.wiki_form.get_widget_resources()"
    },
    {
      "chunk_id": 1303,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@view_config(route_name='wiki_view', renderer='wiki_view.pt')\n    def wiki_view(self):\n        pages = DBSession.query(Page).order_by(Page.title)\n        return dict(title='Wiki View', pages=pages)"
    },
    {
      "chunk_id": 1304,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_add',\n                 renderer='wikipage_addedit.pt')\n    def wikipage_add(self):\n        form = self.wiki_form.render()\n\n        if 'submit' in self.request.params:\n            controls = self.request.POST.items()\n            try:\n                appstruct = self.wiki_form.validate(controls)\n            except deform.ValidationFailure as e:\n                # Form is NOT valid\n                return dict(form=e.render())\n\n            # Add a new page to the database\n            new_title = appstruct['title']\n            new_body = appstruct['body']\n            DBSession.add(Page(title=new_title, body=new_body))\n\n            # Get the new ID and redirect\n            page = DBSession.query(Page).filter_by(title=new_title).one()\n            new_uid = page.uid\n\n            url = self.request.route_url('wikipage_view', uid=new_uid)\n            return HTTPFound(url)\n\n        return dict(form=form)"
    },
    {
      "chunk_id": 1305,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_view', renderer='wikipage_view.pt')\n    def wikipage_view(self):\n        uid = int(self.request.matchdict['uid'])\n        page = DBSession.query(Page).filter_by(uid=uid).one()\n        return dict(page=page)"
    },
    {
      "chunk_id": 1306,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/databases/tutorial/views.py",
      "content": "@view_config(route_name='wikipage_edit',\n                 renderer='wikipage_addedit.pt')\n    def wikipage_edit(self):\n        uid = int(self.request.matchdict['uid'])\n        page = DBSession.query(Page).filter_by(uid=uid).one()\n\n        wiki_form = self.wiki_form\n\n        if 'submit' in self.request.params:\n            controls = self.request.POST.items()\n            try:\n                appstruct = wiki_form.validate(controls)\n            except deform.ValidationFailure as e:\n                return dict(page=page, form=e.render())\n\n            # Change the content and redirect to the view\n            page.title = appstruct['title']\n            page.body = appstruct['body']\n            url = self.request.route_url('wikipage_view', uid=uid)\n            return HTTPFound(url)\n\n        form = self.wiki_form.render(dict(\n            uid=page.uid, title=page.title, body=page.body)\n        )\n\n        return dict(page=page, form=form)"
    },
    {
      "chunk_id": 1307,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/setup.py",
      "content": "from setuptools import setup"
    },
    {
      "chunk_id": 1308,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/setup.py",
      "content": "requires = [\n    'bcrypt',\n    'pyramid',\n    'pyramid_chameleon',\n    'waitress',\n]"
    },
    {
      "chunk_id": 1309,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/setup.py",
      "content": "dev_requires = [\n    'pyramid_debugtoolbar',\n    'pytest',\n    'webtest',\n]"
    },
    {
      "chunk_id": 1310,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/setup.py",
      "content": "setup(\n    name='tutorial',\n    install_requires=requires,\n    extras_require={\n        'dev': dev_requires,\n    },\n    entry_points={\n        'paste.app_factory': [\n            'main = tutorial:main'\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1311,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\n\nfrom .security import SecurityPolicy"
    },
    {
      "chunk_id": 1312,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    config = Configurator(settings=settings)\n    config.include('pyramid_chameleon')\n\n    config.set_security_policy(\n        SecurityPolicy(\n            secret=settings['tutorial.secret'],\n        ),\n    )\n\n    config.add_route('home', '/')\n    config.add_route('hello', '/howdy')\n    config.add_route('login', '/login')\n    config.add_route('logout', '/logout')\n    config.scan('.views')\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1313,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "import bcrypt\nfrom pyramid.authentication import AuthTktCookieHelper"
    },
    {
      "chunk_id": 1314,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def hash_password(pw):\n    pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n    return pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1315,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def check_password(pw, hashed_pw):\n    expected_hash = hashed_pw.encode('utf8')\n    return bcrypt.checkpw(pw.encode('utf8'), expected_hash)"
    },
    {
      "chunk_id": 1316,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "USERS = {'editor': hash_password('editor'),\n         'viewer': hash_password('viewer')}"
    },
    {
      "chunk_id": 1317,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "class SecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret=secret)"
    },
    {
      "chunk_id": 1318,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is not None and identity['userid'] in USERS:\n            return identity"
    },
    {
      "chunk_id": 1319,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        identity = self.identity(request)\n        if identity is not None:\n            return identity['userid']"
    },
    {
      "chunk_id": 1320,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1321,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1322,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "from pyramid.httpexceptions import HTTPFound\nfrom pyramid.security import (\n    remember,\n    forget,\n    )\n\nfrom pyramid.view import (\n    view_config,\n    view_defaults\n    )\n\nfrom .security import (\n    USERS,\n    check_password\n)"
    },
    {
      "chunk_id": 1323,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "@view_defaults(renderer='home.pt')\nclass TutorialViews:\n    def __init__(self, request):\n        self.request = request\n        self.logged_in = request.authenticated_userid"
    },
    {
      "chunk_id": 1324,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "@view_config(route_name='home')\n    def home(self):\n        return {'name': 'Home View'}"
    },
    {
      "chunk_id": 1325,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "@view_config(route_name='hello')\n    def hello(self):\n        return {'name': 'Hello View'}"
    },
    {
      "chunk_id": 1326,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "@view_config(route_name='login', renderer='login.pt')\n    def login(self):\n        request = self.request\n        login_url = request.route_url('login')\n        message = ''\n        login = ''\n        password = ''\n        if 'form.submitted' in request.params:\n            login = request.params['login']\n            password = request.params['password']\n            hashed_pw = USERS.get(login)\n            if hashed_pw and check_password(password, hashed_pw):\n                headers = remember(request, login)\n                return HTTPFound(location=request.route_url(\"home\"),\n                                 headers=headers)\n            message = 'Failed login'\n\n        return dict(\n            name='Login',\n            message=message,\n            url=request.application_url + '/login',\n            login=login,\n            password=password,\n        )"
    },
    {
      "chunk_id": 1327,
      "source": "__internal__/data_repo/pyramid/docs/quick_tutorial/authentication/tutorial/views.py",
      "content": "@view_config(route_name='logout')\n    def logout(self):\n        request = self.request\n        headers = forget(request)\n        url = request.route_url('home')\n        return HTTPFound(location=url,\n                         headers=headers)"
    },
    {
      "chunk_id": 1328,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1329,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.security')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1330,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1331,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1332,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/security.py",
      "content": "from pyramid.csrf import CookieCSRFStoragePolicy"
    },
    {
      "chunk_id": 1333,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/security.py",
      "content": "def includeme(config):\n    config.set_csrf_storage_policy(CookieCSRFStoragePolicy())\n    config.set_default_csrf_options(require_csrf=True)"
    },
    {
      "chunk_id": 1334,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('view_wiki', '/')\n    config.add_route('view_page', '/{pagename}')\n    config.add_route('add_page', '/add_page/{pagename}')\n    config.add_route('edit_page', '/{pagename}/edit_page')"
    },
    {
      "chunk_id": 1335,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1336,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1337,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1338,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom html import escape\nfrom pyramid.httpexceptions import (\n    HTTPNotFound,\n    HTTPSeeOther,\n)\nfrom pyramid.view import view_config\nimport re\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1339,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/default.py",
      "content": "@view_config(route_name='view_wiki')\ndef view_wiki(request):\n    next_url = request.route_url('view_page', pagename='FrontPage')\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1340,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/default.py",
      "content": "@view_config(route_name='view_page', renderer='tutorial:templates/view.jinja2')\ndef view_page(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound('No such page')\n\n    def add_link(match):\n        word = match.group(1)\n        exists = request.dbsession.execute(\n            sa.select(sa.exists(models.Page)).where(models.Page.name == word)\n        ).scalar()\n        if exists:\n            view_url = request.route_url('view_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (view_url, escape(word))\n        else:\n            add_url = request.route_url('add_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (add_url, escape(word))\n\n    content = publish_parts(page.data, writer_name='html')['html_body']\n    content = wikiwords.sub(add_link, content)\n    edit_url = request.route_url('edit_page', pagename=page.name)\n    return dict(page=page, content=content, edit_url=edit_url)"
    },
    {
      "chunk_id": 1341,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/default.py",
      "content": "@view_config(route_name='edit_page', renderer='tutorial:templates/edit.jinja2')\ndef edit_page(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound('No such page')\n    if request.method == 'POST':\n        page.data = request.params['body']\n        next_url = request.route_url('view_page', pagename=page.name)\n        return HTTPSeeOther(location=next_url)\n    return dict(\n        pagename=page.name,\n        pagedata=page.data,\n        save_url=request.route_url('edit_page', pagename=page.name),\n    )"
    },
    {
      "chunk_id": 1342,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/views/default.py",
      "content": "@view_config(route_name='add_page', renderer='tutorial:templates/edit.jinja2')\ndef add_page(request):\n    pagename = request.matchdict['pagename']\n    exists = request.dbsession.execute(\n        sa.select(sa.exists(models.Page)).where(models.Page.name == pagename)\n    ).scalar()\n    if exists:\n        next_url = request.route_url('edit_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    if request.method == 'POST':\n        body = request.params['body']\n        creator = request.dbsession.scalars(\n            sa.select(models.User).where(models.User.name == 'editor')\n        ).one()\n        page = models.Page(name=pagename, data=body, creator=creator)\n        request.dbsession.add(page)\n        next_url = request.route_url('view_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    save_url = request.route_url('add_page', pagename=pagename)\n    return dict(pagename=pagename, pagedata='', save_url=save_url)"
    },
    {
      "chunk_id": 1343,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .page import Page  # flake8: noqa\nfrom .user import User  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1344,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1345,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1346,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1347,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1348,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1349,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    \"\"\"Recommended naming convention used by Alembic, as various different\n    database providers will autogenerate vastly different names making\n    migrations more difficult.\n    See: https://alembic.sqlalchemy.org/en/latest/naming.html\"\"\"\n    \n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1350,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/user.py",
      "content": "import bcrypt\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List, Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1351,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/user.py",
      "content": "class User(Base):\n    \"\"\" The SQLAlchemy declarative model class for a User object. \"\"\"\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    role: Mapped[str]\n    password_hash: Mapped[Optional[str]]\n    created_pages: Mapped[List['Page']] = relationship(back_populates='creator')"
    },
    {
      "chunk_id": 1352,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/user.py",
      "content": "def set_password(self, pw):\n        pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n        self.password_hash = pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1353,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/user.py",
      "content": "def check_password(self, pw):\n        if self.password_hash is not None:\n            expected_hash = self.password_hash.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False"
    },
    {
      "chunk_id": 1354,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/page.py",
      "content": "import bcrypt\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1355,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/models/page.py",
      "content": "class Page(Base):\n    \"\"\" The SQLAlchemy declarative model class for a Page object. \"\"\"\n    __tablename__ = 'pages'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    data: Mapped[str]\n\n    creator_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    creator: Mapped['User'] = relationship(back_populates='created_pages')"
    },
    {
      "chunk_id": 1356,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1357,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1358,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1359,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1360,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1361,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1362,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1363,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1364,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1365,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1366,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1367,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "\"\"\"\nuse new models Page and User\n\nRevision ID: 07f9d6b626b2\nRevises: 4b6614165904\nCreate Date: 2024-02-04 14:39:12.885858\n\n\"\"\""
    },
    {
      "chunk_id": 1368,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '07f9d6b626b2'\ndown_revision = '4b6614165904'\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1369,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('role', sa.String(), nullable=False),\n    sa.Column('password_hash', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),\n    sa.UniqueConstraint('name', name=op.f('uq_users_name'))\n    )\n    op.create_table('pages',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('data', sa.String(), nullable=False),\n    sa.Column('creator_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], name=op.f('fk_pages_creator_id_users')),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_pages')),\n    sa.UniqueConstraint('name', name=op.f('uq_pages_name'))\n    )\n    op.drop_index('my_index', table_name='models')\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1370,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(), nullable=True),\n    sa.Column('value', sa.INTEGER(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name='pk_models')\n    )\n    op.create_index('my_index', 'models', ['name'], unique=1)\n    op.drop_table('pages')\n    op.drop_table('users')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1371,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1372,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1373,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1374,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1375,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1376,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1377,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    editor = models.User(name='editor', role='editor')\n    editor.set_password('editor')\n    dbsession.add(editor)\n\n    basic = models.User(name='basic', role='basic')\n    basic.set_password('basic')\n    dbsession.add(basic)\n\n    page = models.Page(\n        name='FrontPage',\n        creator=editor,\n        data='This is the front page',\n    )\n    dbsession.add(page)"
    },
    {
      "chunk_id": 1378,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1379,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/views/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1380,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1381,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1382,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1383,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1384,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 1385,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1386,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1387,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1388,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One:\", self.value)"
    },
    {
      "chunk_id": 1389,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two:\", self.value)"
    },
    {
      "chunk_id": 1390,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "def standalone_function(param):\n    return param * 2"
    },
    {
      "chunk_id": 1391,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/__init__.py",
      "content": "if __name__ == \"__main__\":\n    obj = MyClass(10)\n    obj.method_one()\n    obj.method_two()\n    result = standalone_function(5)\n    print(\"Standalone Function Result:\", result)\n```"
    },
    {
      "chunk_id": 1392,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1393,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1394,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\nfrom pyramid.response import Response\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1395,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/default.py",
      "content": "@view_config(route_name='home', renderer='tutorial:templates/mytemplate.jinja2')\ndef my_view(request):\n    try:\n        query = sa.select(models.MyModel).where(models.MyModel.name == 'one')\n        one = request.dbsession.execute(query).scalar_one()\n    except sa.exc.SQLAlchemyError:\n        return Response(db_err_msg, content_type='text/plain', status=500)\n    return {'one': one, 'project': 'myproj'}"
    },
    {
      "chunk_id": 1396,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/views/default.py",
      "content": "db_err_msg = \"\"\"\\\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for descriptions and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n\nAfter you fix the problem, please restart the Pyramid application to\ntry it again.\n\"\"\""
    },
    {
      "chunk_id": 1397,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .page import Page  # flake8: noqa\nfrom .user import User  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1398,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1399,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1400,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1401,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1402,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1403,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1404,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/user.py",
      "content": "import bcrypt\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List, Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1405,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/user.py",
      "content": "class User(Base):\n    \"\"\" The SQLAlchemy declarative model class for a User object. \"\"\"\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    role: Mapped[str]\n    password_hash: Mapped[Optional[str]]"
    },
    {
      "chunk_id": 1406,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/user.py",
      "content": "def set_password(self, pw):\n        pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n        self.password_hash = pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1407,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/user.py",
      "content": "def check_password(self, pw):\n        if self.password_hash is not None:\n            expected_hash = self.password_hash.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False"
    },
    {
      "chunk_id": 1408,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/user.py",
      "content": "created_pages: Mapped[List['Page']] = relationship(back_populates='creator')"
    },
    {
      "chunk_id": 1409,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/page.py",
      "content": "import bcrypt\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1410,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/models/page.py",
      "content": "class Page(Base):\n    \"\"\" The SQLAlchemy declarative model class for a Page object. \"\"\"\n    __tablename__ = 'pages'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    data: Mapped[str]\n\n    creator_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    creator: Mapped['User'] = relationship(back_populates='created_pages')"
    },
    {
      "chunk_id": 1411,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1412,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1413,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1414,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1415,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1416,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1417,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1418,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1419,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1420,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1421,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1422,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "\"\"\"\nuse new models Page and User\n\nRevision ID: 07f9d6b626b2\nRevises: 4b6614165904\nCreate Date: 2024-02-04 14:39:12.885858\n\n\"\"\""
    },
    {
      "chunk_id": 1423,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '07f9d6b626b2'\ndown_revision = '4b6614165904'\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1424,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('role', sa.String(), nullable=False),\n    sa.Column('password_hash', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),\n    sa.UniqueConstraint('name', name=op.f('uq_users_name'))\n    )\n    op.create_table('pages',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('data', sa.String(), nullable=False),\n    sa.Column('creator_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], name=op.f('fk_pages_creator_id_users')),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_pages')),\n    sa.UniqueConstraint('name', name=op.f('uq_pages_name'))\n    )\n    op.drop_index('my_index', table_name='models')\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1425,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(), nullable=True),\n    sa.Column('value', sa.INTEGER(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name='pk_models')\n    )\n    op.create_index('my_index', 'models', ['name'], unique=1)\n    op.drop_table('pages')\n    op.drop_table('users')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1426,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1427,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1428,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1429,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1430,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1431,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1432,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    editor = models.User(name='editor', role='editor')\n    editor.set_password('editor')\n    dbsession.add(editor)\n\n    basic = models.User(name='basic', role='basic')\n    basic.set_password('basic')\n    dbsession.add(basic)\n\n    page = models.Page(\n        name='FrontPage',\n        creator=editor,\n        data='This is the front page',\n    )\n    dbsession.add(page)"
    },
    {
      "chunk_id": 1433,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1434,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/models/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1435,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1436,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1437,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1438,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1439,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 1440,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1441,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1442,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1443,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\nfrom pyramid.response import Response\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1444,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/default.py",
      "content": "@view_config(route_name='home', renderer='tutorial:templates/mytemplate.jinja2')\ndef my_view(request):\n    try:\n        query = sa.select(models.MyModel).where(models.MyModel.name == 'one')\n        one = request.dbsession.execute(query).scalar_one()\n    except sa.exc.SQLAlchemyError:\n        return Response(db_err_msg, content_type='text/plain', status=500)\n    return {'one': one, 'project': 'myproj'}"
    },
    {
      "chunk_id": 1445,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/views/default.py",
      "content": "db_err_msg = \"\"\"\\\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for descriptions and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n\nAfter you fix the problem, please restart the Pyramid application to\ntry it again.\n\"\"\""
    },
    {
      "chunk_id": 1446,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .mymodel import MyModel  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1447,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1448,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1449,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1450,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1451,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1452,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1453,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/mymodel.py",
      "content": "from sqlalchemy import Index\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom typing import Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1454,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/mymodel.py",
      "content": "class MyModel(Base):\n    \"\"\"MyModel represents a model in the database.\"\"\"\n    __tablename__ = 'models'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[Optional[str]]\n    value: Mapped[Optional[int]]"
    },
    {
      "chunk_id": 1455,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/models/mymodel.py",
      "content": "Index('my_index', MyModel.name, unique=True, mysql_length=255)"
    },
    {
      "chunk_id": 1456,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1457,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1458,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1459,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1460,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1461,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1462,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1463,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1464,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1465,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1466,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1467,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1468,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1469,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1470,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1471,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1472,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1473,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    model = models.mymodel.MyModel(name='one', value=1)\n    dbsession.add(model)"
    },
    {
      "chunk_id": 1474,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1475,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/installation/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1476,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1477,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1478,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1479,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1480,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 1481,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1482,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1483,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1484,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\nfrom pyramid.response import Response\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1485,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/default.py",
      "content": "@view_config(route_name='home', renderer='tutorial:templates/mytemplate.jinja2')\ndef my_view(request):\n    try:\n        query = sa.select(models.MyModel).where(models.MyModel.name == 'one')\n        one = request.dbsession.execute(query).scalar_one()\n    except sa.exc.SQLAlchemyError:\n        return Response(db_err_msg, content_type='text/plain', status=500)\n    return {'one': one, 'project': 'myproj'}"
    },
    {
      "chunk_id": 1486,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/views/default.py",
      "content": "db_err_msg = \"\"\"\\\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for descriptions and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n\nAfter you fix the problem, please restart the Pyramid application to\ntry it again.\n\"\"\""
    },
    {
      "chunk_id": 1487,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .mymodel import MyModel  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1488,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1489,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1490,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1491,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1492,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1493,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1494,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/mymodel.py",
      "content": "from sqlalchemy import Index\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom typing import Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1495,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/mymodel.py",
      "content": "class MyModel(Base):\n    \"\"\"MyModel represents a model in the database.\"\"\"\n    __tablename__ = 'models'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[Optional[str]]\n    value: Mapped[Optional[int]]"
    },
    {
      "chunk_id": 1496,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/models/mymodel.py",
      "content": "Index('my_index', MyModel.name, unique=True, mysql_length=255)"
    },
    {
      "chunk_id": 1497,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1498,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1499,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1500,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1501,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1502,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1503,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1504,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1505,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1506,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1507,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1508,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1509,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1510,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1511,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1512,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1513,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1514,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    model = models.mymodel.MyModel(name='one', value=1)\n    dbsession.add(model)"
    },
    {
      "chunk_id": 1515,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1516,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/basiclayout/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1517,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1518,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.security')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1519,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1520,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1521,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "from pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.authorization import (\n    ACLHelper,\n    Authenticated,\n    Everyone,\n)\nfrom pyramid.csrf import CookieCSRFStoragePolicy\nfrom pyramid.request import RequestLocalCache\n\nfrom . import models"
    },
    {
      "chunk_id": 1522,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "class MySecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret)\n        self.identity_cache = RequestLocalCache(self.load_identity)\n        self.acl = ACLHelper()"
    },
    {
      "chunk_id": 1523,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def load_identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is None:\n            return None\n\n        userid = identity['userid']\n        user = request.dbsession.get(models.User, userid)\n        return user"
    },
    {
      "chunk_id": 1524,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def identity(self, request):\n        return self.identity_cache.get_or_create(request)"
    },
    {
      "chunk_id": 1525,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        user = self.identity(request)\n        if user is not None:\n            return user.id"
    },
    {
      "chunk_id": 1526,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1527,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1528,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def permits(self, request, context, permission):\n        principals = self.effective_principals(request)\n        return self.acl.permits(context, principals, permission)"
    },
    {
      "chunk_id": 1529,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def effective_principals(self, request):\n        principals = [Everyone]\n        user = self.identity(request)\n        if user is not None:\n            principals.append(Authenticated)\n            principals.append('u:' + str(user.id))\n            principals.append('role:' + user.role)\n        return principals"
    },
    {
      "chunk_id": 1530,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/security.py",
      "content": "def includeme(config):\n    settings = config.get_settings()\n\n    config.set_csrf_storage_policy(CookieCSRFStoragePolicy())\n    config.set_default_csrf_options(require_csrf=True)\n\n    config.set_security_policy(MySecurityPolicy(settings['auth.secret']))"
    },
    {
      "chunk_id": 1531,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "from pyramid.authorization import (\n    Allow,\n    Everyone,\n)\nfrom pyramid.httpexceptions import (\n    HTTPNotFound,\n    HTTPSeeOther,\n)\nimport sqlalchemy as sa\n\nfrom . import models"
    },
    {
      "chunk_id": 1532,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('view_wiki', '/')\n    config.add_route('login', '/login')\n    config.add_route('logout', '/logout')\n    config.add_route('view_page', '/{pagename}', factory=page_factory)\n    config.add_route('add_page', '/add_page/{pagename}',\n                     factory=new_page_factory)\n    config.add_route('edit_page', '/{pagename}/edit_page',\n                     factory=page_factory)"
    },
    {
      "chunk_id": 1533,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "def new_page_factory(request):\n    pagename = request.matchdict['pagename']\n    exists = request.dbsession.execute(\n        sa.select(sa.exists(models.Page)).where(models.Page.name == pagename)\n    ).scalar()\n    if exists:\n        next_url = request.route_url('edit_page', pagename=pagename)\n        raise HTTPSeeOther(location=next_url)\n    return NewPage(pagename)"
    },
    {
      "chunk_id": 1534,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "class NewPage:\n    def __init__(self, pagename):\n        self.pagename = pagename\n\n    def __acl__(self):\n        return [\n            (Allow, 'role:editor', 'create'),\n            (Allow, 'role:basic', 'create'),\n        ]"
    },
    {
      "chunk_id": 1535,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "def page_factory(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound\n    return PageResource(page)"
    },
    {
      "chunk_id": 1536,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/routes.py",
      "content": "class PageResource:\n    def __init__(self, page):\n        self.page = page\n\n    def __acl__(self):\n        return [\n            (Allow, Everyone, 'view'),\n            (Allow, 'role:editor', 'edit'),\n            (Allow, 'u:' + str(self.page.creator_id), 'edit'),\n        ]"
    },
    {
      "chunk_id": 1537,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1538,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1539,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1540,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/auth.py",
      "content": "from pyramid.csrf import new_csrf_token\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.security import (\n    remember,\n    forget,\n)\nfrom pyramid.view import (\n    forbidden_view_config,\n    view_config,\n)\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1541,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/auth.py",
      "content": "@view_config(route_name='login', renderer='tutorial:templates/login.jinja2')\ndef login(request):\n    next_url = request.params.get('next', request.referrer)\n    if not next_url:\n        next_url = request.route_url('view_wiki')\n    message = ''\n    login = ''\n    if request.method == 'POST':\n        login = request.params['login']\n        password = request.params['password']\n        user = request.dbsession.scalars(\n            sa.select(models.User).where(models.User.name == login)\n        ).one_or_none()\n        if user is not None and user.check_password(password):\n            new_csrf_token(request)\n            headers = remember(request, user.id)\n            return HTTPSeeOther(location=next_url, headers=headers)\n        message = 'Failed login'\n        request.response.status = 400\n\n    return dict(\n        message=message,\n        url=request.route_url('login'),\n        next_url=next_url,\n        login=login,\n    )"
    },
    {
      "chunk_id": 1542,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/auth.py",
      "content": "@view_config(route_name='logout')\ndef logout(request):\n    next_url = request.route_url('view_wiki')\n    if request.method == 'POST':\n        new_csrf_token(request)\n        headers = forget(request)\n        return HTTPSeeOther(location=next_url, headers=headers)\n\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1543,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/auth.py",
      "content": "@forbidden_view_config(renderer='tutorial:templates/403.jinja2')\ndef forbidden_view(exc, request):\n    if not request.is_authenticated:\n        next_url = request.route_url('login', _query={'next': request.url})\n        return HTTPSeeOther(location=next_url)\n\n    request.response.status = 403\n    return {}"
    },
    {
      "chunk_id": 1544,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom html import escape\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.view import view_config\nimport re\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1545,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "wikiwords = re.compile(r\"\\b([A-Z]\\w+[A-Z]+\\w+)\")"
    },
    {
      "chunk_id": 1546,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "@view_config(route_name='view_wiki')\ndef view_wiki(request):\n    next_url = request.route_url('view_page', pagename='FrontPage')\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1547,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "@view_config(route_name='view_page', renderer='tutorial:templates/view.jinja2',\n             permission='view')\ndef view_page(request):\n    page = request.context.page\n\n    def add_link(match):\n        word = match.group(1)\n        exists = request.dbsession.execute(\n            sa.select(sa.exists(models.Page)).where(models.Page.name == word)\n        ).scalar()\n        if exists:\n            view_url = request.route_url('view_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (view_url, escape(word))\n        else:\n            add_url = request.route_url('add_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (add_url, escape(word))\n\n    content = publish_parts(page.data, writer_name='html')['html_body']\n    content = wikiwords.sub(add_link, content)\n    edit_url = request.route_url('edit_page', pagename=page.name)\n    return dict(page=page, content=content, edit_url=edit_url)"
    },
    {
      "chunk_id": 1548,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "@view_config(route_name='edit_page', renderer='tutorial:templates/edit.jinja2',\n             permission='edit')\ndef edit_page(request):\n    page = request.context.page\n    if request.method == 'POST':\n        page.data = request.params['body']\n        next_url = request.route_url('view_page', pagename=page.name)\n        return HTTPSeeOther(location=next_url)\n    return dict(\n        pagename=page.name,\n        pagedata=page.data,\n        save_url=request.route_url('edit_page', pagename=page.name),\n    )"
    },
    {
      "chunk_id": 1549,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/views/default.py",
      "content": "@view_config(route_name='add_page', renderer='tutorial:templates/edit.jinja2',\n             permission='create')\ndef add_page(request):\n    pagename = request.context.pagename\n    if request.method == 'POST':\n        body = request.params['body']\n        page = models.Page(name=pagename, data=body, creator=request.identity)\n        request.dbsession.add(page)\n        next_url = request.route_url('view_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    save_url = request.route_url('add_page', pagename=pagename)\n    return dict(pagename=pagename, pagedata='', save_url=save_url)"
    },
    {
      "chunk_id": 1550,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .page import Page  # flake8: noqa\nfrom .user import User  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1551,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1552,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1553,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1554,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1555,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1556,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1557,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/user.py",
      "content": "import bcrypt\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List, Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1558,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/user.py",
      "content": "class User(Base):\n    \"\"\" The SQLAlchemy declarative model class for a User object. \"\"\"\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    role: Mapped[str]\n    password_hash: Mapped[Optional[str]]\n    created_pages: Mapped[List['Page']] = relationship(back_populates='creator')"
    },
    {
      "chunk_id": 1559,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/user.py",
      "content": "def set_password(self, pw):\n        pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n        self.password_hash = pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1560,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/user.py",
      "content": "def check_password(self, pw):\n        if self.password_hash is not None:\n            expected_hash = self.password_hash.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False"
    },
    {
      "chunk_id": 1561,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/page.py",
      "content": "import bcrypt\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1562,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/models/page.py",
      "content": "class Page(Base):\n    \"\"\" The SQLAlchemy declarative model class for a Page object. \"\"\"\n    __tablename__ = 'pages'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    data: Mapped[str]\n\n    creator_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    creator: Mapped['User'] = relationship(back_populates='created_pages')"
    },
    {
      "chunk_id": 1563,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1564,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1565,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1566,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1567,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1568,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1569,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1570,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1571,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1572,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1573,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1574,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "\"\"\"\nuse new models Page and User\n\nRevision ID: 07f9d6b626b2\nRevises: 4b6614165904\nCreate Date: 2024-02-04 14:39:12.885858\n\n\"\"\""
    },
    {
      "chunk_id": 1575,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '07f9d6b626b2'\ndown_revision = '4b6614165904'\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1576,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('role', sa.String(), nullable=False),\n    sa.Column('password_hash', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),\n    sa.UniqueConstraint('name', name=op.f('uq_users_name'))\n    )\n    op.create_table('pages',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('data', sa.String(), nullable=False),\n    sa.Column('creator_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], name=op.f('fk_pages_creator_id_users')),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_pages')),\n    sa.UniqueConstraint('name', name=op.f('uq_pages_name'))\n    )\n    op.drop_index('my_index', table_name='models')\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1577,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(), nullable=True),\n    sa.Column('value', sa.INTEGER(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name='pk_models')\n    )\n    op.create_index('my_index', 'models', ['name'], unique=1)\n    op.drop_table('pages')\n    op.drop_table('users')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1578,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1579,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1580,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1581,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1582,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1583,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1584,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    editor = models.User(name='editor', role='editor')\n    editor.set_password('editor')\n    dbsession.add(editor)\n\n    basic = models.User(name='basic', role='basic')\n    basic.set_password('basic')\n    dbsession.add(basic)\n\n    page = models.Page(\n        name='FrontPage',\n        creator=editor,\n        data='This is the front page',\n    )\n    dbsession.add(page)"
    },
    {
      "chunk_id": 1585,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1586,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authorization/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1587,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1588,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.security')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1589,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1590,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1591,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "from pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.csrf import CookieCSRFStoragePolicy\nfrom pyramid.request import RequestLocalCache\n\nfrom . import models"
    },
    {
      "chunk_id": 1592,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "class MySecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret)\n        self.identity_cache = RequestLocalCache(self.load_identity)"
    },
    {
      "chunk_id": 1593,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def load_identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is None:\n            return None\n\n        userid = identity['userid']\n        user = request.dbsession.get(models.User, userid)\n        return user"
    },
    {
      "chunk_id": 1594,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def identity(self, request):\n        return self.identity_cache.get_or_create(request)"
    },
    {
      "chunk_id": 1595,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        user = self.identity(request)\n        if user is not None:\n            return user.id"
    },
    {
      "chunk_id": 1596,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1597,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1598,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/security.py",
      "content": "def includeme(config):\n    settings = config.get_settings()\n\n    config.set_csrf_storage_policy(CookieCSRFStoragePolicy())\n    config.set_default_csrf_options(require_csrf=True)\n\n    config.set_security_policy(MySecurityPolicy(settings['auth.secret']))"
    },
    {
      "chunk_id": 1599,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('view_wiki', '/')\n    config.add_route('login', '/login')\n    config.add_route('logout', '/logout')\n    config.add_route('view_page', '/{pagename}')\n    config.add_route('add_page', '/add_page/{pagename}')\n    config.add_route('edit_page', '/{pagename}/edit_page')"
    },
    {
      "chunk_id": 1600,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1601,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1602,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1603,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One\")"
    },
    {
      "chunk_id": 1604,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two\")"
    },
    {
      "chunk_id": 1605,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 1606,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1607,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1608,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/auth.py",
      "content": "from pyramid.csrf import new_csrf_token\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.security import (\n    remember,\n    forget,\n)\nfrom pyramid.view import (\n    forbidden_view_config,\n    view_config,\n)\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1609,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/auth.py",
      "content": "@view_config(route_name='login', renderer='tutorial:templates/login.jinja2')\ndef login(request):\n    next_url = request.params.get('next', request.referrer)\n    if not next_url:\n        next_url = request.route_url('view_wiki')\n    message = ''\n    login = ''\n    if request.method == 'POST':\n        login = request.params['login']\n        password = request.params['password']\n        user = request.dbsession.scalars(\n            sa.select(models.User).where(models.User.name == login)\n        ).one_or_none()\n        if user is not None and user.check_password(password):\n            new_csrf_token(request)\n            headers = remember(request, user.id)\n            return HTTPSeeOther(location=next_url, headers=headers)\n        message = 'Failed login'\n        request.response.status = 400\n\n    return dict(\n        message=message,\n        url=request.route_url('login'),\n        next_url=next_url,\n        login=login,\n    )"
    },
    {
      "chunk_id": 1610,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/auth.py",
      "content": "@view_config(route_name='logout')\ndef logout(request):\n    next_url = request.route_url('view_wiki')\n    if request.method == 'POST':\n        new_csrf_token(request)\n        headers = forget(request)\n        return HTTPSeeOther(location=next_url, headers=headers)\n\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1611,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/auth.py",
      "content": "@forbidden_view_config(renderer='tutorial:templates/403.jinja2')\ndef forbidden_view(exc, request):\n    if not request.is_authenticated:\n        next_url = request.route_url('login', _query={'next': request.url})\n        return HTTPSeeOther(location=next_url)\n\n    request.response.status = 403\n    return {}"
    },
    {
      "chunk_id": 1612,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom html import escape\nfrom pyramid.httpexceptions import (\n    HTTPForbidden,\n    HTTPNotFound,\n    HTTPSeeOther,\n)\nfrom pyramid.view import view_config\nimport re\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1613,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/default.py",
      "content": "@view_config(route_name='view_wiki')\ndef view_wiki(request):\n    next_url = request.route_url('view_page', pagename='FrontPage')\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1614,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/default.py",
      "content": "@view_config(route_name='view_page', renderer='tutorial:templates/view.jinja2')\ndef view_page(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound('No such page')\n\n    def add_link(match):\n        word = match.group(1)\n        exists = request.dbsession.execute(\n            sa.select(sa.exists(models.Page)).where(models.Page.name == word)\n        ).scalar()\n        if exists:\n            view_url = request.route_url('view_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (view_url, escape(word))\n        else:\n            add_url = request.route_url('add_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (add_url, escape(word))\n\n    content = publish_parts(page.data, writer_name='html')['html_body']\n    content = wikiwords.sub(add_link, content)\n    edit_url = request.route_url('edit_page', pagename=page.name)\n    return dict(page=page, content=content, edit_url=edit_url)"
    },
    {
      "chunk_id": 1615,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/default.py",
      "content": "@view_config(route_name='edit_page', renderer='tutorial:templates/edit.jinja2')\ndef edit_page(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound('No such page')\n    user = request.identity\n    if user is None or (user.role != 'editor' and page.creator != user):\n        raise HTTPForbidden\n    if request.method == 'POST':\n        page.data = request.params['body']\n        next_url = request.route_url('view_page', pagename=page.name)\n        return HTTPSeeOther(location=next_url)\n    return dict(\n        pagename=page.name,\n        pagedata=page.data,\n        save_url=request.route_url('edit_page', pagename=page.name),\n    )"
    },
    {
      "chunk_id": 1616,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/views/default.py",
      "content": "@view_config(route_name='add_page', renderer='tutorial:templates/edit.jinja2')\ndef add_page(request):\n    user = request.identity\n    if user is None or user.role not in ('editor', 'basic'):\n        raise HTTPForbidden\n    pagename = request.matchdict['pagename']\n    exists = request.dbsession.execute(\n        sa.select(sa.exists(models.Page)).where(models.Page.name == pagename)\n    ).scalar()\n    if exists:\n        next_url = request.route_url('edit_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    if request.method == 'POST':\n        body = request.params['body']\n        page = models.Page(name=pagename, data=body, creator=request.identity)\n        request.dbsession.add(page)\n        next_url = request.route_url('view_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    save_url = request.route_url('add_page', pagename=pagename)\n    return dict(pagename=pagename, pagedata='', save_url=save_url)"
    },
    {
      "chunk_id": 1617,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .page import Page  # flake8: noqa\nfrom .user import User  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1618,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1619,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1620,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1621,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1622,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1623,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1624,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/user.py",
      "content": "import bcrypt\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List, Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1625,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/user.py",
      "content": "class User(Base):\n    \"\"\" The SQLAlchemy declarative model class for a User object. \"\"\"\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    role: Mapped[str]\n    password_hash: Mapped[Optional[str]]\n    created_pages: Mapped[List['Page']] = relationship(back_populates='creator')"
    },
    {
      "chunk_id": 1626,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/user.py",
      "content": "def set_password(self, pw):\n        pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n        self.password_hash = pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1627,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/user.py",
      "content": "def check_password(self, pw):\n        if self.password_hash is not None:\n            expected_hash = self.password_hash.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False"
    },
    {
      "chunk_id": 1628,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/page.py",
      "content": "import bcrypt\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1629,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/models/page.py",
      "content": "class Page(Base):\n    \"\"\" The SQLAlchemy declarative model class for a Page object. \"\"\"\n    __tablename__ = 'pages'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    data: Mapped[str]\n\n    creator_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    creator: Mapped['User'] = relationship(back_populates='created_pages')"
    },
    {
      "chunk_id": 1630,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1631,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1632,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1633,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1634,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1635,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1636,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"init\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1637,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa"
    },
    {
      "chunk_id": 1638,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1639,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1640,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1641,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "\"\"\"\nuse new models Page and User\n\nRevision ID: 07f9d6b626b2\nRevises: 4b6614165904\nCreate Date: 2024-02-04 14:39:12.885858\n\n\"\"\""
    },
    {
      "chunk_id": 1642,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '07f9d6b626b2'\ndown_revision = '4b6614165904'\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1643,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('role', sa.String(), nullable=False),\n    sa.Column('password_hash', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),\n    sa.UniqueConstraint('name', name=op.f('uq_users_name'))\n    )\n    op.create_table('pages',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('data', sa.String(), nullable=False),\n    sa.Column('creator_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], name=op.f('fk_pages_creator_id_users')),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_pages')),\n    sa.UniqueConstraint('name', name=op.f('uq_pages_name'))\n    )\n    op.drop_index('my_index', table_name='models')\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1644,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(), nullable=True),\n    sa.Column('value', sa.INTEGER(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name='pk_models')\n    )\n    op.create_index('my_index', 'models', ['name'], unique=1)\n    op.drop_table('pages')\n    op.drop_table('users')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1645,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1646,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1647,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1648,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1649,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1650,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1651,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    editor = models.User(name='editor', role='editor')\n    editor.set_password('editor')\n    dbsession.add(editor)\n\n    basic = models.User(name='basic', role='basic')\n    basic.set_password('basic')\n    dbsession.add(basic)\n\n    page = models.Page(\n        name='FrontPage',\n        creator=editor,\n        data='This is the front page',\n    )\n    dbsession.add(page)"
    },
    {
      "chunk_id": 1652,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1653,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/authentication/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1654,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1655,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.security')\n        config.include('.routes')\n        config.include('.models')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1656,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1657,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['dbsession'] = request.dbsession\n    env['models'] = models"
    },
    {
      "chunk_id": 1658,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "from pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.authorization import (\n    ACLHelper,\n    Authenticated,\n    Everyone,\n)\nfrom pyramid.csrf import CookieCSRFStoragePolicy\nfrom pyramid.request import RequestLocalCache\n\nfrom . import models"
    },
    {
      "chunk_id": 1659,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "class MySecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret)\n        self.identity_cache = RequestLocalCache(self.load_identity)\n        self.acl = ACLHelper()"
    },
    {
      "chunk_id": 1660,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def load_identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is None:\n            return None\n\n        userid = identity['userid']\n        user = request.dbsession.get(models.User, userid)\n        return user"
    },
    {
      "chunk_id": 1661,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def identity(self, request):\n        return self.identity_cache.get_or_create(request)"
    },
    {
      "chunk_id": 1662,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        user = self.identity(request)\n        if user is not None:\n            return user.id"
    },
    {
      "chunk_id": 1663,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1664,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1665,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def permits(self, request, context, permission):\n        principals = self.effective_principals(request)\n        return self.acl.permits(context, principals, permission)"
    },
    {
      "chunk_id": 1666,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def effective_principals(self, request):\n        principals = [Everyone]\n        user = self.identity(request)\n        if user is not None:\n            principals.append(Authenticated)\n            principals.append('u:' + str(user.id))\n            principals.append('role:' + user.role)\n        return principals"
    },
    {
      "chunk_id": 1667,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/security.py",
      "content": "def includeme(config):\n    settings = config.get_settings()\n\n    config.set_csrf_storage_policy(CookieCSRFStoragePolicy())\n    config.set_default_csrf_options(require_csrf=True)\n\n    config.set_security_policy(MySecurityPolicy(settings['auth.secret']))"
    },
    {
      "chunk_id": 1668,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "from pyramid.authorization import (\n    Allow,\n    Everyone,\n)\nfrom pyramid.httpexceptions import (\n    HTTPNotFound,\n    HTTPSeeOther,\n)\nimport sqlalchemy as sa\n\nfrom . import models"
    },
    {
      "chunk_id": 1669,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('view_wiki', '/')\n    config.add_route('login', '/login')\n    config.add_route('logout', '/logout')\n    config.add_route('view_page', '/{pagename}', factory=page_factory)\n    config.add_route('add_page', '/add_page/{pagename}',\n                     factory=new_page_factory)\n    config.add_route('edit_page', '/{pagename}/edit_page',\n                     factory=page_factory)"
    },
    {
      "chunk_id": 1670,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "def new_page_factory(request):\n    pagename = request.matchdict['pagename']\n    exists = request.dbsession.execute(\n        sa.select(sa.exists(models.Page)).where(models.Page.name == pagename)\n    ).scalar()\n    if exists:\n        next_url = request.route_url('edit_page', pagename=pagename)\n        raise HTTPSeeOther(location=next_url)\n    return NewPage(pagename)"
    },
    {
      "chunk_id": 1671,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "class NewPage:\n    def __init__(self, pagename):\n        self.pagename = pagename\n\n    def __acl__(self):\n        return [\n            (Allow, 'role:editor', 'create'),\n            (Allow, 'role:basic', 'create'),\n        ]"
    },
    {
      "chunk_id": 1672,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "def page_factory(request):\n    pagename = request.matchdict['pagename']\n    page = request.dbsession.scalars(\n        sa.select(models.Page).where(models.Page.name == pagename)\n    ).one_or_none()\n    if page is None:\n        raise HTTPNotFound\n    return PageResource(page)"
    },
    {
      "chunk_id": 1673,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/routes.py",
      "content": "class PageResource:\n    def __init__(self, page):\n        self.page = page\n\n    def __acl__(self):\n        return [\n            (Allow, Everyone, 'view'),\n            (Allow, 'role:editor', 'edit'),\n            (Allow, 'u:' + str(self.page.creator_id), 'edit'),\n        ]"
    },
    {
      "chunk_id": 1674,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1675,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1676,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1677,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/auth.py",
      "content": "from pyramid.csrf import new_csrf_token\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.security import (\n    remember,\n    forget,\n)\nfrom pyramid.view import (\n    forbidden_view_config,\n    view_config,\n)\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1678,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/auth.py",
      "content": "@view_config(route_name='login', renderer='tutorial:templates/login.jinja2')\ndef login(request):\n    next_url = request.params.get('next', request.referrer)\n    if not next_url:\n        next_url = request.route_url('view_wiki')\n    message = ''\n    login = ''\n    if request.method == 'POST':\n        login = request.params['login']\n        password = request.params['password']\n        user = request.dbsession.scalars(\n            sa.select(models.User).where(models.User.name == login)\n        ).one_or_none()\n        if user is not None and user.check_password(password):\n            new_csrf_token(request)\n            headers = remember(request, user.id)\n            return HTTPSeeOther(location=next_url, headers=headers)\n        message = 'Failed login'\n        request.response.status = 400\n\n    return dict(\n        message=message,\n        url=request.route_url('login'),\n        next_url=next_url,\n        login=login,\n    )"
    },
    {
      "chunk_id": 1679,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/auth.py",
      "content": "@view_config(route_name='logout')\ndef logout(request):\n    next_url = request.route_url('view_wiki')\n    if request.method == 'POST':\n        new_csrf_token(request)\n        headers = forget(request)\n        return HTTPSeeOther(location=next_url, headers=headers)\n\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1680,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/auth.py",
      "content": "@forbidden_view_config(renderer='tutorial:templates/403.jinja2')\ndef forbidden_view(exc, request):\n    if not request.is_authenticated:\n        next_url = request.route_url('login', _query={'next': request.url})\n        return HTTPSeeOther(location=next_url)\n\n    request.response.status = 403\n    return {}"
    },
    {
      "chunk_id": 1681,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom html import escape\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.view import view_config\nimport re\nimport sqlalchemy as sa\n\nfrom .. import models"
    },
    {
      "chunk_id": 1682,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "wikiwords = re.compile(r\"\\b([A-Z]\\w+[A-Z]+\\w+)\")"
    },
    {
      "chunk_id": 1683,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "@view_config(route_name='view_wiki')\ndef view_wiki(request):\n    next_url = request.route_url('view_page', pagename='FrontPage')\n    return HTTPSeeOther(location=next_url)"
    },
    {
      "chunk_id": 1684,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "@view_config(route_name='view_page', renderer='tutorial:templates/view.jinja2',\n             permission='view')\ndef view_page(request):\n    page = request.context.page\n\n    def add_link(match):\n        word = match.group(1)\n        exists = request.dbsession.execute(\n            sa.select(sa.exists(models.Page)).where(models.Page.name == word)\n        ).scalar()\n        if exists:\n            view_url = request.route_url('view_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (view_url, escape(word))\n        else:\n            add_url = request.route_url('add_page', pagename=word)\n            return '<a href=\"%s\">%s</a>' % (add_url, escape(word))\n\n    content = publish_parts(page.data, writer_name='html')['html_body']\n    content = wikiwords.sub(add_link, content)\n    edit_url = request.route_url('edit_page', pagename=page.name)\n    return dict(page=page, content=content, edit_url=edit_url)"
    },
    {
      "chunk_id": 1685,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "@view_config(route_name='edit_page', renderer='tutorial:templates/edit.jinja2',\n             permission='edit')\ndef edit_page(request):\n    page = request.context.page\n    if request.method == 'POST':\n        page.data = request.params['body']\n        next_url = request.route_url('view_page', pagename=page.name)\n        return HTTPSeeOther(location=next_url)\n    return dict(\n        pagename=page.name,\n        pagedata=page.data,\n        save_url=request.route_url('edit_page', pagename=page.name),\n    )"
    },
    {
      "chunk_id": 1686,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/views/default.py",
      "content": "@view_config(route_name='add_page', renderer='tutorial:templates/edit.jinja2',\n             permission='create')\ndef add_page(request):\n    pagename = request.context.pagename\n    if request.method == 'POST':\n        body = request.params['body']\n        page = models.Page(name=pagename, data=body, creator=request.identity)\n        request.dbsession.add(page)\n        next_url = request.route_url('view_page', pagename=pagename)\n        return HTTPSeeOther(location=next_url)\n    save_url = request.route_url('add_page', pagename=pagename)\n    return dict(pagename=pagename, pagedata='', save_url=save_url)"
    },
    {
      "chunk_id": 1687,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/__init__.py",
      "content": "from sqlalchemy import engine_from_config\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import configure_mappers\nimport zope.sqlalchemy\n\n# Import or define all models here to ensure they are attached to the\n# ``Base.metadata`` prior to any initialization routines.\nfrom .page import Page  # flake8: noqa\nfrom .user import User  # flake8: noqa\n\n# Run ``configure_mappers`` after defining all of the models to ensure\n# all relationships can be setup.\nconfigure_mappers()"
    },
    {
      "chunk_id": 1688,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/__init__.py",
      "content": "def get_engine(settings, prefix='sqlalchemy.'):\n    return engine_from_config(settings, prefix)"
    },
    {
      "chunk_id": 1689,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/__init__.py",
      "content": "def get_session_factory(engine):\n    factory = sessionmaker()\n    factory.configure(bind=engine)\n    return factory"
    },
    {
      "chunk_id": 1690,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/__init__.py",
      "content": "def get_tm_session(session_factory, transaction_manager, request=None):\n    \"\"\"\n    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example:\n\n      .. code-block:: python\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)\n\n    This function may be invoked with a ``request`` kwarg, such as when invoked\n    by the reified ``.dbsession`` Pyramid request attribute which is configured\n    via the ``includeme`` function below. The default value, for backwards\n    compatibility, is ``None``.\n\n    The ``request`` kwarg is used to populate the ``sqlalchemy.orm.Session``'s\n    \"info\" dict.  The \"info\" dict is the official namespace for developers to\n    stash session-specific information.  For more information, please see the\n    SQLAlchemy docs:\n    https://docs.sqlalchemy.org/en/stable/orm/session_api.html#sqlalchemy.orm.session.Session.params.info\n\n    By placing the active ``request`` in the \"info\" dict, developers will be\n    able to access the active Pyramid request from an instance of an SQLAlchemy\n    object in one of two ways:\n\n    - Classic SQLAlchemy. This uses the ``Session``'s utility class method:\n\n      .. code-block:: python\n\n          from sqlalchemy.orm.session import Session as sa_Session\n\n          dbsession = sa_Session.object_session(dbObject)\n          request = dbsession.info[\"request\"]\n\n    - Modern SQLAlchemy. This uses the \"Runtime Inspection API\":\n\n      .. code-block:: python\n\n          from sqlalchemy import inspect as sa_inspect\n\n          dbsession = sa_inspect(dbObject).session\n          request = dbsession.info[\"request\"]\n    \"\"\"\n    dbsession = session_factory(info={\"request\": request})\n    zope.sqlalchemy.register(\n        dbsession, transaction_manager=transaction_manager\n    )\n    return dbsession"
    },
    {
      "chunk_id": 1691,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/__init__.py",
      "content": "def includeme(config):\n    \"\"\"\n    Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('tutorial.models')``.\n\n    \"\"\"\n    settings = config.get_settings()\n    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'\n\n    # Use ``pyramid_tm`` to hook the transaction lifecycle to the request.\n    # Note: the packages ``pyramid_tm`` and ``transaction`` work together to\n    # automatically close the active database session after every request.\n    # If your project migrates away from ``pyramid_tm``, you may need to use a\n    # Pyramid callback function to close the database session after each\n    # request.\n    config.include('pyramid_tm')\n\n    # use pyramid_retry to retry a request when transient exceptions occur\n    config.include('pyramid_retry')\n\n    # hook to share the dbengine fixture in testing\n    dbengine = settings.get('dbengine')\n    if not dbengine:\n        dbengine = get_engine(settings)\n\n    session_factory = get_session_factory(dbengine)\n    config.registry['dbsession_factory'] = session_factory\n\n    # make request.dbsession available for use in Pyramid\n    def dbsession(request):\n        # hook to share the dbsession fixture in testing\n        dbsession = request.environ.get('app.dbsession')\n        if dbsession is None:\n            # request.tm is the transaction manager used by pyramid_tm\n            dbsession = get_tm_session(\n                session_factory, request.tm, request=request\n            )\n        return dbsession\n\n    config.add_request_method(dbsession, reify=True)"
    },
    {
      "chunk_id": 1692,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/meta.py",
      "content": "from sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase"
    },
    {
      "chunk_id": 1693,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/meta.py",
      "content": "class Base(DeclarativeBase):\n    # Recommended naming convention used by Alembic, as various different\n    # database providers will autogenerate vastly different names making\n    # migrations more difficult.\n    # See: https://alembic.sqlalchemy.org/en/latest/naming.html\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_`%(constraint_name)s`\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })"
    },
    {
      "chunk_id": 1694,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/user.py",
      "content": "import bcrypt\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom typing import List, Optional\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1695,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/user.py",
      "content": "class User(Base):\n    \"\"\" The SQLAlchemy declarative model class for a User object. \"\"\"\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    role: Mapped[str]\n    password_hash: Mapped[Optional[str]]"
    },
    {
      "chunk_id": 1696,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/user.py",
      "content": "def set_password(self, pw):\n        pwhash = bcrypt.hashpw(pw.encode('utf8'), bcrypt.gensalt())\n        self.password_hash = pwhash.decode('utf8')"
    },
    {
      "chunk_id": 1697,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/user.py",
      "content": "def check_password(self, pw):\n        if self.password_hash is not None:\n            expected_hash = self.password_hash.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False"
    },
    {
      "chunk_id": 1698,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/user.py",
      "content": "created_pages: Mapped[List['Page']] = relationship(back_populates='creator')"
    },
    {
      "chunk_id": 1699,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/page.py",
      "content": "import bcrypt\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .meta import Base"
    },
    {
      "chunk_id": 1700,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/models/page.py",
      "content": "class Page(Base):\n    \"\"\" The SQLAlchemy declarative model class for a Page object. \"\"\"\n    __tablename__ = 'pages'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    data: Mapped[str]\n\n    creator_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    creator: Mapped['User'] = relationship(back_populates='created_pages')"
    },
    {
      "chunk_id": 1701,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "\"\"\"Pyramid bootstrap environment. \"\"\""
    },
    {
      "chunk_id": 1702,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "from alembic import context\nfrom pyramid.paster import get_appsettings, setup_logging\nfrom sqlalchemy import engine_from_config\n\nfrom tutorial.models.meta import Base"
    },
    {
      "chunk_id": 1703,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "config = context.config\n\nsetup_logging(config.config_file_name)\n\nsettings = get_appsettings(config.config_file_name)\ntarget_metadata = Base.metadata"
    },
    {
      "chunk_id": 1704,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(url=settings['sqlalchemy.url'])\n    with context.begin_transaction():\n        context.run_migrations()"
    },
    {
      "chunk_id": 1705,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    engine = engine_from_config(settings, prefix='sqlalchemy.')\n\n    connection = engine.connect()\n    context.configure(\n        connection=connection,\n        target_metadata=target_metadata\n    )\n\n    try:\n        with context.begin_transaction():\n            context.run_migrations()\n    finally:\n        connection.close()"
    },
    {
      "chunk_id": 1706,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/env.py",
      "content": "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
    },
    {
      "chunk_id": 1707,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "\"\"\"\ninit\n\nRevision ID: 4b6614165904\nRevises: \nCreate Date: 2024-02-04 14:32:46.784813\n\n\"\"\""
    },
    {
      "chunk_id": 1708,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '4b6614165904'\ndown_revision = None\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1709,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.Column('value', sa.Integer(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_models'))\n    )\n    op.create_index('my_index', 'models', ['name'], unique=True, mysql_length=255)\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1710,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_4b6614165904.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index('my_index', table_name='models', mysql_length=255)\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1711,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "\"\"\"\nuse new models Page and User\n\nRevision ID: 07f9d6b626b2\nRevises: 4b6614165904\nCreate Date: 2024-02-04 14:39:12.885858\n\n\"\"\""
    },
    {
      "chunk_id": 1712,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "from alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '07f9d6b626b2'\ndown_revision = '4b6614165904'\nbranch_labels = None\ndepends_on = None"
    },
    {
      "chunk_id": 1713,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('role', sa.String(), nullable=False),\n    sa.Column('password_hash', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),\n    sa.UniqueConstraint('name', name=op.f('uq_users_name'))\n    )\n    op.create_table('pages',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=False),\n    sa.Column('data', sa.String(), nullable=False),\n    sa.Column('creator_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['creator_id'], ['users.id'], name=op.f('fk_pages_creator_id_users')),\n    sa.PrimaryKeyConstraint('id', name=op.f('pk_pages')),\n    sa.UniqueConstraint('name', name=op.f('uq_pages_name'))\n    )\n    op.drop_index('my_index', table_name='models')\n    op.drop_table('models')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1714,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/alembic/versions/20240204_07f9d6b626b2.py",
      "content": "def downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('models',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(), nullable=True),\n    sa.Column('value', sa.INTEGER(), nullable=True),\n    sa.PrimaryKeyConstraint('id', name='pk_models')\n    )\n    op.create_index('my_index', 'models', ['name'], unique=1)\n    op.drop_table('pages')\n    op.drop_table('users')\n    # ### end Alembic commands ###"
    },
    {
      "chunk_id": 1715,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/__init__.py",
      "content": "# package"
    },
    {
      "chunk_id": 1716,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1717,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1718,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1719,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2"
    },
    {
      "chunk_id": 1720,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/initialize_db.py",
      "content": "import argparse\nimport sys\n\nfrom pyramid.paster import bootstrap, setup_logging\nfrom sqlalchemy.exc import OperationalError\n\nfrom .. import models"
    },
    {
      "chunk_id": 1721,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/initialize_db.py",
      "content": "def setup_models(dbsession):\n    \"\"\"\n    Add or update models / fixtures in the database.\n\n    \"\"\"\n    editor = models.User(name='editor', role='editor')\n    editor.set_password('editor')\n    dbsession.add(editor)\n\n    basic = models.User(name='basic', role='basic')\n    basic.set_password('basic')\n    dbsession.add(basic)\n\n    page = models.Page(\n        name='FrontPage',\n        creator=editor,\n        data='This is the front page',\n    )\n    dbsession.add(page)"
    },
    {
      "chunk_id": 1722,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/initialize_db.py",
      "content": "def parse_args(argv):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'config_uri',\n        help='Configuration file, e.g., development.ini',\n    )\n    return parser.parse_args(argv[1:])"
    },
    {
      "chunk_id": 1723,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki2/src/tests/tutorial/scripts/initialize_db.py",
      "content": "def main(argv=sys.argv):\n    args = parse_args(argv)\n    setup_logging(args.config_uri)\n    env = bootstrap(args.config_uri)\n\n    try:\n        with env['request'].tm:\n            dbsession = env['request'].dbsession\n            setup_models(dbsession)\n    except OperationalError:\n        print('''\nPyramid is having a problem using your SQL database.  The problem\nmight be caused by one of the following things:\n\n1.  You may need to initialize your database tables with `alembic`.\n    Check your README.txt for description and try to run it.\n\n2.  Your database server may not be running.  Check that the\n    database server referred to by the \"sqlalchemy.url\" setting in\n    your \"development.ini\" file is running.\n            ''')"
    },
    {
      "chunk_id": 1724,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1725,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1726,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1727,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1728,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1729,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1730,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1731,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1732,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    pagename = request.path\n    page = Page(pagename)\n    page.__name__ = pagename\n    return dict(page=page)"
    },
    {
      "chunk_id": 1733,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.view import view_config\nimport re\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1734,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "wikiwords = re.compile(r\"\\b([A-Z]\\w+[A-Z]+\\w+)\")"
    },
    {
      "chunk_id": 1735,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "@view_config(context='..models.Wiki')\ndef view_wiki(context, request):\n    return HTTPSeeOther(location=request.resource_url(context, 'FrontPage'))"
    },
    {
      "chunk_id": 1736,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "@view_config(context='..models.Page', renderer='tutorial:templates/view.pt')\ndef view_page(context, request):\n    wiki = context.__parent__\n\n    def check(match):\n        word = match.group(1)\n        if word in wiki:\n            page = wiki[word]\n            view_url = request.resource_url(page)\n            return '<a href=\"%s\">%s</a>' % (view_url, word)\n        else:\n            add_url = request.application_url + '/add_page/' + word\n            return '<a href=\"%s\">%s</a>' % (add_url, word)\n\n    page_text = publish_parts(context.data, writer_name='html')['html_body']\n    page_text = wikiwords.sub(check, page_text)\n    edit_url = request.resource_url(context, 'edit_page')\n    return dict(page=context, page_text=page_text, edit_url=edit_url)"
    },
    {
      "chunk_id": 1737,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "@view_config(name='add_page', context='..models.Wiki',\n             renderer='tutorial:templates/edit.pt')\ndef add_page(context, request):\n    pagename = request.subpath[0]\n    if 'form.submitted' in request.params:\n        body = request.params['body']\n        page = Page(body)\n        page.__name__ = pagename\n        page.__parent__ = context\n        context[pagename] = page\n        return HTTPSeeOther(location=request.resource_url(page))\n    save_url = request.resource_url(context, 'add_page', pagename)\n    page = Page('')\n    page.__name__ = pagename\n    page.__parent__ = context\n    return dict(page=page, save_url=save_url)"
    },
    {
      "chunk_id": 1738,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/views/default.py",
      "content": "@view_config(name='edit_page', context='..models.Page',\n             renderer='tutorial:templates/edit.pt')\ndef edit_page(context, request):\n    if 'form.submitted' in request.params:\n        context.data = request.params['body']\n        return HTTPSeeOther(location=request.resource_url(context))\n\n    return dict(\n        page=context,\n        save_url=request.resource_url(context, 'edit_page'),\n    )"
    },
    {
      "chunk_id": 1739,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/models/__init__.py",
      "content": "from persistent import Persistent\nfrom persistent.mapping import PersistentMapping"
    },
    {
      "chunk_id": 1740,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/models/__init__.py",
      "content": "class Wiki(PersistentMapping):\n    __name__ = None\n    __parent__ = None"
    },
    {
      "chunk_id": 1741,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/models/__init__.py",
      "content": "class Page(Persistent):\n    def __init__(self, data):\n        self.data = data"
    },
    {
      "chunk_id": 1742,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/views/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    if 'app_root' not in zodb_root:\n        app_root = Wiki()\n        frontpage = Page('This is the front page')\n        app_root['FrontPage'] = frontpage\n        frontpage.__name__ = 'FrontPage'\n        frontpage.__parent__ = app_root\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1743,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1744,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1745,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1746,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1747,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1748,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1749,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1750,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1751,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1752,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\n\nfrom ..models import MyModel"
    },
    {
      "chunk_id": 1753,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/views/default.py",
      "content": "@view_config(context=MyModel, renderer='tutorial:templates/mytemplate.pt')\ndef my_view(request):\n    return {'project': 'tutorial'}"
    },
    {
      "chunk_id": 1754,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/models/__init__.py",
      "content": "from persistent import Persistent\nfrom persistent.mapping import PersistentMapping"
    },
    {
      "chunk_id": 1755,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/models/__init__.py",
      "content": "class Wiki(PersistentMapping):\n    __name__ = None\n    __parent__ = None"
    },
    {
      "chunk_id": 1756,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/models/__init__.py",
      "content": "class Page(Persistent):\n    def __init__(self, data):\n        self.data = data"
    },
    {
      "chunk_id": 1757,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/models/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    if 'app_root' not in zodb_root:\n        app_root = Wiki()\n        frontpage = Page('This is the front page')\n        app_root['FrontPage'] = frontpage\n        frontpage.__name__ = 'FrontPage'\n        frontpage.__parent__ = app_root\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1758,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1759,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1760,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1761,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1762,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1763,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1764,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1765,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1766,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1767,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\n\nfrom ..models import MyModel"
    },
    {
      "chunk_id": 1768,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/views/default.py",
      "content": "@view_config(context=MyModel, renderer='tutorial:templates/mytemplate.pt')\ndef my_view(request):\n    return {'project': 'tutorial'}"
    },
    {
      "chunk_id": 1769,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/models/__init__.py",
      "content": "from persistent.mapping import PersistentMapping"
    },
    {
      "chunk_id": 1770,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/models/__init__.py",
      "content": "class MyModel(PersistentMapping):\n    \"\"\"MyModel class that extends PersistentMapping.\"\"\"\n    __parent__ = __name__ = None"
    },
    {
      "chunk_id": 1771,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/installation/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    \"\"\"Creates and returns the app_root in the zodb_root if it doesn't exist.\"\"\"\n    if 'app_root' not in zodb_root:\n        app_root = MyModel()\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1772,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1773,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1774,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1775,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1776,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1777,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1778,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1779,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1780,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1781,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/views/default.py",
      "content": "from pyramid.view import view_config\n\nfrom ..models import MyModel"
    },
    {
      "chunk_id": 1782,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/views/default.py",
      "content": "@view_config(context=MyModel, renderer='tutorial:templates/mytemplate.pt')\ndef my_view(request):\n    return {'project': 'tutorial'}"
    },
    {
      "chunk_id": 1783,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/models/__init__.py",
      "content": "from persistent.mapping import PersistentMapping"
    },
    {
      "chunk_id": 1784,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/models/__init__.py",
      "content": "class MyModel(PersistentMapping):\n    \"\"\"MyModel class that extends PersistentMapping.\"\"\"\n    __parent__ = __name__ = None"
    },
    {
      "chunk_id": 1785,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/basiclayout/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    \"\"\"Creates and returns the app_root from the ZODB root.\"\"\"\n    if 'app_root' not in zodb_root:\n        app_root = MyModel()\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1786,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1787,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1788,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.include('.security')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1789,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1790,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1791,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "import bcrypt\nfrom pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.authorization import (\n    ACLHelper,\n    Authenticated,\n    Everyone,\n)"
    },
    {
      "chunk_id": 1792,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def hash_password(pw):\n    hashed_pw = bcrypt.hashpw(pw.encode('utf-8'), bcrypt.gensalt())\n    # return unicode instead of bytes because databases handle it better\n    return hashed_pw.decode('utf-8')"
    },
    {
      "chunk_id": 1793,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def check_password(expected_hash, pw):\n    if expected_hash is not None:\n        return bcrypt.checkpw(pw.encode('utf-8'), expected_hash.encode('utf-8'))\n    return False"
    },
    {
      "chunk_id": 1794,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "USERS = {\n    'editor': hash_password('editor'),\n    'viewer': hash_password('viewer'),\n}\nGROUPS = {'editor': ['group:editors']}"
    },
    {
      "chunk_id": 1795,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "class MySecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret)\n        self.acl = ACLHelper()"
    },
    {
      "chunk_id": 1796,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is not None and identity['userid'] in USERS:\n            return identity"
    },
    {
      "chunk_id": 1797,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        identity = self.identity(request)\n        if identity is not None:\n            return identity['userid']"
    },
    {
      "chunk_id": 1798,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1799,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1800,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def permits(self, request, context, permission):\n        principals = self.effective_principals(request)\n        return self.acl.permits(context, principals, permission)"
    },
    {
      "chunk_id": 1801,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def effective_principals(self, request):\n        principals = [Everyone]\n        identity = self.identity(request)\n        if identity is not None:\n            principals.append(Authenticated)\n            principals.append('u:' + identity['userid'])\n            principals.extend(GROUPS.get(identity['userid'], []))\n        return principals"
    },
    {
      "chunk_id": 1802,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/security.py",
      "content": "def includeme(config):\n    settings = config.get_settings()\n\n    config.set_security_policy(MySecurityPolicy(settings['auth.secret']))"
    },
    {
      "chunk_id": 1803,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1804,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1805,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1806,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1807,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One:\", self.value)"
    },
    {
      "chunk_id": 1808,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two:\", self.value)"
    },
    {
      "chunk_id": 1809,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 1810,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1811,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    pagename = request.path\n    page = Page(pagename)\n    page.__name__ = pagename\n    return dict(page=page)"
    },
    {
      "chunk_id": 1812,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/auth.py",
      "content": "from pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.security import (\n    forget,\n    remember,\n)\nfrom pyramid.view import (\n    forbidden_view_config,\n    view_config,\n)\n\nfrom ..security import check_password, USERS"
    },
    {
      "chunk_id": 1813,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/auth.py",
      "content": "@view_config(context='..models.Wiki', name='login',\n             renderer='tutorial:templates/login.pt')\n@forbidden_view_config(renderer='tutorial:templates/login.pt')\ndef login(request):\n    login_url = request.resource_url(request.root, 'login')\n    referrer = request.url\n    if referrer == login_url:\n        referrer = '/'  # never use the login form itself as came_from\n    came_from = request.params.get('came_from', referrer)\n    message = ''\n    login = ''\n    password = ''\n    if 'form.submitted' in request.params:\n        login = request.params['login']\n        password = request.params['password']\n        if check_password(USERS.get(login), password):\n            headers = remember(request, login)\n            return HTTPSeeOther(location=came_from, headers=headers)\n        message = 'Failed login'\n        request.response.status = 400\n\n    return dict(\n        message=message,\n        url=login_url,\n        came_from=came_from,\n        login=login,\n        password=password,\n        title='Login',\n    )"
    },
    {
      "chunk_id": 1814,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/auth.py",
      "content": "@view_config(context='..models.Wiki', name='logout')\ndef logout(request):\n    headers = forget(request)\n    return HTTPSeeOther(\n        location=request.resource_url(request.context),\n        headers=headers,\n    )"
    },
    {
      "chunk_id": 1815,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.view import view_config\nimport re\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1816,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/default.py",
      "content": "@view_config(context='..models.Wiki', permission='view')\ndef view_wiki(context, request):\n    return HTTPSeeOther(location=request.resource_url(context, 'FrontPage'))"
    },
    {
      "chunk_id": 1817,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/default.py",
      "content": "@view_config(context='..models.Page',\n             renderer='tutorial:templates/view.pt',\n             permission='view')\ndef view_page(context, request):\n    wiki = context.__parent__\n\n    def check(match):\n        word = match.group(1)\n        if word in wiki:\n            page = wiki[word]\n            view_url = request.resource_url(page)\n            return '<a href=\"%s\">%s</a>' % (view_url, word)\n        else:\n            add_url = request.application_url + '/add_page/' + word\n            return '<a href=\"%s\">%s</a>' % (add_url, word)\n\n    page_text = publish_parts(context.data, writer_name='html')['html_body']\n    page_text = wikiwords.sub(check, page_text)\n    edit_url = request.resource_url(context, 'edit_page')\n    return dict(page=context, page_text=page_text, edit_url=edit_url)"
    },
    {
      "chunk_id": 1818,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/default.py",
      "content": "@view_config(name='add_page', context='..models.Wiki',\n             renderer='tutorial:templates/edit.pt',\n             permission='edit')\ndef add_page(context, request):\n    pagename = request.subpath[0]\n    if 'form.submitted' in request.params:\n        body = request.params['body']\n        page = Page(body)\n        page.__name__ = pagename\n        page.__parent__ = context\n        context[pagename] = page\n        return HTTPSeeOther(location=request.resource_url(page))\n    save_url = request.resource_url(context, 'add_page', pagename)\n    page = Page('')\n    page.__name__ = pagename\n    page.__parent__ = context\n    return dict(page=page, save_url=save_url)"
    },
    {
      "chunk_id": 1819,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/views/default.py",
      "content": "@view_config(name='edit_page', context='..models.Page',\n             renderer='tutorial:templates/edit.pt',\n             permission='edit')\ndef edit_page(context, request):\n    if 'form.submitted' in request.params:\n        context.data = request.params['body']\n        return HTTPSeeOther(location=request.resource_url(context))\n\n    return dict(\n        page=context,\n        save_url=request.resource_url(context, 'edit_page'),\n    )"
    },
    {
      "chunk_id": 1820,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/models/__init__.py",
      "content": "from persistent import Persistent\nfrom persistent.mapping import PersistentMapping\nfrom pyramid.authorization import (\n    Allow,\n    Everyone,\n)"
    },
    {
      "chunk_id": 1821,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/models/__init__.py",
      "content": "class Wiki(PersistentMapping):\n    __name__ = None\n    __parent__ = None\n    __acl__ = [\n        (Allow, Everyone, 'view'),\n        (Allow, 'group:editors', 'edit'),\n    ]"
    },
    {
      "chunk_id": 1822,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/models/__init__.py",
      "content": "class Page(Persistent):\n    def __init__(self, data):\n        self.data = data"
    },
    {
      "chunk_id": 1823,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/authorization/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    if 'app_root' not in zodb_root:\n        app_root = Wiki()\n        frontpage = Page('This is the front page')\n        app_root['FrontPage'] = frontpage\n        frontpage.__name__ = 'FrontPage'\n        frontpage.__parent__ = app_root\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1824,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/__init__.py",
      "content": "from pyramid.config import Configurator\nfrom pyramid_zodbconn import get_connection\n\nfrom .models import appmaker"
    },
    {
      "chunk_id": 1825,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/__init__.py",
      "content": "def root_factory(request):\n    conn = get_connection(request)\n    return appmaker(conn.root())"
    },
    {
      "chunk_id": 1826,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_chameleon')\n        config.include('pyramid_tm')\n        config.include('pyramid_retry')\n        config.include('pyramid_zodbconn')\n        config.include('.routes')\n        config.include('.security')\n        config.set_root_factory(root_factory)\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1827,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/pshell.py",
      "content": "from . import models"
    },
    {
      "chunk_id": 1828,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/pshell.py",
      "content": "def setup(env):\n    request = env['request']\n\n    # start a transaction\n    request.tm.begin()\n\n    # inject some vars into the shell builtins\n    env['tm'] = request.tm\n    env['models'] = models"
    },
    {
      "chunk_id": 1829,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "import bcrypt\nfrom pyramid.authentication import AuthTktCookieHelper\nfrom pyramid.authorization import (\n    ACLHelper,\n    Authenticated,\n    Everyone,\n)"
    },
    {
      "chunk_id": 1830,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def hash_password(pw):\n    hashed_pw = bcrypt.hashpw(pw.encode('utf-8'), bcrypt.gensalt())\n    # return unicode instead of bytes because databases handle it better\n    return hashed_pw.decode('utf-8')"
    },
    {
      "chunk_id": 1831,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def check_password(expected_hash, pw):\n    if expected_hash is not None:\n        return bcrypt.checkpw(pw.encode('utf-8'), expected_hash.encode('utf-8'))\n    return False"
    },
    {
      "chunk_id": 1832,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "USERS = {\n    'editor': hash_password('editor'),\n    'viewer': hash_password('viewer'),\n}\nGROUPS = {'editor': ['group:editors']}"
    },
    {
      "chunk_id": 1833,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "class MySecurityPolicy:\n    def __init__(self, secret):\n        self.authtkt = AuthTktCookieHelper(secret)\n        self.acl = ACLHelper()"
    },
    {
      "chunk_id": 1834,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def identity(self, request):\n        identity = self.authtkt.identify(request)\n        if identity is not None and identity['userid'] in USERS:\n            return identity"
    },
    {
      "chunk_id": 1835,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def authenticated_userid(self, request):\n        identity = self.identity(request)\n        if identity is not None:\n            return identity['userid']"
    },
    {
      "chunk_id": 1836,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def remember(self, request, userid, **kw):\n        return self.authtkt.remember(request, userid, **kw)"
    },
    {
      "chunk_id": 1837,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def forget(self, request, **kw):\n        return self.authtkt.forget(request, **kw)"
    },
    {
      "chunk_id": 1838,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def permits(self, request, context, permission):\n        principals = self.effective_principals(request)\n        return self.acl.permits(context, principals, permission)"
    },
    {
      "chunk_id": 1839,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def effective_principals(self, request):\n        principals = [Everyone]\n        identity = self.identity(request)\n        if identity is not None:\n            principals.append(Authenticated)\n            principals.append('u:' + identity['userid'])\n            principals.extend(GROUPS.get(identity['userid'], []))\n        return principals"
    },
    {
      "chunk_id": 1840,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/security.py",
      "content": "def includeme(config):\n    settings = config.get_settings()\n\n    config.set_security_policy(MySecurityPolicy(settings['auth.secret']))"
    },
    {
      "chunk_id": 1841,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)"
    },
    {
      "chunk_id": 1842,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1843,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1844,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/notfound.py",
      "content": "@notfound_view_config(renderer='tutorial:templates/404.pt')\ndef notfound_view(request):\n    request.response.status = 404\n    pagename = request.path\n    page = Page(pagename)\n    page.__name__ = pagename\n    return dict(page=page)"
    },
    {
      "chunk_id": 1845,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/auth.py",
      "content": "from pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.security import (\n    forget,\n    remember,\n)\nfrom pyramid.view import (\n    forbidden_view_config,\n    view_config,\n)\n\nfrom ..security import check_password, USERS"
    },
    {
      "chunk_id": 1846,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/auth.py",
      "content": "@view_config(context='..models.Wiki', name='login',\n             renderer='tutorial:templates/login.pt')\n@forbidden_view_config(renderer='tutorial:templates/login.pt')\ndef login(request):\n    login_url = request.resource_url(request.root, 'login')\n    referrer = request.url\n    if referrer == login_url:\n        referrer = '/'  # never use the login form itself as came_from\n    came_from = request.params.get('came_from', referrer)\n    message = ''\n    login = ''\n    password = ''\n    if 'form.submitted' in request.params:\n        login = request.params['login']\n        password = request.params['password']\n        if check_password(USERS.get(login), password):\n            headers = remember(request, login)\n            return HTTPSeeOther(location=came_from, headers=headers)\n        message = 'Failed login'\n        request.response.status = 400\n\n    return dict(\n        message=message,\n        url=login_url,\n        came_from=came_from,\n        login=login,\n        password=password,\n        title='Login',\n    )"
    },
    {
      "chunk_id": 1847,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/auth.py",
      "content": "@view_config(context='..models.Wiki', name='logout')\ndef logout(request):\n    headers = forget(request)\n    return HTTPSeeOther(\n        location=request.resource_url(request.context),\n        headers=headers,\n    )"
    },
    {
      "chunk_id": 1848,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "from docutils.core import publish_parts\nfrom pyramid.httpexceptions import HTTPSeeOther\nfrom pyramid.view import view_config\nimport re\n\nfrom ..models import Page"
    },
    {
      "chunk_id": 1849,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "wikiwords = re.compile(r\"\\b([A-Z]\\w+[A-Z]+\\w+)\")"
    },
    {
      "chunk_id": 1850,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "@view_config(context='..models.Wiki', permission='view')\ndef view_wiki(context, request):\n    return HTTPSeeOther(location=request.resource_url(context, 'FrontPage'))"
    },
    {
      "chunk_id": 1851,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "@view_config(context='..models.Page',\n             renderer='tutorial:templates/view.pt',\n             permission='view')\ndef view_page(context, request):\n    wiki = context.__parent__\n\n    def check(match):\n        word = match.group(1)\n        if word in wiki:\n            page = wiki[word]\n            view_url = request.resource_url(page)\n            return '<a href=\"%s\">%s</a>' % (view_url, word)\n        else:\n            add_url = request.application_url + '/add_page/' + word\n            return '<a href=\"%s\">%s</a>' % (add_url, word)\n\n    page_text = publish_parts(context.data, writer_name='html')['html_body']\n    page_text = wikiwords.sub(check, page_text)\n    edit_url = request.resource_url(context, 'edit_page')\n    return dict(page=context, page_text=page_text, edit_url=edit_url)"
    },
    {
      "chunk_id": 1852,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "@view_config(name='add_page', context='..models.Wiki',\n             renderer='tutorial:templates/edit.pt',\n             permission='edit')\ndef add_page(context, request):\n    pagename = request.subpath[0]\n    if 'form.submitted' in request.params:\n        body = request.params['body']\n        page = Page(body)\n        page.__name__ = pagename\n        page.__parent__ = context\n        context[pagename] = page\n        return HTTPSeeOther(location=request.resource_url(page))\n    save_url = request.resource_url(context, 'add_page', pagename)\n    page = Page('')\n    page.__name__ = pagename\n    page.__parent__ = context\n    return dict(page=page, save_url=save_url)"
    },
    {
      "chunk_id": 1853,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/views/default.py",
      "content": "@view_config(name='edit_page', context='..models.Page',\n             renderer='tutorial:templates/edit.pt',\n             permission='edit')\ndef edit_page(context, request):\n    if 'form.submitted' in request.params:\n        context.data = request.params['body']\n        return HTTPSeeOther(location=request.resource_url(context))\n\n    return dict(\n        page=context,\n        save_url=request.resource_url(context, 'edit_page'),\n    )"
    },
    {
      "chunk_id": 1854,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/models/__init__.py",
      "content": "from persistent import Persistent\nfrom persistent.mapping import PersistentMapping\nfrom pyramid.authorization import (\n    Allow,\n    Everyone,\n)"
    },
    {
      "chunk_id": 1855,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/models/__init__.py",
      "content": "class Wiki(PersistentMapping):\n    __name__ = None\n    __parent__ = None\n    __acl__ = [\n        (Allow, Everyone, 'view'),\n        (Allow, 'group:editors', 'edit'),\n    ]"
    },
    {
      "chunk_id": 1856,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/models/__init__.py",
      "content": "class Page(Persistent):\n    def __init__(self, data):\n        self.data = data"
    },
    {
      "chunk_id": 1857,
      "source": "__internal__/data_repo/pyramid/docs/tutorials/wiki/src/tests/tutorial/models/__init__.py",
      "content": "def appmaker(zodb_root):\n    if 'app_root' not in zodb_root:\n        app_root = Wiki()\n        frontpage = Page('This is the front page')\n        app_root['FrontPage'] = frontpage\n        frontpage.__name__ = 'FrontPage'\n        frontpage.__parent__ = app_root\n        zodb_root['app_root'] = app_root\n    return zodb_root['app_root']"
    },
    {
      "chunk_id": 1858,
      "source": "__internal__/data_repo/pyramid/docs/narr/helloworld.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1859,
      "source": "__internal__/data_repo/pyramid/docs/narr/helloworld.py",
      "content": "def hello_world(request):\n    return Response('Hello World!')"
    },
    {
      "chunk_id": 1860,
      "source": "__internal__/data_repo/pyramid/docs/narr/helloworld.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.add_route('hello', '/')\n        config.add_view(hello_world, route_name='hello')\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 1861,
      "source": "__internal__/data_repo/pyramid/docs/narr/hellotraversal.py",
      "content": "from wsgiref.simple_server import make_server\nfrom pyramid.config import Configurator\nfrom pyramid.response import Response"
    },
    {
      "chunk_id": 1862,
      "source": "__internal__/data_repo/pyramid/docs/narr/hellotraversal.py",
      "content": "class Resource(dict):\n    \"\"\"A resource that can contain other resources.\"\"\"\n    pass"
    },
    {
      "chunk_id": 1863,
      "source": "__internal__/data_repo/pyramid/docs/narr/hellotraversal.py",
      "content": "def get_root(request):\n    return Resource({'a': Resource({'b': Resource({'c': Resource()})})})"
    },
    {
      "chunk_id": 1864,
      "source": "__internal__/data_repo/pyramid/docs/narr/hellotraversal.py",
      "content": "def hello_world_of_resources(context, request):\n    output = \"Here's a resource and its children: %s\" % context\n    return Response(output)"
    },
    {
      "chunk_id": 1865,
      "source": "__internal__/data_repo/pyramid/docs/narr/hellotraversal.py",
      "content": "if __name__ == '__main__':\n    with Configurator() as config:\n        config.set_root_factory(get_root)\n        config.add_view(hello_world_of_resources, context=Resource)\n        app = config.make_wsgi_app()\n    server = make_server('0.0.0.0', 6543, app)\n    server.serve_forever()"
    },
    {
      "chunk_id": 1866,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/setup.py",
      "content": "import os\n\nfrom setuptools import setup, find_packages\n\nhere = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(here, 'README.txt')) as f:\n    README = f.read()\nwith open(os.path.join(here, 'CHANGES.txt')) as f:\n    CHANGES = f.read()\n\nrequires = [\n    'plaster_pastedeploy',\n    'pyramid',\n    'pyramid_jinja2',\n    'pyramid_debugtoolbar',\n    'waitress',\n]\n\ntests_require = [\n    'WebTest',\n    'pytest',\n    'pytest-cov',\n]"
    },
    {
      "chunk_id": 1867,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/setup.py",
      "content": "setup(\n    name='myproject',\n    version='0.0',\n    description='myproject',\n    long_description=README + '\\n\\n' + CHANGES,\n    classifiers=[\n        'Programming Language :: Python',\n        'Framework :: Pyramid',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n    ],\n    author='',\n    author_email='',\n    url='',\n    keywords='web pyramid pylons',\n    packages=find_packages(exclude=['tests']),\n    include_package_data=True,\n    zip_safe=False,\n    extras_require={\n        'testing': tests_require,\n    },\n    install_requires=requires,\n    entry_points={\n        'paste.app_factory': [\n            'main = myproject:main',\n        ],\n    },\n)"
    },
    {
      "chunk_id": 1868,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/__init__.py",
      "content": "from pyramid.config import Configurator"
    },
    {
      "chunk_id": 1869,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/__init__.py",
      "content": "def main(global_config, **settings):\n    \"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"\n    with Configurator(settings=settings) as config:\n        config.include('pyramid_jinja2')\n        config.include('.routes')\n        config.scan()\n    return config.make_wsgi_app()"
    },
    {
      "chunk_id": 1870,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/routes.py",
      "content": "def includeme(config):\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    config.add_route('home', '/')"
    },
    {
      "chunk_id": 1871,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/views/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1872,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/views/notfound.py",
      "content": "from pyramid.view import notfound_view_config"
    },
    {
      "chunk_id": 1873,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/views/notfound.py",
      "content": "@notfound_view_config(renderer='myproject:templates/404.jinja2')\ndef notfound_view(request):\n    request.response.status = 404\n    return {}"
    },
    {
      "chunk_id": 1874,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/views/default.py",
      "content": "from pyramid.view import view_config"
    },
    {
      "chunk_id": 1875,
      "source": "__internal__/data_repo/pyramid/docs/narr/myproject/myproject/views/default.py",
      "content": "@view_config(route_name='home', renderer='myproject:templates/mytemplate.jinja2')\ndef my_view(request):\n    return {'project': 'myproject'}"
    }
  ]
}