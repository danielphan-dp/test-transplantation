{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "import codecs\nimport os\nimport re\nimport sys\n\nfrom setuptools import find_packages, setup\nfrom setuptools.command.test import test as TestCommand"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "class PyTest(TestCommand):\n    \"\"\"\n    Provide a Test runner to be used from setup.py to run unit tests\n    \"\"\"\n\n    user_options = [(\"pytest-args=\", \"a\", \"Arguments to pass to pytest\")]\n\n    def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = \"\"\n\n    def run_tests(self):\n        import shlex\n\n        import pytest\n\n        errno = pytest.main(shlex.split(self.pytest_args))\n        sys.exit(errno)"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "def open_local(paths, mode=\"r\", encoding=\"utf8\"):\n    path = os.path.join(os.path.abspath(os.path.dirname(__file__)), *paths)\n\n    return codecs.open(path, mode, encoding)"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "def str_to_bool(val: str) -> bool:\n    val = val.lower()\n    if val in {\n        \"y\",\n        \"yes\",\n        \"yep\",\n        \"yup\",\n        \"t\",\n        \"true\",\n        \"on\",\n        \"enable\",\n        \"enabled\",\n        \"1\",\n    }:\n        return True\n    elif val in {\"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"}:\n        return False\n    else:\n        raise ValueError(f\"Invalid truth value {val}\")"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "with open_local([\"sanic\", \"__version__.py\"], encoding=\"latin1\") as fp:\n    try:\n        version = re.findall(\n            r\"^__version__ = \\\"([^']+)\\\"\\r?$\", fp.read(), re.M\n        )[0]\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "with open_local([\"README.rst\"]) as rm:\n    long_description = rm.read()"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "setup_kwargs = {\n    \"name\": \"sanic\",\n    \"version\": version,\n    \"url\": \"http://github.com/sanic-org/sanic/\",\n    \"license\": \"MIT\",\n    \"author\": \"Sanic Community\",\n    \"author_email\": \"admhpkns@gmail.com\",\n    \"description\": (\n        \"A web server and web framework that's written to go fast. \"\n        \"Build fast. Run fast.\"\n    ),\n    \"long_description\": long_description,\n    \"packages\": find_packages(exclude=(\"tests\", \"tests.*\")),\n    \"package_data\": {\"sanic\": [\"py.typed\", \"pages/styles/*\"]},\n    \"platforms\": \"any\",\n    \"python_requires\": \">=3.8\",\n    \"classifiers\": [\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Web Environment\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.13\",\n    ],\n    \"entry_points\": {\"console_scripts\": [\"sanic = sanic.__main__:main\"]},\n}"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "env_dependency = (\n    '; sys_platform != \"win32\" ' 'and implementation_name == \"cpython\"'\n)\nujson = \"ujson>=1.35\" + env_dependency\nuvloop = \"uvloop>=0.15.0\" + env_dependency\ntypes_ujson = \"types-ujson\" + env_dependency\nrequirements = [\n    \"sanic-routing>=23.12.0\",\n    \"httptools>=0.0.10\",\n    uvloop,\n    ujson,\n    \"aiofiles>=0.6.0\",\n    \"websockets>=10.0\",\n    \"multidict>=5.0,<7.0\",\n    \"html5tagger>=1.2.1\",\n    \"tracerite>=1.0.0\",\n    \"typing-extensions>=4.4.0\",\n    \"setuptools>=70.1.0\",\n]"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "tests_require = [\n    \"sanic-testing>=23.6.0\",\n    \"pytest>=8.2.2\",\n    \"coverage\",\n    \"beautifulsoup4\",\n    \"pytest-sanic\",\n    \"pytest-benchmark\",\n    \"chardet==3.*\",\n    \"ruff\",\n    \"bandit\",\n    \"mypy\",\n    \"docutils\",\n    \"pygments\",\n    \"uvicorn\",\n    \"slotscheck>=0.8.0,<1\",\n    types_ujson,\n]"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "docs_require = [\n    \"sphinx>=2.1.2\",\n    \"sphinx_rtd_theme>=0.4.3\",\n    \"docutils\",\n    \"pygments\",\n    \"m2r2\",\n    \"enum-tools[sphinx]\",\n    \"mistune<2.0.0\",\n    \"autodocsumm>=0.2.11\",\n]"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "dev_require = tests_require + [\n    \"cryptography\",\n    \"tox\",\n    \"towncrier\",\n]"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "all_require = list(set(dev_require + docs_require))"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "if str_to_bool(os.environ.get(\"SANIC_NO_UJSON\", \"no\")):\n    print(\"Installing without uJSON\")\n    requirements.remove(ujson)\n    tests_require.remove(types_ujson)"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "if str_to_bool(os.environ.get(\"SANIC_NO_UVLOOP\", \"no\")):\n    print(\"Installing without uvLoop\")\n    requirements.remove(uvloop)"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "extras_require = {\n    \"test\": tests_require,\n    \"dev\": dev_require,\n    \"docs\": docs_require,\n    \"all\": all_require,\n    \"ext\": [\"sanic-ext\"],\n    \"http3\": [\"aioquic\"],\n}"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/sanic/setup.py",
      "content": "setup_kwargs[\"install_requires\"] = requirements\nsetup_kwargs[\"tests_require\"] = tests_require\nsetup_kwargs[\"extras_require\"] = extras_require\nsetup_kwargs[\"cmdclass\"] = {\"test\": PyTest}\nsetup(**setup_kwargs)"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/sanic/sanic/__init__.py",
      "content": "from types import SimpleNamespace\n\nfrom typing_extensions import TypeAlias\n\nfrom sanic.__version__ import __version__\nfrom sanic.app import Sanic\nfrom sanic.blueprints import Blueprint\nfrom sanic.config import Config\nfrom sanic.constants import HTTPMethod\nfrom sanic.exceptions import (\n    BadRequest,\n    ExpectationFailed,\n    FileNotFound,\n    Forbidden,\n    HeaderNotFound,\n    InternalServerError,\n    InvalidHeader,\n    MethodNotAllowed,\n    NotFound,\n    RangeNotSatisfiable,\n    SanicException,\n    ServerError,\n    ServiceUnavailable,\n    Unauthorized,\n)\nfrom sanic.request import Request\nfrom sanic.response import (\n    HTTPResponse,\n    empty,\n    file,\n    html,\n    json,\n    raw,\n    redirect,\n    text,\n)\nfrom sanic.server.websockets.impl import WebsocketImplProtocol as Websocket"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/sanic/sanic/__init__.py",
      "content": "DefaultSanic: TypeAlias = \"Sanic[Config, SimpleNamespace]\"\n\"\"\"\nA type alias for a Sanic app with a default config and namespace.\n\"\"\""
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/sanic/sanic/__init__.py",
      "content": "DefaultRequest: TypeAlias = Request[DefaultSanic, SimpleNamespace]\n\"\"\"\nA type alias for a request with a default Sanic app and namespace.\n\"\"\""
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/sanic/sanic/__init__.py",
      "content": "__all__ = (\n    \"__version__\",\n    # Common objects\n    \"Sanic\",\n    \"Config\",\n    \"Blueprint\",\n    \"HTTPMethod\",\n    \"HTTPResponse\",\n    \"Request\",\n    \"Websocket\",\n    # Common types\n    \"DefaultSanic\",\n    \"DefaultRequest\",\n    # Common exceptions\n    \"BadRequest\",\n    \"ExpectationFailed\",\n    \"FileNotFound\",\n    \"Forbidden\",\n    \"HeaderNotFound\",\n    \"InternalServerError\",\n    \"InvalidHeader\",\n    \"MethodNotAllowed\",\n    \"NotFound\",\n    \"RangeNotSatisfiable\",\n    \"SanicException\",\n    \"ServerError\",\n    \"ServiceUnavailable\",\n    \"Unauthorized\",\n    # Common response methods\n    \"empty\",\n    \"file\",\n    \"html\",\n    \"json\",\n    \"raw\",\n    \"redirect\",\n    \"text\",\n)"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "from __future__ import annotations\n\nfrom collections import deque\nfrom collections.abc import Sequence\nfrom enum import IntEnum, auto\nfrom itertools import count\nfrom typing import Deque, Union\n\nfrom sanic.models.handler_types import MiddlewareType"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "class MiddlewareLocation(IntEnum):\n    REQUEST = auto()\n    RESPONSE = auto()"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "class Middleware:\n    \"\"\"Middleware object that is used to encapsulate middleware functions.\n\n    This should generally not be instantiated directly, but rather through\n    the `sanic.Sanic.middleware` decorator and its variants.\n\n    Args:\n        func (MiddlewareType): The middleware function to be called.\n        location (MiddlewareLocation): The location of the middleware.\n        priority (int): The priority of the middleware.\n    \"\"\"\n\n    _counter = count()\n    count: int\n\n    __slots__ = (\"func\", \"priority\", \"location\", \"definition\")\n\n    def __init__(\n        self,\n        func: MiddlewareType,\n        location: MiddlewareLocation,\n        priority: int = 0,\n    ) -> None:\n        self.func = func\n        self.priority = priority\n        self.location = location\n        self.definition = next(Middleware._counter)"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "def __call__(self, *args, **kwargs):\n        return self.func(*args, **kwargs)"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "def __hash__(self) -> int:\n        return hash(self.func)"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "def __repr__(self) -> str:\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"func=<function {self.func.__name__}>, \"\n            f\"priority={self.priority}, \"\n            f\"location={self.location.name})\"\n        )"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "@property\n    def order(self) -> tuple[int, int]:\n        \"\"\"Return a tuple of the priority and definition order.\n\n        This is used to sort the middleware.\n\n        Returns:\n            tuple[int, int]: The priority and definition order.\n        \"\"\"\n        return (self.priority, -self.definition)"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "@classmethod\n    def convert(\n        cls,\n        *middleware_collections: Sequence[Union[Middleware, MiddlewareType]],\n        location: MiddlewareLocation,\n    ) -> Deque[Middleware]:\n        \"\"\"Convert middleware collections to a deque of Middleware objects.\n\n        Args:\n            *middleware_collections (Sequence[Union[Middleware, MiddlewareType]]):\n                The middleware collections to convert.\n            location (MiddlewareLocation): The location of the middleware.\n\n        Returns:\n            Deque[Middleware]: The converted middleware.\n        \"\"\"  # noqa: E501\n        return deque(\n            [\n                middleware\n                if isinstance(middleware, Middleware)\n                else Middleware(middleware, location)\n                for collection in middleware_collections\n                for middleware in collection\n            ]\n        )"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/sanic/sanic/middleware.py",
      "content": "@classmethod\n    def reset_count(cls) -> None:\n        \"\"\"Reset the counter for the middleware definition order.\n\n        This is used for testing.\n\n        Returns:\n            None\n        \"\"\"\n        cls._counter = count()\n        cls.count = next(cls._counter)"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/sanic/sanic/__main__.py",
      "content": "from sanic.cli.app import SanicCLI\nfrom sanic.compat import OS_IS_WINDOWS, enable_windows_color_support"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/sanic/sanic/__main__.py",
      "content": "if OS_IS_WINDOWS:\n    enable_windows_color_support()"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/sanic/sanic/__main__.py",
      "content": "def main(args=None):\n    cli = SanicCLI()\n    cli.attach()\n    cli.run(args)"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/sanic/sanic/__main__.py",
      "content": "if __name__ == \"__main__\":\n    main()"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "from __future__ import annotations\n\nimport warnings\n\nfrom typing import TYPE_CHECKING, Optional\n\nfrom sanic.compat import Header\nfrom sanic.exceptions import BadRequest, ServerError\nfrom sanic.helpers import Default\nfrom sanic.http import Stage\nfrom sanic.log import error_logger, logger\nfrom sanic.models.asgi import ASGIReceive, ASGIScope, ASGISend, MockTransport\nfrom sanic.request import Request\nfrom sanic.response import BaseHTTPResponse\nfrom sanic.server import ConnInfo\nfrom sanic.server.websockets.connection import WebSocketConnection"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "class Lifespan:\n    def __init__(\n        self, sanic_app, scope: ASGIScope, receive: ASGIReceive, send: ASGISend\n    ) -> None:\n        self.sanic_app = sanic_app\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n\n        if \"server.init.before\" in self.sanic_app.signal_router.name_index:\n            logger.debug(\n                'You have set a listener for \"before_server_start\" '\n                \"in ASGI mode. \"\n                \"It will be executed as early as possible, but not before \"\n                \"the ASGI server is started.\",\n                extra={\"verbosity\": 1},\n            )\n        if \"server.shutdown.after\" in self.sanic_app.signal_router.name_index:\n            logger.debug(\n                'You have set a listener for \"after_server_stop\" '\n                \"in ASGI mode. \"\n                \"It will be executed as late as possible, but not after \"\n                \"the ASGI server is stopped.\",\n                extra={\"verbosity\": 1},\n            )\n\n    async def startup(self) -> None:\n        \"\"\"\n        Gather the listeners to fire on server start.\n        Because we are using a third-party server and not Sanic server, we do\n        not have access to fire anything BEFORE the server starts.\n        Therefore, we fire before_server_start and after_server_start\n        in sequence since the ASGI lifespan protocol only supports a single\n        startup event.\n        \"\"\"\n        await self.sanic_app._startup()\n        await self.sanic_app._server_event(\"init\", \"before\")\n        await self.sanic_app._server_event(\"init\", \"after\")\n\n        if not isinstance(self.sanic_app.config.USE_UVLOOP, Default):\n            warnings.warn(\n                \"You have set the USE_UVLOOP configuration option, but Sanic \"\n                \"cannot control the event loop when running in ASGI mode.\"\n                \"This option will be ignored.\"\n            )\n\n    async def shutdown(self) -> None:\n        \"\"\"\n        Gather the listeners to fire on server stop.\n        Because we are using a third-party server and not Sanic server, we do\n        not have access to fire anything AFTER the server stops.\n        Therefore, we fire before_server_stop and after_server_stop\n        in sequence since the ASGI lifespan protocol only supports a single\n        shutdown event.\n        \"\"\"\n        await self.sanic_app._server_event(\"shutdown\", \"before\")\n        await self.sanic_app._server_event(\"shutdown\", \"after\")\n\n    async def __call__(self) -> None:\n        while True:\n            message = await self.receive()\n            if message[\"type\"] == \"lifespan.startup\":\n                try:\n                    await self.startup()\n                except Exception as e:\n                    error_logger.exception(e)\n                    await self.send(\n                        {\"type\": \"lifespan.startup.failed\", \"message\": str(e)}\n                    )\n                else:\n                    await self.send({\"type\": \"lifespan.startup.complete\"})\n            elif message[\"type\"] == \"lifespan.shutdown\":\n                try:\n                    await self.shutdown()\n                except Exception as e:\n                    error_logger.exception(e)\n                    await self.send(\n                        {\"type\": \"lifespan.shutdown.failed\", \"message\": str(e)}\n                    )\n                else:\n                    await self.send({\"type\": \"lifespan.shutdown.complete\"})\n                return"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "class ASGIApp:\n    sanic_app: Sanic\n    request: Request\n    transport: MockTransport\n    lifespan: Lifespan\n    ws: Optional[WebSocketConnection]\n    stage: Stage\n    response: Optional[BaseHTTPResponse]\n\n    @classmethod\n    async def create(\n        cls,\n        sanic_app: Sanic,\n        scope: ASGIScope,\n        receive: ASGIReceive,\n        send: ASGISend,\n    ) -> ASGIApp:\n        instance = cls()\n        instance.ws = None\n        instance.sanic_app = sanic_app\n        instance.transport = MockTransport(scope, receive, send)\n        instance.transport.loop = sanic_app.loop\n        instance.stage = Stage.IDLE\n        instance.response = None\n        instance.sanic_app.state.is_started = True\n        setattr(instance.transport, \"add_task\", sanic_app.loop.create_task)\n\n        try:\n            headers = Header(\n                [\n                    (\n                        key.decode(\"ASCII\"),\n                        value.decode(errors=\"surrogateescape\"),\n                    )\n                    for key, value in scope.get(\"headers\", [])\n                ]\n            )\n        except UnicodeDecodeError:\n            raise BadRequest(\n                \"Header names can only contain US-ASCII characters\"\n            )\n\n        if scope[\"type\"] == \"http\":\n            version = scope[\"http_version\"]\n            method = scope[\"method\"]\n        elif scope[\"type\"] == \"websocket\":\n            version = \"1.1\"\n            method = \"GET\"\n\n            instance.ws = instance.transport.create_websocket_connection(\n                send, receive\n            )\n        else:\n            raise ServerError(\"Received unknown ASGI scope\")\n\n        url_bytes, query = scope[\"raw_path\"], scope[\"query_string\"]\n        if query:\n            # httpx ASGI client sends query string as part of raw_path\n            url_bytes = url_bytes.split(b\"?\", 1)[0]\n            # All servers send them separately\n            url_bytes = b\"%b?%b\" % (url_bytes, query)\n\n        request_class = sanic_app.request_class or Request  # type: ignore\n        instance.request = request_class(\n            url_bytes,\n            headers,\n            version,\n            method,\n            instance.transport,\n            sanic_app,\n        )\n        request_class._current.set(instance.request)\n        instance.request.stream = instance  # type: ignore\n        instance.request_body = True\n        instance.request.conn_info = ConnInfo(instance.transport)\n\n        await instance.sanic_app.dispatch(\n            \"http.lifecycle.request\",\n            inline=True,\n            context={\"request\": instance.request},\n            fail_not_found=False,\n        )\n\n        return instance"
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "async def read(self) -> Optional[bytes]:\n        \"\"\"\n        Read and stream the body in chunks from an incoming ASGI message.\n        \"\"\"\n        if self.stage is Stage.IDLE:\n            self.stage = Stage.REQUEST\n        message = await self.transport.receive()\n        body = message.get(\"body\", b\"\")\n        if not message.get(\"more_body\", False):\n            self.request_body = False\n            if not body:\n                return None\n        return body"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "async def __aiter__(self):\n        while self.request_body:\n            data = await self.read()\n            if data:\n                yield data"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "def respond(self, response: BaseHTTPResponse):\n        if self.stage is not Stage.HANDLER:\n            self.stage = Stage.FAILED\n            raise RuntimeError(\"Response already started\")\n        if self.response is not None:\n            self.response.stream = None\n        response.stream, self.response = self, response\n        return response"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "async def send(self, data, end_stream):\n        if self.stage is Stage.IDLE:\n            if not end_stream or data:\n                raise RuntimeError(\n                    \"There is no request to respond to, either the \"\n                    \"response has already been sent or the \"\n                    \"request has not been received yet.\"\n                )\n            return\n        if self.response and self.stage is Stage.HANDLER:\n            await self.transport.send(\n                {\n                    \"type\": \"http.response.start\",\n                    \"status\": self.response.status,\n                    \"headers\": self.response.processed_headers,\n                }\n            )\n            response_body = getattr(self.response, \"body\", None)\n            if response_body:\n                data = response_body + data if data else response_body\n        self.stage = Stage.IDLE if end_stream else Stage.RESPONSE\n        await self.transport.send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": data.encode() if hasattr(data, \"encode\") else data,\n                \"more_body\": not end_stream,\n            }\n        )"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/sanic/sanic/asgi.py",
      "content": "_asgi_single_callable = True  # We conform to ASGI 3.0 single-callable\n\n    async def __call__(self) -> None:\n        \"\"\"\n        Handle the incoming request.\n        \"\"\"\n        try:\n            self.stage = Stage.HANDLER\n            await self.sanic_app.handle_request(self.request)\n        except Exception as e:\n            try:\n                await self.sanic_app.handle_exception(self.request, e)\n            except Exception as exc:\n                await self.sanic_app.handle_exception(self.request, exc, False)"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/sanic/sanic/constants.py",
      "content": "from enum import auto\n\nfrom sanic.compat import UpperStrEnum"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/sanic/sanic/constants.py",
      "content": "class HTTPMethod(UpperStrEnum):\n    \"\"\"HTTP methods that are commonly used.\"\"\"\n\n    GET = auto()\n    POST = auto()\n    PUT = auto()\n    HEAD = auto()\n    OPTIONS = auto()\n    PATCH = auto()\n    DELETE = auto()"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/sanic/sanic/constants.py",
      "content": "class LocalCertCreator(UpperStrEnum):\n    \"\"\"Local certificate creator.\"\"\"\n\n    AUTO = auto()\n    TRUSTME = auto()\n    MKCERT = auto()"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/sanic/sanic/constants.py",
      "content": "HTTP_METHODS = tuple(HTTPMethod.__members__.values())\nSAFE_HTTP_METHODS = (HTTPMethod.GET, HTTPMethod.HEAD, HTTPMethod.OPTIONS)\nIDEMPOTENT_HTTP_METHODS = (\n    HTTPMethod.GET,\n    HTTPMethod.HEAD,\n    HTTPMethod.PUT,\n    HTTPMethod.DELETE,\n    HTTPMethod.OPTIONS,\n)\nCACHEABLE_HTTP_METHODS = (HTTPMethod.GET, HTTPMethod.HEAD)\nDEFAULT_HTTP_CONTENT_TYPE = \"application/octet-stream\"\nDEFAULT_LOCAL_TLS_KEY = \"key.pem\"\nDEFAULT_LOCAL_TLS_CERT = \"cert.pem\""
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "```python"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport logging.config\nimport re\nimport sys\n\nfrom asyncio import (\n    AbstractEventLoop,\n    CancelledError,\n    Task,\n    ensure_future,\n    get_running_loop,\n    wait_for,\n)\nfrom asyncio.futures import Future\nfrom collections import defaultdict, deque\nfrom collections.abc import Awaitable, Coroutine, Iterable, Iterator\nfrom contextlib import contextmanager, suppress\nfrom enum import Enum\nfrom functools import partial, wraps\nfrom inspect import isawaitable\nfrom os import environ\nfrom pathlib import Path\nfrom socket import socket\nfrom traceback import format_exc\nfrom types import SimpleNamespace\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    AnyStr,\n    Callable,\n    ClassVar,\n    Deque,\n    Generic,\n    Literal,\n    Optional,\n    TypeVar,\n    Union,\n    cast,\n    overload,\n)\nfrom urllib.parse import urlencode, urlunparse\n\nfrom sanic_routing.exceptions import FinalizationError, NotFound\nfrom sanic_routing.route import Route\n\nfrom sanic.application.ext import setup_ext\nfrom sanic.application.state import ApplicationState, ServerStage\nfrom sanic.asgi import ASGIApp, Lifespan\nfrom sanic.base.root import BaseSanic\nfrom sanic.blueprint_group import BlueprintGroup\nfrom sanic.blueprints import Blueprint\nfrom sanic.compat import OS_IS_WINDOWS, enable_windows_color_support\nfrom sanic.config import SANIC_PREFIX, Config\nfrom sanic.exceptions import (\n    BadRequest,\n    SanicException,\n    ServerError,\n    URLBuildError,\n)\nfrom sanic.handlers import ErrorHandler\nfrom sanic.helpers import Default, _default\nfrom sanic.http import Stage\nfrom sanic.log import LOGGING_CONFIG_DEFAULTS, error_logger, logger\nfrom sanic.logging.setup import setup_logging\nfrom sanic.middleware import Middleware, MiddlewareLocation\nfrom sanic.mixins.commands import CommandMixin\nfrom sanic.mixins.listeners import ListenerEvent\nfrom sanic.mixins.startup import StartupMixin\nfrom sanic.mixins.static import StaticHandleMixin\nfrom sanic.models.futures import (\n    FutureException,\n    FutureListener,\n    FutureMiddleware,\n    FutureRegistry,\n    FutureRoute,\n    FutureSignal,\n)\nfrom sanic.models.handler_types import ListenerType, MiddlewareType\nfrom sanic.models.handler_types import Sanic as SanicVar\nfrom sanic.request import Request\nfrom sanic.response import BaseHTTPResponse, HTTPResponse, ResponseStream\nfrom sanic.router import Router\nfrom sanic.server.websockets.impl import ConnectionClosed\nfrom sanic.signals import Event, Signal, SignalRouter\nfrom sanic.touchup import TouchUp, TouchUpMeta\nfrom sanic.types.shared_ctx import SharedContext\nfrom sanic.worker.inspector import Inspector\nfrom sanic.worker.loader import CertLoader\nfrom sanic.worker.manager import WorkerManager\n\n\nif TYPE_CHECKING:\n    try:\n        from sanic_ext import Extend  # type: ignore\n        from sanic_ext.extensions.base import Extension  # type: ignore\n    except ImportError:\n        Extend = TypeVar(\"Extend\", type)  # type: ignore\n\n\nif OS_IS_WINDOWS:  # no cov\n    enable_windows_color_support()\n\nctx_type = TypeVar(\"ctx_type\")\nconfig_type = TypeVar(\"config_type\", bound=Config)"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "class Sanic(\n    Generic[config_type, ctx_type],\n    StaticHandleMixin,\n    BaseSanic,\n    StartupMixin,\n    CommandMixin,\n    metaclass=TouchUpMeta,\n):\n    \"\"\"The main application instance\n\n    You will create an instance of this class and use it to register\n    routes, listeners, middleware, blueprints, error handlers, etc.\n\n    By convention, it is often called `app`. It must be named using\n    the `name` parameter and is roughly constrained to the same\n    restrictions as a Python module name, however, it can contain\n    hyphens (`-`).\n\n    ```python\n    # will cause an error because it contains spaces\n    Sanic(\"This is not legal\")\n    ```\n\n    ```python\n    # this is legal\n    Sanic(\"Hyphens-are-legal_or_also_underscores\")\n    ```\n\n    Args:\n        name (str): The name of the application. Must be a valid\n            Python module name (including hyphens).\n        config (Optional[config_type]): The configuration to use for\n            the application. Defaults to `None`.\n        ctx (Optional[ctx_type]): The context to use for the\n            application. Defaults to `None`.\n        router (Optional[Router]): The router to use for the\n            application. Defaults to `None`.\n        signal_router (Optional[SignalRouter]): The signal router to\n            use for the application. Defaults to `None`.\n        error_handler (Optional[ErrorHandler]): The error handler to\n            use for the application. Defaults to `None`.\n        env_prefix (Optional[str]): The prefix to use for environment\n            variables. Defaults to `SANIC_`.\n        request_class (Optional[Type[Request]]): The request class to\n            use for the application. Defaults to `Request`.\n        strict_slashes (bool): Whether to enforce strict slashes.\n            Defaults to `False`.\n        log_config (Optional[Dict[str, Any]]): The logging configuration\n            to use for the application. Defaults to `None`.\n        configure_logging (bool): Whether to configure logging.\n            Defaults to `True`.\n        dumps (Optional[Callable[..., AnyStr]]): The function to use\n            for serializing JSON. Defaults to `None`.\n        loads (Optional[Callable[..., Any]]): The function to use\n            for deserializing JSON. Defaults to `None`.\n        inspector (bool): Whether to enable the inspector. Defaults\n            to `False`.\n        inspector_class (Optional[Type[Inspector]]): The inspector\n            class to use for the application. Defaults to `None`.\n        certloader_class (Optional[Type[CertLoader]]): The certloader\n            class to use for the application. Defaults to `None`.\n    \"\"\"\n\n    __touchup__ = (\n        \"handle_request\",\n        \"handle_exception\",\n        \"_run_response_middleware\",\n        \"_run_request_middleware\",\n    )\n    __slots__ = (\n        \"_asgi_app\",\n        \"_asgi_lifespan\",\n        \"_asgi_client\",\n        \"_blueprint_order\",\n        \"_delayed_tasks\",\n        \"_ext\",\n        \"_future_commands\",\n        \"_future_exceptions\",\n        \"_future_listeners\",\n        \"_future_middleware\",\n        \"_future_registry\",\n        \"_future_routes\",\n        \"_future_signals\",\n        \"_future_statics\",\n        \"_inspector\",\n        \"_manager\",\n        \"_state\",\n        \"_task_registry\",\n        \"_test_client\",\n        \"_test_manager\",\n        \"blueprints\",\n        \"certloader_class\",\n        \"config\",\n        \"configure_logging\",\n        \"ctx\",\n        \"error_handler\",\n        \"inspector_class\",\n        \"go_fast\",\n        \"listeners\",\n        \"multiplexer\",\n        \"named_request_middleware\",\n        \"named_response_middleware\",\n        \"request_class\",\n        \"request_middleware\",\n        \"response_middleware\",\n        \"router\",\n        \"shared_ctx\",\n        \"signal_router\",\n        \"sock\",\n        \"strict_slashes\",\n        \"websocket_enabled\",\n        \"websocket_tasks\",\n    )\n\n    _app_registry: ClassVar[dict[str, Sanic]] = {}\n    test_mode: ClassVar[bool] = False\n\n    @overload\n    def __init__(\n        self: Sanic[Config, SimpleNamespace],\n        name: str,\n        config: None = None,\n        ctx: None = None,\n        router: Optional[Router] = None,\n        signal_router: Optional[SignalRouter] = None,\n        error_handler: Optional[ErrorHandler] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        request_class: Optional[type[Request]] = None,\n        strict_slashes: bool = False,\n        log_config: Optional[dict[str, Any]] = None,\n        configure_logging: bool = True,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        loads: Optional[Callable[..., Any]] = None,\n        inspector: bool = False,\n        inspector_class: Optional[type[Inspector]] = None,\n        certloader_class: Optional[type[CertLoader]] = None,\n    ) -> None: ...\n\n    @overload\n    def __init__(\n        self: Sanic[config_type, SimpleNamespace],\n        name: str,\n        config: Optional[config_type] = None,\n        ctx: None = None,\n        router: Optional[Router] = None,\n        signal_router: Optional[SignalRouter] = None,\n        error_handler: Optional[ErrorHandler] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        request_class: Optional[type[Request]] = None,\n        strict_slashes: bool = False,\n        log_config: Optional[dict[str, Any]] = None,\n        configure_logging: bool = True,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        loads: Optional[Callable[..., Any]] = None,\n        inspector: bool = False,\n        inspector_class: Optional[type[Inspector]] = None,\n        certloader_class: Optional[type[CertLoader]] = None,\n    ) -> None: ...\n\n    @overload\n    def __init__(\n        self: Sanic[Config, ctx_type],\n        name: str,\n        config: None = None,\n        ctx: Optional[ctx_type] = None,\n        router: Optional[Router] = None,\n        signal_router: Optional[SignalRouter] = None,\n        error_handler: Optional[ErrorHandler] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        request_class: Optional[type[Request]] = None,\n        strict_slashes: bool = False,\n        log_config: Optional[dict[str, Any]] = None,\n        configure_logging: bool = True,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        loads: Optional[Callable[..., Any]] = None,\n        inspector: bool = False,\n        inspector_class: Optional[type[Inspector]] = None,\n        certloader_class: Optional[type[CertLoader]] = None,\n    ) -> None: ...\n\n    @overload\n    def __init__(\n        self: Sanic[config_type, ctx_type],\n        name: str,\n        config: Optional[config_type] = None,\n        ctx: Optional[ctx_type] = None,\n        router: Optional[Router] = None,\n        signal_router: Optional[SignalRouter] = None,\n        error_handler: Optional[ErrorHandler] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        request_class: Optional[type[Request]] = None,\n        strict_slashes: bool = False,\n        log_config: Optional[dict[str, Any]] = None,\n        configure_logging: bool = True,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        loads: Optional[Callable[..., Any]] = None,\n        inspector: bool = False,\n        inspector_class: Optional[type[Inspector]] = None,\n        certloader_class: Optional[type[CertLoader]] = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        name: str,\n        config: Optional[config_type] = None,\n        ctx: Optional[ctx_type] = None,\n        router: Optional[Router] = None,\n        signal_router: Optional[SignalRouter] = None,\n        error_handler: Optional[ErrorHandler] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        request_class: Optional[type[Request]] = None,\n        strict_slashes: bool = False,\n        log_config: Optional[dict[str, Any]] = None,\n        configure_logging: bool = True,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        loads: Optional[Callable[..., Any]] = None,\n        inspector: bool = False,\n        inspector_class: Optional[type[Inspector]] = None,\n        certloader_class: Optional[type[CertLoader]] = None,\n    ) -> None:\n        super().__init__(name=name)\n        # logging\n        if configure_logging:\n            dict_config = log_config or LOGGING_CONFIG_DEFAULTS\n            logging.config.dictConfig(dict_config)  # type: ignore\n\n        if config and env_prefix != SANIC_PREFIX:\n            raise SanicException(\n                \"When instantiating Sanic with config, you cannot also pass \"\n                \"env_prefix\"\n            )\n\n        # First setup config\n        self.config: config_type = cast(\n            config_type, config or Config(env_prefix=env_prefix)\n        )\n        if inspector:\n            self.config.INSPECTOR = inspector\n\n        # Then we can do the rest\n        self._asgi_app: Optional[ASGIApp] = None\n        self._asgi_lifespan: Optional[Lifespan] = None\n        self._asgi_client: Any = None\n        self._blueprint_order: list[Blueprint] = []\n        self._delayed_tasks: list[str] = []\n        self._future_registry: FutureRegistry = FutureRegistry()\n        self._inspector: Optional[Inspector] = None\n        self._manager: Optional[WorkerManager] = None\n        self._state: ApplicationState = ApplicationState(app=self)\n        self._task_registry: dict[str, Union[Task, None]] = {}\n        self._test_client: Any = None\n        self._test_manager: Any = None\n        self.asgi = False\n        self.auto_reload = False\n        self.blueprints: dict[str, Blueprint] = {}\n        self.certloader_class: type[CertLoader] = (\n            certloader_class or CertLoader\n        )\n        self.configure_logging: bool = configure_logging\n        self.ctx: ctx_type = cast(ctx_type, ctx or SimpleNamespace())\n        self.error_handler: ErrorHandler = error_handler or ErrorHandler()\n        self.inspector_class: type[Inspector] = inspector_class or Inspector\n        self.listeners: dict[str, list[ListenerType[Any]]] = defaultdict(list)\n        self.named_request_middleware: dict[str, Deque[Middleware]] = {}\n        self.named_response_middleware: dict[str, Deque[Middleware]] = {}\n        self.request_class = request_class or Request\n        self.request_middleware: Deque[Middleware] = deque()\n        self.response_middleware: Deque[Middleware] = deque()\n        self.router: Router = router or Router()\n        self.shared_ctx: SharedContext = SharedContext()\n        self.signal_router: SignalRouter = signal_router or SignalRouter()\n        self.sock: Optional[socket] = None\n        self.strict_slashes: bool = strict_slashes\n        self.websocket_enabled: bool = False\n        self.websocket_tasks: set[Future[Any]] = set()\n\n        # Register alternative method names\n        self.go_fast = self.run\n        self.router.ctx.app = self\n        self.signal_router.ctx.app = self\n        self.__class__.register_app(self)\n\n        if dumps:\n            BaseHTTPResponse._dumps = dumps  # type: ignore\n        if loads:\n            Request._loads = loads  # type: ignore"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def loop(self) -> AbstractEventLoop:\n        \"\"\"Synonymous with asyncio.get_event_loop().\n\n        .. note::\n            Only supported when using the `app.run` method.\n\n        Returns:\n            AbstractEventLoop: The event loop for the application.\n\n        Raises:\n            SanicException: If the application is not running.\n        \"\"\"\n        if self.state.stage is ServerStage.STOPPED and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        try:\n            return get_running_loop()\n        except RuntimeError:  # no cov\n            if sys.version_info > (3, 10):\n                return asyncio.get_event_loop_policy().get_event_loop()\n            else:\n                return asyncio.get_event_loop()"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Registration\n    # -------------------------------------------------------------------- #\n\n    def register_listener(\n        self,\n        listener: ListenerType[SanicVar],\n        event: str,\n        *,\n        priority: int = 0,\n    ) -> ListenerType[SanicVar]:\n        \"\"\"Register the listener for a given event.\n\n        Args:\n            listener (Callable): The listener to register.\n            event (str): The event to listen for.\n\n        Returns:\n            Callable: The listener that was registered.\n        \"\"\"\n\n        try:\n            _event = ListenerEvent[event.upper()]\n        except (ValueError, AttributeError):\n            valid = \", \".join(\n                map(lambda x: x.lower(), ListenerEvent.__members__.keys())\n            )\n            raise BadRequest(f\"Invalid event: {event}. Use one of: {valid}\")\n\n        if \".\" in _event:\n            self.signal(_event.value, priority=priority)(\n                partial(self._listener, listener=listener)\n            )\n        else:\n            if priority:\n                error_logger.warning(\n                    f\"Priority is not supported for {_event.value}\"\n                )\n            self.listeners[_event.value].append(listener)\n\n        return listener"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def register_middleware(\n        self,\n        middleware: Union[MiddlewareType, Middleware],\n        attach_to: str = \"request\",\n        *,\n        priority: Union[Default, int] = _default,\n    ) -> Union[MiddlewareType, Middleware]:\n        \"\"\"Register a middleware to be called before a request is handled.\n\n        Args:\n            middleware (Callable): A callable that takes in a request.\n            attach_to (str): Whether to attach to request or response.\n                Defaults to `'request'`.\n            priority (int): The priority level of the middleware.\n                Lower numbers are executed first. Defaults to `0`.\n\n        Returns:\n            Union[Callable, Callable[[Callable], Callable]]: The decorated\n                middleware function or a partial function depending on how\n                the method was called.\n        \"\"\"\n        retval = middleware\n        location = MiddlewareLocation[attach_to.upper()]\n\n        if not isinstance(middleware, Middleware):\n            middleware = Middleware(\n                middleware,\n                location=location,\n                priority=priority if isinstance(priority, int) else 0,\n            )\n        elif middleware.priority != priority and isinstance(priority, int):\n            middleware = Middleware(\n                middleware.func,\n                location=middleware.location,\n                priority=priority,\n            )\n\n        if location is MiddlewareLocation.REQUEST:\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if location is MiddlewareLocation.RESPONSE:\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return retval"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def register_named_middleware(\n        self,\n        middleware: MiddlewareType,\n        route_names: Iterable[str],\n        attach_to: str = \"request\",\n        *,\n        priority: Union[Default, int] = _default,\n    ):\n        \"\"\"Used to register named middleqare (middleware typically on blueprints)\n\n        Args:\n            middleware (Callable): A callable that takes in a request.\n            route_names (Iterable[str]): The route names to attach the\n                middleware to.\n            attach_to (str): Whether to attach to request or response.\n                Defaults to `'request'`.\n            priority (int): The priority level of the middleware.\n                Lower numbers are executed first. Defaults to `0`.\n\n        Returns:\n            Union[Callable, Callable[[Callable], Callable]]: The decorated\n                middleware function or a partial function depending on how\n                the method was called.\n        \"\"\"  # noqa: E501\n        retval = middleware\n        location = MiddlewareLocation[attach_to.upper()]\n\n        if not isinstance(middleware, Middleware):\n            middleware = Middleware(\n                middleware,\n                location=location,\n                priority=priority if isinstance(priority, int) else 0,\n            )\n        elif middleware.priority != priority and isinstance(priority, int):\n            middleware = Middleware(\n                middleware.func,\n                location=middleware.location,\n                priority=priority,\n            )\n\n        if location is MiddlewareLocation.REQUEST:\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if location is MiddlewareLocation.RESPONSE:\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n                    self.named_response_middleware[_rn].appendleft(middleware)\n        return retval"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _apply_exception_handler(\n        self,\n        handler: FutureException,\n        route_names: Optional[list[str]] = None,\n    ):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        for exception in handler.exceptions:\n            if isinstance(exception, (tuple, list)):\n                for e in exception:\n                    self.error_handler.add(e, handler.handler, route_names)\n            else:\n                self.error_handler.add(exception, handler.handler, route_names)\n        return handler.handler"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _apply_listener(self, listener: FutureListener):\n        return self.register_listener(\n            listener.listener, listener.event, priority=listener.priority\n        )"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _apply_route(\n        self, route: FutureRoute, overwrite: bool = False\n    ) -> list[Route]:\n        params = route._asdict()\n        params[\"overwrite\"] = overwrite\n        websocket = params.pop(\"websocket\", False)\n        subprotocols = params.pop(\"subprotocols\", None)\n\n        if websocket:\n            self.enable_websocket()\n            websocket_handler = partial(\n                self._websocket_handler,\n                route.handler,\n                subprotocols=subprotocols,\n            )\n            websocket_handler.__name__ = route.handler.__name__  # type: ignore\n            websocket_handler.is_websocket = True  # type: ignore\n            params[\"handler\"] = websocket_handler\n\n        ctx = params.pop(\"route_context\")\n\n        with self.amend():\n            routes = self.router.add(**params)\n            if isinstance(routes, Route):\n                routes = [routes]\n\n            for r in routes:\n                r.extra.websocket = websocket\n                r.extra.static = params.get(\"static\", False)\n                r.ctx.__dict__.update(ctx)\n\n        return routes"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _apply_middleware(\n        self,\n        middleware: FutureMiddleware,\n        route_names: Optional[list[str]] = None,\n    ):\n        with self.amend():\n            if route_names:\n                return self.register_named_middleware(\n                    middleware.middleware, route_names, middleware.attach_to\n                )\n            else:\n                return self.register_middleware(\n                    middleware.middleware, middleware.attach_to\n                )"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _apply_signal(self, signal: FutureSignal) -> Signal:\n        with self.amend():\n            return self.signal_router.add(\n                handler=signal.handler,\n                event=signal.event,\n                condition=signal.condition,\n                exclusive=signal.exclusive,\n                priority=signal.priority,\n            )"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@overload\n    def dispatch(\n        self,\n        event: str,\n        *,\n        condition: Optional[dict[str, str]] = None,\n        context: Optional[dict[str, Any]] = None,\n        fail_not_found: bool = True,\n        inline: Literal[True],\n        reverse: bool = False,\n    ) -> Coroutine[Any, Any, Awaitable[Any]]: ...\n\n    @overload\n    def dispatch(\n        self,\n        event: str,\n        *,\n        condition: Optional[dict[str, str]] = None,\n        context: Optional[dict[str, Any]] = None,\n        fail_not_found: bool = True,\n        inline: Literal[False] = False,\n        reverse: bool = False,\n    ) -> Coroutine[Any, Any, Awaitable[Task]]: ...\n\n    def dispatch(\n        self,\n        event: str,\n        *,\n        condition: Optional[dict[str, str]] = None,\n        context: Optional[dict[str, Any]] = None,\n        fail_not_found: bool = True,\n        inline: bool = False,\n        reverse: bool = False,\n    ) -> Coroutine[Any, Any, Awaitable[Union[Task, Any]]]:\n        \"\"\"Dispatches an event to the signal router.\n\n        Args:\n            event (str): Name of the event to dispatch.\n            condition (Optional[Dict[str, str]]): Condition for the\n                event dispatch.\n            context (Optional[Dict[str, Any]]): Context for the event dispatch.\n            fail_not_found (bool): Whether to fail if the event is not found.\n                Default is `True`.\n            inline (bool): If `True`, returns the result directly. If `False`,\n                returns a `Task`. Default is `False`.\n            reverse (bool): Whether to reverse the dispatch order.\n                Default is `False`.\n\n        Returns:\n            Coroutine[Any, Any, Awaitable[Union[Task, Any]]]: An awaitable\n                that returns the result directly if `inline=True`, or a `Task`\n                if `inline=False`.\n\n        Examples:\n            ```python\n            @app.signal(\"user.registration.created\")\n            async def send_registration_email(**context):\n                await send_email(context[\"email\"], template=\"registration\")\n\n            @app.post(\"/register\")\n            async def handle_registration(request):\n                await do_registration(request)\n                await request.app.dispatch(\n                    \"user.registration.created\",\n                    context={\"email\": request.json.email}\n                })\n            ```\n        \"\"\"\n        return self.signal_router.dispatch(\n            event,\n            context=context,\n            condition=condition,\n            inline=inline,\n            reverse=reverse,\n            fail_not_found=fail_not_found,\n        )"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "async def event(\n        self,\n        event: Union[str, Enum],\n        timeout: Optional[Union[int, float]] = None,\n        *,\n        condition: Optional[dict[str, Any]] = None,\n        exclusive: bool = True,\n    ) -> None:\n        \"\"\"Wait for a specific event to be triggered.\n\n        This method waits for a named event to be triggered and can be used\n        in conjunction with the signal system to wait for specific signals.\n        If the event is not found and auto-registration of events is enabled,\n        the event will be registered and then waited on. If the event is not\n        found and auto-registration is not enabled, a `NotFound` exception\n        is raised.\n\n        Auto-registration can be handled by setting the `EVENT_AUTOREGISTER`\n        config value to `True`.\n\n        ```python\n        app.config.EVENT_AUTOREGISTER = True\n        ```\n\n        Args:\n            event (str): The name of the event to wait for.\n            timeout (Optional[Union[int, float]]): An optional timeout value\n                in seconds. If provided, the wait will be terminated if the\n                timeout is reached. Defaults to `None`, meaning no timeout.\n            condition: If provided, method will only return when the signal\n                is dispatched with the given condition.\n            exclusive: When true (default), the signal can only be dispatched\n                when the condition has been met. When ``False``, the signal can\n                be dispatched either with or without it.\n\n        Raises:\n            NotFound: If the event is not found and auto-registration of\n                events is not enabled.\n\n        Returns:\n            The context dict of the dispatched signal.\n\n        Examples:\n            ```python\n            async def wait_for_event(app):\n                while True:\n                    print(\"> waiting\")\n                    await app.event(\"foo.bar.baz\")\n                    print(\"> event found\")\n\n            @app.after_server_start\n            async def after_server_start(app, loop):\n                app.add_task(wait_for_event(app))\n            ```\n        \"\"\"\n\n        waiter = self.signal_router.get_waiter(event, condition, exclusive)\n\n        if not waiter and self.config.EVENT_AUTOREGISTER:\n            self.signal_router.reset()\n            self.add_signal(None, event)\n            waiter = self.signal_router.get_waiter(event, condition, exclusive)\n            self.signal_router.finalize()\n\n        if not waiter:\n            raise NotFound(f\"Could not find signal {event}\")\n\n        return await wait_for(waiter.wait(), timeout=timeout)"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def report_exception(\n        self, handler: Callable[[Sanic, Exception], Coroutine[Any, Any, None]]\n    ) -> Callable[[Exception], Coroutine[Any, Any, None]]:\n        \"\"\"Register a handler to report exceptions.\n\n        A convenience method to register a handler for the signal that\n        is emitted when an exception occurs. It is typically used to\n        report exceptions to an external service.\n\n        It is equivalent to:\n\n        ```python\n        @app.signal(Event.SERVER_EXCEPTION_REPORT)\n        async def report(exception):\n            await do_something_with_error(exception)\n        ```\n\n        Args:\n            handler (Callable[[Sanic, Exception], Coroutine[Any, Any, None]]):\n                The handler to register.\n\n        Returns:\n            Callable[[Sanic, Exception], Coroutine[Any, Any, None]]: The\n                handler that was registered.\n        \"\"\"\n\n        @wraps(handler)\n        async def report(exception: Exception) -> None:\n            await handler(self, exception)\n\n        self.add_signal(\n            handler=report, event=Event.SERVER_EXCEPTION_REPORT.value\n        )\n\n        return report"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def enable_websocket(self, enable: bool = True) -> None:\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application. This typically will not need to be\n        called manually.\n\n        Args:\n            enable (bool, optional): If set to `True`, enables websocket\n                support. If set to `False`, disables websocket support.\n                Defaults to `True`.\n\n        Returns:\n            None\n        \"\"\"\n\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            self.listener(\"before_server_stop\")(self._cancel_websocket_tasks)\n\n        self.websocket_enabled = enable"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def blueprint(\n        self,\n        blueprint: Union[Blueprint, Iterable[Blueprint], BlueprintGroup],\n        *,\n        url_prefix: Optional[str] = None,\n        version: Optional[Union[int, float, str]] = None,\n        strict_slashes: Optional[bool] = None,\n        version_prefix: Optional[str] = None,\n        name_prefix: Optional[str] = None,\n    ) -> None:\n        \"\"\"Register a blueprint on the application.\n\n        See [Blueprints](/en/guide/best-practices/blueprints) for more information.\n\n        Args:\n            blueprint (Union[Blueprint, Iterable[Blueprint], BlueprintGroup]): Blueprint object or (list, tuple) thereof.\n            url_prefix (Optional[str]): Prefix for all URLs bound to the blueprint. Defaults to `None`.\n            version (Optional[Union[int, float, str]]): Version prefix for URLs. Defaults to `None`.\n            strict_slashes (Optional[bool]): Enforce the trailing slashes. Defaults to `None`.\n            version_prefix (Optional[str]): Prefix for version. Defaults to `None`.\n            name_prefix (Optional[str]): Prefix for the blueprint name. Defaults to `None`.\n\n        Example:\n            ```python\n            app = Sanic(\"TestApp\")\n            bp = Blueprint('TestBP')\n\n            @bp.route('/route')\n            def handler(request):\n                return text('Hello, Blueprint!')\n\n            app.blueprint(bp, url_prefix='/blueprint')\n            ```\n        \"\"\"  # noqa: E501\n        options: dict[str, Any] = {}\n        if url_prefix is not None:\n            options[\"url_prefix\"] = url_prefix\n        if version is not None:\n            options[\"version\"] = version\n        if strict_slashes is not None:\n            options[\"strict_slashes\"] = strict_slashes\n        if version_prefix is not None:\n            options[\"version_prefix\"] = version_prefix\n        if name_prefix is not None:\n            options[\"name_prefix\"] = name_prefix\n        if isinstance(blueprint, (Iterable, BlueprintGroup)):\n            for item in blueprint:\n                params: dict[str, Any] = {**options}\n                if isinstance(blueprint, BlueprintGroup):\n                    merge_from = [\n                        options.get(\"url_prefix\", \"\"),\n                        blueprint.url_prefix or \"\",\n                    ]\n                    if not isinstance(item, BlueprintGroup):\n                        merge_from.append(item.url_prefix or \"\")\n                    merged_prefix = \"/\".join(\n                        str(u).strip(\"/\") for u in merge_from if u\n                    ).rstrip(\"/\")\n                    params[\"url_prefix\"] = f\"/{merged_prefix}\"\n\n                    for _attr in [\"version\", \"strict_slashes\"]:\n                        if getattr(item, _attr) is None:\n                            params[_attr] = getattr(\n                                blueprint, _attr\n                            ) or options.get(_attr)\n                    if item.version_prefix == \"/v\":\n                        if blueprint.version_prefix == \"/v\":\n                            params[\"version_prefix\"] = options.get(\n                                \"version_prefix\"\n                            )\n                        else:\n                            params[\"version_prefix\"] = blueprint.version_prefix\n                    name_prefix = getattr(blueprint, \"name_prefix\", None)\n                    if name_prefix and \"name_prefix\" not in params:\n                        params[\"name_prefix\"] = name_prefix\n                self.blueprint(item, **params)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n\n        if (\n            self.strict_slashes is not None\n            and blueprint.strict_slashes is None\n        ):\n            blueprint.strict_slashes = self.strict_slashes\n        blueprint.register(self, options)"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def url_for(self, view_name: str, **kwargs):\n        \"\"\"Build a URL based on a view name and the values provided.\n\n        This method constructs URLs for a given view name, taking into account\n        various special keyword arguments that can be used to modify the resulting\n        URL. It can handle internal routing as well as external URLs with different\n        schemes.\n\n        There are several special keyword arguments that can be used to modify\n        the URL that is built. They each begin with an underscore. They are:\n\n        - `_anchor`\n        - `_external`\n        - `_host`\n        - `_server`\n        - `_scheme`\n\n        Args:\n            view_name (str): String referencing the view name.\n            _anchor (str): Adds an \"#anchor\" to the end.\n            _scheme (str): Should be either \"http\" or \"https\", default is \"http\".\n            _external (bool): Whether to return the path or a full URL with scheme and host.\n            _host (str): Used when one or more hosts are defined for a route to tell Sanic which to use.\n            _server (str): If not using \"_host\", this will be used for defining the hostname of the URL.\n            **kwargs: Keys and values that are used to build request parameters and\n                    query string arguments.\n\n        Raises:\n            URLBuildError: If there are issues with constructing the URL.\n\n        Returns:\n            str: The built URL.\n\n        Examples:\n            Building a URL for a specific view with parameters:\n            ```python\n            url_for('view_name', param1='value1', param2='value2')\n            # /view-name?param1=value1&param2=value2\n            ```\n\n            Creating an external URL with a specific scheme and anchor:\n            ```python\n            url_for('view_name', _scheme='https', _external=True, _anchor='section1')\n            # https://example.com/view-name#section1\n            ```\n\n            Creating a URL with a specific host:\n            ```python\n            url_for('view_name', _host='subdomain.example.com')\n            # http://subdomain.example.com/view-name\n        \"\"\"  # noqa: E501\n        # find the route by the supplied view name\n        kw: dict[str, str] = {}\n        # special static files url_for\n\n        if \".\" not in view_name:\n            view_name = f\"{self.name}.{view_name}\"\n\n        if view_name.endswith(\".static\"):\n            name = kwargs.pop(\"name\", None)\n            if name:\n                view_name = view_name.replace(\"static\", name)\n            kw.update(name=view_name)\n\n        route = self.router.find_route_by_view_name(view_name, **kw)\n        if not route:\n            raise URLBuildError(\n                f\"Endpoint with name `{view_name}` was not found\"\n            )\n\n        uri = route.path\n\n        if getattr(route.extra, \"static\", None):\n            filename = kwargs.pop(\"filename\", \"\")\n            # it's static folder\n            if \"__file_uri__\" in uri:\n                folder_ = uri.split(\"<__file_uri__:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                kwargs[\"__file_uri__\"] = filename\n\n        if (\n            uri != \"/\"\n            and uri.endswith(\"/\")\n            and not route.strict\n            and not route.raw_path[:-1]\n        ):\n            uri = uri[:-1]\n\n        if not uri.startswith(\"/\"):\n            uri = f\"/{uri}\"\n\n        out = uri\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        host = kwargs.pop(\"_host\", None)\n        external = kwargs.pop(\"_external\", False) or bool(host)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if route.extra.hosts and external:\n            if not host and len(route.extra.hosts) > 1:\n                raise ValueError(\n                    f\"Host is ambiguous: {', '.join(route.extra.hosts)}\"\n                )\n            elif host and host not in route.extra.hosts:\n                raise ValueError(\n                    f\"Requested host ({host}) is not available for this \"\n                    f\"route: {route.extra.hosts}\"\n                )\n            elif not host:\n                host = list(route.extra.hosts)[0]\n\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = host or self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n                # Replace http/https with ws/wss for WebSocket handlers\n                if route.extra.websocket:\n                    scheme = scheme.replace(\"http\", \"ws\")\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        # find all the parameters we will need to build in the URL\n        # matched_params = re.findall(self.router.parameter_pattern, uri)\n        route.finalize()\n        for param_info in route.params.values():\n            # name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n\n            try:\n                supplied_param = str(kwargs.pop(param_info.name))\n            except KeyError:\n                raise URLBuildError(\n                    f\"Required parameter `{param_info.name}` was not \"\n                    \"passed to url_for\"\n                )\n\n            # determine if the parameter supplied by the caller\n            # passes the test in the URL\n            if param_info.pattern:\n                pattern = (\n                    param_info.pattern[1]\n                    if isinstance(param_info.pattern, tuple)\n                    else param_info.pattern\n                )\n                passes_pattern = pattern.match(supplied_param)\n                if not passes_pattern:\n                    if param_info.cast is not str:\n                        msg = (\n                            f'Value \"{supplied_param}\" '\n                            f\"for parameter `{param_info.name}` does \"\n                            \"not match pattern for type \"\n                            f\"`{param_info.cast.__name__}`: \"\n                            f\"{pattern.pattern}\"\n                        )\n                    else:\n                        msg = (\n                            f'Value \"{supplied_param}\" for parameter '\n                            f\"`{param_info.name}` does not satisfy \"\n                            f\"pattern {pattern.pattern}\"\n                        )\n                    raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = f\"(<{param_info.name}.*?>)\"\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Request Handling\n    # -------------------------------------------------------------------- #\n\n    async def handle_exception(\n        self,\n        request: Request,\n        exception: BaseException,\n        run_middleware: bool = True,\n    ) -> None:  # no cov\n        \"\"\"A handler that catches specific exceptions and outputs a response.\n\n        .. note::\n            This method is typically used internally, and you should not need\n            to call it directly.\n\n        Args:\n            request (Request): The current request object.\n            exception (BaseException): The exception that was raised.\n            run_middleware (bool): Whether to run middleware. Defaults\n                to `True`.\n\n        Raises:\n            ServerError: response 500.\n        \"\"\"\n        response = None\n        if not getattr(exception, \"__dispatched__\", False):\n            ...  # DO NOT REMOVE THIS LINE. IT IS NEEDED FOR TOUCHUP.\n            await self.dispatch(\n                \"server.exception.report\",\n                context={\"exception\": exception},\n            )\n        await self.dispatch(\n            \"http.lifecycle.exception\",\n            inline=True,\n            context={\"request\": request, \"exception\": exception},\n        )\n\n        if (\n            request.stream is not None\n            and request.stream.stage is not Stage.HANDLER\n        ):\n            error_logger.exception(exception, exc_info=True)\n            logger.error(\n                \"The error response will not be sent to the client for \"\n                f'the following exception:\"{exception}\". A previous response '\n                \"has at least partially been sent.\"\n            )\n\n            handler = self.error_handler._lookup(\n                exception, request.name if request else None\n            )\n            if handler:\n                logger.warning(\n                    \"An error occurred while handling the request after at \"\n                    \"least some part of the response was sent to the client. \"\n                    \"The response from your custom exception handler \"\n                    f\"{handler.__name__} will not be sent to the client.\"\n                    \"Exception handlers should only be used to generate the \"\n                    \"exception responses. If you would like to perform any \"\n                    \"other action on a raised exception, consider using a \"\n                    \"signal handler like \"\n                    '`@app.signal(\"http.lifecycle.exception\")`\\n'\n                    \"For further information, please see the docs: \"\n                    \"https://sanicframework.org/en/guide/advanced/\"\n                    \"signals.html\",\n                )\n            return\n\n        # -------------------------------------------- #\n        # Request Middleware\n        # -------------------------------------------- #\n        if run_middleware:\n            try:\n                middleware = (\n                    request.route and request.route.extra.request_middleware\n                ) or self.request_middleware\n                response = await self._run_request_middleware(\n                    request, middleware\n                )\n            except Exception as e:\n                return await self.handle_exception(request, e, False)\n        # No middleware results\n        if not response:\n            try:\n                response = self.error_handler.response(request, exception)\n                if isawaitable(response):\n                    response = await response\n            except Exception as e:\n                if isinstance(e, SanicException):\n                    response = self.error_handler.default(request, e)\n                elif self.debug:\n                    response = HTTPResponse(\n                        (\n                            f\"Error while handling error: {e}\\n\"\n                            f\"Stack: {format_exc()}\"\n                        ),\n                        status=500,\n                    )\n                else:\n                    response = HTTPResponse(\n                        \"An error occurred while handling an error\", status=500\n                    )\n        if response is not None:\n            try:\n                request.reset_response()\n                response = await request.respond(response)\n            except BaseException:\n                # Skip response middleware\n                if request.stream:\n                    request.stream.respond(response)\n                await response.send(end_stream=True)\n                raise\n        else:\n            if request.stream:\n                response = request.stream.response\n\n        # Marked for cleanup and DRY with handle_request/handle_exception\n        # when ResponseStream is no longer supporder\n        if isinstance(response, BaseHTTPResponse):\n            await self.dispatch(\n                \"http.lifecycle.response\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": response,\n                },\n            )\n            await response.send(end_stream=True)\n        elif isinstance(response, ResponseStream):\n            resp = await response(request)\n            await self.dispatch(\n                \"http.lifecycle.response\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": resp,\n                },\n            )\n            await response.eof()\n        else:\n            raise ServerError(\n                f\"Invalid response type {response!r} (need HTTPResponse)\"\n            )"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "async def handle_request(self, request: Request) -> None:  # no cov\n        \"\"\"Handles a request by dispatching it to the appropriate handler.\n\n        .. note::\n            This method is typically used internally, and you should not need\n            to call it directly.\n\n        Args:\n            request (Request): The current request object.\n\n        Raises:\n            ServerError: response 500.\n        \"\"\"\n        __tracebackhide__ = True\n\n        await self.dispatch(\n            \"http.lifecycle.handle\",\n            inline=True,\n            context={\"request\": request},\n        )\n\n        # Define `response` var here to remove warnings about\n        # allocation before assignment below.\n        response: Optional[\n            Union[\n                BaseHTTPResponse,\n                Coroutine[Any, Any, Optional[BaseHTTPResponse]],\n                ResponseStream,\n            ]\n        ] = None\n        run_middleware = True\n        try:\n            await self.dispatch(\n                \"http.routing.before\",\n                inline=True,\n                context={\"request\": request},\n            )\n            # Fetch handler from router\n            route, handler, kwargs = self.router.get(\n                request.path,\n                request.method,\n                request.headers.getone(\"host\", None),\n            )\n\n            request._match_info = {**kwargs}\n            request.route = route\n\n            await self.dispatch(\n                \"http.routing.after\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"route\": route,\n                    \"kwargs\": kwargs,\n                    \"handler\": handler,\n                },\n            )\n\n            if (\n                request.stream\n                and request.stream.request_body\n                and not route.extra.ignore_body\n            ):\n                if hasattr(handler, \"is_stream\"):\n                    # Streaming handler: lift the size limit\n                    request.stream.request_max_size = float(\"inf\")\n                else:\n                    # Non-streaming handler: preload body\n                    await request.receive_body()\n\n            # -------------------------------------------- #\n            # Request Middleware\n            # -------------------------------------------- #\n            run_middleware = False\n            if request.route.extra.request_middleware:\n                response = await self._run_request_middleware(\n                    request, request.route.extra.request_middleware\n                )\n\n            # No middleware results\n            if not response:\n                # -------------------------------------------- #\n                # Execute Handler\n                # -------------------------------------------- #\n\n                if handler is None:\n                    raise ServerError(\n                        \"'None' was returned while requesting a \"\n                        \"handler from the router\"\n                    )\n\n                # Run response handler\n                await self.dispatch(\n                    \"http.handler.before\",\n                    inline=True,\n                    context={\"request\": request},\n                )\n                response = handler(request, **request.match_info)\n                if isawaitable(response):\n                    response = await response\n                await self.dispatch(\n                    \"http.handler.after\",\n                    inline=True,\n                    context={\"request\": request},\n                )\n\n            if request.responded:\n                if response is not None:\n                    error_logger.error(\n                        \"The response object returned by the route handler \"\n                        \"will not be sent to client. The request has already \"\n                        \"been responded to.\"\n                    )\n                if request.stream is not None:\n                    response = request.stream.response\n            elif response is not None:\n                response = await request.respond(response)  # type: ignore\n            elif not hasattr(handler, \"is_websocket\"):\n                response = request.stream.response  # type: ignore\n\n            # Marked for cleanup and DRY with handle_request/handle_exception\n            # when ResponseStream is no longer supporder\n            if isinstance(response, BaseHTTPResponse):\n                await self.dispatch(\n                    \"http.lifecycle.response\",\n                    inline=True,\n                    context={\n                        \"request\": request,\n                        \"response\": response,\n                    },\n                )\n                ...\n                await response.send(end_stream=True)\n            elif isinstance(response, ResponseStream):\n                resp = await response(request)\n                await self.dispatch(\n                    \"http.lifecycle.response\",\n                    inline=True,\n                    context={\n                        \"request\": request,\n                        \"response\": resp,\n                    },\n                )\n                await response.eof()\n            else:\n                if not hasattr(handler, \"is_websocket\"):\n                    raise ServerError(\n                        f\"Invalid response type {response!r} \"\n                        \"(need HTTPResponse)\"\n                    )"
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "async def _websocket_handler(\n        self, handler, request, *args, subprotocols=None, **kwargs\n    ):\n        if self.asgi:\n            ws = request.transport.get_websocket_connection()\n            await ws.accept(subprotocols)\n        else:\n            protocol = request.transport.get_protocol()\n            ws = await protocol.websocket_handshake(request, subprotocols)\n\n        await self.dispatch(\n            \"websocket.handler.before\",\n            inline=True,\n            context={\"request\": request, \"websocket\": ws},\n            fail_not_found=False,\n        )\n        # schedule the application handler\n        # its future is kept in self.websocket_tasks in case it\n        # needs to be cancelled due to the server being stopped\n        fut = ensure_future(handler(request, ws, *args, **kwargs))\n        self.websocket_tasks.add(fut)\n        cancelled = False\n        try:\n            await fut\n            await self.dispatch(\n                \"websocket.handler.after\",\n                inline=True,\n                context={\"request\": request, \"websocket\": ws},\n                reverse=True,\n                fail_not_found=False,\n            )\n        except (CancelledError, ConnectionClosed):  # type: ignore\n            cancelled = True\n        except Exception as e:\n            self.error_handler.log(request, e)\n            await self.dispatch(\n                \"websocket.handler.exception\",\n                inline=True,\n                context={\"request\": request, \"websocket\": ws, \"exception\": e},\n                reverse=True,\n                fail_not_found=False,\n            )\n        finally:\n            self.websocket_tasks.remove(fut)\n            if cancelled:\n                ws.end_connection(1000)\n            else:\n                await ws.close()"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Testing\n    # -------------------------------------------------------------------- #\n\n    @property\n    def test_client(self) -> SanicTestClient:  # type: ignore # noqa\n        \"\"\"A testing client that uses httpx and a live running server to reach into the application to execute handlers.\n\n        This property is available if the `sanic-testing` package is installed.\n\n        See [Test Clients](/en/plugins/sanic-testing/clients#wsgi-client-sanictestclient) for details.\n\n        Returns:\n            SanicTestClient: A testing client from the `sanic-testing` package.\n        \"\"\"  # noqa: E501\n        if self._test_client:\n            return self._test_client\n        elif self._test_manager:\n            return self._test_manager.test_client\n        from sanic_testing.testing import SanicTestClient  # type: ignore\n\n        self._test_client = SanicTestClient(self)\n        return self._test_client"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def asgi_client(self) -> SanicASGITestClient:  # type: ignore # noqa\n        \"\"\"A testing client that uses ASGI to reach into the application to execute handlers.\n\n        This property is available if the `sanic-testing` package is installed.\n\n        See [Test Clients](/en/plugins/sanic-testing/clients#asgi-async-client-sanicasgitestclient) for details.\n\n        Returns:\n            SanicASGITestClient: A testing client from the `sanic-testing` package.\n        \"\"\"  # noqa: E501\n        if self._asgi_client:\n            return self._asgi_client\n        elif self._test_manager:\n            return self._test_manager.asgi_client\n        from sanic_testing.testing import SanicASGITestClient  # type: ignore\n\n        self._asgi_client = SanicASGITestClient(self)\n        return self._asgi_client"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Execution\n    # -------------------------------------------------------------------- #\n\n    async def _run_request_middleware(\n        self, request, middleware_collection\n    ):  # no cov\n        request._request_middleware_started = True\n\n        for middleware in middleware_collection:\n            await self.dispatch(\n                \"http.middleware.before\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": None,\n                },\n                condition={\"attach_to\": \"request\"},\n            )\n\n            response = middleware(request)\n            if isawaitable(response):\n                response = await response\n\n            await self.dispatch(\n                \"http.middleware.after\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": None,\n                },\n                condition={\"attach_to\": \"request\"},\n            )\n\n            if response:\n                return response\n        return None"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "async def _run_response_middleware(\n        self, request, response, middleware_collection\n    ):  # no cov\n        for middleware in middleware_collection:\n            await self.dispatch(\n                \"http.middleware.before\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": response,\n                },\n                condition={\"attach_to\": \"response\"},\n            )\n\n            _response = middleware(request, response)\n            if isawaitable(_response):\n                _response = await _response\n\n            await self.dispatch(\n                \"http.middleware.after\",\n                inline=True,\n                context={\n                    \"request\": request,\n                    \"response\": _response if _response else response,\n                },\n                condition={\"attach_to\": \"response\"},\n            )\n\n            if _response:\n                response = _response\n                if isinstance(response, BaseHTTPResponse):\n                    response = request.stream.respond(response)\n                break\n        return response"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@classmethod\n    def _cancel_websocket_tasks(cls, app, loop):\n        for task in app.websocket_tasks:\n            task.cancel()"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@staticmethod\n    async def _listener(\n        app: Sanic, loop: AbstractEventLoop, listener: ListenerType\n    ):\n        try:\n            maybe_coro = listener(app)  # type: ignore\n        except TypeError:\n            maybe_coro = listener(app, loop)  # type: ignore\n        if maybe_coro and isawaitable(maybe_coro):\n            await maybe_coro"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Task management\n    # -------------------------------------------------------------------- #\n\n    @classmethod\n    def _prep_task(\n        cls,\n        task,\n        app,\n        loop,\n    ):\n        async def do(task):\n            try:\n                if callable(task):\n                    try:\n                        task = task(app)\n                    except TypeError:\n                        task = task()\n                if isawaitable(task):\n                    await task\n            except CancelledError:\n                error_logger.warning(\n                    f\"Task {task} was cancelled before it completed.\"\n                )\n                raise\n            except Exception as e:\n                await app.dispatch(\n                    \"server.exception.report\",\n                    context={\"exception\": e},\n                )\n                raise\n\n        return do(task)"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@classmethod\n    def _loop_add_task(\n        cls,\n        task,\n        app,\n        loop,\n        *,\n        name: Optional[str] = None,\n        register: bool = True,\n    ) -> Task:\n        tsk: Task = task\n        if not isinstance(task, Future):\n            prepped = cls._prep_task(task, app, loop)\n            tsk = loop.create_task(prepped, name=name)\n\n        if name and register:\n            app._task_registry[name] = tsk\n\n        return tsk"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@staticmethod\n    async def dispatch_delayed_tasks(\n        app: Sanic,\n        loop: AbstractEventLoop,\n    ) -> None:\n        \"\"\"Signal handler for dispatching delayed tasks.\n\n        This is used to dispatch tasks that were added before the loop was\n        started, and will be called after the loop has started. It is\n        not typically used directly.\n\n        Args:\n            app (Sanic): The Sanic application instance.\n            loop (AbstractEventLoop): The event loop in which the tasks are\n                being run.\n\n        Returns:\n            None\n        \"\"\"\n        for name in app._delayed_tasks:\n            await app.dispatch(name, context={\"app\": app, \"loop\": loop})\n        app._delayed_tasks.clear()"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@staticmethod\n    async def run_delayed_task(\n        app: Sanic,\n        loop: AbstractEventLoop,\n        task: Union[Future[Any], Task[Any], Awaitable[Any]],\n    ) -> None:\n        \"\"\"Executes a delayed task within the context of a given app and loop.\n\n        This method prepares a given task by invoking the app's private\n        `_prep_task` method and then awaits the execution of the prepared task.\n\n        Args:\n            app (Any): The application instance on which the task will\n                be executed.\n            loop (AbstractEventLoop): The event loop where the task will\n                be scheduled.\n            task (Task[Any]): The task function that will be prepared\n                and executed.\n\n        Returns:\n            None\n        \"\"\"\n        prepped = app._prep_task(task, app, loop)\n        await prepped"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def add_task(\n        self,\n        task: Union[Future[Any], Coroutine[Any, Any, Any], Awaitable[Any]],\n        *,\n        name: Optional[str] = None,\n        register: bool = True,\n    ) -> Optional[Task[Any]]:\n        \"\"\"Schedule a task to run later, after the loop has started.\n\n        While this is somewhat similar to `asyncio.create_task`, it can be\n        used before the loop has started (in which case it will run after the\n        loop has started in the `before_server_start` listener).\n\n        Naming tasks is a good practice as it allows you to cancel them later,\n        and allows Sanic to manage them when the server is stopped, if needed.\n\n        [See user guide re: background tasks](/en/guide/basics/tasks#background-tasks)\n\n        Args:\n            task (Union[Future[Any], Coroutine[Any, Any, Any], Awaitable[Any]]):\n                The future, coroutine, or awaitable to schedule.\n            name (Optional[str], optional): The name of the task, if needed for\n                later reference. Defaults to `None`.\n            register (bool, optional): Whether to register the task. Defaults\n                to `True`.\n\n        Returns:\n            Optional[Task[Any]]: The task that was scheduled, if applicable.\n        \"\"\"  # noqa: E501\n        try:\n            loop = self.loop  # Will raise SanicError if loop is not started\n            return self._loop_add_task(\n                task, self, loop, name=name, register=register\n            )\n        except SanicException:\n            task_name = f\"sanic.delayed_task.{hash(task)}\"\n            if not self._delayed_tasks:\n                self.after_server_start(partial(self.dispatch_delayed_tasks))\n\n            if name:\n                raise RuntimeError(\n                    \"Cannot name task outside of a running application\"\n                )\n\n            self.signal(task_name)(partial(self.run_delayed_task, task=task))\n            self._delayed_tasks.append(task_name)\n            return None"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@overload\n    def get_task(\n        self, name: str, *, raise_exception: Literal[True]\n    ) -> Task: ...\n\n    @overload\n    def get_task(\n        self, name: str, *, raise_exception: Literal[False]\n    ) -> Optional[Task]: ...\n\n    @overload\n    def get_task(\n        self, name: str, *, raise_exception: bool\n    ) -> Optional[Task]: ...\n\n    def get_task(\n        self, name: str, *, raise_exception: bool = True\n    ) -> Optional[Task]:\n        \"\"\"Get a named task.\n\n        This method is used to get a task by its name. Optionally, you can\n        control whether an exception should be raised if the task is not found.\n\n        Args:\n            name (str): The name of the task to be retrieved.\n            raise_exception (bool): If `True`, an exception will be raised if\n                the task is not found. Defaults to `True`.\n\n        Returns:\n            Optional[Task]: The task, if found.\n        \"\"\"\n        try:\n            return self._task_registry[name]\n        except KeyError:\n            if raise_exception:\n                raise SanicException(\n                    f'Registered task named \"{name}\" not found.'\n                )\n            return None"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "async def cancel_task(\n        self,\n        name: str,\n        msg: Optional[str] = None,\n        *,\n        raise_exception: bool = True,\n    ) -> None:\n        \"\"\"Cancel a named task.\n\n        This method is used to cancel a task by its name. Optionally, you can\n        provide a message that describes why the task was canceled, and control\n        whether an exception should be raised if the task is not found.\n\n        Args:\n            name (str): The name of the task to be canceled.\n            msg (Optional[str]): Optional message describing why the task was canceled. Defaults to None.\n            raise_exception (bool): If True, an exception will be raised if the task is not found. Defaults to True.\n\n        Example:\n            ```python\n            async def my_task():\n                try:\n                    await asyncio.sleep(10)\n                except asyncio.CancelledError as e:\n                    current_task = asyncio.current_task()\n                    print(f\"Task {current_task.get_name()} was cancelled. {e}\")\n                    # Task sleepy_task was cancelled. No more sleeping!\n\n\n            @app.before_server_start\n            async def before_start(app):\n                app.add_task(my_task, name=\"sleepy_task\")\n                await asyncio.sleep(1)\n                await app.cancel_task(\"sleepy_task\", msg=\"No more sleeping!\")\n            ```\n        \"\"\"  # noqa: E501\n        task = self.get_task(name, raise_exception=raise_exception)\n        if task and not task.cancelled():\n            args: tuple[str, ...] = ()\n            if msg:\n                args = (msg,)\n            task.cancel(*args)\n            try:\n                await task\n            except CancelledError:\n                ..."
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def purge_tasks(self) -> None:\n        \"\"\"Purges completed and cancelled tasks from the task registry.\n\n        This method iterates through the task registry, identifying any tasks\n        that are either done or cancelled, and then removes those tasks,\n        leaving only the pending tasks in the registry.\n        \"\"\"\n        for key, task in self._task_registry.items():\n            if task is None:\n                continue\n            if task.done() or task.cancelled():\n                self._task_registry[key] = None\n\n        self._task_registry = {\n            k: v for k, v in self._task_registry.items() if v is not None\n        }"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def shutdown_tasks(\n        self, timeout: Optional[float] = None, increment: float = 0.1\n    ) -> None:\n        \"\"\"Cancel all tasks except the server task.\n\n        This method is used to cancel all tasks except the server task. It\n        iterates through the task registry, cancelling all tasks except the\n        server task, and then waits for the tasks to complete. Optionally, you\n        can provide a timeout and an increment to control how long the method\n        will wait for the tasks to complete.\n\n        Args:\n            timeout (Optional[float]): The amount of time to wait for the tasks\n                to complete. Defaults to `None`.\n            increment (float): The amount of time to wait between checks for\n                whether the tasks have completed. Defaults to `0.1`.\n        \"\"\"\n        for task in self.tasks:\n            if task.get_name() != \"RunServer\":\n                task.cancel()\n\n        if timeout is None:\n            timeout = self.config.GRACEFUL_SHUTDOWN_TIMEOUT\n\n        while len(self._task_registry) and timeout:\n            with suppress(RuntimeError):\n                running_loop = get_running_loop()\n                running_loop.run_until_complete(asyncio.sleep(increment))\n            self.purge_tasks()\n            timeout -= increment"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def tasks(self) -> Iterable[Task[Any]]:\n        \"\"\"The tasks that are currently registered with the application.\n\n        Returns:\n            Iterable[Task[Any]]: The tasks that are currently registered with\n                the application.\n        \"\"\"\n        return (\n            task\n            for task in iter(self._task_registry.values())\n            if task is not None\n        )"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # ASGI\n    # -------------------------------------------------------------------- #\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"\n        To be ASGI compliant, our instance must be a callable that accepts\n        three arguments: scope, receive, send. See the ASGI reference for more\n        details: https://asgi.readthedocs.io/en/latest\n        \"\"\"\n        if scope[\"type\"] == \"lifespan\":\n            setup_logging(self.state.is_debug, self.config.NO_COLOR)\n            self.asgi = True\n            self.motd(\"\")\n            self._asgi_lifespan = Lifespan(self, scope, receive, send)\n            await self._asgi_lifespan()\n        else:\n            self._asgi_app = await ASGIApp.create(self, scope, receive, send)\n            await self._asgi_app()\n\n    _asgi_single_callable = True  # We conform to ASGI 3.0 single-callable"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Configuration\n    # -------------------------------------------------------------------- #\n\n    def update_config(self, config: Union[bytes, str, dict, Any]) -> None:\n        \"\"\"Update the application configuration.\n\n        This method is used to update the application configuration. It can\n        accept a configuration object, a dictionary, or a path to a file that\n        contains a configuration object or dictionary.\n\n        See [Configuration](/en/guide/deployment/configuration) for details.\n\n        Args:\n            config (Union[bytes, str, dict, Any]): The configuration object,\n                dictionary, or path to a configuration file.\n        \"\"\"\n\n        self.config.update_config(config)"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def asgi(self) -> bool:\n        \"\"\"Whether the app is running in ASGI mode.\"\"\"\n        return self.state.asgi\n\n    @asgi.setter\n    def asgi(self, value: bool):\n        self.state.asgi = value"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def debug(self) -> bool:\n        \"\"\"Whether the app is running in debug mode.\"\"\"\n        return self.state.is_debug"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def auto_reload(self) -> bool:\n        \"\"\"Whether the app is running in auto-reload mode.\"\"\"\n        return self.config.AUTO_RELOAD\n\n    @auto_reload.setter\n    def auto_reload(self, value: bool):\n        self.config.AUTO_RELOAD = value\n        self.state.auto_reload = value"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def state(self) -> ApplicationState:  # type: ignore\n        \"\"\"The application state.\n\n        Returns:\n            ApplicationState: The current state of the application.\n        \"\"\"\n        return self._state"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@property\n    def reload_dirs(self) -> set[Path]:\n        \"\"\"The directories that are monitored for auto-reload.\n\n        Returns:\n            Set[str]: The set of directories that are monitored for\n                auto-reload.\n        \"\"\"\n        return self.state.reload_dirs"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Sanic Extensions\n    # -------------------------------------------------------------------- #\n\n    @property\n    def ext(self) -> Extend:\n        \"\"\"Convenience property for accessing Sanic Extensions.\n\n        This property is available if the `sanic-ext` package is installed.\n\n        See [Sanic Extensions](/en/plugins/sanic-ext/getting-started)\n            for details.\n\n        Returns:\n            Extend: The Sanic Extensions instance.\n\n        Examples:\n            A typical use case might be for registering a dependency injection.\n            ```python\n            app.ext.dependency(SomeObject())\n            ```\n        \"\"\"\n        if not hasattr(self, \"_ext\"):\n            setup_ext(self, fail=True)\n\n        if not hasattr(self, \"_ext\"):\n            raise RuntimeError(\n                \"Sanic Extensions is not installed. You can add it to your \"\n                \"environment using:\\n$ pip install sanic[ext]\\nor\\n$ pip \"\n                \"install sanic-ext\"\n            )\n        return self._ext  # type: ignore"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "def extend(\n        self,\n        *,\n        extensions: Optional[list[type[Extension]]] = None,\n        built_in_extensions: bool = True,\n        config: Optional[Union[Config, dict[str, Any]]] = None,\n        **kwargs,\n    ) -> Extend:\n        \"\"\"Extend Sanic with additional functionality using Sanic Extensions.\n\n        This method enables you to add one or more Sanic Extensions to the\n        current Sanic instance. It allows for more control over the Extend\n        object, such as enabling or disabling built-in extensions or providing\n        custom configuration.\n\n        See [Sanic Extensions](/en/plugins/sanic-ext/getting-started)\n            for details.\n\n        Args:\n            extensions (Optional[List[Type[Extension]]], optional): A list of\n                extensions to add. Defaults to `None`, meaning only built-in\n                extensions are added.\n            built_in_extensions (bool, optional): Whether to enable built-in\n                extensions. Defaults to `True`.\n            config (Optional[Union[Config, Dict[str, Any]]], optional):\n                Optional custom configuration for the extensions. Defaults\n                to `None`.\n            **kwargs: Additional keyword arguments that might be needed by\n                specific extensions.\n\n        Returns:\n            Extend: The Sanic Extensions instance.\n\n        Raises:\n            RuntimeError: If an attempt is made to extend Sanic after Sanic\n                Extensions has already been set up.\n\n        Examples:\n            A typical use case might be to add a custom extension along with\n                built-in ones.\n            ```python\n            app.extend(\n                extensions=[MyCustomExtension],\n                built_in_extensions=True\n            )\n            ```\n        \"\"\"\n        if hasattr(self, \"_ext\"):\n            raise RuntimeError(\n                \"Cannot extend Sanic after Sanic Extensions has been setup.\"\n            )\n        setup_ext(\n            self,\n            extensions=extensions,\n            built_in_extensions=built_in_extensions,\n            config=config,\n            fail=True,\n            **kwargs,\n        )\n        return self.ext"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Class methods\n    # -------------------------------------------------------------------- #\n\n    @classmethod\n    def register_app(cls, app: Sanic) -> None:\n        \"\"\"Register a Sanic instance with the class registry.\n\n        This method adds a Sanic application instance to the class registry,\n        which is used for tracking all instances of the application. It is\n        usually used internally, but can be used to register an application\n        that may have otherwise been created outside of the class registry.\n\n        Args:\n            app (Sanic): The Sanic instance to be registered.\n\n        Raises:\n            SanicException: If the app is not an instance of Sanic or if the\n                name of the app is already in use (unless in test mode).\n\n        Examples:\n            ```python\n            Sanic.register_app(my_app)\n            ```\n        \"\"\"\n        if not isinstance(app, cls):\n            raise SanicException(\"Registered app must be an instance of Sanic\")\n\n        name = app.name\n        if name in cls._app_registry and not cls.test_mode:\n            raise SanicException(f'Sanic app name \"{name}\" already in use.')\n\n        cls._app_registry[name] = app"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@classmethod\n    def unregister_app(cls, app: Sanic) -> None:\n        \"\"\"Unregister a Sanic instance from the class registry.\n\n        This method removes a previously registered Sanic application instance\n        from the class registry. This can be useful for cleanup purposes,\n        especially in testing or when an app instance is no longer needed. But,\n        it is typically used internally and should not be needed in most cases.\n\n        Args:\n            app (Sanic): The Sanic instance to be unregistered.\n\n        Raises:\n            SanicException: If the app is not an instance of Sanic.\n\n        Examples:\n            ```python\n            Sanic.unregister_app(my_app)\n            ```\n        \"\"\"\n        if not isinstance(app, cls):\n            raise SanicException(\"Registered app must be an instance of Sanic\")\n\n        name = app.name\n        if name in cls._app_registry:\n            del cls._app_registry[name]"
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@classmethod\n    def get_app(\n        cls, name: Optional[str] = None, *, force_create: bool = False\n    ) -> Sanic:\n        \"\"\"Retrieve an instantiated Sanic instance by name.\n\n        This method is best used when needing to get access to an already\n        defined application instance in another part of an app.\n\n        .. warning::\n            Be careful when using this method in the global scope as it is\n            possible that the import path running will cause it to error if\n            the imported global scope runs before the application instance\n            is created.\n\n            It is typically best used in a function or method that is called\n            after the application instance has been created.\n\n            ```python\n            def setup_routes():\n                app = Sanic.get_app()\n                app.add_route(handler_1, '/route1')\n                app.add_route(handler_2, '/route2')\n            ```\n\n        Args:\n            name (Optional[str], optional): Name of the application instance\n                to retrieve. When not specified, it will return the only\n                application instance if there is only one. If not specified\n                and there are multiple application instances, it will raise\n                an exception. Defaults to `None`.\n            force_create (bool, optional): If `True` and the named app does\n                not exist, a new instance will be created. Defaults to `False`.\n\n        Returns:\n            Sanic: The requested Sanic app instance.\n\n        Raises:\n            SanicException: If there are multiple or no Sanic apps found, or\n                if the specified name is not found.\n\n\n        Example:\n            ```python\n            app1 = Sanic(\"app1\")\n            app2 = Sanic.get_app(\"app1\")  # app2 is the same instance as app1\n            ```\n        \"\"\"\n        if name is None:\n            if len(cls._app_registry) > 1:\n                raise SanicException(\n                    'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'\n                )\n            elif len(cls._app_registry) == 0:\n                raise SanicException(\"No Sanic apps have been registered.\")\n            else:\n                return list(cls._app_registry.values())[0]\n        try:\n            return cls._app_registry[name]\n        except KeyError:\n            if name == \"__main__\":\n                return cls.get_app(\"__mp_main__\", force_create=force_create)\n            if force_create:\n                return cls(name)\n            raise SanicException(\n                f\"Sanic app name '{name}' not found.\\n\"\n                \"App instantiation must occur outside \"\n                \"if __name__ == '__main__' \"\n                \"block or by using an AppLoader.\\nSee \"\n                \"https://sanic.dev/en/guide/deployment/app-loader.html\"\n                \" for more details.\"\n            )"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "@classmethod\n    def _check_uvloop_conflict(cls) -> None:\n        values = {app.config.USE_UVLOOP for app in cls._app_registry.values()}\n        if len(values) > 1:\n            error_logger.warning(\n                \"It looks like you're running several apps with different \"\n                \"uvloop settings. This is not supported and may lead to \"\n                \"unintended behaviour.\"\n            )"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/sanic/sanic/app.py",
      "content": "# -------------------------------------------------------------------- #\n    # Lifecycle\n    # -------------------------------------------------------------------- #\n\n    @contextmanager\n    def amend(self) -> Iterator[None]:\n        \"\"\"Context manager to allow changes to the app after it has started.\n\n        Typically, once an application has started and is running, you cannot\n        make certain changes, like adding routes, middleware, or signals. This\n        context manager allows you to make those changes, and then finalizes\n        the app again when the context manager exits.\n\n        Yields:\n            None\n\n        Example:\n            ```python\n            with app.amend():\n                app.add_route(handler, '/new_route')\n            ```\n        \"\"\""
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nfrom inspect import signature\nfrom typing import Any, Optional, Union\nfrom uuid import UUID\n\nfrom sanic_routing import BaseRouter\nfrom sanic_routing.exceptions import NoMethod\nfrom sanic_routing.exceptions import NotFound as RoutingNotFound\nfrom sanic_routing.group import RouteGroup\nfrom sanic_routing.route import Route\n\nfrom sanic.constants import HTTP_METHODS\nfrom sanic.errorpages import check_error_format\nfrom sanic.exceptions import MethodNotAllowed, NotFound, SanicException\nfrom sanic.models.handler_types import RouteHandler"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "ROUTER_CACHE_SIZE = 1024\nALLOWED_LABELS = (\"__file_uri__\",)"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "class Router(BaseRouter):\n    \"\"\"The router implementation responsible for routing a `Request` object to the appropriate handler.\"\"\"  # noqa: E501\n\n    DEFAULT_METHOD = \"GET\"\n    ALLOWED_METHODS = HTTP_METHODS\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "def _get(\n        self, path: str, method: str, host: Optional[str]\n    ) -> tuple[Route, RouteHandler, dict[str, Any]]:\n        try:\n            return self.resolve(\n                path=path,\n                method=method,\n                extra={\"host\": host} if host else None,\n            )\n        except RoutingNotFound as e:\n            raise NotFound(f\"Requested URL {e.path} not found\") from None\n        except NoMethod as e:\n            raise MethodNotAllowed(\n                f\"Method {method} not allowed for URL {path}\",\n                method=method,\n                allowed_methods=tuple(e.allowed_methods)\n                if e.allowed_methods\n                else None,\n            ) from None"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@lru_cache(maxsize=ROUTER_CACHE_SIZE)\n    def get(  # type: ignore\n        self, path: str, method: str, host: Optional[str]\n    ) -> tuple[Route, RouteHandler, dict[str, Any]]:\n        \"\"\"Retrieve a `Route` object containing the details about how to handle a response for a given request\n\n        :param request: the incoming request object\n        :type request: Request\n        :return: details needed for handling the request and returning the\n            correct response\n        :rtype: Tuple[ Route, RouteHandler, Dict[str, Any]]\n\n        Args:\n            path (str): the path of the route\n            method (str): the HTTP method of the route\n            host (Optional[str]): the host of the route\n\n        Raises:\n            NotFound: if the route is not found\n            MethodNotAllowed: if the method is not allowed for the route\n\n        Returns:\n            Tuple[Route, RouteHandler, Dict[str, Any]]: the route, handler, and match info\n        \"\"\"  # noqa: E501\n        __tracebackhide__ = True\n        return self._get(path, method, host)"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "def add(  # type: ignore\n        self,\n        uri: str,\n        methods: Iterable[str],\n        handler: RouteHandler,\n        host: Optional[Union[str, Iterable[str]]] = None,\n        strict_slashes: bool = False,\n        stream: bool = False,\n        ignore_body: bool = False,\n        version: Optional[Union[str, float, int]] = None,\n        name: Optional[str] = None,\n        unquote: bool = False,\n        static: bool = False,\n        version_prefix: str = \"/v\",\n        overwrite: bool = False,\n        error_format: Optional[str] = None,\n    ) -> Union[Route, list[Route]]:\n        \"\"\"Add a handler to the router\n\n        Args:\n            uri (str): The path of the route.\n            methods (Iterable[str]): The types of HTTP methods that should be attached,\n                example: [\"GET\", \"POST\", \"OPTIONS\"].\n            handler (RouteHandler): The sync or async function to be executed.\n            host (Optional[str], optional): Host that the route should be on. Defaults to None.\n            strict_slashes (bool, optional): Whether to apply strict slashes. Defaults to False.\n            stream (bool, optional): Whether to stream the response. Defaults to False.\n            ignore_body (bool, optional): Whether the incoming request body should be read.\n                Defaults to False.\n            version (Union[str, float, int], optional): A version modifier for the uri. Defaults to None.\n            name (Optional[str], optional): An identifying name of the route. Defaults to None.\n\n        Returns:\n            Route: The route object.\n        \"\"\"  # noqa: E501\n\n        if version is not None:\n            version = str(version).strip(\"/\").lstrip(\"v\")\n            uri = \"/\".join([f\"{version_prefix}{version}\", uri.lstrip(\"/\")])\n\n        uri = self._normalize(uri, handler)\n\n        params = dict(\n            path=uri,\n            handler=handler,\n            methods=frozenset(map(str, methods)) if methods else None,\n            name=name,\n            strict=strict_slashes,\n            unquote=unquote,\n            overwrite=overwrite,\n        )\n\n        if isinstance(host, str):\n            hosts = [host]\n        else:\n            hosts = host or [None]  # type: ignore\n\n        routes = []\n\n        for host in hosts:\n            if host:\n                params.update({\"requirements\": {\"host\": host}})\n\n            ident = name\n            if len(hosts) > 1:\n                ident = (\n                    f\"{name}_{host.replace('.', '_')}\"\n                    if name\n                    else \"__unnamed__\"\n                )\n\n            route = super().add(**params)  # type: ignore\n            route.extra.ident = ident\n            route.extra.ignore_body = ignore_body\n            route.extra.stream = stream\n            route.extra.hosts = hosts\n            route.extra.static = static\n            route.extra.error_format = error_format\n\n            if error_format:\n                check_error_format(route.extra.error_format)\n\n            routes.append(route)\n\n        if len(routes) == 1:\n            return routes[0]\n        return routes"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@lru_cache(maxsize=ROUTER_CACHE_SIZE)\n    def find_route_by_view_name(\n        self, view_name: str, name: Optional[str] = None\n    ) -> Optional[Route]:\n        \"\"\"Find a route in the router based on the specified view name.\n\n        Args:\n            view_name (str): the name of the view to search for\n            name (Optional[str], optional): the name of the route. Defaults to `None`.\n\n        Returns:\n            Optional[Route]: the route object\n        \"\"\"  # noqa: E501\n        if not view_name:\n            return None\n\n        route = self.name_index.get(view_name)\n        if not route:\n            full_name = self.ctx.app.generate_name(view_name)\n            route = self.name_index.get(full_name)\n\n        if not route:\n            return None\n\n        return route"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@property\n    def routes_all(self) -> dict[tuple[str, ...], Route]:\n        \"\"\"Return all routes in the router.\n\n        Returns:\n            Dict[Tuple[str, ...], Route]: a dictionary of routes\n        \"\"\"\n        return {route.parts: route for route in self.routes}"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@property\n    def routes_static(self) -> dict[tuple[str, ...], RouteGroup]:\n        \"\"\"Return all static routes in the router.\n\n        _In this context \"static\" routes do not refer to the `app.static()`\n        method. Instead, they refer to routes that do not contain\n        any path parameters._\n\n        Returns:\n            Dict[Tuple[str, ...], Route]: a dictionary of routes\n        \"\"\"\n        return self.static_routes"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@property\n    def routes_dynamic(self) -> dict[tuple[str, ...], RouteGroup]:\n        \"\"\"Return all dynamic routes in the router.\n\n        _Dynamic routes are routes that contain path parameters._\n\n        Returns:\n            Dict[Tuple[str, ...], Route]: a dictionary of routes\n        \"\"\"\n        return self.dynamic_routes"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "@property\n    def routes_regex(self) -> dict[tuple[str, ...], RouteGroup]:\n        \"\"\"Return all regex routes in the router.\n\n        _Regex routes are routes that contain path parameters with regex\n        expressions, or otherwise need regex to resolve._\n\n        Returns:\n            Dict[Tuple[str, ...], Route]: a dictionary of routes\n        \"\"\"\n        return self.regex_routes"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "def finalize(self, *args, **kwargs) -> None:\n        \"\"\"Finalize the router.\n\n        Raises:\n            SanicException: if a route contains a parameter name that starts with \"__\" and is not in ALLOWED_LABELS\n        \"\"\"  # noqa: E501\n        super().finalize(*args, **kwargs)\n\n        for route in self.dynamic_routes.values():\n            if any(\n                label.startswith(\"__\") and label not in ALLOWED_LABELS\n                for label in route.labels\n            ):\n                raise SanicException(\n                    f\"Invalid route: {route}. Parameter names cannot use '__'.\"\n                )"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/sanic/sanic/router.py",
      "content": "def _normalize(self, uri: str, handler: RouteHandler) -> str:\n        if \"<\" not in uri:\n            return uri\n\n        sig = signature(handler)\n        mapping = {\n            param.name: param.annotation.__name__.lower()\n            for param in sig.parameters.values()\n            if param.annotation in (str, int, float, UUID)\n        }\n\n        reconstruction = []\n        for part in uri.split(\"/\"):\n            if part.startswith(\"<\") and \":\" not in part:\n                name = part[1:-1]\n                annotation = mapping.get(name)\n                if annotation:\n                    part = f\"<{name}:{annotation}>\"\n            reconstruction.append(part)\n        return \"/\".join(reconstruction)"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/sanic/sanic/simple.py",
      "content": "from pathlib import Path\n\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException"
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/sanic/sanic/simple.py",
      "content": "def create_simple_server(directory: Path):\n    if not directory.is_dir():\n        raise SanicException(\n            \"Cannot setup Sanic Simple Server without a path to a directory\"\n        )\n\n    app = Sanic(\"SimpleServer\")\n    app.static(\n        \"/\", directory, name=\"main\", directory_view=True, index=\"index.html\"\n    )\n\n    return app"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/sanic/sanic/log.py",
      "content": "from sanic.logging.color import Colors\nfrom sanic.logging.default import LOGGING_CONFIG_DEFAULTS\nfrom sanic.logging.deprecation import deprecation\nfrom sanic.logging.filter import VerbosityFilter\nfrom sanic.logging.loggers import (\n    access_logger,\n    error_logger,\n    logger,\n    server_logger,\n    websockets_logger,\n)"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/sanic/sanic/log.py",
      "content": "__all__ = (\n    \"deprecation\",\n    \"logger\",\n    \"access_logger\",\n    \"error_logger\",\n    \"server_logger\",\n    \"websockets_logger\",\n    \"VerbosityFilter\",\n    \"Colors\",\n    \"LOGGING_CONFIG_DEFAULTS\",\n)"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "import asyncio\nimport os\nimport platform\nimport signal\nimport sys\n\nfrom collections.abc import Awaitable\nfrom contextlib import contextmanager\nfrom enum import Enum\nfrom typing import Literal, Union\n\nfrom multidict import CIMultiDict  # type: ignore\n\nfrom sanic.helpers import Default\nfrom sanic.log import error_logger"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "StartMethod = Union[\n    Default, Literal[\"fork\"], Literal[\"forkserver\"], Literal[\"spawn\"]\n]\n\nOS_IS_WINDOWS = os.name == \"nt\"\nPYPY_IMPLEMENTATION = platform.python_implementation() == \"PyPy\"\nUVLOOP_INSTALLED = False\n\ntry:\n    import uvloop  # type: ignore # noqa\n\n    UVLOOP_INSTALLED = True\nexcept ImportError:\n    pass"
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "if sys.version_info < (3, 11, 0):\n\n    class StrEnum(str, Enum):\n        pass\n\nelse:\n    from enum import StrEnum  # type: ignore # noqa"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "class UpperStrEnum(StrEnum):\n    \"\"\"Base class for string enums that are case insensitive.\"\"\"\n\n    def _generate_next_value_(name, start, count, last_values):\n        return name.upper()\n\n    def __eq__(self, value: object) -> bool:\n        value = str(value).upper()\n        return super().__eq__(value)\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def __str__(self) -> str:\n        return self.value"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "@contextmanager\ndef use_context(method: StartMethod):\n    from sanic import Sanic\n\n    orig = Sanic.start_method\n    Sanic.start_method = method\n    yield\n    Sanic.start_method = orig"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "def enable_windows_color_support():\n    import ctypes\n\n    kernel = ctypes.windll.kernel32\n    kernel.SetConsoleMode(kernel.GetStdHandle(-11), 7)"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "def pypy_os_module_patch() -> None:\n    \"\"\"\n    The PyPy os module is missing the 'readlink' function, which causes issues\n    with aiofiles. This workaround replaces the missing 'readlink' function\n    with 'os.path.realpath', which serves the same purpose.\n    \"\"\"\n    if hasattr(os, \"readlink\"):\n        error_logger.warning(\n            \"PyPy: Skipping patching of the os module as it appears the \"\n            \"'readlink' function has been added.\"\n        )\n        return\n\n    module = sys.modules[\"os\"]\n    module.readlink = os.path.realpath  # type: ignore"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "def pypy_windows_set_console_cp_patch() -> None:\n    \"\"\"\n    A patch function for PyPy on Windows that sets the console code page to\n    UTF-8 encoding to allow for proper handling of non-ASCII characters. This\n    function uses ctypes to call the Windows API functions SetConsoleCP and\n    SetConsoleOutputCP to set the code page.\n    \"\"\"\n    from ctypes import windll  # type: ignore\n\n    code: int = windll.kernel32.GetConsoleOutputCP()\n    if code != 65001:\n        windll.kernel32.SetConsoleCP(65001)\n        windll.kernel32.SetConsoleOutputCP(65001)"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "class Header(CIMultiDict):\n    \"\"\"Container used for both request and response headers.\n    It is a subclass of  [CIMultiDict](https://multidict.readthedocs.io/en/stable/multidict.html#cimultidictproxy)\n\n    It allows for multiple values for a single key in keeping with the HTTP\n    spec. Also, all keys are *case in-sensitive*.\n\n    Please checkout [the MultiDict documentation](https://multidict.readthedocs.io/en/stable/multidict.html#multidict)\n    for more details about how to use the object. In general, it should work\n    very similar to a regular dictionary.\n    \"\"\"  # noqa: E501\n\n    def __getattr__(self, key: str) -> str:\n        if key.startswith(\"_\"):\n            return self.__getattribute__(key)\n        key = key.rstrip(\"_\").replace(\"_\", \"-\")\n        return \",\".join(self.getall(key, []))\n\n    def get_all(self, key: str):\n        \"\"\"Convenience method mapped to ``getall()``.\"\"\"\n        return self.getall(key, [])"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "use_trio = sys.argv[0].endswith(\"hypercorn\") and \"trio\" in sys.argv\n\nif use_trio:  # pragma: no cover\n    import trio  # type: ignore\n\n    def stat_async(path) -> Awaitable[os.stat_result]:\n        return trio.Path(path).stat()\n\n    open_async = trio.open_file\n    CancelledErrors = tuple([asyncio.CancelledError, trio.Cancelled])\nelse:\n    if PYPY_IMPLEMENTATION:\n        pypy_os_module_patch()\n\n        if OS_IS_WINDOWS:\n            pypy_windows_set_console_cp_patch()\n\n    from aiofiles import open as aio_open  # type: ignore\n    from aiofiles.os import stat as stat_async  # type: ignore  # noqa: F401\n\n    async def open_async(file, mode=\"r\", **kwargs):\n        return aio_open(file, mode, **kwargs)\n\n    CancelledErrors = tuple([asyncio.CancelledError])"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/sanic/sanic/compat.py",
      "content": "def ctrlc_workaround_for_windows(app):\n    async def stay_active(app):\n        \"\"\"Asyncio wakeups to allow receiving SIGINT in Python\"\"\"\n        while not die:\n            # If someone else stopped the app, just exit\n            if app.state.is_stopping:\n                return\n            # Windows Python blocks signal handlers while the event loop is\n            # waiting for I/O. Frequent wakeups keep interrupts flowing.\n            await asyncio.sleep(0.1)\n        # Can't be called from signal handler, so call it from here\n        app.stop()\n\n    def ctrlc_handler(sig, frame):\n        nonlocal die\n        if die:\n            raise KeyboardInterrupt(\"Non-graceful Ctrl+C\")\n        die = True\n\n    die = False\n    signal.signal(signal.SIGINT, ctrlc_handler)\n    app.add_task(stay_active)"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "from __future__ import annotations\n\nimport re\n\nfrom collections.abc import Iterable\nfrom typing import Any, Optional, Union\nfrom urllib.parse import unquote\n\nfrom sanic.exceptions import InvalidHeader\nfrom sanic.helpers import STATUS_CODES"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "HeaderIterable = Iterable[tuple[str, Any]]  # Values convertible to str\nHeaderBytesIterable = Iterable[tuple[bytes, bytes]]\nOptions = dict[str, Union[int, str]]  # key=value fields in various headers\nOptionsIterable = Iterable[tuple[str, str]]  # May contain duplicate keys\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_ipv6 = \"(?:[0-9A-Fa-f]{0,4}:){2,7}[0-9A-Fa-f]{0,4}\"\n_ipv6_re = re.compile(_ipv6)\n_host_re = re.compile(\n    r\"((?:\\[\" + _ipv6 + r\"\\])|[a-zA-Z0-9.\\-]{1,253})(?::(\\d{1,5}))?\"\n)"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "class MediaType:\n    \"\"\"A media type, as used in the Accept header.\n\n    This class is a representation of a media type, as used in the Accept\n    header. It encapsulates the type, subtype and any parameters, and\n    provides methods for matching against other media types.\n\n    Two separate methods are provided for searching the list:\n    - 'match' for finding the most preferred match (wildcards supported)\n    -  operator 'in' for checking explicit matches (wildcards as literals)\n\n    Args:\n        type_ (str): The type of the media type.\n        subtype (str): The subtype of the media type.\n        **params (str): Any parameters for the media type.\n    \"\"\"\n\n    def __init__(\n        self,\n        type_: str,\n        subtype: str,\n        **params: str,\n    ):\n        self.type = type_\n        self.subtype = subtype\n        self.q = float(params.get(\"q\", \"1.0\"))\n        self.params = params\n        self.mime = f\"{type_}/{subtype}\"\n        self.key = (\n            -1 * self.q,\n            -1 * len(self.params),\n            self.subtype == \"*\",\n            self.type == \"*\",\n        )"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __repr__(self):\n        return self.mime + \"\".join(f\";{k}={v}\" for k, v in self.params.items())"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __eq__(self, other):\n        \"\"\"Check for mime (str or MediaType) identical type/subtype.\n        Parameters such as q are not considered.\"\"\"\n        if isinstance(other, str):\n            # Give a friendly reminder if str contains parameters\n            if \";\" in other:\n                raise ValueError(\"Use match() to compare with parameters\")\n            return self.mime == other\n        if isinstance(other, MediaType):\n            # Ignore parameters silently with MediaType objects\n            return self.mime == other.mime\n        return NotImplemented"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def match(\n        self,\n        mime_with_params: Union[str, MediaType],\n    ) -> Optional[MediaType]:\n        \"\"\"Match this media type against another media type.\n\n        Check if this media type matches the given mime type/subtype.\n        Wildcards are supported both ways on both type and subtype.\n        If mime contains a semicolon, optionally followed by parameters,\n        the parameters of the two media types must match exactly.\n\n        .. note::\n            Use the `==` operator instead to check for literal matches\n            without expanding wildcards.\n\n\n        Args:\n            media_type (str): A type/subtype string to match.\n\n        Returns:\n            MediaType: Returns `self` if the media types are compatible.\n            None: Returns `None` if the media types are not compatible.\n        \"\"\"\n        mt = (\n            MediaType._parse(mime_with_params)\n            if isinstance(mime_with_params, str)\n            else mime_with_params\n        )\n        return (\n            self\n            if (\n                mt\n                # All parameters given in the other media type must match\n                and all(self.params.get(k) == v for k, v in mt.params.items())\n                # Subtype match\n                and (\n                    self.subtype == mt.subtype\n                    or self.subtype == \"*\"\n                    or mt.subtype == \"*\"\n                )\n                # Type match\n                and (\n                    self.type == mt.type or self.type == \"*\" or mt.type == \"*\"\n                )\n            )\n            else None\n        )"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "@property\n    def has_wildcard(self) -> bool:\n        \"\"\"Return True if this media type has a wildcard in it.\n\n        Returns:\n            bool: True if this media type has a wildcard in it.\n        \"\"\"\n        return any(part == \"*\" for part in (self.subtype, self.type))"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "@classmethod\n    def _parse(cls, mime_with_params: str) -> Optional[MediaType]:\n        mtype = mime_with_params.strip()\n        if \"/\" not in mime_with_params:\n            return None\n\n        mime, *raw_params = mtype.split(\";\")\n        type_, subtype = mime.split(\"/\", 1)\n        if not type_ or not subtype:\n            raise ValueError(f\"Invalid media type: {mtype}\")\n\n        params = {\n            key.strip(): value.strip()\n            for key, value in (param.split(\"=\", 1) for param in raw_params)\n        }\n\n        return cls(type_.lstrip(), subtype.rstrip(), **params)"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "class Matched:\n    \"\"\"A matching result of a MIME string against a header.\n\n    This class is a representation of a matching result of a MIME string\n    against a header. It encapsulates the MIME string, the header, and\n    provides methods for matching against other MIME strings.\n\n    Args:\n        mime (str): The MIME string to match.\n        header (MediaType): The header to match against, if any.\n    \"\"\"\n\n    def __init__(self, mime: str, header: Optional[MediaType]):\n        self.mime = mime\n        self.header = header"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __repr__(self):\n        return f\"<{self} matched {self.header}>\" if self else \"<no match>\""
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __str__(self):\n        return self.mime"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __bool__(self):\n        return self.header is not None"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __eq__(self, other: Any) -> bool:\n        try:\n            comp, other_accept = self._compare(other)\n        except TypeError:\n            return False\n\n        return bool(\n            comp\n            and (\n                (self.header and other_accept.header)\n                or (not self.header and not other_accept.header)\n            )\n        )"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def _compare(self, other) -> tuple[bool, Matched]:\n        if isinstance(other, str):\n            parsed = Matched.parse(other)\n            if self.mime == other:\n                return True, parsed\n            other = parsed\n\n        if isinstance(other, Matched):\n            return self.header == other.header, other\n\n        raise TypeError(\n            \"Comparison not supported between unequal \"\n            f\"mime types of '{self.mime}' and '{other}'\"\n        )"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def match(self, other: Union[str, Matched]) -> Optional[Matched]:\n        \"\"\"Match this MIME string against another MIME string.\n\n        Check if this MIME string matches the given MIME string. Wildcards are supported both ways on both type and subtype.\n\n        Args:\n            other (str): A MIME string to match.\n\n        Returns:\n            Matched: Returns `self` if the MIME strings are compatible.\n            None: Returns `None` if the MIME strings are not compatible.\n        \"\"\"  # noqa: E501\n        accept = Matched.parse(other) if isinstance(other, str) else other\n        if not self.header or not accept.header:\n            return None\n        if self.header.match(accept.header):\n            return accept\n        return None"
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "@classmethod\n    def parse(cls, raw: str) -> Matched:\n        media_type = MediaType._parse(raw)\n        return cls(raw, media_type)"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "class AcceptList(list):\n    \"\"\"A list of media types, as used in the Accept header.\n\n    The Accept header entries are listed in order of preference, starting\n    with the most preferred. This class is a list of `MediaType` objects,\n    that encapsulate also the q value or any other parameters.\n\n    Two separate methods are provided for searching the list:\n    - 'match' for finding the most preferred match (wildcards supported)\n    -  operator 'in' for checking explicit matches (wildcards as literals)\n\n    Args:\n        *args (MediaType): Any number of MediaType objects.\n    \"\"\"\n\n    def match(self, *mimes: str, accept_wildcards=True) -> Matched:\n        \"\"\"Find a media type accepted by the client.\n\n        This method can be used to find which of the media types requested by\n        the client is most preferred against the ones given as arguments.\n\n        The ordering of preference is set by:\n        1. The order set by RFC 7231, s. 5.3.2, giving a higher priority\n            to q values and more specific type definitions,\n        2. The order of the arguments (first is most preferred), and\n        3. The first matching entry on the Accept header.\n\n        Wildcards are matched both ways. A match is usually found, as the\n        Accept headers typically include `*/*`, in particular if the header\n        is missing, is not manually set, or if the client is a browser.\n\n        Note: the returned object behaves as a string of the mime argument\n        that matched, and is empty/falsy if no match was found. The matched\n        header entry `MediaType` or `None` is available as the `m` attribute.\n\n        Args:\n            mimes (List[str]): Any MIME types to search for in order of preference.\n            accept_wildcards (bool): Match Accept entries with wildcards in them.\n\n        Returns:\n            Match: A match object with the mime string and the MediaType object.\n        \"\"\"  # noqa: E501\n        a = sorted(\n            (-acc.q, i, j, mime, acc)\n            for j, acc in enumerate(self)\n            if accept_wildcards or not acc.has_wildcard\n            for i, mime in enumerate(mimes)\n            if acc.match(mime)\n        )\n        return Matched(*(a[0][-2:] if a else (\"\", None)))"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def __str__(self):\n        \"\"\"Format as Accept header value (parsed, not original).\"\"\"\n        return \", \".join(str(m) for m in self)"
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_accept(accept: Optional[str]) -> AcceptList:\n    \"\"\"Parse an Accept header and order the acceptable media types according to RFC 7231, s. 5.3.2\n\n    https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.2\n\n    Args:\n        accept (str): The Accept header value to parse.\n\n    Returns:\n        AcceptList: A list of MediaType objects, ordered by preference.\n\n    Raises:\n        InvalidHeader: If the header value is invalid.\n    \"\"\"  # noqa: E501\n    if not accept:\n        if accept == \"\":\n            return AcceptList()  # Empty header, accept nothing\n        accept = \"*/*\"  # No header means that all types are accepted\n    try:\n        a = [\n            mt\n            for mt in [MediaType._parse(mtype) for mtype in accept.split(\",\")]\n            if mt\n        ]\n        if not a:\n            raise ValueError\n        return AcceptList(sorted(a, key=lambda x: x.key))\n    except ValueError:\n        raise InvalidHeader(f\"Invalid header value in Accept: {accept}\")"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_content_header(value: str) -> tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. `form-data; name=upload; filename=\"file.txt\"` to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better.\n\n    Unescapes %22 to `\"` and %0D%0A to `\\n` in field values.\n\n    Args:\n        value (str): The header value to parse.\n\n    Returns:\n        Tuple[str, Options]: The header value and a dict of options.\n    \"\"\"\n    pos = value.find(\";\")\n    if pos == -1:\n        options: dict[str, Union[int, str]] = {}\n    else:\n        options = {\n            m.group(1).lower(): (m.group(2) or m.group(3))\n            .replace(\"%22\", '\"')\n            .replace(\"%0D%0A\", \"\\n\")\n            for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "# https://tools.ietf.org/html/rfc7230#section-3.2.6 and\n# https://tools.ietf.org/html/rfc7239#section-4\n# This regex is for *reversed* strings because that works much faster for\n# right-to-left matching than the other way around. Be wary that all things are\n# a bit backwards! _rparam matches forwarded pairs alike \";key=value\"\n_rparam = re.compile(f\"(?:{_token}|{_quoted})={_token}\\\\s*($|[;,])\", re.ASCII)"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_forwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse RFC 7239 Forwarded headers.\n    The value of `by` or `secret` must match `config.FORWARDED_SECRET`\n    :return: dict with keys and values, or None if nothing matched\n    \"\"\"\n    header = headers.getall(\"forwarded\", None)\n    secret = config.FORWARDED_SECRET\n    if header is None or not secret:\n        return None\n    header = \",\".join(header)  # Join multiple header lines\n    if secret not in header:\n        return None\n    # Loop over <separator><key>=<value> elements from right to left\n    sep = pos = None\n    options: list[tuple[str, str]] = []\n    found = False\n    for m in _rparam.finditer(header[::-1]):\n        # Start of new element? (on parser skips and non-semicolon right sep)\n        if m.start() != pos or sep != \";\":\n            # Was the previous element (from right) what we wanted?\n            if found:\n                break\n            # Clear values and parse as new element\n            del options[:]\n        pos = m.end()\n        val_token, val_quoted, key, sep = m.groups()\n        key = key.lower()[::-1]\n        val = (val_token or val_quoted.replace('\"\\\\', '\"'))[::-1]\n        options.append((key, val))\n        if key in (\"secret\", \"by\") and val == secret:\n            found = True\n        # Check if we would return on next round, to avoid useless parse\n        if found and sep != \";\":\n            break\n    # If secret was found, return the matching options in left-to-right order\n    return fwd_normalize(reversed(options)) if found else None"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_xforwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse traditional proxy headers.\"\"\"\n    real_ip_header = config.REAL_IP_HEADER\n    proxies_count = config.PROXIES_COUNT\n    addr = real_ip_header and headers.getone(real_ip_header, None)\n    if not addr and proxies_count:\n        assert proxies_count > 0\n        try:\n            # Combine, split and filter multiple headers' entries\n            forwarded_for = headers.getall(config.FORWARDED_FOR_HEADER)\n            proxies = [\n                p\n                for p in (\n                    p.strip() for h in forwarded_for for p in h.split(\",\")\n                )\n                if p\n            ]\n            addr = proxies[-proxies_count]\n        except (KeyError, IndexError):\n            pass\n    # No processing of other headers if no address is found\n    if not addr:\n        return None\n\n    def options():\n        yield \"for\", addr\n        for key, header in (\n            (\"proto\", \"x-scheme\"),\n            (\"proto\", \"x-forwarded-proto\"),  # Overrides X-Scheme if present\n            (\"host\", \"x-forwarded-host\"),\n            (\"port\", \"x-forwarded-port\"),\n            (\"path\", \"x-forwarded-path\"),\n        ):\n            yield key, headers.getone(header, None)\n\n    return fwd_normalize(options())"
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def fwd_normalize(fwd: OptionsIterable) -> Options:\n    \"\"\"Normalize and convert values extracted from forwarded headers.\n\n    Args:\n        fwd (OptionsIterable): An iterable of key-value pairs.\n\n    Returns:\n        Options: A dict of normalized key-value pairs.\n    \"\"\"\n    ret: dict[str, Union[int, str]] = {}\n    for key, val in fwd:\n        if val is not None:\n            try:\n                if key in (\"by\", \"for\"):\n                    ret[key] = fwd_normalize_address(val)\n                elif key in (\"host\", \"proto\"):\n                    ret[key] = val.lower()\n                elif key == \"port\":\n                    ret[key] = int(val)\n                elif key == \"path\":\n                    ret[key] = unquote(val)\n                else:\n                    ret[key] = val\n            except ValueError:\n                pass\n    return ret"
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\n\n    Args:\n        addr (str): An address string.\n\n    Returns:\n        str: A normalized address string.\n    \"\"\"\n    if addr == \"unknown\":\n        raise ValueError()  # omit unknown value identifiers\n    if addr.startswith(\"_\"):\n        return addr  # do not lower-case obfuscated strings\n    if _ipv6_re.fullmatch(addr):\n        addr = f\"[{addr}]\"  # bracket IPv6\n    return addr.lower()"
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_host(host: str) -> tuple[Optional[str], Optional[int]]:\n    \"\"\"Split host:port into hostname and port.\n\n    Args:\n        host (str): A host string.\n\n    Returns:\n        Tuple[Optional[str], Optional[int]]: A tuple of hostname and port.\n    \"\"\"\n    m = _host_re.fullmatch(host)\n    if not m:\n        return None, None\n    host, port = m.groups()\n    return host.lower(), int(port) if port is not None else None"
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "_HTTP1_STATUSLINES = [\n    b\"HTTP/1.1 %d %b\\r\\n\" % (status, STATUS_CODES.get(status, b\"UNKNOWN\"))\n    for status in range(1000)\n]"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\n\n    Args:\n        status (int): The HTTP status code.\n        headers (HeaderBytesIterable): An iterable of header tuples.\n\n    Returns:\n        bytes: The formatted response header.\n    \"\"\"\n    # Note: benchmarks show that here bytes concat is faster than bytearray,\n    # b\"\".join() or %-formatting. %timeit any changes you make.\n    ret = _HTTP1_STATUSLINES[status]\n    for h in headers:\n        ret += b\"%b: %b\\r\\n\" % h\n    ret += b\"\\r\\n\"\n    return ret"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/sanic/sanic/headers.py",
      "content": "def parse_credentials(\n    header: Optional[str],\n    prefixes: Optional[Union[list, tuple, set]] = None,\n) -> tuple[Optional[str], Optional[str]]:\n    \"\"\"Parses any header with the aim to retrieve any credentials from it.\n\n    Args:\n        header (Optional[str]): The header to parse.\n        prefixes (Optional[Union[List, Tuple, Set]], optional): The prefixes to look for. Defaults to None.\n\n    Returns:\n        Tuple[Optional[str], Optional[str]]: The prefix and the credentials.\n    \"\"\"  # noqa: E501\n    if not prefixes or not isinstance(prefixes, (list, tuple, set)):\n        prefixes = (\"Basic\", \"Bearer\", \"Token\")\n    if header is not None:\n        for prefix in prefixes:\n            if prefix in header:\n                return prefix, header.partition(prefix)[-1].strip()\n    return None, header"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "\"\"\"Defines basics of HTTP standard.\"\"\""
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "import sys\n\nfrom functools import partial\nfrom importlib import import_module\nfrom inspect import ismodule\n\n\ntry:\n    from ujson import dumps as ujson_dumps\n\n    json_dumps = partial(ujson_dumps, escape_forward_slashes=False)\nexcept ImportError:\n    from json import dumps\n\n    json_dumps = partial(dumps, separators=(\",\", \":\"))"
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "STATUS_CODES: dict[int, bytes] = {\n    100: b\"Continue\",\n    101: b\"Switching Protocols\",\n    102: b\"Processing\",\n    103: b\"Early Hints\",\n    200: b\"OK\",\n    201: b\"Created\",\n    202: b\"Accepted\",\n    203: b\"Non-Authoritative Information\",\n    204: b\"No Content\",\n    205: b\"Reset Content\",\n    206: b\"Partial Content\",\n    207: b\"Multi-Status\",\n    208: b\"Already Reported\",\n    226: b\"IM Used\",\n    300: b\"Multiple Choices\",\n    301: b\"Moved Permanently\",\n    302: b\"Found\",\n    303: b\"See Other\",\n    304: b\"Not Modified\",\n    305: b\"Use Proxy\",\n    307: b\"Temporary Redirect\",\n    308: b\"Permanent Redirect\",\n    400: b\"Bad Request\",\n    401: b\"Unauthorized\",\n    402: b\"Payment Required\",\n    403: b\"Forbidden\",\n    404: b\"Not Found\",\n    405: b\"Method Not Allowed\",\n    406: b\"Not Acceptable\",\n    407: b\"Proxy Authentication Required\",\n    408: b\"Request Timeout\",\n    409: b\"Conflict\",\n    410: b\"Gone\",\n    411: b\"Length Required\",\n    412: b\"Precondition Failed\",\n    413: b\"Request Entity Too Large\",\n    414: b\"Request-URI Too Long\",\n    415: b\"Unsupported Media Type\",\n    416: b\"Requested Range Not Satisfiable\",\n    417: b\"Expectation Failed\",\n    418: b\"I'm a teapot\",\n    422: b\"Unprocessable Entity\",\n    423: b\"Locked\",\n    424: b\"Failed Dependency\",\n    426: b\"Upgrade Required\",\n    428: b\"Precondition Required\",\n    429: b\"Too Many Requests\",\n    431: b\"Request Header Fields Too Large\",\n    451: b\"Unavailable For Legal Reasons\",\n    500: b\"Internal Server Error\",\n    501: b\"Not Implemented\",\n    502: b\"Bad Gateway\",\n    503: b\"Service Unavailable\",\n    504: b\"Gateway Timeout\",\n    505: b\"HTTP Version Not Supported\",\n    506: b\"Variant Also Negotiates\",\n    507: b\"Insufficient Storage\",\n    508: b\"Loop Detected\",\n    510: b\"Not Extended\",\n    511: b\"Network Authentication Required\",\n}"
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "_ENTITY_HEADERS = frozenset(\n    [\n        \"allow\",\n        \"content-encoding\",\n        \"content-language\",\n        \"content-length\",\n        \"content-location\",\n        \"content-md5\",\n        \"content-range\",\n        \"content-type\",\n        \"expires\",\n        \"last-modified\",\n        \"extension-header\",\n    ]\n)"
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "_HOP_BY_HOP_HEADERS = frozenset(\n    [\n        \"connection\",\n        \"keep-alive\",\n        \"proxy-authenticate\",\n        \"proxy-authorization\",\n        \"te\",\n        \"trailers\",\n        \"transfer-encoding\",\n        \"upgrade\",\n    ]\n)"
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "def has_message_body(status):\n    \"\"\"\n    According to the following RFC message body and length SHOULD NOT\n    be included in responses status 1XX, 204 and 304.\n    https://tools.ietf.org/html/rfc2616#section-4.4\n    https://tools.ietf.org/html/rfc2616#section-4.3\n    \"\"\"\n    return status not in (204, 304) and not (100 <= status < 200)"
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "def is_entity_header(header):\n    \"\"\"Checks if the given header is an Entity Header\"\"\"\n    return header.lower() in _ENTITY_HEADERS"
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "def is_hop_by_hop_header(header):\n    \"\"\"Checks if the given header is a Hop By Hop header\"\"\"\n    return header.lower() in _HOP_BY_HOP_HEADERS"
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "def import_string(module_name, package=None):\n    \"\"\"\n    import a module or class by string path.\n\n    :module_name: str with path of module or path to import and\n    instantiate a class\n    :returns: a module object or one instance from class if\n    module_name is a valid path to class\n\n    \"\"\"\n    module, klass = module_name.rsplit(\".\", 1)\n    module = import_module(module, package=package)\n    obj = getattr(module, klass)\n    if ismodule(obj):\n        return obj\n    return obj()"
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "def is_atty() -> bool:\n    return bool(sys.stdout and sys.stdout.isatty())"
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "class Default:\n    \"\"\"\n    It is used to replace `None` or `object()` as a sentinel\n    that represents a default value. Sometimes we want to set\n    a value to `None` so we cannot use `None` to represent the\n    default value, and `object()` is hard to be typed.\n    \"\"\"\n\n    def __repr__(self):\n        return \"<Default>\"\n\n    def __str__(self) -> str:\n        return self.__repr__()"
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/sanic/sanic/helpers.py",
      "content": "_default = Default()"
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Iterable\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Optional,\n    Union,\n)\n\nfrom sanic.models.handler_types import RouteHandler\nfrom sanic.request.types import Request\n\n\nif TYPE_CHECKING:\n    from sanic import Sanic\n    from sanic.blueprints import Blueprint"
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "class HTTPMethodView:\n    \"\"\"Class based implementation for creating and grouping handlers\n\n    Class-based views (CBVs) are an alternative to function-based views. They\n    allow you to reuse common logic, and group related views, while keeping\n    the flexibility of function-based views.\n\n\n    To use a class-based view, subclass the method handler, and implement\n    methods (`get`, `post`, `put`, `patch`, `delete`) for the class\n    to correspond to each HTTP method you want to support.\n\n    For example:\n\n    ```python\n    class DummyView(HTTPMethodView):\n        def get(self, request: Request):\n            return text('I am get method')\n\n        def put(self, request: Request):\n            return text('I am put method')\n    ```\n\n    If someone tries to use a non-implemented method, they will reveive a\n    405 response.\n\n    If you need any url params just include them in method signature, like\n    you would for function-based views.\n\n    ```python\n    class DummyView(HTTPMethodView):\n        def get(self, request: Request, my_param_here: str):\n            return text(f\"I am get method with {my_param_here}\")\n    ```\n\n    Next, you need to attach the view to the app or blueprint. You can do this\n    in the exact same way as you would for a function-based view, except you\n    should you use `MyView.as_view()` instead of `my_view_handler`.\n\n    ```python\n    app.add_route(DummyView.as_view(), \"/<my_param_here>\")\n    ```\n\n    Alternatively, you can use the `attach` method:\n\n    ```python\n    DummyView.attach(app, \"/<my_param_here>\")\n    ```\n\n    Or, at the time of subclassing:\n\n    ```python\n    class DummyView(HTTPMethodView, attach=app, uri=\"/<my_param_here>\"):\n        ...\n    ```\n\n    To add a decorator, you can either:\n\n    1. Add it to the `decorators` list on the class, which will apply it to\n         all methods on the class; or\n    2. Add it to the method directly, which will only apply it to that method.\n\n    ```python\n    class DummyView(HTTPMethodView):\n        decorators = [my_decorator]\n        ...\n\n    # or\n\n    class DummyView(HTTPMethodView):\n        @my_decorator\n        def get(self, request: Request):\n            ...\n    ```\n\n    One catch is that you need to be mindful that the call inside the decorator\n    may need to account for the `self` argument, which is passed to the method\n    as the first argument. Alternatively, you may want to also mark your method\n    as `staticmethod` to avoid this.\n\n    Available attributes at the time of subclassing:\n    - **attach** (Optional[Union[Sanic, Blueprint]]): The app or blueprint to\n        attach the view to.\n    - **uri** (str): The uri to attach the view to.\n    - **methods** (Iterable[str]): The HTTP methods to attach the view to.\n        Defaults to `{\"GET\"}`.\n    - **host** (Optional[str]): The host to attach the view to.\n    - **strict_slashes** (Optional[bool]): Whether to add a redirect rule for\n        the uri with a trailing slash.\n    - **version** (Optional[int]): The version to attach the view to.\n    - **name** (Optional[str]): The name to attach the view to.\n    - **stream** (bool): Whether the view is a stream handler.\n    - **version_prefix** (str): The prefix to use for the version. Defaults\n        to `\"/v\"`.\n    \"\"\"\n\n    decorators: list[Callable[[Callable[..., Any]], Callable[..., Any]]] = []\n\n    def __init_subclass__(\n        cls,\n        attach: Optional[Union[Sanic, Blueprint]] = None,\n        uri: str = \"\",\n        methods: Iterable[str] = frozenset({\"GET\"}),\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        stream: bool = False,\n        version_prefix: str = \"/v\",\n    ) -> None:\n        if attach:\n            cls.attach(\n                attach,\n                uri=uri,\n                methods=methods,\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n                stream=stream,\n                version_prefix=version_prefix,\n            )"
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "def dispatch_request(self, request: Request, *args, **kwargs):\n        \"\"\"Dispatch request to appropriate handler method.\"\"\"\n        method = request.method.lower()\n        handler = getattr(self, method, None)\n\n        if not handler and method == \"head\":\n            handler = getattr(self, \"get\")\n        if not handler:\n            # The router will never allow us to get here, but this is\n            # included as a fallback and for completeness.\n            raise NotImplementedError(\n                f\"{request.method} is not supported for this endpoint.\"\n            )\n        return handler(request, *args, **kwargs)"
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "@classmethod\n    def as_view(cls, *class_args: Any, **class_kwargs: Any) -> RouteHandler:\n        \"\"\"Return view function for use with the routing system, that dispatches request to appropriate handler method.\n\n        If you need to pass arguments to the class's constructor, you can\n        pass the arguments to `as_view` and they will be passed to the class\n        `__init__` method.\n\n        Args:\n            *class_args: Variable length argument list for the class instantiation.\n            **class_kwargs: Arbitrary keyword arguments for the class instantiation.\n\n        Returns:\n            RouteHandler: The view function.\n\n        Examples:\n            ```python\n            class DummyView(HTTPMethodView):\n                def __init__(self, foo: MyFoo):\n                    self.foo = foo\n\n                async def get(self, request: Request):\n                    return text(self.foo.bar)\n\n            app.add_route(DummyView.as_view(foo=MyFoo()), \"/\")\n            ```\n        \"\"\"  # noqa: E501\n\n        def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)\n\n        if cls.decorators:\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        view.view_class = cls  # type: ignore\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.__name__ = cls.__name__\n        return view"
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "@classmethod\n    def attach(\n        cls,\n        to: Union[Sanic, Blueprint],\n        uri: str,\n        methods: Iterable[str] = frozenset({\"GET\"}),\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        stream: bool = False,\n        version_prefix: str = \"/v\",\n    ) -> None:\n        \"\"\"Attaches the view to a Sanic app or Blueprint at the specified URI.\n\n        Args:\n            cls: The class that this method is part of.\n            to (Union[Sanic, Blueprint]): The Sanic application or Blueprint to attach to.\n            uri (str): The URI to bind the view to.\n            methods (Iterable[str], optional): A collection of HTTP methods that the view should respond to. Defaults to `frozenset({\"GET\"})`.\n            host (Optional[str], optional): A specific host or hosts to bind the view to. Defaults to `None`.\n            strict_slashes (Optional[bool], optional): Enforce or not the trailing slash. Defaults to `None`.\n            version (Optional[int], optional): Version of the API if versioning is used. Defaults to `None`.\n            name (Optional[str], optional): Unique name for the route. Defaults to `None`.\n            stream (bool, optional): Enable or disable streaming for the view. Defaults to `False`.\n            version_prefix (str, optional): The prefix for the version, if versioning is used. Defaults to `\"/v\"`.\n        \"\"\"  # noqa: E501\n        to.add_route(\n            cls.as_view(),\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            stream=stream,\n            version_prefix=version_prefix,\n        )"
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/sanic/sanic/views.py",
      "content": "def stream(func):\n    \"\"\"Decorator to mark a function as a stream handler.\"\"\"\n    func.is_stream = True\n    return func"
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "from __future__ import annotations\n\nimport sys\nimport typing as t\n\nfrom functools import partial\nfrom traceback import extract_tb\n\nfrom sanic.exceptions import BadRequest, SanicException\nfrom sanic.helpers import STATUS_CODES\nfrom sanic.log import deprecation, logger\nfrom sanic.pages.error import ErrorPage\nfrom sanic.response import html, json, text"
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "dumps: t.Callable[..., str]\ntry:\n    from ujson import dumps\n\n    dumps = partial(dumps, escape_forward_slashes=False)\nexcept ImportError:  # noqa\n    from json import dumps\n\nif t.TYPE_CHECKING:\n    from sanic import HTTPResponse, Request\n\nDEFAULT_FORMAT = \"auto\"\nFALLBACK_TEXT = \"\"\"\\\nThe application encountered an unexpected error and could not continue.\\\n\"\"\"\nFALLBACK_STATUS = 500\nJSON = \"application/json\""
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "class BaseRenderer:\n    \"\"\"Base class that all renderers must inherit from.\n\n    This class defines the structure for rendering objects, handling the core functionality that specific renderers may extend.\n\n    Attributes:\n        request (Request): The incoming request object that needs rendering.\n        exception (Exception): Any exception that occurred and needs to be rendered.\n        debug (bool): Flag indicating whether to render with debugging information.\n\n    Methods:\n        dumps: A static method that must be overridden by subclasses to define the specific rendering.\n\n    Args:\n        request (Request): The incoming request object that needs rendering.\n        exception (Exception): Any exception that occurred and needs to be rendered.\n        debug (bool): Flag indicating whether to render with debugging information.\n    \"\"\"  # noqa: E501\n\n    dumps = staticmethod(dumps)\n\n    def __init__(self, request: Request, exception: Exception, debug: bool):\n        self.request = request\n        self.exception = exception\n        self.debug = debug"
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def headers(self) -> t.Dict[str, str]:\n        \"\"\"The headers to be used for the response.\"\"\"\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"headers\", {})\n        return {}"
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def status(self):\n        \"\"\"The status code to be used for the response.\"\"\"\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"status_code\", FALLBACK_STATUS)\n        return FALLBACK_STATUS"
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def text(self):\n        \"\"\"The text to be used for the response.\"\"\"\n        if self.debug or isinstance(self.exception, SanicException):\n            return str(self.exception)\n        return FALLBACK_TEXT"
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def title(self):\n        \"\"\"The title to be used for the response.\"\"\"\n        status_text = STATUS_CODES.get(self.status, b\"Error Occurred\").decode()\n        return f\"{self.status} \u2014 {status_text}\""
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def render(self) -> HTTPResponse:\n        \"\"\"Outputs the exception as a response.\n\n        Returns:\n            HTTPResponse: The response object.\n        \"\"\"\n        output = (\n            self.full\n            if self.debug and not getattr(self.exception, \"quiet\", False)\n            else self.minimal\n        )()\n        output.status = self.status\n        output.headers.update(self.headers)\n        return output"
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def minimal(self) -> HTTPResponse:  # noqa\n        \"\"\"Provide a formatted message that is meant to not show any sensitive data or details.\n\n        This is the default fallback for production environments.\n\n        Returns:\n            HTTPResponse: The response object.\n        \"\"\"  # noqa: E501\n        raise NotImplementedError"
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def full(self) -> HTTPResponse:  # noqa\n        \"\"\"Provide a formatted message that has all details and is mean to be used primarily for debugging and non-production environments.\n\n        Returns:\n            HTTPResponse: The response object.\n        \"\"\"  # noqa: E501\n        raise NotImplementedError"
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "class HTMLRenderer(BaseRenderer):\n    \"\"\"Render an exception as HTML.\n\n    The default fallback type.\n    \"\"\""
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def full(self) -> HTTPResponse:\n        page = ErrorPage(\n            debug=self.debug,\n            title=super().title,\n            text=super().text,\n            request=self.request,\n            exc=self.exception,\n        )\n        return html(page.render())"
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def minimal(self) -> HTTPResponse:\n        return self.full()"
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "class TextRenderer(BaseRenderer):\n    \"\"\"Render an exception as plain text.\"\"\"\n\n    OUTPUT_TEXT = \"{title}\\n{bar}\\n{text}\\n\\n{body}\"\n    SPACER = \"  \""
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def full(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=self._generate_body(full=True),\n            )\n        )"
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def minimal(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=self._generate_body(full=False),\n            )\n        )"
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def title(self):\n        return f\"\u26a0\ufe0f {super().title}\""
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def _generate_body(self, *, full):\n        lines = []\n        if full:\n            _, exc_value, __ = sys.exc_info()\n            exceptions = []\n\n            lines += [\n                f\"{self.exception.__class__.__name__}: {self.exception} while \"\n                f\"handling path {self.request.path}\",\n                f\"Traceback of {self.request.app.name} \"\n                \"(most recent call last):\\n\",\n            ]\n\n            while exc_value:\n                exceptions.append(self._format_exc(exc_value))\n                exc_value = exc_value.__cause__\n\n            lines += exceptions[::-1]\n\n        for attr, display in ((\"context\", True), (\"extra\", bool(full))):\n            info = getattr(self.exception, attr, None)\n            if info and display:\n                lines += self._generate_object_display_list(info, attr)\n\n        return \"\\n\".join(lines)"
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def _format_exc(self, exc):\n        frames = \"\\n\\n\".join(\n            [\n                f\"{self.SPACER * 2}File {frame.filename}, \"\n                f\"line {frame.lineno}, in \"\n                f\"{frame.name}\\n{self.SPACER * 2}{frame.line}\"\n                for frame in extract_tb(exc.__traceback__)\n            ]\n        )\n        return f\"{self.SPACER}{exc.__class__.__name__}: {exc}\\n{frames}\""
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def _generate_object_display_list(self, obj, descriptor):\n        lines = [f\"\\n{descriptor.title()}\"]\n        for key, value in obj.items():\n            display = self.dumps(value)\n            lines.append(f\"{self.SPACER * 2}{key}: {display}\")\n        return lines"
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "class JSONRenderer(BaseRenderer):\n    \"\"\"Render an exception as JSON.\"\"\""
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def full(self) -> HTTPResponse:\n        output = self._generate_output(full=True)\n        return json(output, dumps=self.dumps)"
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def minimal(self) -> HTTPResponse:\n        output = self._generate_output(full=False)\n        return json(output, dumps=self.dumps)"
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def _generate_output(self, *, full):\n        output = {\n            \"description\": self.title,\n            \"status\": self.status,\n            \"message\": self.text,\n        }\n\n        for attr, display in ((\"context\", True), (\"extra\", bool(full))):\n            info = getattr(self.exception, attr, None)\n            if info and display:\n                output[attr] = info\n\n        if full:\n            _, exc_value, __ = sys.exc_info()\n            exceptions = []\n\n            while exc_value:\n                exceptions.append(\n                    {\n                        \"type\": exc_value.__class__.__name__,\n                        \"exception\": str(exc_value),\n                        \"frames\": [\n                            {\n                                \"file\": frame.filename,\n                                \"line\": frame.lineno,\n                                \"name\": frame.name,\n                                \"src\": frame.line,\n                            }\n                            for frame in extract_tb(exc_value.__traceback__)\n                        ],\n                    }\n                )\n                exc_value = exc_value.__cause__\n\n            output[\"path\"] = self.request.path\n            output[\"args\"] = self.request.args\n            output[\"exceptions\"] = exceptions[::-1]\n\n        return output"
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "@property\n    def title(self):\n        return STATUS_CODES.get(self.status, b\"Error Occurred\").decode()"
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def escape(text):\n    \"\"\"Minimal HTML escaping, not for attribute values (unlike html.escape).\"\"\"\n    return f\"{text}\".replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\")"
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "MIME_BY_CONFIG = {\n    \"text\": \"text/plain\",\n    \"json\": \"application/json\",\n    \"html\": \"text/html\",\n}\nCONFIG_BY_MIME = {v: k for k, v in MIME_BY_CONFIG.items()}\nRENDERERS_BY_CONTENT_TYPE = {\n    \"text/plain\": TextRenderer,\n    \"application/json\": JSONRenderer,\n    \"multipart/form-data\": HTMLRenderer,\n    \"text/html\": HTMLRenderer,\n}"
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "RESPONSE_MAPPING = {\n    \"json\": \"json\",\n    \"text\": \"text\",\n    \"html\": \"html\",\n    \"JSONResponse\": \"json\",\n    \"text/plain\": \"text\",\n    \"text/html\": \"html\",\n    \"application/json\": \"json\",\n}"
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def check_error_format(format):\n    \"\"\"Check that the format is known.\"\"\"\n    if format not in MIME_BY_CONFIG and format != \"auto\":\n        raise SanicException(f\"Unknown format: {format}\")"
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def exception_response(\n    request: Request,\n    exception: Exception,\n    debug: bool,\n    fallback: str,\n    base: t.Type[BaseRenderer],\n    renderer: t.Optional[t.Type[BaseRenderer]] = None,\n) -> HTTPResponse:\n    \"\"\"Render a response for the default FALLBACK exception handler.\"\"\"\n    if not renderer:\n        mt = guess_mime(request, fallback)\n        renderer = RENDERERS_BY_CONTENT_TYPE.get(mt, base)\n\n    renderer = t.cast(t.Type[BaseRenderer], renderer)\n    return renderer(request, exception, debug).render()"
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/sanic/sanic/errorpages.py",
      "content": "def guess_mime(req: Request, fallback: str) -> str:\n    \"\"\"Guess the MIME type for the response based upon the request.\"\"\"\n    # Attempt to find a suitable MIME format for the response.\n    # Insertion-ordered map of formats[\"html\"] = \"source of that suggestion\"\n    formats = {}\n    name = \"\"\n    # Route error_format (by magic from handler code if auto, the default)\n    if req.route:\n        name = req.route.name\n        f = req.route.extra.error_format\n        if f in MIME_BY_CONFIG:\n            formats[f] = name\n\n    if not formats and fallback in MIME_BY_CONFIG:\n        formats[fallback] = \"FALLBACK_ERROR_FORMAT\"\n\n    # If still not known, check for the request for clues of JSON\n    if not formats and fallback == \"auto\" and req.accept.match(JSON):\n        if JSON in req.accept:  # Literally, not wildcard\n            formats[\"json\"] = \"request.accept\"\n        elif JSON in req.headers.getone(\"content-type\", \"\"):\n            formats[\"json\"] = \"content-type\"\n        # DEPRECATION: Remove this block in 24.3\n        else:\n            c = None\n            try:\n                c = req.json\n            except BadRequest:\n                pass\n            if c:\n                formats[\"json\"] = \"request.json\"\n                deprecation(\n                    \"Response type was determined by the JSON content of \"\n                    \"the request. This behavior is deprecated and will be \"\n                    \"removed in v24.3. Please specify the format either by\\n\"\n                    f'  error_format=\"json\" on route {name}, by\\n'\n                    '  FALLBACK_ERROR_FORMAT = \"json\", or by adding header\\n'\n                    \"  accept: application/json to your requests.\",\n                    24.3,\n                )\n\n    # Any other supported formats\n    if fallback == \"auto\":\n        for k in MIME_BY_CONFIG:\n            if k not in formats:\n                formats[k] = \"any\"\n\n    mimes = [MIME_BY_CONFIG[k] for k in formats]\n    m = req.accept.match(*mimes)\n    if m:\n        format = CONFIG_BY_MIME[m.mime]\n        source = formats[format]\n        logger.debug(\n            \"Error Page: The client accepts %s, using '%s' from %s\",\n            m.header,\n            format,\n            source,\n        )\n    else:\n        logger.debug(\n            \"Error Page: No format found, the client accepts %s\",\n            repr(req.accept),\n        )\n    return m.mime"
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/sanic/sanic/blueprint_group.py",
      "content": "from .blueprints import BlueprintGroup"
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/sanic/sanic/blueprint_group.py",
      "content": "__all__ = [\"BlueprintGroup\"]  # noqa: F405"
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "from __future__ import annotations\n\nimport asyncio\n\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom inspect import isawaitable\nfrom typing import Any, Optional, Union, cast\n\nfrom sanic_routing import BaseRouter, Route, RouteGroup\nfrom sanic_routing.exceptions import NotFound\nfrom sanic_routing.utils import path_to_parts\n\nfrom sanic.exceptions import InvalidSignal\nfrom sanic.log import error_logger, logger\nfrom sanic.models.handler_types import SignalHandler"
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "class Event(Enum):\n    \"\"\"Event names for the SignalRouter\"\"\"\n\n    SERVER_EXCEPTION_REPORT = \"server.exception.report\"\n    SERVER_INIT_AFTER = \"server.init.after\"\n    SERVER_INIT_BEFORE = \"server.init.before\"\n    SERVER_SHUTDOWN_AFTER = \"server.shutdown.after\"\n    SERVER_SHUTDOWN_BEFORE = \"server.shutdown.before\"\n    HTTP_LIFECYCLE_BEGIN = \"http.lifecycle.begin\"\n    HTTP_LIFECYCLE_COMPLETE = \"http.lifecycle.complete\"\n    HTTP_LIFECYCLE_EXCEPTION = \"http.lifecycle.exception\"\n    HTTP_LIFECYCLE_HANDLE = \"http.lifecycle.handle\"\n    HTTP_LIFECYCLE_READ_BODY = \"http.lifecycle.read_body\"\n    HTTP_LIFECYCLE_READ_HEAD = \"http.lifecycle.read_head\"\n    HTTP_LIFECYCLE_REQUEST = \"http.lifecycle.request\"\n    HTTP_LIFECYCLE_RESPONSE = \"http.lifecycle.response\"\n    HTTP_ROUTING_AFTER = \"http.routing.after\"\n    HTTP_ROUTING_BEFORE = \"http.routing.before\"\n    HTTP_HANDLER_AFTER = \"http.handler.after\"\n    HTTP_HANDLER_BEFORE = \"http.handler.before\"\n    HTTP_LIFECYCLE_SEND = \"http.lifecycle.send\"\n    HTTP_MIDDLEWARE_AFTER = \"http.middleware.after\"\n    HTTP_MIDDLEWARE_BEFORE = \"http.middleware.before\"\n    WEBSOCKET_HANDLER_AFTER = \"websocket.handler.after\"\n    WEBSOCKET_HANDLER_BEFORE = \"websocket.handler.before\"\n    WEBSOCKET_HANDLER_EXCEPTION = \"websocket.handler.exception\""
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "RESERVED_NAMESPACES = {\n    \"server\": (\n        Event.SERVER_EXCEPTION_REPORT.value,\n        Event.SERVER_INIT_AFTER.value,\n        Event.SERVER_INIT_BEFORE.value,\n        Event.SERVER_SHUTDOWN_AFTER.value,\n        Event.SERVER_SHUTDOWN_BEFORE.value,\n    ),\n    \"http\": (\n        Event.HTTP_LIFECYCLE_BEGIN.value,\n        Event.HTTP_LIFECYCLE_COMPLETE.value,\n        Event.HTTP_LIFECYCLE_EXCEPTION.value,\n        Event.HTTP_LIFECYCLE_HANDLE.value,\n        Event.HTTP_LIFECYCLE_READ_BODY.value,\n        Event.HTTP_LIFECYCLE_READ_HEAD.value,\n        Event.HTTP_LIFECYCLE_REQUEST.value,\n        Event.HTTP_LIFECYCLE_RESPONSE.value,\n        Event.HTTP_ROUTING_AFTER.value,\n        Event.HTTP_ROUTING_BEFORE.value,\n        Event.HTTP_HANDLER_AFTER.value,\n        Event.HTTP_HANDLER_BEFORE.value,\n        Event.HTTP_LIFECYCLE_SEND.value,\n        Event.HTTP_MIDDLEWARE_AFTER.value,\n        Event.HTTP_MIDDLEWARE_BEFORE.value,\n    ),\n    \"websocket\": {\n        Event.WEBSOCKET_HANDLER_AFTER.value,\n        Event.WEBSOCKET_HANDLER_BEFORE.value,\n        Event.WEBSOCKET_HANDLER_EXCEPTION.value,\n    },\n}\n\nGENERIC_SIGNAL_FORMAT = \"__generic__.__signal__.%s\""
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def _blank(): ..."
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "class Signal(Route):\n    \"\"\"A `Route` that is used to dispatch signals to handlers\"\"\""
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "@dataclass\nclass SignalWaiter:\n    \"\"\"A record representing a future waiting for a signal\"\"\"\n\n    signal: Signal\n    event_definition: str\n    trigger: str = \"\"\n    requirements: Optional[dict[str, str]] = None\n    exclusive: bool = True\n\n    future: Optional[asyncio.Future] = None\n\n    async def wait(self):\n        \"\"\"Block until the signal is next dispatched.\n\n        Return the context of the signal dispatch, if any.\n        \"\"\"\n        loop = asyncio.get_running_loop()\n        self.future = loop.create_future()\n        self.signal.ctx.waiters.append(self)\n        try:\n            return await self.future\n        finally:\n            self.signal.ctx.waiters.remove(self)\n\n    def matches(self, event, condition):\n        return (\n            (condition is None and not self.exclusive)\n            or (condition is None and not self.requirements)\n            or condition == self.requirements\n        ) and (self.trigger or event == self.event_definition)"
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "class SignalGroup(RouteGroup):\n    \"\"\"A `RouteGroup` that is used to dispatch signals to handlers\"\"\""
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "class SignalRouter(BaseRouter):\n    \"\"\"A `BaseRouter` that is used to dispatch signals to handlers\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            delimiter=\".\",\n            route_class=Signal,\n            group_class=SignalGroup,\n            stacking=True,\n        )\n        self.allow_fail_builtin = True\n        self.ctx.loop = None"
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "@staticmethod\n    def format_event(event: Union[str, Enum]) -> str:\n        \"\"\"Ensure event strings in proper format\n\n        Args:\n            event (str): event string\n\n        Returns:\n            str: formatted event string\n        \"\"\"\n        if isinstance(event, Enum):\n            event = str(event.value)\n        if \".\" not in event:\n            event = GENERIC_SIGNAL_FORMAT % event\n        return event"
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def get(  # type: ignore\n        self,\n        event: Union[str, Enum],\n        condition: Optional[dict[str, str]] = None,\n    ):\n        \"\"\"Get the handlers for a signal\n\n        Args:\n            event (str): The event to get the handlers for\n            condition (Optional[Dict[str, str]], optional): A dictionary of conditions to match against the handlers. Defaults to `None`.\n\n        Returns:\n            Tuple[SignalGroup, List[SignalHandler], Dict[str, Any]]: A tuple of the `SignalGroup` that matched, a list of the handlers that matched, and a dictionary of the params that matched\n\n        Raises:\n            NotFound: If no handlers are found\n        \"\"\"  # noqa: E501\n        event = self.format_event(event)\n        extra = condition or {}\n        try:\n            group, param_basket = self.find_route(\n                f\".{event}\",\n                self.DEFAULT_METHOD,\n                self,\n                {\"__params__\": {}, \"__matches__\": {}},\n                extra=extra,\n            )\n        except NotFound:\n            message = \"Could not find signal %s\"\n            terms: list[Union[str, Optional[dict[str, str]]]] = [event]\n            if extra:\n                message += \" with %s\"\n                terms.append(extra)\n            raise NotFound(message % tuple(terms))\n\n        # Regex routes evaluate and can extract params directly. They are set\n        # on param_basket[\"__params__\"]\n        params = param_basket[\"__params__\"]\n        if not params:\n            # If param_basket[\"__params__\"] does not exist, we might have\n            # param_basket[\"__matches__\"], which are indexed based matches\n            # on path segments. They should already be cast types.\n            params = {\n                param.name: param_basket[\"__matches__\"][idx]\n                for idx, param in group.params.items()\n            }\n\n        return group, [route.handler for route in group], params"
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "async def _dispatch(\n        self,\n        event: str,\n        context: Optional[dict[str, Any]] = None,\n        condition: Optional[dict[str, str]] = None,\n        fail_not_found: bool = True,\n        reverse: bool = False,\n    ) -> Any:\n        event = self.format_event(event)\n        try:\n            group, handlers, params = self.get(event, condition=condition)\n        except NotFound as e:\n            is_reserved = event.split(\".\", 1)[0] in RESERVED_NAMESPACES\n            if fail_not_found and (not is_reserved or self.allow_fail_builtin):\n                raise e\n            else:\n                if self.ctx.app.debug and self.ctx.app.state.verbosity >= 1:\n                    error_logger.warning(str(e))\n                return None\n\n        if context:\n            params.update(context)\n        params.pop(\"__trigger__\", None)\n\n        signals = group.routes\n        if not reverse:\n            signals = signals[::-1]\n        try:\n            for signal in signals:\n                for waiter in signal.ctx.waiters:\n                    if waiter.matches(event, condition):\n                        waiter.future.set_result(dict(params))\n\n            for signal in signals:\n                requirements = signal.extra.requirements\n                if (\n                    (condition is None and signal.ctx.exclusive is False)\n                    or (condition is None and not requirements)\n                    or (condition == requirements)\n                ) and (signal.ctx.trigger or event == signal.ctx.definition):\n                    maybe_coroutine = signal.handler(**params)\n                    if isawaitable(maybe_coroutine):\n                        retval = await maybe_coroutine\n                        if retval:\n                            return retval\n                    elif maybe_coroutine:\n                        return maybe_coroutine\n            return None\n        except Exception as e:\n            if self.ctx.app.debug and self.ctx.app.state.verbosity >= 1:\n                error_logger.exception(e)\n\n            if event != Event.SERVER_EXCEPTION_REPORT.value:\n                await self.dispatch(\n                    Event.SERVER_EXCEPTION_REPORT.value,\n                    context={\"exception\": e},\n                )\n                setattr(e, \"__dispatched__\", True)\n            raise e"
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "async def dispatch(\n        self,\n        event: Union[str, Enum],\n        *,\n        context: Optional[dict[str, Any]] = None,\n        condition: Optional[dict[str, str]] = None,\n        fail_not_found: bool = True,\n        inline: bool = False,\n        reverse: bool = False,\n    ) -> Union[asyncio.Task, Any]:\n        \"\"\"Dispatch a signal to all handlers that match the event\n\n        Args:\n            event (str): The event to dispatch\n            context (Optional[Dict[str, Any]], optional): A dictionary of context to pass to the handlers. Defaults to `None`.\n            condition (Optional[Dict[str, str]], optional): A dictionary of conditions to match against the handlers. Defaults to `None`.\n            fail_not_found (bool, optional): Whether to raise an exception if no handlers are found. Defaults to `True`.\n            inline (bool, optional): Whether to run the handlers inline. An inline run means it will return the value of the signal handler. When `False` (which is the default) the signal handler will run in a background task. Defaults to `False`.\n            reverse (bool, optional): Whether to run the handlers in reverse order. Defaults to `False`.\n\n        Returns:\n            Union[asyncio.Task, Any]: If `inline` is `True` then the return value of the signal handler will be returned. If `inline` is `False` then an `asyncio.Task` will be returned.\n\n        Raises:\n            RuntimeError: If the signal is dispatched outside of an event loop\n        \"\"\"  # noqa: E501\n\n        event = self.format_event(event)\n        dispatch = self._dispatch(\n            event,\n            context=context,\n            condition=condition,\n            fail_not_found=fail_not_found and inline,\n            reverse=reverse,\n        )\n        logger.debug(f\"Dispatching signal: {event}\", extra={\"verbosity\": 1})\n\n        if inline:\n            return await dispatch\n\n        task = asyncio.get_running_loop().create_task(dispatch)\n        await asyncio.sleep(0)\n        return task"
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def get_waiter(\n        self,\n        event: Union[str, Enum],\n        condition: Optional[dict[str, str]] = None,\n        exclusive: bool = True,\n    ) -> Optional[SignalWaiter]:\n        event_definition = self.format_event(event)\n        name, trigger, _ = self._get_event_parts(event_definition)\n        signal = cast(Signal, self.name_index.get(name))\n        if not signal:\n            return None\n\n        if event_definition.endswith(\".*\") and not trigger:\n            trigger = \"*\"\n        return SignalWaiter(\n            signal=signal,\n            event_definition=event_definition,\n            trigger=trigger,\n            requirements=condition,\n            exclusive=bool(exclusive),\n        )"
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def _get_event_parts(self, event: str) -> tuple[str, str, str]:\n        parts = self._build_event_parts(event)\n        if parts[2].startswith(\"<\"):\n            name = \".\".join([*parts[:-1], \"*\"])\n            trigger = self._clean_trigger(parts[2])\n        else:\n            name = event\n            trigger = \"\"\n\n        if not trigger:\n            event = \".\".join([*parts[:2], \"<__trigger__>\"])\n\n        return name, trigger, event"
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def add(  # type: ignore\n        self,\n        handler: SignalHandler,\n        event: Union[str, Enum],\n        condition: Optional[dict[str, str]] = None,\n        exclusive: bool = True,\n        *,\n        priority: int = 0,\n    ) -> Signal:\n        event_definition = self.format_event(event)\n        name, trigger, event_string = self._get_event_parts(event_definition)\n\n        signal = super().add(\n            event_string,\n            handler,\n            name=name,\n            append=True,\n            priority=priority,\n        )  # type: ignore\n\n        signal.ctx.exclusive = exclusive\n        signal.ctx.trigger = trigger\n        signal.ctx.definition = event_definition\n        signal.extra.requirements = condition\n\n        return cast(Signal, signal)"
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def finalize(self, do_compile: bool = True, do_optimize: bool = False):\n        \"\"\"Finalize the router and compile the routes\n\n        Args:\n            do_compile (bool, optional): Whether to compile the routes. Defaults to `True`.\n            do_optimize (bool, optional): Whether to optimize the routes. Defaults to `False`.\n\n        Returns:\n            SignalRouter: The router\n\n        Raises:\n            RuntimeError: If the router is finalized outside of an event loop\n        \"\"\"  # noqa: E501\n        self.add(_blank, \"sanic.__signal__.__init__\")\n\n        try:\n            self.ctx.loop = asyncio.get_running_loop()\n        except RuntimeError:\n            raise RuntimeError(\"Cannot finalize signals outside of event loop\")\n\n        for signal in self.routes:\n            signal.ctx.waiters = deque()\n\n        return super().finalize(do_compile=do_compile, do_optimize=do_optimize)"
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def _build_event_parts(self, event: str) -> tuple[str, str, str]:\n        parts = path_to_parts(event, self.delimiter)\n        if (\n            len(parts) != 3\n            or parts[0].startswith(\"<\")\n            or parts[1].startswith(\"<\")\n        ):\n            raise InvalidSignal(\"Invalid signal event: %s\" % event)\n\n        if (\n            parts[0] in RESERVED_NAMESPACES\n            and event not in RESERVED_NAMESPACES[parts[0]]\n            and not (parts[2].startswith(\"<\") and parts[2].endswith(\">\"))\n        ):\n            raise InvalidSignal(\n                \"Cannot declare reserved signal event: %s\" % event\n            )\n        return parts"
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/sanic/sanic/signals.py",
      "content": "def _clean_trigger(self, trigger: str) -> str:\n        trigger = trigger[1:-1]\n        if \":\" in trigger:\n            trigger, _ = trigger.split(\":\")\n        return trigger"
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "from __future__ import annotations\n\nfrom abc import ABCMeta\nfrom collections.abc import Sequence\nfrom inspect import getmembers, isclass, isdatadescriptor\nfrom os import environ\nfrom pathlib import Path\nfrom typing import Any, Callable, Literal, Optional, Union\nfrom warnings import filterwarnings\n\nfrom sanic.constants import LocalCertCreator\nfrom sanic.errorpages import DEFAULT_FORMAT, check_error_format\nfrom sanic.helpers import Default, _default\nfrom sanic.http import Http\nfrom sanic.log import error_logger\nfrom sanic.utils import load_module_from_file_location, str_to_bool"
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "FilterWarningType = Union[\n    Literal[\"default\"],\n    Literal[\"error\"],\n    Literal[\"ignore\"],\n    Literal[\"always\"],\n    Literal[\"module\"],\n    Literal[\"once\"],\n]\n\nSANIC_PREFIX = \"SANIC_\"\n\n\nDEFAULT_CONFIG = {\n    \"_FALLBACK_ERROR_FORMAT\": _default,\n    \"ACCESS_LOG\": False,\n    \"AUTO_EXTEND\": True,\n    \"AUTO_RELOAD\": False,\n    \"EVENT_AUTOREGISTER\": False,\n    \"DEPRECATION_FILTER\": \"once\",\n    \"FORWARDED_FOR_HEADER\": \"X-Forwarded-For\",\n    \"FORWARDED_SECRET\": None,\n    \"GRACEFUL_SHUTDOWN_TIMEOUT\": 15.0,\n    \"GRACEFUL_TCP_CLOSE_TIMEOUT\": 5.0,\n    \"INSPECTOR\": False,\n    \"INSPECTOR_HOST\": \"localhost\",\n    \"INSPECTOR_PORT\": 6457,\n    \"INSPECTOR_TLS_KEY\": _default,\n    \"INSPECTOR_TLS_CERT\": _default,\n    \"INSPECTOR_API_KEY\": \"\",\n    \"KEEP_ALIVE_TIMEOUT\": 120,\n    \"KEEP_ALIVE\": True,\n    \"LOCAL_CERT_CREATOR\": LocalCertCreator.AUTO,\n    \"LOCAL_TLS_KEY\": _default,\n    \"LOCAL_TLS_CERT\": _default,\n    \"LOCALHOST\": \"localhost\",\n    \"LOG_EXTRA\": _default,\n    \"MOTD\": True,\n    \"MOTD_DISPLAY\": {},\n    \"NO_COLOR\": False,\n    \"NOISY_EXCEPTIONS\": False,\n    \"PROXIES_COUNT\": None,\n    \"REAL_IP_HEADER\": None,\n    \"REQUEST_BUFFER_SIZE\": 65536,\n    \"REQUEST_MAX_HEADER_SIZE\": 8192,  # Cannot exceed 16384\n    \"REQUEST_ID_HEADER\": \"X-Request-ID\",\n    \"REQUEST_MAX_SIZE\": 100_000_000,\n    \"REQUEST_TIMEOUT\": 60,\n    \"RESPONSE_TIMEOUT\": 60,\n    \"TLS_CERT_PASSWORD\": \"\",\n    \"TOUCHUP\": _default,\n    \"USE_UVLOOP\": _default,\n    \"WEBSOCKET_MAX_SIZE\": 2**20,  # 1 MiB\n    \"WEBSOCKET_PING_INTERVAL\": 20,\n    \"WEBSOCKET_PING_TIMEOUT\": 20,\n}"
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "class DescriptorMeta(ABCMeta):\n    \"\"\"Metaclass for Config.\"\"\"\n\n    def __init__(cls, *_):\n        cls.__setters__ = {name for name, _ in getmembers(cls, cls._is_setter)}\n\n    @staticmethod\n    def _is_setter(member: object):\n        return isdatadescriptor(member) and hasattr(member, \"setter\")"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "class Config(dict, metaclass=DescriptorMeta):\n    \"\"\"Configuration object for Sanic.\n\n    You can use this object to both: (1) configure how Sanic will operate, and\n    (2) manage your application's custom configuration values.\n    \"\"\"\n\n    ACCESS_LOG: bool\n    AUTO_EXTEND: bool\n    AUTO_RELOAD: bool\n    EVENT_AUTOREGISTER: bool\n    DEPRECATION_FILTER: FilterWarningType\n    FORWARDED_FOR_HEADER: str\n    FORWARDED_SECRET: Optional[str]\n    GRACEFUL_SHUTDOWN_TIMEOUT: float\n    GRACEFUL_TCP_CLOSE_TIMEOUT: float\n    INSPECTOR: bool\n    INSPECTOR_HOST: str\n    INSPECTOR_PORT: int\n    INSPECTOR_TLS_KEY: Union[Path, str, Default]\n    INSPECTOR_TLS_CERT: Union[Path, str, Default]\n    INSPECTOR_API_KEY: str\n    KEEP_ALIVE_TIMEOUT: int\n    KEEP_ALIVE: bool\n    LOCAL_CERT_CREATOR: Union[str, LocalCertCreator]\n    LOCAL_TLS_KEY: Union[Path, str, Default]\n    LOCAL_TLS_CERT: Union[Path, str, Default]\n    LOCALHOST: str\n    LOG_EXTRA: Union[Default, bool]\n    MOTD: bool\n    MOTD_DISPLAY: dict[str, str]\n    NO_COLOR: bool\n    NOISY_EXCEPTIONS: bool\n    PROXIES_COUNT: Optional[int]\n    REAL_IP_HEADER: Optional[str]\n    REQUEST_BUFFER_SIZE: int\n    REQUEST_MAX_HEADER_SIZE: int\n    REQUEST_ID_HEADER: str\n    REQUEST_MAX_SIZE: int\n    REQUEST_TIMEOUT: int\n    RESPONSE_TIMEOUT: int\n    SERVER_NAME: str\n    TLS_CERT_PASSWORD: str\n    TOUCHUP: Union[Default, bool]\n    USE_UVLOOP: Union[Default, bool]\n    WEBSOCKET_MAX_SIZE: int\n    WEBSOCKET_PING_INTERVAL: int\n    WEBSOCKET_PING_TIMEOUT: int\n\n    def __init__(\n        self,\n        defaults: Optional[\n            dict[str, Union[str, bool, int, float, None]]\n        ] = None,\n        env_prefix: Optional[str] = SANIC_PREFIX,\n        keep_alive: Optional[bool] = None,\n        *,\n        converters: Optional[Sequence[Callable[[str], Any]]] = None,\n    ):\n        defaults = defaults or {}\n        super().__init__({**DEFAULT_CONFIG, **defaults})\n        self._configure_warnings()\n\n        self._converters = [str, str_to_bool, float, int]\n\n        if converters:\n            for converter in converters:\n                self.register_type(converter)\n\n        if keep_alive is not None:\n            self.KEEP_ALIVE = keep_alive\n\n        if env_prefix != SANIC_PREFIX:\n            if env_prefix:\n                self.load_environment_vars(env_prefix)\n        else:\n            self.load_environment_vars(SANIC_PREFIX)\n\n        self._configure_header_size()\n        self._check_error_format()\n        self._init = True"
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def __getattr__(self, attr: Any):\n        try:\n            return self[attr]\n        except KeyError as ke:\n            raise AttributeError(f\"Config has no '{ke.args[0]}'\")"
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def __setattr__(self, attr: str, value: Any) -> None:\n        self.update({attr: value})"
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def __setitem__(self, attr: str, value: Any) -> None:\n        self.update({attr: value})"
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def update(self, *other: Any, **kwargs: Any) -> None:\n        \"\"\"Update the config with new values.\n\n        This method will update the config with the values from the provided\n        `other` objects, and then update the config with the provided\n        `kwargs`. The `other` objects can be any object that can be converted\n        to a dictionary, such as a `dict`, `Config` object, or `str` path to a\n        Python file. The `kwargs` must be a dictionary of key-value pairs.\n\n        .. note::\n            Only upper case settings are considered\n\n        Args:\n            *other: Any number of objects that can be converted to a\n                dictionary.\n            **kwargs: Any number of key-value pairs.\n\n        Raises:\n            AttributeError: If a key is not in the config.\n\n        Examples:\n            ```python\n            config.update(\n                {\"A\": 1, \"B\": 2},\n                {\"C\": 3, \"D\": 4},\n                E=5,\n                F=6,\n            )\n            ```\n        \"\"\"\n        kwargs.update({k: v for item in other for k, v in dict(item).items()})\n        setters: dict[str, Any] = {\n            k: kwargs.pop(k)\n            for k in {**kwargs}.keys()\n            if k in self.__class__.__setters__\n        }\n\n        for key, value in setters.items():\n            try:\n                super().__setattr__(key, value)\n            except AttributeError:\n                ...\n\n        super().update(**kwargs)\n        for attr, value in {**setters, **kwargs}.items():\n            self._post_set(attr, value)"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def _post_set(self, attr, value) -> None:\n        if self.get(\"_init\"):\n            if attr in (\n                \"REQUEST_MAX_HEADER_SIZE\",\n                \"REQUEST_BUFFER_SIZE\",\n                \"REQUEST_MAX_SIZE\",\n            ):\n                self._configure_header_size()\n\n        if attr == \"LOCAL_CERT_CREATOR\" and not isinstance(\n            self.LOCAL_CERT_CREATOR, LocalCertCreator\n        ):\n            self.LOCAL_CERT_CREATOR = LocalCertCreator[\n                self.LOCAL_CERT_CREATOR.upper()\n            ]\n        elif attr == \"DEPRECATION_FILTER\":\n            self._configure_warnings()"
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "@property\n    def FALLBACK_ERROR_FORMAT(self) -> str:\n        if isinstance(self._FALLBACK_ERROR_FORMAT, Default):\n            return DEFAULT_FORMAT\n        return self._FALLBACK_ERROR_FORMAT"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "@FALLBACK_ERROR_FORMAT.setter\n    def FALLBACK_ERROR_FORMAT(self, value):\n        self._check_error_format(value)\n        if (\n            not isinstance(self._FALLBACK_ERROR_FORMAT, Default)\n            and value != self._FALLBACK_ERROR_FORMAT\n        ):\n            error_logger.warning(\n                \"Setting config.FALLBACK_ERROR_FORMAT on an already \"\n                \"configured value may have unintended consequences.\"\n            )\n        self._FALLBACK_ERROR_FORMAT = value"
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def _configure_header_size(self):\n        Http.set_header_max_size(\n            self.REQUEST_MAX_HEADER_SIZE,\n            self.REQUEST_BUFFER_SIZE - 4096,\n            self.REQUEST_MAX_SIZE,\n        )"
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def _configure_warnings(self):\n        filterwarnings(\n            self.DEPRECATION_FILTER,\n            category=DeprecationWarning,\n            module=r\"sanic.*\",\n        )"
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def _check_error_format(self, format: Optional[str] = None):\n        check_error_format(format or self.FALLBACK_ERROR_FORMAT)"
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def load_environment_vars(self, prefix=SANIC_PREFIX):\n        \"\"\"Load environment variables into the config.\n\n        Looks for prefixed environment variables and applies them to the\n        configuration if present. This is called automatically when Sanic\n        starts up to load environment variables into config. Environment\n        variables should start with the defined prefix and should only\n        contain uppercase letters.\n\n        It will automatically hydrate the following types:\n\n        - ``int``\n        - ``float``\n        - ``bool``\n\n        Anything else will be imported as a ``str``. If you would like to add\n        additional types to this list, you can use\n        :meth:`sanic.config.Config.register_type`. Just make sure that they\n        are registered before you instantiate your application.\n\n        You likely won't need to call this method directly.\n\n        See [Configuration](/en/guide/deployment/configuration) for more details.\n\n        Args:\n            prefix (str): The prefix to use when looking for environment\n                variables. Defaults to `SANIC_`.\n\n\n        Examples:\n            ```python\n            # Environment variables\n            # SANIC_SERVER_NAME=example.com\n            # SANIC_SERVER_PORT=9999\n            # SANIC_SERVER_AUTORELOAD=true\n\n            # Python\n            app.config.load_environment_vars()\n            ```\n        \"\"\"  # noqa: E501\n        for key, value in environ.items():\n            if not key.startswith(prefix) or not key.isupper():\n                continue\n\n            _, config_key = key.split(prefix, 1)\n\n            for converter in reversed(self._converters):\n                try:\n                    self[config_key] = converter(value)\n                    break\n                except ValueError:\n                    pass"
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def update_config(self, config: Union[bytes, str, dict, Any]):\n        \"\"\"Update app.config.\n\n        .. note::\n\n            Only upper case settings are considered\n\n        See [Configuration](/en/guide/deployment/configuration) for more details.\n\n        Args:\n            config (Union[bytes, str, dict, Any]): Path to py file holding\n                settings, dict holding settings, or any object holding\n                settings.\n\n        Examples:\n            You can upload app config by providing path to py file\n            holding settings.\n\n            ```python\n            # /some/py/file\n            A = 1\n            B = 2\n            ```\n\n            ```python\n            config.update_config(\"${some}/py/file\")\n            ```\n\n            Yes you can put environment variable here, but they must be provided\n            in format: ``${some_env_var}``, and mark that ``$some_env_var`` is\n            treated as plain string.\n\n            You can upload app config by providing dict holding settings.\n\n            ```python\n            d = {\"A\": 1, \"B\": 2}\n            config.update_config(d)\n            ```\n\n            You can upload app config by providing any object holding settings,\n            but in such case config.__dict__ will be used as dict holding settings.\n\n            ```python\n            class C:\n                A = 1\n                B = 2\n\n            config.update_config(C)\n            ```\n        \"\"\"  # noqa: E501\n        if isinstance(config, (bytes, str, Path)):\n            config = load_module_from_file_location(location=config)\n\n        if not isinstance(config, dict):\n            cfg = {}\n            if not isclass(config):\n                cfg.update(\n                    {\n                        key: getattr(config, key)\n                        for key in config.__class__.__dict__.keys()\n                    }\n                )\n\n            config = dict(config.__dict__)\n            config.update(cfg)\n\n        config = dict(filter(lambda i: i[0].isupper(), config.items()))\n\n        self.update(config)"
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "load = update_config"
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/sanic/sanic/config.py",
      "content": "def register_type(self, converter: Callable[[str], Any]) -> None:\n        \"\"\"Register a custom type converter.\n\n        Allows for adding custom function to cast from a string value to any\n        other type. The function should raise ValueError if it is not the\n        correct type.\n\n        Args:\n            converter (Callable[[str], Any]): A function that takes a string\n                and returns a value of any type.\n\n        Examples:\n            ```python\n            def my_converter(value: str) -> Any:\n                # Do something to convert the value\n                return value\n\n            config.register_type(my_converter)\n            ```\n        \"\"\"\n        if converter in self._converters:\n            error_logger.warning(\n                f\"Configuration value converter '{converter.__name__}' has \"\n                \"already been registered\"\n            )\n            return\n        self._converters.append(converter)"
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/sanic/sanic/__version__.py",
      "content": "__version__ = \"24.12.0\""
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "from asyncio import CancelledError\nfrom collections.abc import Sequence\nfrom os import PathLike\nfrom typing import Any, Optional, Union\n\nfrom sanic.helpers import STATUS_CODES\nfrom sanic.models.protocol_types import Range"
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class RequestCancelled(CancelledError):\n    quiet = True"
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class ServerKilled(Exception):\n    \"\"\"Exception Sanic server uses when killing a server process for something unexpected happening.\"\"\"  # noqa: E501\n\n    quiet = True"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class SanicException(Exception):\n    \"\"\"Generic exception that will generate an HTTP response when raised in the context of a request lifecycle.\n\n    Usually, it is best practice to use one of the more specific exceptions\n    than this generic one. Even when trying to raise a 500, it is generally\n    preferable to use `ServerError`.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`,\n            then the appropriate HTTP response status message will be used instead. Defaults to `None`.\n        status_code (Optional[int], optional): The HTTP response code to send, if applicable. If `None`,\n            then it will be 500. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed from the logs.\n            Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n\n    Examples:\n        ```python\n        raise SanicException(\n            \"Something went wrong\",\n            status_code=999,\n            context={\n                \"info\": \"Some additional details to send to the client\",\n            },\n            headers={\n                \"X-Foo\": \"bar\"\n            }\n        )\n        ```\n    \"\"\"  # noqa: E501\n\n    status_code: int = 500\n    quiet: Optional[bool] = False\n    headers: dict[str, str] = {}\n    message: str = \"\"\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        status_code: Optional[int] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, str]] = None,\n    ) -> None:\n        self.context = context\n        self.extra = extra\n        status_code = status_code or getattr(\n            self.__class__, \"status_code\", None\n        )\n        quiet = (\n            quiet\n            if quiet is not None\n            else getattr(self.__class__, \"quiet\", None)\n        )\n        headers = headers or getattr(self.__class__, \"headers\", {})\n        if message is None:\n            message = self.message\n            if not message and status_code:\n                msg = STATUS_CODES.get(status_code, b\"\")\n                message = msg.decode()\n        elif isinstance(message, bytes):\n            message = message.decode()\n\n        super().__init__(message)\n\n        self.status_code = status_code or self.status_code\n        self.quiet = quiet\n        self.headers = headers\n        try:\n            self.message = message\n        except AttributeError:\n            ..."
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class HTTPException(SanicException):\n    \"\"\"A base class for other exceptions and should not be called directly.\"\"\"\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ) -> None:\n        super().__init__(\n            message,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )"
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class NotFound(HTTPException):\n    \"\"\"A base class for other exceptions and should not be called directly.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`,\n            then the appropriate HTTP response status message will be used instead. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed from the logs.\n            Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 404\n    quiet = True"
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class BadRequest(HTTPException):\n    \"\"\"400 Bad Request\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 400\n    quiet = True"
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "InvalidUsage = BadRequest\nBadURL = BadRequest"
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class MethodNotAllowed(HTTPException):\n    \"\"\"405 Method Not Allowed\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Method Not Allowed' will be sent. Defaults to `None`.\n        method (Optional[str], optional): The HTTP method that was used. Defaults to an empty string.\n        allowed_methods (Optional[Sequence[str]], optional): The HTTP methods that can be used instead of the\n            one that was attempted.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 405\n    quiet = True\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        method: str = \"\",\n        allowed_methods: Optional[Sequence[str]] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ):\n        super().__init__(\n            message,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )\n        if allowed_methods:\n            self.headers = {\n                **self.headers,\n                \"Allow\": \", \".join(allowed_methods),\n            }\n        self.method = method\n        self.allowed_methods = allowed_methods"
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "MethodNotSupported = MethodNotAllowed"
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class ServerError(HTTPException):\n    \"\"\"500 Internal Server Error\n\n    A general server-side error has occurred. If no other HTTP exception is\n    appropriate, then this should be used\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 500"
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "InternalServerError = ServerError"
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class ServiceUnavailable(HTTPException):\n    \"\"\"503 Service Unavailable\n\n    The server is currently unavailable (because it is overloaded or\n    down for maintenance). Generally, this is a temporary state.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 503\n    quiet = True"
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class URLBuildError(HTTPException):\n    \"\"\"500 Internal Server Error\n\n    An exception used by Sanic internals when unable to build a URL.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 500"
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class FileNotFound(NotFound):\n    \"\"\"404 Not Found\n\n    A specific form of :class:`.NotFound` that is specifically when looking\n    for a file on the file system at a known path.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Not Found' will be sent. Defaults to `None`.\n        path (Optional[PathLike], optional): The path, if any, to the file that could not\n            be found. Defaults to `None`.\n        relative_url (Optional[str], optional): A relative URL of the file. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        path: Optional[PathLike] = None,\n        relative_url: Optional[str] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ):\n        super().__init__(\n            message,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )\n        self.path = path\n        self.relative_url = relative_url"
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class RequestTimeout(HTTPException):\n    \"\"\"408 Request Timeout\n\n    The Web server (running the Web site) thinks that there has been too\n    long an interval of time between 1) the establishment of an IP\n    connection (socket) between the client and the server and\n    2) the receipt of any data on that socket, so the server has dropped\n    the connection. The socket connection has actually been lost - the Web\n    server has 'timed out' on that particular socket connection.\n\n    This is an internal exception thrown by Sanic and should not be used\n    directly.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 408\n    quiet = True"
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class PayloadTooLarge(HTTPException):\n    \"\"\"413 Payload Too Large\n\n    This is an internal exception thrown by Sanic and should not be used\n    directly.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 413\n    quiet = True"
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class HeaderNotFound(BadRequest):\n    \"\"\"400 Bad Request\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class InvalidHeader(BadRequest):\n    \"\"\"400 Bad Request\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class RangeNotSatisfiable(HTTPException):\n    \"\"\"416 Range Not Satisfiable\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Range Not Satisfiable' will be sent. Defaults to `None`.\n        content_range (Optional[ContentRange], optional): An object meeting the :class:`.ContentRange` protocol\n            that has a `total` property. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 416\n    quiet = True\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        content_range: Optional[Range] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ):\n        super().__init__(\n            message,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )\n        if content_range is not None:\n            self.headers = {\n                **self.headers,\n                \"Content-Range\": f\"bytes */{content_range.total}\",\n            }"
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "ContentRangeError = RangeNotSatisfiable"
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class ExpectationFailed(HTTPException):\n    \"\"\"417 Expectation Failed\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 417\n    quiet = True"
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "HeaderExpectationFailed = ExpectationFailed"
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class Forbidden(HTTPException):\n    \"\"\"403 Forbidden\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 403\n    quiet = True"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class InvalidRangeType(RangeNotSatisfiable):\n    \"\"\"416 Range Not Satisfiable\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    status_code = 416\n    quiet = True"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class PyFileError(SanicException):\n    def __init__(\n        self,\n        file,\n        status_code: Optional[int] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ):\n        super().__init__(\n            \"could not execute config file %s\" % file,\n            status_code=status_code,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class Unauthorized(HTTPException):\n    \"\"\"\n    **Status**: 401 Unauthorized\n\n    When present, additional keyword arguments may be used to complete\n    the WWW-Authentication header.\n\n    Args:\n        message (Optional[Union[str, bytes]], optional): The message to be sent to the client. If `None`\n            then the HTTP status 'Bad Request' will be sent. Defaults to `None`.\n        scheme (Optional[str], optional): Name of the authentication scheme to be used. Defaults to `None`.\n        quiet (Optional[bool], optional): When `True`, the error traceback will be suppressed\n            from the logs. Defaults to `None`.\n        context (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will be\n            sent to the client upon exception. Defaults to `None`.\n        extra (Optional[Dict[str, Any]], optional): Additional mapping of key/value data that will NOT be\n            sent to the client when in PRODUCTION mode. Defaults to `None`.\n        headers (Optional[Dict[str, Any]], optional): Additional headers that should be sent with the HTTP\n            response. Defaults to `None`.\n        **challenges (Dict[str, Any]): Additional keyword arguments that will be used to complete the\n            WWW-Authentication header. Defaults to `None`.\n\n    Examples:\n        With a Basic auth-scheme, realm MUST be present:\n        ```python\n        raise Unauthorized(\n            \"Auth required.\",\n            scheme=\"Basic\",\n            realm=\"Restricted Area\"\n        )\n        ```\n\n        With a Digest auth-scheme, things are a bit more complicated:\n        ```python\n        raise Unauthorized(\n            \"Auth required.\",\n            scheme=\"Digest\",\n            realm=\"Restricted Area\",\n            qop=\"auth, auth-int\",\n            algorithm=\"MD5\",\n            nonce=\"abcdef\",\n            opaque=\"zyxwvu\"\n        )\n        ```\n\n        With a Bearer auth-scheme, realm is optional so you can write:\n        ```python\n        raise Unauthorized(\"Auth required.\", scheme=\"Bearer\")\n        ```\n\n        or, if you want to specify the realm:\n        ```python\n        raise Unauthorized(\n            \"Auth required.\",\n            scheme=\"Bearer\",\n            realm=\"Restricted Area\"\n        )\n        ```\n    \"\"\"  # noqa: E501\n\n    status_code = 401\n    quiet = True\n\n    def __init__(\n        self,\n        message: Optional[Union[str, bytes]] = None,\n        scheme: Optional[str] = None,\n        *,\n        quiet: Optional[bool] = None,\n        context: Optional[dict[str, Any]] = None,\n        extra: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n        **challenges,\n    ):\n        super().__init__(\n            message,\n            quiet=quiet,\n            context=context,\n            extra=extra,\n            headers=headers,\n        )\n\n        # if auth-scheme is specified, set \"WWW-Authenticate\" header\n        if scheme is not None:\n            values = [f'{k!s}=\"{v!s}\"' for k, v in challenges.items()]\n            challenge = \", \".join(values)\n\n            self.headers = {\n                **self.headers,\n                \"WWW-Authenticate\": f\"{scheme} {challenge}\".rstrip(),\n            }"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class LoadFileException(SanicException):\n    \"\"\"Exception raised when a file cannot be loaded.\"\"\""
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class InvalidSignal(SanicException):\n    \"\"\"Exception raised when an invalid signal is sent.\"\"\""
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/sanic/sanic/exceptions.py",
      "content": "class WebsocketClosed(SanicException):\n    \"\"\"Exception raised when a websocket is closed.\"\"\"\n\n    quiet = True\n    message = \"Client has closed the websocket connection\""
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "from __future__ import annotations\n\nimport asyncio\n\nfrom collections import defaultdict\nfrom collections.abc import Iterable, Iterator, MutableSequence, Sequence\nfrom copy import deepcopy\nfrom functools import partial, wraps\nfrom inspect import isfunction\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Optional,\n    Union,\n    overload,\n)\n\nfrom sanic_routing.exceptions import NotFound\nfrom sanic_routing.route import Route\n\nfrom sanic.base.root import BaseSanic\nfrom sanic.exceptions import SanicException\nfrom sanic.helpers import Default, _default\nfrom sanic.models.futures import FutureRoute, FutureSignal, FutureStatic\nfrom sanic.models.handler_types import (\n    ListenerType,\n    MiddlewareType,\n    RouteHandler,\n)"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def lazy(func, as_decorator=True):\n    \"\"\"Decorator to register a function to be called later.\n\n    Args:\n        func (Callable): Function to be called later.\n        as_decorator (bool): Whether the function should be called\n            immediately or not.\n    \"\"\"\n\n    @wraps(func)\n    def decorator(bp, *args, **kwargs):\n        nonlocal as_decorator\n        kwargs[\"apply\"] = False\n        pass_handler = None\n\n        if args and isfunction(args[0]):\n            as_decorator = False\n\n        def wrapper(handler):\n            future = func(bp, *args, **kwargs)\n            if as_decorator:\n                future = future(handler)\n\n            if bp.registered:\n                for app in bp.apps:\n                    bp.register(app, {})\n\n            return future\n\n        return wrapper if as_decorator else wrapper(pass_handler)\n\n    return decorator"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "class Blueprint(BaseSanic):\n    \"\"\"A logical collection of URLs that consist of a similar logical domain.\n\n    A Blueprint object is the main tool for grouping functionality and similar endpoints. It allows the developer to\n    organize routes, exception handlers, middleware, and other web functionalities into separate, modular groups.\n\n    See [Blueprints](/en/guide/best-practices/blueprints) for more information.\n\n    Args:\n        name (str): The name of the blueprint.\n        url_prefix (Optional[str]): The URL prefix for all routes defined on this blueprint.\n        host (Optional[Union[List[str], str]]): Host or list of hosts that this blueprint should respond to.\n        version (Optional[Union[int, str, float]]): Version number of the API implemented by this blueprint.\n        strict_slashes (Optional[bool]): Whether or not the URL should end with a slash.\n        version_prefix (str): Prefix for the version. Default is \"/v\".\n    \"\"\"  # noqa: E501\n\n    __slots__ = (\n        \"_apps\",\n        \"_future_commands\",\n        \"_future_routes\",\n        \"_future_statics\",\n        \"_future_middleware\",\n        \"_future_listeners\",\n        \"_future_exceptions\",\n        \"_future_signals\",\n        \"_allow_route_overwrite\",\n        \"copied_from\",\n        \"ctx\",\n        \"exceptions\",\n        \"host\",\n        \"listeners\",\n        \"middlewares\",\n        \"routes\",\n        \"statics\",\n        \"strict_slashes\",\n        \"url_prefix\",\n        \"version\",\n        \"version_prefix\",\n        \"websocket_routes\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        url_prefix: Optional[str] = None,\n        host: Optional[Union[list[str], str]] = None,\n        version: Optional[Union[int, str, float]] = None,\n        strict_slashes: Optional[bool] = None,\n        version_prefix: str = \"/v\",\n    ):\n        super().__init__(name=name)\n        self.reset()\n        self._allow_route_overwrite = False\n        self.copied_from = \"\"\n        self.ctx = SimpleNamespace()\n        self.host = host\n        self.strict_slashes = strict_slashes\n        self.url_prefix = (\n            url_prefix[:-1]\n            if url_prefix and url_prefix.endswith(\"/\")\n            else url_prefix\n        )\n        self.version = version\n        self.version_prefix = version_prefix"
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def __repr__(self) -> str:\n        args = \", \".join(\n            [\n                f'{attr}=\"{getattr(self, attr)}\"'\n                if isinstance(getattr(self, attr), str)\n                else f\"{attr}={getattr(self, attr)}\"\n                for attr in (\n                    \"name\",\n                    \"url_prefix\",\n                    \"host\",\n                    \"version\",\n                    \"strict_slashes\",\n                )\n            ]\n        )\n        return f\"Blueprint({args})\""
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def apps(self) -> set[Sanic]:\n        \"\"\"Get the set of apps that this blueprint is registered to.\n\n        Returns:\n            Set[Sanic]: Set of apps that this blueprint is registered to.\n\n        Raises:\n            SanicException: If the blueprint has not yet been registered to\n                an app.\n        \"\"\"\n        if not self._apps:\n            raise SanicException(\n                f\"{self} has not yet been registered to an app\"\n            )\n        return self._apps"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def registered(self) -> bool:\n        \"\"\"Check if the blueprint has been registered to an app.\n\n        Returns:\n            bool: `True` if the blueprint has been registered to an app,\n                `False` otherwise.\n        \"\"\"\n        return bool(self._apps)"
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "exception = lazy(BaseSanic.exception)\n    listener = lazy(BaseSanic.listener)\n    middleware = lazy(BaseSanic.middleware)\n    route = lazy(BaseSanic.route)\n    signal = lazy(BaseSanic.signal)\n    static = lazy(BaseSanic.static, as_decorator=False)"
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def reset(self) -> None:\n        \"\"\"Reset the blueprint to its initial state.\"\"\"\n        self._apps: set[Sanic] = set()\n        self._allow_route_overwrite = False\n        self.exceptions: list[RouteHandler] = []\n        self.listeners: dict[str, list[ListenerType[Any]]] = {}\n        self.middlewares: list[MiddlewareType] = []\n        self.routes: list[Route] = []\n        self.statics: list[RouteHandler] = []\n        self.websocket_routes: list[Route] = []"
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def copy(\n        self,\n        name: str,\n        url_prefix: Optional[Union[str, Default]] = _default,\n        version: Optional[Union[int, str, float, Default]] = _default,\n        version_prefix: Union[str, Default] = _default,\n        allow_route_overwrite: Union[bool, Default] = _default,\n        strict_slashes: Optional[Union[bool, Default]] = _default,\n        with_registration: bool = True,\n        with_ctx: bool = False,\n    ):\n        \"\"\"Copy a blueprint instance with some optional parameters to override the values of attributes in the old instance.\n\n        Args:\n            name (str): Unique name of the blueprint.\n            url_prefix (Optional[Union[str, Default]]): URL to be prefixed before all route URLs.\n            version (Optional[Union[int, str, float, Default]]): Blueprint version.\n            version_prefix (Union[str, Default]): The prefix of the version number shown in the URL.\n            allow_route_overwrite (Union[bool, Default]): Whether to allow route overwrite or not.\n            strict_slashes (Optional[Union[bool, Default]]): Enforce the API URLs are requested with a trailing \"/*\".\n            with_registration (bool): Whether to register the new blueprint instance with Sanic apps that were registered with the old instance or not. Default is `True`.\n            with_ctx (bool): Whether the ``ctx`` will be copied or not. Default is `False`.\n\n        Returns:\n            Blueprint: A new Blueprint instance with the specified attributes.\n        \"\"\"  # noqa: E501\n\n        attrs_backup = {\n            \"_apps\": self._apps,\n            \"routes\": self.routes,\n            \"websocket_routes\": self.websocket_routes,\n            \"middlewares\": self.middlewares,\n            \"exceptions\": self.exceptions,\n            \"listeners\": self.listeners,\n            \"statics\": self.statics,\n        }\n\n        self.reset()\n        new_bp = deepcopy(self)\n        new_bp.name = name\n        new_bp.copied_from = self.name\n\n        if not isinstance(url_prefix, Default):\n            new_bp.url_prefix = url_prefix\n        if not isinstance(version, Default):\n            new_bp.version = version\n        if not isinstance(strict_slashes, Default):\n            new_bp.strict_slashes = strict_slashes\n        if not isinstance(version_prefix, Default):\n            new_bp.version_prefix = version_prefix\n        if not isinstance(allow_route_overwrite, Default):\n            new_bp._allow_route_overwrite = allow_route_overwrite\n\n        for key, value in attrs_backup.items():\n            setattr(self, key, value)\n\n        if with_registration and self._apps:\n            if new_bp._future_statics:\n                raise SanicException(\n                    \"Static routes registered with the old blueprint instance,\"\n                    \" cannot be registered again.\"\n                )\n            for app in self._apps:\n                app.blueprint(new_bp)\n\n        if not with_ctx:\n            new_bp.ctx = SimpleNamespace()\n\n        return new_bp"
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@staticmethod\n    def group(\n        *blueprints: Union[Blueprint, BlueprintGroup],\n        url_prefix: Optional[str] = None,\n        version: Optional[Union[int, str, float]] = None,\n        strict_slashes: Optional[bool] = None,\n        version_prefix: str = \"/v\",\n        name_prefix: Optional[str] = \"\",\n    ) -> BlueprintGroup:\n        \"\"\"Group multiple blueprints (or other blueprint groups) together.\n\n        Gropuping blueprings is a method for modularizing and organizing\n        your application's code. This can be a powerful tool for creating\n        reusable components, logically structuring your application code,\n        and easily maintaining route definitions in bulk.\n\n        This is the preferred way to group multiple blueprints together.\n\n        Args:\n            blueprints (Union[Blueprint, BlueprintGroup]): Blueprints to be\n                registered as a group.\n            url_prefix (Optional[str]): URL route to be prepended to all\n                sub-prefixes. Default is `None`.\n            version (Optional[Union[int, str, float]]): API Version to be\n                used for Blueprint group. Default is `None`.\n            strict_slashes (Optional[bool]): Indicate strict slash\n                termination behavior for URL. Default is `None`.\n            version_prefix (str): Prefix to be used for the version in the\n                URL. Default is \"/v\".\n            name_prefix (Optional[str]): Prefix to be used for the name of\n                the blueprints in the group. Default is an empty string.\n\n        Returns:\n            BlueprintGroup: A group of blueprints.\n\n        Example:\n            The resulting group will have the URL prefixes\n            `'/v2/bp1'` and `'/v2/bp2'` for bp1 and bp2, respectively.\n            ```python\n            bp1 = Blueprint('bp1', url_prefix='/bp1')\n            bp2 = Blueprint('bp2', url_prefix='/bp2')\n            group = group(bp1, bp2, version=2)\n            ```\n        \"\"\"\n\n        def chain(nested) -> Iterable[Blueprint]:\n            \"\"\"Iterate through nested blueprints\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                else:\n                    yield i\n\n        bps = BlueprintGroup(\n            url_prefix=url_prefix,\n            version=version,\n            strict_slashes=strict_slashes,\n            version_prefix=version_prefix,\n            name_prefix=name_prefix,\n        )\n        for bp in chain(blueprints):\n            bps.append(bp)\n        return bps"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def register(self, app, options):\n        \"\"\"Register the blueprint to the sanic app.\n\n        Args:\n            app (Sanic): Sanic app to register the blueprint to.\n            options (dict): Options to be passed to the blueprint.\n        \"\"\"\n\n        self._apps.add(app)\n        url_prefix = options.get(\"url_prefix\", self.url_prefix)\n        opt_version = options.get(\"version\", None)\n        opt_strict_slashes = options.get(\"strict_slashes\", None)\n        opt_version_prefix = options.get(\"version_prefix\", self.version_prefix)\n        opt_name_prefix = options.get(\"name_prefix\", None)\n        error_format = options.get(\n            \"error_format\", app.config.FALLBACK_ERROR_FORMAT\n        )\n\n        routes = []\n        middleware = []\n        exception_handlers = []\n        listeners = defaultdict(list)\n        registered = set()\n\n        # Routes\n        for future in self._future_routes:\n            # Prepend the blueprint URI prefix if available\n            uri = self._setup_uri(future.uri, url_prefix)\n\n            route_error_format = (\n                future.error_format if future.error_format else error_format\n            )\n\n            version_prefix = self.version_prefix\n            for prefix in (\n                future.version_prefix,\n                opt_version_prefix,\n            ):\n                if prefix and prefix != \"/v\":\n                    version_prefix = prefix\n                    break\n\n            version = self._extract_value(\n                future.version, opt_version, self.version\n            )\n            strict_slashes = self._extract_value(\n                future.strict_slashes, opt_strict_slashes, self.strict_slashes\n            )\n\n            name = future.name\n            if opt_name_prefix:\n                name = f\"{opt_name_prefix}_{future.name}\"\n            name = app.generate_name(name)\n            host = future.host or self.host\n            if isinstance(host, list):\n                host = tuple(host)\n\n            apply_route = FutureRoute(\n                future.handler,\n                uri,\n                future.methods,\n                host,\n                strict_slashes,\n                future.stream,\n                version,\n                name,\n                future.ignore_body,\n                future.websocket,\n                future.subprotocols,\n                future.unquote,\n                future.static,\n                version_prefix,\n                route_error_format,\n                future.route_context,\n            )\n\n            if (self, apply_route) in app._future_registry:\n                continue\n\n            registered.add(apply_route)\n            route = app._apply_route(\n                apply_route, overwrite=self._allow_route_overwrite\n            )\n\n            # If it is a copied BP, then make sure all of the names of routes\n            # matchup with the new BP name\n            if self.copied_from:\n                for r in route:\n                    r.name = r.name.replace(self.copied_from, self.name)\n                    r.extra.ident = r.extra.ident.replace(\n                        self.copied_from, self.name\n                    )\n\n            operation = (\n                routes.extend if isinstance(route, list) else routes.append\n            )\n            operation(route)\n\n        # Static Files\n        for future in self._future_statics:\n            # Prepend the blueprint URI prefix if available\n            uri = self._setup_uri(future.uri, url_prefix)\n            apply_route = FutureStatic(uri, *future[1:])\n\n            if (self, apply_route) in app._future_registry:\n                continue\n\n            registered.add(apply_route)\n            route = app._apply_static(apply_route)\n            routes.append(route)\n\n        route_names = [route.name for route in routes if route]\n\n        if route_names:\n            # Middleware\n            for future in self._future_middleware:\n                if (self, future) in app._future_registry:\n                    continue\n                middleware.append(app._apply_middleware(future, route_names))\n\n            # Exceptions\n            for future in self._future_exceptions:\n                if (self, future) in app._future_registry:\n                    continue\n                exception_handlers.append(\n                    app._apply_exception_handler(future, route_names)\n                )\n\n        # Event listeners\n        for future in self._future_listeners:\n            if (self, future) in app._future_registry:\n                continue\n            listeners[future.event].append(app._apply_listener(future))\n\n        # Signals\n        for future in self._future_signals:\n            if (self, future) in app._future_registry:\n                continue\n            future.condition.update({\"__blueprint__\": self.name})\n            # Force exclusive to be False\n            app._apply_signal(\n                FutureSignal(\n                    future.handler,\n                    future.event,\n                    future.condition,\n                    False,\n                    future.priority,\n                )\n            )\n\n        self.routes += [route for route in routes if isinstance(route, Route)]\n        self.websocket_routes += [\n            route for route in self.routes if route.extra.websocket\n        ]\n        self.middlewares += middleware\n        self.exceptions += exception_handlers\n        self.listeners.update(dict(listeners))\n\n        if self.registered:\n            self.register_futures(\n                self.apps,\n                self,\n                chain(\n                    registered,\n                    self._future_middleware,\n                    self._future_exceptions,\n                    self._future_listeners,\n                    self._future_signals,\n                ),\n            )\n\n        if self._future_commands:\n            raise SanicException(\n                \"Registering commands with blueprints is not supported.\"\n            )"
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "async def dispatch(self, *args, **kwargs):\n        \"\"\"Dispatch a signal event\n\n        Args:\n            *args: Arguments to be passed to the signal event.\n            **kwargs: Keyword arguments to be passed to the signal event.\n        \"\"\"\n        condition = kwargs.pop(\"condition\", {})\n        condition.update({\"__blueprint__\": self.name})\n        kwargs[\"condition\"] = condition\n        return await asyncio.gather(\n            *[app.dispatch(*args, **kwargs) for app in self.apps]\n        )"
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def event(\n        self,\n        event: str,\n        timeout: Optional[Union[int, float]] = None,\n        *,\n        condition: Optional[dict[str, Any]] = None,\n    ):\n        \"\"\"Wait for a signal event to be dispatched.\n\n        Args:\n            event (str): Name of the signal event.\n            timeout (Optional[Union[int, float]]): Timeout for the event to be\n                dispatched.\n            condition: If provided, method will only return when the signal\n                is dispatched with the given condition.\n\n        Returns:\n            Awaitable: Awaitable for the event to be dispatched.\n        \"\"\"\n        if condition is None:\n            condition = {}\n        condition.update({\"__blueprint__\": self.name})\n\n        waiters = []\n        for app in self.apps:\n            waiter = app.signal_router.get_waiter(\n                event, condition, exclusive=False\n            )\n            if not waiter:\n                raise NotFound(\"Could not find signal %s\" % event)\n            waiters.append(waiter)\n\n        return self._event(waiters, timeout)"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "async def _event(self, waiters, timeout):\n        done, pending = await asyncio.wait(\n            [asyncio.create_task(waiter.wait()) for waiter in waiters],\n            return_when=asyncio.FIRST_COMPLETED,\n            timeout=timeout,\n        )\n        for task in pending:\n            task.cancel()\n        if not done:\n            raise TimeoutError()\n        (finished_task,) = done\n        return finished_task.result()"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@staticmethod\n    def _extract_value(*values):\n        value = values[-1]\n        for v in values:\n            if v is not None:\n                value = v\n                break\n        return value"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@staticmethod\n    def _setup_uri(base: str, prefix: Optional[str]):\n        uri = base\n        if prefix:\n            uri = prefix\n            if base.startswith(\"/\") and prefix.endswith(\"/\"):\n                uri += base[1:]\n            else:\n                uri += base\n\n        return uri[1:] if uri.startswith(\"//\") else uri"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@staticmethod\n    def register_futures(\n        apps: set[Sanic], bp: Blueprint, futures: Sequence[tuple[Any, ...]]\n    ):\n        \"\"\"Register futures to the apps.\n\n        Args:\n            apps (Set[Sanic]): Set of apps to register the futures to.\n            bp (Blueprint): Blueprint that the futures belong to.\n            futures (Sequence[Tuple[Any, ...]]): Sequence of futures to be\n                registered.\n        \"\"\"\n\n        for app in apps:\n            app._future_registry.update({(bp, item) for item in futures})"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "bpg_base = MutableSequence[Blueprint]"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "class BlueprintGroup(bpg_base):\n    \"\"\"This class provides a mechanism to implement a Blueprint Group.\n\n    The `BlueprintGroup` class allows grouping blueprints under a common\n    URL prefix, version, and other shared attributes. It integrates with\n    Sanic's Blueprint system, offering a custom iterator to treat an\n    object of this class as a list/tuple.\n\n    Although possible to instantiate a group directly, it is recommended\n    to use the `Blueprint.group` method to create a group of blueprints.\n\n    Args:\n        url_prefix (Optional[str]): URL to be prefixed before all the\n            Blueprint Prefixes. Default is `None`.\n        version (Optional[Union[int, str, float]]): API Version for the\n            blueprint group, inherited by each Blueprint. Default is `None`.\n        strict_slashes (Optional[bool]): URL Strict slash behavior\n            indicator. Default is `None`.\n        version_prefix (str): Prefix for the version in the URL.\n            Default is `\"/v\"`.\n        name_prefix (Optional[str]): Prefix for the name of the blueprints\n            in the group. Default is an empty string.\n\n    Examples:\n        ```python\n        bp1 = Blueprint(\"bp1\", url_prefix=\"/bp1\")\n        bp2 = Blueprint(\"bp2\", url_prefix=\"/bp2\")\n\n        bp3 = Blueprint(\"bp3\", url_prefix=\"/bp4\")\n        bp4 = Blueprint(\"bp3\", url_prefix=\"/bp4\")\n\n\n        group1 = Blueprint.group(bp1, bp2)\n        group2 = Blueprint.group(bp3, bp4, version_prefix=\"/api/v\", version=\"1\")\n\n\n        @bp1.on_request\n        async def bp1_only_middleware(request):\n            print(\"applied on Blueprint : bp1 Only\")\n\n\n        @bp1.route(\"/\")\n        async def bp1_route(request):\n            return text(\"bp1\")\n\n\n        @bp2.route(\"/<param>\")\n        async def bp2_route(request, param):\n            return text(param)\n\n\n        @bp3.route(\"/\")\n        async def bp3_route(request):\n            return text(\"bp3\")\n\n\n        @bp4.route(\"/<param>\")\n        async def bp4_route(request, param):\n            return text(param)\n\n\n        @group1.on_request\n        async def group_middleware(request):\n            print(\"common middleware applied for both bp1 and bp2\")\n\n\n        # Register Blueprint group under the app\n        app.blueprint(group1)\n        app.blueprint(group2)\n        ```\n    \"\"\"  # noqa: E501\n\n    __slots__ = (\n        \"_blueprints\",\n        \"_url_prefix\",\n        \"_version\",\n        \"_strict_slashes\",\n        \"_version_prefix\",\n        \"_name_prefix\",\n    )\n\n    def __init__(\n        self,\n        url_prefix: Optional[str] = None,\n        version: Optional[Union[int, str, float]] = None,\n        strict_slashes: Optional[bool] = None,\n        version_prefix: str = \"/v\",\n        name_prefix: Optional[str] = \"\",\n    ):\n        self._blueprints: list[Blueprint] = []\n        self._url_prefix = url_prefix\n        self._version = version\n        self._version_prefix = version_prefix\n        self._strict_slashes = strict_slashes\n        self._name_prefix = name_prefix"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def url_prefix(self) -> Optional[Union[int, str, float]]:\n        \"\"\"The URL prefix for the Blueprint Group.\n\n        Returns:\n            Optional[Union[int, str, float]]: URL prefix for the Blueprint\n                Group.\n        \"\"\"\n        return self._url_prefix"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def blueprints(self) -> list[Blueprint]:\n        \"\"\"A list of all the available blueprints under this group.\n\n        Returns:\n            List[Blueprint]: List of all the available blueprints under\n                this group.\n        \"\"\"\n        return self._blueprints"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def version(self) -> Optional[Union[str, int, float]]:\n        \"\"\"API Version for the Blueprint Group, if any.\n\n        Returns:\n            Optional[Union[str, int, float]]: API Version for the Blueprint\n        \"\"\"\n        return self._version"
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def strict_slashes(self) -> Optional[bool]:\n        \"\"\"Whether to enforce strict slashes for the Blueprint Group.\n\n        Returns:\n            Optional[bool]: Whether to enforce strict slashes for the\n        \"\"\"\n        return self._strict_slashes"
    },
    {
      "chunk_id": 295,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def version_prefix(self) -> str:\n        \"\"\"Version prefix for the Blueprint Group.\n\n        Returns:\n            str: Version prefix for the Blueprint Group.\n        \"\"\"\n        return self._version_prefix"
    },
    {
      "chunk_id": 296,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@property\n    def name_prefix(self) -> Optional[str]:\n        \"\"\"Name prefix for the Blueprint Group.\n\n        This is mainly needed when blueprints are copied in order to\n        avoid name conflicts.\n\n        Returns:\n            Optional[str]: Name prefix for the Blueprint Group.\n        \"\"\"\n        return self._name_prefix"
    },
    {
      "chunk_id": 297,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def __iter__(self) -> Iterator[Blueprint]:\n        \"\"\"Iterate over the list of blueprints in the group.\n\n        Returns:\n            Iterator[Blueprint]: Iterator for the list of blueprints in\n        \"\"\"\n        return iter(self._blueprints)"
    },
    {
      "chunk_id": 298,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@overload\n    def __getitem__(self, item: int) -> Blueprint: ...\n\n    @overload\n    def __getitem__(self, item: slice) -> MutableSequence[Blueprint]: ...\n\n    def __getitem__(\n        self, item: Union[int, slice]\n    ) -> Union[Blueprint, MutableSequence[Blueprint]]:\n        \"\"\"Get the Blueprint object at the specified index.\n\n        This method returns a blueprint inside the group specified by\n        an index value. This will enable indexing, splice and slicing\n        of the blueprint group like we can do with regular list/tuple.\n\n        This method is provided to ensure backward compatibility with\n        any of the pre-existing usage that might break.\n\n        Returns:\n            Blueprint: Blueprint object at the specified index.\n\n        Raises:\n            IndexError: If the index is out of range.\n        \"\"\"\n        return self._blueprints[item]"
    },
    {
      "chunk_id": 299,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@overload\n    def __setitem__(self, index: int, item: Blueprint) -> None: ...\n\n    @overload\n    def __setitem__(self, index: slice, item: Iterable[Blueprint]) -> None: ...\n\n    def __setitem__(\n        self,\n        index: Union[int, slice],\n        item: Union[Blueprint, Iterable[Blueprint]],\n    ) -> None:\n        \"\"\"Set the Blueprint object at the specified index.\n\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to perform the list's indexed setter operation.\n\n        Args:\n            index (int): Index to use for removing a new Blueprint item\n            item (Blueprint): New `Blueprint` object.\n\n        Returns:\n            None\n\n        Raises:\n            IndexError: If the index is out of range.\n        \"\"\"\n        if isinstance(index, int):\n            if not isinstance(item, Blueprint):\n                raise TypeError(\"Expected a Blueprint instance\")\n            self._blueprints[index] = item\n        elif isinstance(index, slice):\n            if not isinstance(item, Iterable):\n                raise TypeError(\"Expected an iterable of Blueprint instances\")\n            self._blueprints[index] = list(item)\n        else:\n            raise TypeError(\"Index must be int or slice\")"
    },
    {
      "chunk_id": 300,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "@overload\n    def __delitem__(self, index: int) -> None: ...\n\n    @overload\n    def __delitem__(self, index: slice) -> None: ...\n\n    def __delitem__(self, index: Union[int, slice]) -> None:\n        \"\"\"Delete the Blueprint object at the specified index.\n\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to delete an item from the list of blueprint\n        groups like it can be done on a regular list with index.\n\n        Args:\n            index (int): Index to use for removing a new Blueprint item\n\n        Returns:\n            None\n\n        Raises:\n            IndexError: If the index is out of range.\n        \"\"\"\n        del self._blueprints[index]"
    },
    {
      "chunk_id": 301,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def __len__(self) -> int:\n        \"\"\"Get the Length of the blueprint group object.\n\n        Returns:\n            int: Length of the blueprint group object.\n        \"\"\"\n        return len(self._blueprints)"
    },
    {
      "chunk_id": 302,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def append(self, value: Blueprint) -> None:\n        \"\"\"Add a new Blueprint object to the group.\n\n        The Abstract class `MutableSequence` leverages this append method to\n        perform the `BlueprintGroup.append` operation.\n\n        Args:\n            value (Blueprint): New `Blueprint` object.\n\n        Returns:\n            None\n        \"\"\"\n        self._blueprints.append(value)"
    },
    {
      "chunk_id": 303,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def exception(self, *exceptions: Exception, **kwargs) -> Callable:\n        \"\"\"Decorate a function to handle exceptions for all blueprints in the group.\n\n        In case of nested Blueprint Groups, the same handler is applied\n        across each of the Blueprints recursively.\n\n        Args:\n            *exceptions (Exception): Exceptions to handle\n            **kwargs (dict): Optional Keyword arg to use with Middleware\n\n        Returns:\n            Partial function to apply the middleware\n\n        Examples:\n            ```python\n            bp1 = Blueprint(\"bp1\", url_prefix=\"/bp1\")\n            bp2 = Blueprint(\"bp2\", url_prefix=\"/bp2\")\n            group1 = Blueprint.group(bp1, bp2)\n\n            @group1.exception(Exception)\n            def handler(request, exception):\n                return text(\"Exception caught\")\n            ```\n        \"\"\"  # noqa: E501\n\n        def register_exception_handler_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.exception(*exceptions, **kwargs)(fn)\n\n        return register_exception_handler_for_blueprints"
    },
    {
      "chunk_id": 304,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def insert(self, index: int, item: Blueprint) -> None:\n        \"\"\"Insert a new Blueprint object to the group at the specified index.\n\n        The Abstract class `MutableSequence` leverages this insert method to\n        perform the `BlueprintGroup.append` operation.\n\n        Args:\n            index (int): Index to use for removing a new Blueprint item\n            item (Blueprint): New `Blueprint` object.\n\n        Returns:\n            None\n        \"\"\"\n        self._blueprints.insert(index, item)"
    },
    {
      "chunk_id": 305,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def middleware(self, *args, **kwargs):\n        \"\"\"A decorator that can be used to implement a Middleware for all blueprints in the group.\n\n        In case of nested Blueprint Groups, the same middleware is applied\n        across each of the Blueprints recursively.\n\n        Args:\n            *args (Optional): Optional positional Parameters to be use middleware\n            **kwargs (Optional): Optional Keyword arg to use with Middleware\n\n        Returns:\n            Partial function to apply the middleware\n        \"\"\"  # noqa: E501\n\n        def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)\n\n        if args and callable(args[0]):\n            fn = args[0]\n            args = list(args)[1:]\n            return register_middleware_for_blueprints(fn)\n        return register_middleware_for_blueprints"
    },
    {
      "chunk_id": 306,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def on_request(self, middleware=None):\n        \"\"\"Convenience method to register a request middleware for all blueprints in the group.\n\n        Args:\n            middleware (Optional): Optional positional Parameters to be use middleware\n\n        Returns:\n            Partial function to apply the middleware\n        \"\"\"  # noqa: E501\n        if callable(middleware):\n            return self.middleware(middleware, \"request\")\n        else:\n            return partial(self.middleware, attach_to=\"request\")"
    },
    {
      "chunk_id": 307,
      "source": "__internal__/data_repo/sanic/sanic/blueprints.py",
      "content": "def on_response(self, middleware=None):\n        \"\"\"Convenience method to register a response middleware for all blueprints in the group.\n\n        Args:\n            middleware (Optional): Optional positional Parameters to be use middleware\n\n        Returns:\n            Partial function to apply the middleware\n        \"\"\"  # noqa: E501\n        if callable(middleware):\n            return self.middleware(middleware, \"response\")\n        else:\n            return partial(self.middleware, attach_to=\"response\")"
    },
    {
      "chunk_id": 308,
      "source": "__internal__/data_repo/sanic/sanic/utils.py",
      "content": "import types\n\nfrom importlib.util import module_from_spec, spec_from_file_location\nfrom os import environ as os_environ\nfrom pathlib import Path\nfrom re import findall as re_findall\nfrom typing import Union\n\nfrom sanic.exceptions import LoadFileException, PyFileError\nfrom sanic.helpers import import_string"
    },
    {
      "chunk_id": 309,
      "source": "__internal__/data_repo/sanic/sanic/utils.py",
      "content": "def str_to_bool(val: str) -> bool:\n    \"\"\"Takes string and tries to turn it into bool as human would do.\n\n    If val is in case insensitive (\n        \"y\", \"yes\", \"yep\", \"yup\", \"t\",\n        \"true\", \"on\", \"enable\", \"enabled\", \"1\"\n    ) returns True.\n    If val is in case insensitive (\n        \"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"\n    ) returns False.\n    Else Raise ValueError.\"\"\"\n    \n    val = val.lower()\n    if val in {\n        \"y\",\n        \"yes\",\n        \"yep\",\n        \"yup\",\n        \"t\",\n        \"true\",\n        \"on\",\n        \"enable\",\n        \"enabled\",\n        \"1\",\n    }:\n        return True\n    elif val in {\"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"}:\n        return False\n    else:\n        raise ValueError(f\"Invalid truth value {val}\")"
    },
    {
      "chunk_id": 310,
      "source": "__internal__/data_repo/sanic/sanic/utils.py",
      "content": "def load_module_from_file_location(\n    location: Union[bytes, str, Path], encoding: str = \"utf8\", *args, **kwargs\n):  # noqa\n    \"\"\"Returns loaded module provided as a file path.\n\n    :param args:\n        Corresponds to importlib.util.spec_from_file_location location\n        parameters,but with this differences:\n        - It has to be of a string or bytes type.\n        - You can also use here environment variables\n          in format ${some_env_var}.\n          Mark that $some_env_var will not be resolved as environment variable.\n    :encoding:\n        If location parameter is of a bytes type, then use this encoding\n        to decode it into string.\n    :param args:\n        Corresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n    :param kwargs:\n        Corresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n\n    For example You can:\n\n        some_module = load_module_from_file_location(\n            \"some_module_name\",\n            \"/some/path/${some_env_var}\"\n        )\n    \"\"\"\n    if isinstance(location, bytes):\n        location = location.decode(encoding)\n\n    if isinstance(location, Path) or \"/\" in location or \"$\" in location:\n        if not isinstance(location, Path):\n            # A) Check if location contains any environment variables\n            #    in format ${some_env_var}.\n            env_vars_in_location = set(re_findall(r\"\\${(.+?)}\", location))\n\n            # B) Check these variables exists in environment.\n            not_defined_env_vars = env_vars_in_location.difference(\n                os_environ.keys()\n            )\n            if not_defined_env_vars:\n                raise LoadFileException(\n                    \"The following environment variables are not set: \"\n                    f\"{', '.join(not_defined_env_vars)}\"\n                )\n\n            # C) Substitute them in location.\n            for env_var in env_vars_in_location:\n                location = location.replace(\n                    \"${\" + env_var + \"}\", os_environ[env_var]\n                )\n\n        location = str(location)\n        if \".py\" in location:\n            name = location.split(\"/\")[-1].split(\".\")[\n                0\n            ]  # get just the file name without path and .py extension\n            _mod_spec = spec_from_file_location(\n                name, location, *args, **kwargs\n            )\n            assert _mod_spec is not None  # type assertion for mypy\n            module = module_from_spec(_mod_spec)\n            _mod_spec.loader.exec_module(module)  # type: ignore\n\n        else:\n            module = types.ModuleType(\"config\")\n            module.__file__ = str(location)\n            try:\n                with open(location) as config_file:\n                    exec(  # nosec\n                        compile(config_file.read(), location, \"exec\"),\n                        module.__dict__,\n                    )\n            except OSError as e:\n                e.strerror = \"Unable to load configuration file (e.strerror)\"\n                raise\n            except Exception as e:\n                raise PyFileError(location) from e\n\n        return module\n    else:\n        try:\n            return import_string(location)\n        except ValueError:\n            raise OSError(\"Unable to load configuration %s\" % str(location))"
    },
    {
      "chunk_id": 311,
      "source": "__internal__/data_repo/sanic/sanic/request/__init__.py",
      "content": "from .form import File, parse_multipart_form\nfrom .parameters import RequestParameters\nfrom .types import Request"
    },
    {
      "chunk_id": 312,
      "source": "__internal__/data_repo/sanic/sanic/request/__init__.py",
      "content": "__all__ = (\n    \"File\",\n    \"parse_multipart_form\",\n    \"Request\",\n    \"RequestParameters\",\n)"
    },
    {
      "chunk_id": 313,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "from __future__ import annotations\n\nfrom asyncio import BaseProtocol\nfrom contextvars import ContextVar\nfrom inspect import isawaitable\nfrom types import SimpleNamespace\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    DefaultDict,\n    Generic,\n    Optional,\n    Union,\n    cast,\n)\n\nfrom sanic_routing.route import Route\nfrom typing_extensions import TypeVar\n\nfrom sanic.http.constants import HTTP  # type: ignore\nfrom sanic.http.stream import Stream\nfrom sanic.models.asgi import ASGIScope\nfrom sanic.models.http_types import Credentials\n\n\nif TYPE_CHECKING:\n    from sanic.app import Sanic\n    from sanic.config import Config\n    from sanic.server import ConnInfo\n\nimport uuid\n\nfrom collections import defaultdict\nfrom urllib.parse import parse_qs, parse_qsl, urlunparse\n\nfrom httptools import parse_url\nfrom httptools.parser.errors import HttpParserInvalidURLError\n\nfrom sanic.compat import CancelledErrors, Header\nfrom sanic.constants import (\n    CACHEABLE_HTTP_METHODS,\n    DEFAULT_HTTP_CONTENT_TYPE,\n    IDEMPOTENT_HTTP_METHODS,\n    SAFE_HTTP_METHODS,\n)\nfrom sanic.cookies.request import CookieRequestParameters, parse_cookie\nfrom sanic.exceptions import BadRequest, BadURL, ServerError\nfrom sanic.headers import (\n    AcceptList,\n    Options,\n    parse_accept,\n    parse_content_header,\n    parse_credentials,\n    parse_forwarded,\n    parse_host,\n    parse_xforwarded,\n)\nfrom sanic.http import Stage\nfrom sanic.log import error_logger\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.response import BaseHTTPResponse, HTTPResponse\n\nfrom .form import parse_multipart_form\nfrom .parameters import RequestParameters\n\n\ntry:\n    from ujson import loads as json_loads  # type: ignore\nexcept ImportError:\n    from json import loads as json_loads  # type: ignore\n\nif TYPE_CHECKING:\n    sanic_type = TypeVar(\n        \"sanic_type\", bound=Sanic, default=Sanic[Config, SimpleNamespace]\n    )\n    ctx_type = TypeVar(\n        \"ctx_type\", bound=SimpleNamespace, default=SimpleNamespace\n    )\nelse:\n    sanic_type = TypeVar(\"sanic_type\")\n    ctx_type = TypeVar(\"ctx_type\")"
    },
    {
      "chunk_id": 314,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "class Request(Generic[sanic_type, ctx_type]):\n    \"\"\"State of HTTP request.\n\n    Args:\n        url_bytes (bytes): Raw URL bytes.\n        headers (Header): Request headers.\n        version (str): HTTP version.\n        method (str): HTTP method.\n        transport (TransportProtocol): Transport protocol.\n        app (Sanic): Sanic instance.\n        head (bytes, optional): Request head. Defaults to `b\"\"`.\n        stream_id (int, optional): HTTP/3 stream ID. Defaults to `0`.\n    \"\"\"\n\n    _current: ContextVar[Request] = ContextVar(\"request\")\n    _loads = json_loads\n\n    __slots__ = (\n        \"__weakref__\",\n        \"_cookies\",\n        \"_ctx\",\n        \"_id\",\n        \"_ip\",\n        \"_parsed_url\",\n        \"_port\",\n        \"_protocol\",\n        \"_remote_addr\",\n        \"_request_middleware_started\",\n        \"_response_middleware_started\",\n        \"_scheme\",\n        \"_socket\",\n        \"_stream_id\",\n        \"_match_info\",\n        \"_name\",\n        \"app\",\n        \"body\",\n        \"conn_info\",\n        \"head\",\n        \"headers\",\n        \"method\",\n        \"parsed_accept\",\n        \"parsed_args\",\n        \"parsed_cookies\",\n        \"parsed_credentials\",\n        \"parsed_files\",\n        \"parsed_form\",\n        \"parsed_forwarded\",\n        \"parsed_json\",\n        \"parsed_not_grouped_args\",\n        \"parsed_token\",\n        \"raw_url\",\n        \"responded\",\n        \"route\",\n        \"stream\",\n        \"transport\",\n        \"version\",\n    )\n\n    def __init__(\n        self,\n        url_bytes: bytes,\n        headers: Header,\n        version: str,\n        method: str,\n        transport: TransportProtocol,\n        app: sanic_type,\n        head: bytes = b\"\",\n        stream_id: int = 0,\n    ):\n        self.raw_url = url_bytes\n        try:\n            self._parsed_url = parse_url(url_bytes)\n        except HttpParserInvalidURLError:\n            url = url_bytes.decode(errors=\"backslashreplace\")\n            raise BadURL(f\"Bad URL: {url}\")\n        self._id: Optional[Union[uuid.UUID, str, int]] = None\n        self._name: Optional[str] = None\n        self._stream_id = stream_id\n        self.app = app\n\n        self.headers = Header(headers)\n        self.version = version\n        self.method = method\n        self.transport = transport\n        self.head = head\n\n        # Init but do not inhale\n        self.body = b\"\"\n        self.conn_info: Optional[ConnInfo] = None\n        self._ctx: Optional[ctx_type] = None\n        self.parsed_accept: Optional[AcceptList] = None\n        self.parsed_args: DefaultDict[\n            tuple[bool, bool, str, str], RequestParameters\n        ] = defaultdict(RequestParameters)\n        self.parsed_cookies: Optional[RequestParameters] = None\n        self.parsed_credentials: Optional[Credentials] = None\n        self.parsed_files: Optional[RequestParameters] = None\n        self.parsed_form: Optional[RequestParameters] = None\n        self.parsed_forwarded: Optional[Options] = None\n        self.parsed_json = None\n        self.parsed_not_grouped_args: DefaultDict[\n            tuple[bool, bool, str, str], list[tuple[str, str]]\n        ] = defaultdict(list)\n        self.parsed_token: Optional[str] = None\n        self._request_middleware_started = False\n        self._response_middleware_started = False\n        self.responded: bool = False\n        self.route: Optional[Route] = None\n        self.stream: Optional[Stream] = None\n        self._match_info: dict[str, Any] = {}\n        self._protocol: Optional[BaseProtocol] = None"
    },
    {
      "chunk_id": 315,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def __repr__(self):\n        class_name = self.__class__.__name__\n        return f\"<{class_name}: {self.method} {self.path}>\""
    },
    {
      "chunk_id": 316,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@staticmethod\n    def make_context() -> ctx_type:\n        \"\"\"Create a new context object.\n\n        This method is called when a new request context is pushed. It is\n        a great candidate for overriding in a subclass if you want to\n        control the type of context object that is created.\n\n        By default, it returns a `types.SimpleNamespace` instance.\n\n        Returns:\n            ctx_type: A new context object.\n        \"\"\"\n        return cast(ctx_type, SimpleNamespace())"
    },
    {
      "chunk_id": 317,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@classmethod\n    def get_current(cls) -> Request:\n        \"\"\"Retrieve the current request object\n\n        This implements [Context Variables](https://docs.python.org/3/library/contextvars.html)\n        to allow for accessing the current request from anywhere.\n\n        A typical usecase is when you want to access the current request\n        from a function that is not a handler, such as a logging function:\n\n        ```python\n        import logging\n\n        class LoggingFormater(logging.Formatter):\n            def format(self, record):\n                request = Request.get_current()\n                record.url = request.url\n                record.ip = request.ip\n                return super().format(record)\n        ```\n\n        Returns:\n            Request: The current request object\n\n        Raises:\n            sanic.exceptions.ServerError: If it is outside of a request\n                lifecycle.\n        \"\"\"  # noqa: E501\n        request = cls._current.get(None)\n        if not request:\n            raise ServerError(\"No current request\")\n        return request"
    },
    {
      "chunk_id": 318,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@classmethod\n    def generate_id(*_) -> Union[uuid.UUID, str, int]:\n        \"\"\"Generate a unique ID for the request.\n\n        This method is called to generate a unique ID for each request.\n        By default, it returns a `uuid.UUID` instance.\n\n        Returns:\n            Union[uuid.UUID, str, int]: A unique ID for the request.\n        \"\"\"\n        return uuid.uuid4()"
    },
    {
      "chunk_id": 319,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def ctx(self) -> ctx_type:\n        \"\"\"The current request context.\n\n        This is a context object for the current request. It is created\n        by `Request.make_context` and is a great place to store data\n        that you want to be accessible during the request lifecycle.\n\n        Returns:\n            ctx_type: The current request context.\n        \"\"\"\n        if not self._ctx:\n            self._ctx = self.make_context()\n        return self._ctx"
    },
    {
      "chunk_id": 320,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def stream_id(self) -> int:\n        \"\"\"Access the HTTP/3 stream ID.\n\n        Raises:\n            sanic.exceptions.ServerError: If the request is not HTTP/3.\n\n        Returns:\n            int: The HTTP/3 stream ID.\n        \"\"\"\n        if self.protocol.version is not HTTP.VERSION_3:\n            raise ServerError(\n                \"Stream ID is only a property of a HTTP/3 request\"\n            )\n        return self._stream_id"
    },
    {
      "chunk_id": 321,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def reset_response(self) -> None:\n        \"\"\"Reset the response object.\n\n        This clears much of the state of the object. It should\n        generally not be called directly, but is called automatically as\n        part of the request lifecycle.\n\n        Raises:\n            sanic.exceptions.ServerError: If the response has already been\n                sent.\n        \"\"\"\n        try:\n            if (\n                self.stream is not None\n                and self.stream.stage is not Stage.HANDLER\n            ):\n                raise ServerError(\n                    \"Cannot reset response because previous response was sent.\"\n                )\n            self.stream.response.stream = None  # type: ignore\n            self.stream.response = None  # type: ignore\n            self.responded = False\n        except AttributeError:\n            pass"
    },
    {
      "chunk_id": 322,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "async def respond(\n        self,\n        response: Optional[BaseHTTPResponse] = None,\n        *,\n        status: int = 200,\n        headers: Optional[Union[Header, dict[str, str]]] = None,\n        content_type: Optional[str] = None,\n    ):\n        \"\"\"Respond to the request without returning.\n\n        This method can only be called once, as you can only respond once.\n        If no ``response`` argument is passed, one will be created from the\n        ``status``, ``headers`` and ``content_type`` arguments.\n\n        **The first typical usecase** is if you wish to respond to the\n        request without returning from the handler:\n\n        ```python\n        @app.get(\"/\")\n        async def handler(request: Request):\n            data = ...  # Process something\n\n            json_response = json({\"data\": data})\n            await request.respond(json_response)\n\n        @app.on_response\n        async def add_header(_, response: HTTPResponse):\n            # Middlewares still get executed as expected\n            response.headers[\"one\"] = \"two\"\n        ```\n\n        **The second possible usecase** is for when you want to directly\n        respond to the request:\n\n        ```python\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n\n        # You can control the completion of the response by calling\n        # the 'eof()' method:\n        await response.eof()\n        ```\n\n        Args:\n            response (ResponseType): Response instance to send.\n            status (int): Status code to return in the response.\n            headers (Optional[Dict[str, str]]): Headers to return in the response, defaults to None.\n            content_type (Optional[str]): Content-Type header of the response, defaults to None.\n\n        Returns:\n            FinalResponseType: Final response being sent (may be different from the\n                \"response\" parameter because of middlewares), which can be\n                used to manually send data.\n        \"\"\"  # noqa: E501\n        try:\n            if self.stream is not None and self.stream.response:\n                raise ServerError(\"Second respond call is not allowed.\")\n        except AttributeError:\n            pass\n        # This logic of determining which response to use is subject to change\n        if response is None:\n            response = HTTPResponse(\n                status=status,\n                headers=headers,\n                content_type=content_type,\n            )\n\n        # Connect the response\n        if isinstance(response, BaseHTTPResponse) and self.stream:\n            response = self.stream.respond(response)\n\n            if isawaitable(response):\n                response = await response  # type: ignore\n        # Run response middleware\n        try:\n            middleware = (\n                self.route and self.route.extra.response_middleware\n            ) or self.app.response_middleware\n            if middleware and not self._response_middleware_started:\n                self._response_middleware_started = True\n                response = await self.app._run_response_middleware(\n                    self, response, middleware\n                )\n        except CancelledErrors:\n            raise\n        except Exception:\n            error_logger.exception(\n                \"Exception occurred in one of response middleware handlers\"\n            )\n        self.responded = True\n        return response"
    },
    {
      "chunk_id": 323,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "async def receive_body(self):\n        \"\"\"Receive request.body, if not already received.\n\n        Streaming handlers may call this to receive the full body. Sanic calls\n        this function before running any handlers of non-streaming routes.\n\n        Custom request classes can override this for custom handling of both\n        streaming and non-streaming routes.\n        \"\"\"\n        if not self.body:\n            self.body = b\"\".join([data async for data in self.stream])"
    },
    {
      "chunk_id": 324,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def name(self) -> Optional[str]:\n        \"\"\"The route name\n\n        In the following pattern:\n\n        ```\n        <AppName>.[<BlueprintName>.]<HandlerName>\n        ```\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        if self._name:\n            return self._name\n        elif self.route:\n            return self.route.name\n        return None"
    },
    {
      "chunk_id": 325,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def endpoint(self) -> Optional[str]:\n        \"\"\"Alias of `sanic.request.Request.name`\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        return self.name"
    },
    {
      "chunk_id": 326,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def uri_template(self) -> Optional[str]:\n        \"\"\"The defined URI template\n\n        Returns:\n            Optional[str]: The defined URI template\n        \"\"\"\n        if self.route:\n            return f\"/{self.route.path}\"\n        return None"
    },
    {
      "chunk_id": 327,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def protocol(self) -> TransportProtocol:\n        \"\"\"The HTTP protocol instance\n\n        Returns:\n            Protocol: The HTTP protocol instance\n        \"\"\"\n        if not self._protocol:\n            self._protocol = self.transport.get_protocol()\n        return self._protocol  # type: ignore"
    },
    {
      "chunk_id": 328,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def raw_headers(self) -> bytes:\n        \"\"\"The unparsed HTTP headers\n\n        Returns:\n            bytes: The unparsed HTTP headers\n        \"\"\"\n        _, headers = self.head.split(b\"\\r\\n\", 1)\n        return bytes(headers)"
    },
    {
      "chunk_id": 329,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def request_line(self) -> bytes:\n        \"\"\"The first line of a HTTP request\n\n        Returns:\n            bytes: The first line of a HTTP request\n        \"\"\"\n        reqline, _ = self.head.split(b\"\\r\\n\", 1)\n        return bytes(reqline)"
    },
    {
      "chunk_id": 330,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        \"\"\"A request ID passed from the client, or generated from the backend.\n\n        By default, this will look in a request header defined at:\n        `self.app.config.REQUEST_ID_HEADER`. It defaults to\n        `X-Request-ID`. Sanic will try to cast the ID into a `UUID` or an\n        `int`.\n\n        If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling `Request.generate_id()`. The default\n        behavior is to generate a `UUID`. You can customize this behavior\n        by subclassing `Request` and overwriting that method.\n\n        ```python\n        from sanic import Request, Sanic\n        from itertools import count\n\n        class IntRequest(Request):\n            counter = count()\n\n            def generate_id(self):\n                return next(self.counter)\n\n        app = Sanic(\"MyApp\", request_class=IntRequest)\n        ```\n\n        Returns:\n            Optional[Union[uuid.UUID, str, int]]: A request ID passed from the\n                client, or generated from the backend.\n        \"\"\"\n        if not self._id:\n            self._id = self.headers.getone(\n                self.app.config.REQUEST_ID_HEADER,\n                self.__class__.generate_id(self),  # type: ignore\n            )\n\n            # Try casting to a UUID or an integer\n            if isinstance(self._id, str):\n                try:\n                    self._id = uuid.UUID(self._id)\n                except ValueError:\n                    try:\n                        self._id = int(self._id)  # type: ignore\n                    except ValueError:\n                        ...\n\n        return self._id  # type: ignore"
    },
    {
      "chunk_id": 331,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def json(self) -> Any:\n        \"\"\"The request body parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        if self.parsed_json is None:\n            self.load_json()\n\n        return self.parsed_json"
    },
    {
      "chunk_id": 332,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def load_json(self, loads=None) -> Any:\n        \"\"\"Load the request body as JSON\n\n        Args:\n            loads (Callable, optional): A custom JSON loader. Defaults to None.\n\n        Raises:\n            BadRequest: If the request body cannot be parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        try:\n            if not loads:\n                loads = self.__class__._loads\n\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise BadRequest(\"Failed when parsing body as json\")\n\n        return self.parsed_json"
    },
    {
      "chunk_id": 333,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def accept(self) -> AcceptList:\n        \"\"\"Accepted response content types.\n\n        A convenience handler for easier RFC-compliant matching of MIME types,\n        parsed as a list that can match wildcards and includes */* by default.\n\n        Returns:\n            AcceptList: Accepted response content types\n        \"\"\"\n        if self.parsed_accept is None:\n            self.parsed_accept = parse_accept(self.headers.get(\"accept\"))\n        return self.parsed_accept"
    },
    {
      "chunk_id": 334,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def token(self) -> Optional[str]:\n        \"\"\"Attempt to return the auth header token.\n\n        Returns:\n            Optional[str]: The auth header token\n        \"\"\"\n        if self.parsed_token is None:\n            prefixes = (\"Bearer\", \"Token\")\n            _, token = parse_credentials(\n                self.headers.getone(\"authorization\", None), prefixes\n            )\n            self.parsed_token = token\n        return self.parsed_token"
    },
    {
      "chunk_id": 335,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def credentials(self) -> Optional[Credentials]:\n        \"\"\"Attempt to return the auth header value.\n\n        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication\n        schemas.\n\n        Returns:\n            Optional[Credentials]: A Credentials object with token, or username\n                and password related to the request\n        \"\"\"\n        if self.parsed_credentials is None:\n            try:\n                prefix, credentials = parse_credentials(\n                    self.headers.getone(\"authorization\", None)\n                )\n                if credentials:\n                    self.parsed_credentials = Credentials(\n                        auth_type=prefix, token=credentials\n                    )\n            except ValueError:\n                pass\n        return self.parsed_credentials"
    },
    {
      "chunk_id": 336,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def get_form(\n        self, keep_blank_values: bool = False\n    ) -> Optional[RequestParameters]:\n        \"\"\"Method to extract and parse the form data from a request.\n\n        Args:\n            keep_blank_values (bool): Whether to discard blank values from the form data.\n\n        Returns:\n            Optional[RequestParameters]: The parsed form data.\n        \"\"\"  # noqa: E501\n        self.parsed_form = RequestParameters()\n        self.parsed_files = RequestParameters()\n        content_type = self.headers.getone(\n            \"content-type\", DEFAULT_HTTP_CONTENT_TYPE\n        )\n        content_type, parameters = parse_content_header(content_type)\n        try:\n            if content_type == \"application/x-www-form-urlencoded\":\n                self.parsed_form = RequestParameters(\n                    parse_qs(\n                        self.body.decode(\"utf-8\"),\n                        keep_blank_values=keep_blank_values,\n                    )\n                )\n            elif content_type == \"multipart/form-data\":\n                # TODO: Stream this instead of reading to/from memory\n                boundary = parameters[\"boundary\"].encode(  # type: ignore\n                    \"utf-8\"\n                )  # type: ignore\n                self.parsed_form, self.parsed_files = parse_multipart_form(\n                    self.body, boundary\n                )\n        except Exception:\n            error_logger.exception(\"Failed when parsing form\")\n\n        return self.parsed_form"
    },
    {
      "chunk_id": 337,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def form(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as form data\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as form data\n        \"\"\"\n        if self.parsed_form is None:\n            self.get_form()\n\n        return self.parsed_form"
    },
    {
      "chunk_id": 338,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def files(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as uploaded files\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as uploaded files\n        \"\"\"  # noqa: E501\n        if self.parsed_files is None:\n            self.form  # compute form to get files\n\n        return self.parsed_files"
    },
    {
      "chunk_id": 339,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def get_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> RequestParameters:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qs`.\n\n        This methods is used by the `args` property, but it also\n        can be used directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with parsing\n                errors. If `False` (the default), errors are silently ignored.\n                If `True`, errors raise a `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            RequestParameters: A dictionary containing the parsed arguments.\n        \"\"\"\n        if (\n            keep_blank_values,\n            strict_parsing,\n            encoding,\n            errors,\n        ) not in self.parsed_args:\n            if self.query_string:\n                self.parsed_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = RequestParameters(\n                    parse_qs(\n                        qs=self.query_string,\n                        keep_blank_values=keep_blank_values,\n                        strict_parsing=strict_parsing,\n                        encoding=encoding,\n                        errors=errors,\n                    )\n                )\n\n        return self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]"
    },
    {
      "chunk_id": 340,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "args = property(get_args)\n    \"\"\"Convenience property to access `Request.get_args` with default values.\n    \"\"\""
    },
    {
      "chunk_id": 341,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def get_query_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> list:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qsl`.\n\n        This methods is used by `query_args` propertyn but can be used\n        directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with\n                parsing errors. If `False` (the default), errors are\n                silently ignored. If `True`, errors raise a\n                `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            list: A list of tuples containing the parsed arguments.\n        \"\"\"\n        if (\n            keep_blank_values,\n            strict_parsing,\n            encoding,\n            errors,\n        ) not in self.parsed_not_grouped_args:\n            if self.query_string:\n                self.parsed_not_grouped_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = parse_qsl(\n                    qs=self.query_string,\n                    keep_blank_values=keep_blank_values,\n                    strict_parsing=strict_parsing,\n                    encoding=encoding,\n                    errors=errors,\n                )\n        return self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]"
    },
    {
      "chunk_id": 342,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "query_args = property(get_query_args)\n    \"\"\"Convenience property to access `Request.get_query_args` with default values.\n    \"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 343,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def get_cookies(self) -> RequestParameters:\n        cookie = self.headers.getone(\"cookie\", \"\")\n        self.parsed_cookies = CookieRequestParameters(parse_cookie(cookie))\n        return self.parsed_cookies"
    },
    {
      "chunk_id": 344,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def cookies(self) -> RequestParameters:\n        \"\"\"Incoming cookies on the request\n\n        Returns:\n            RequestParameters: Incoming cookies on the request\n        \"\"\"\n\n        if self.parsed_cookies is None:\n            self.get_cookies()\n        return cast(CookieRequestParameters, self.parsed_cookies)"
    },
    {
      "chunk_id": 345,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def content_type(self) -> str:\n        \"\"\"Content-Type header form the request\n\n        Returns:\n            str: Content-Type header form the request\n        \"\"\"\n        return self.headers.getone(\"content-type\", DEFAULT_HTTP_CONTENT_TYPE)"
    },
    {
      "chunk_id": 346,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def match_info(self) -> dict[str, Any]:\n        \"\"\"Matched path parameters after resolving route\n\n        Returns:\n            Dict[str, Any]: Matched path parameters after resolving route\n        \"\"\"\n        return self._match_info"
    },
    {
      "chunk_id": 347,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@match_info.setter\n    def match_info(self, value):\n        self._match_info = value"
    },
    {
      "chunk_id": 348,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def ip(self) -> str:\n        \"\"\"Peer ip of the socket\n\n        Returns:\n            str: Peer ip of the socket\n        \"\"\"\n        return self.conn_info.client_ip if self.conn_info else \"\""
    },
    {
      "chunk_id": 349,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def port(self) -> int:\n        \"\"\"Peer port of the socket\n\n        Returns:\n            int: Peer port of the socket\n        \"\"\"\n        return self.conn_info.client_port if self.conn_info else 0"
    },
    {
      "chunk_id": 350,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def socket(self) -> Union[tuple[str, int], tuple[None, None]]:\n        \"\"\"Information about the connected socket if available\n\n        Returns:\n            Tuple[Optional[str], Optional[int]]: Information about the\n                connected socket if available, in the form of a tuple of\n                (ip, port)\n        \"\"\"\n        return (\n            self.conn_info.peername\n            if self.conn_info and self.conn_info.peername\n            else (None, None)\n        )"
    },
    {
      "chunk_id": 351,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def path(self) -> str:\n        \"\"\"Path of the local HTTP request\n\n        Returns:\n            str: Path of the local HTTP request\n        \"\"\"\n        return self._parsed_url.path.decode(\"utf-8\")"
    },
    {
      "chunk_id": 352,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def network_paths(self) -> Optional[list[Any]]:\n        \"\"\"Access the network paths if available\n\n        Returns:\n            Optional[List[Any]]: Access the network paths if available\n        \"\"\"\n        if self.conn_info is None:\n            return None\n        return self.conn_info.network_paths"
    },
    {
      "chunk_id": 353,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "# Proxy properties (using SERVER_NAME/forwarded/request/transport info)\n\n    @property\n    def forwarded(self) -> Options:\n        \"\"\"Active proxy information obtained from request headers, as specified in Sanic configuration.\n\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n\n        Additional values may be available from new style Forwarded headers.\n\n        Returns:\n            Options: proxy information from request headers\n        \"\"\"  # noqa: E501\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = (\n                parse_forwarded(self.headers, self.app.config)\n                or parse_xforwarded(self.headers, self.app.config)\n                or {}\n            )\n        return self.parsed_forwarded"
    },
    {
      "chunk_id": 354,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def remote_addr(self) -> str:\n        \"\"\"Client IP address, if available from proxy.\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        if not hasattr(self, \"_remote_addr\"):\n            self._remote_addr = str(self.forwarded.get(\"for\", \"\"))\n        return self._remote_addr"
    },
    {
      "chunk_id": 355,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def client_ip(self) -> str:\n        \"\"\"\n        Client IP address.\n        1. proxied remote address `self.forwarded['for']`\n        2. local peer address `self.ip`\n\n        New in Sanic 23.6. Prefer this over `remote_addr` for determining the\n        client address regardless of whether the service runs behind a proxy\n        or not (proxy deployment needs separate configuration).\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        return self.remote_addr or self.ip"
    },
    {
      "chunk_id": 356,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def scheme(self) -> str:\n        \"\"\"Determine request scheme.\n\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n\n        Returns:\n            str: http|https|ws|wss or arbitrary value given by the headers.\n        \"\"\"\n        if not hasattr(self, \"_scheme\"):\n            if (\n                self.app.websocket_enabled\n                and self.headers.upgrade.lower() == \"websocket\"\n            ):\n                scheme = \"ws\"\n            else:\n                scheme = \"http\"\n            proto = None\n            sp = self.app.config.get(\"SERVER_NAME\", \"\").split(\"://\", 1)\n            if len(sp) == 2:\n                proto = sp[0]\n            elif \"proto\" in self.forwarded:\n                proto = str(self.forwarded[\"proto\"])\n            if proto:\n                # Give ws/wss if websocket, otherwise keep the same\n                scheme = proto.replace(\"http\", scheme)\n            elif self.conn_info and self.conn_info.ssl:\n                scheme += \"s\"\n            self._scheme = scheme\n\n        return self._scheme"
    },
    {
      "chunk_id": 357,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def host(self) -> str:\n        \"\"\"The currently effective server 'host' (hostname or hostname:port).\n\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n\n        Returns:\n            str: the first matching host found, or empty string\n        \"\"\"\n        server_name = self.app.config.get(\"SERVER_NAME\")\n        if server_name:\n            return server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]\n        return str(\n            self.forwarded.get(\"host\") or self.headers.getone(\"host\", \"\")\n        )"
    },
    {
      "chunk_id": 358,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def server_name(self) -> str:\n        \"\"\"hostname the client connected to, by `request.host`\n\n        Returns:\n            str: hostname the client connected to, by `request.host`\n        \"\"\"\n        return parse_host(self.host)[0] or \"\""
    },
    {
      "chunk_id": 359,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def server_port(self) -> int:\n        \"\"\"The port the client connected to, by forwarded `port` or `request.host`.\n\n        Default port is returned as 80 and 443 based on `request.scheme`.\n\n        Returns:\n            int: The port the client connected to, by forwarded `port` or `request.host`.\n        \"\"\"  # noqa: E501\n        port = self.forwarded.get(\"port\") or parse_host(self.host)[1]\n        return int(port or (80 if self.scheme in (\"http\", \"ws\") else 443))"
    },
    {
      "chunk_id": 360,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def server_path(self) -> str:\n        \"\"\"Full path of current URL; uses proxied or local path\n\n        Returns:\n            str: Full path of current URL; uses proxied or local path\n        \"\"\"\n        return str(self.forwarded.get(\"path\") or self.path)"
    },
    {
      "chunk_id": 361,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def query_string(self) -> str:\n        \"\"\"Representation of the requested query\n\n        Returns:\n            str: Representation of the requested query\n        \"\"\"\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode(\"utf-8\")\n        else:\n            return \"\""
    },
    {
      "chunk_id": 362,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def url(self) -> str:\n        \"\"\"The URL\n\n        Returns:\n            str: The URL\n        \"\"\"\n        return urlunparse(\n            (self.scheme, self.host, self.path, None, self.query_string, None)\n        )"
    },
    {
      "chunk_id": 363,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "def url_for(self, view_name: str, **kwargs) -> str:\n        \"\"\"Retrieve a URL for a given view name.\n\n        Same as `sanic.Sanic.url_for`, but automatically determine `scheme`\n        and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        Args:\n            view_name (str): The view name to generate URL for.\n            **kwargs: Arbitrary keyword arguments to build URL query string.\n\n        Returns:\n            str: The generated URL.\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        try:\n            sp = self.app.config.get(\"SERVER_NAME\", \"\").split(\"://\", 1)\n            if len(sp) == 2:\n                return self.app.url_for(view_name, _external=True, **kwargs)\n        except AttributeError:\n            pass\n\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n\n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = f\"{host}:{port}\"\n\n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )"
    },
    {
      "chunk_id": 364,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def scope(self) -> ASGIScope:\n        \"\"\"The ASGI scope of the request.\n\n        Returns:\n            ASGIScope: The ASGI scope of the request.\n\n        Raises:\n            NotImplementedError: If the app isn't an ASGI app.\n        \"\"\"\n        if not self.app.asgi:\n            raise NotImplementedError(\n                \"App isn't running in ASGI mode. \"\n                \"Scope is only available for ASGI apps.\"\n            )\n\n        return self.transport.scope"
    },
    {
      "chunk_id": 365,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def is_safe(self) -> bool:\n        \"\"\"Whether the HTTP method is safe.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n\n        Returns:\n            bool: Whether the HTTP method is safe.\n        \"\"\"\n        return self.method in SAFE_HTTP_METHODS"
    },
    {
      "chunk_id": 366,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def is_idempotent(self) -> bool:\n        \"\"\"Whether the HTTP method is iempotent.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2\n\n        Returns:\n            bool: Whether the HTTP method is iempotent.\n        \"\"\"\n        return self.method in IDEMPOTENT_HTTP_METHODS"
    },
    {
      "chunk_id": 367,
      "source": "__internal__/data_repo/sanic/sanic/request/types.py",
      "content": "@property\n    def is_cacheable(self) -> bool:\n        \"\"\"Whether the HTTP method is cacheable.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.3\n\n        Returns:\n            bool: Whether the HTTP method is cacheable.\n        \"\"\"\n        return self.method in CACHEABLE_HTTP_METHODS"
    },
    {
      "chunk_id": 368,
      "source": "__internal__/data_repo/sanic/sanic/request/form.py",
      "content": "from __future__ import annotations\n\nimport email.utils\nimport unicodedata\n\nfrom typing import NamedTuple\nfrom urllib.parse import unquote\n\nfrom sanic.headers import parse_content_header\nfrom sanic.log import logger\n\nfrom .parameters import RequestParameters"
    },
    {
      "chunk_id": 369,
      "source": "__internal__/data_repo/sanic/sanic/request/form.py",
      "content": "class File(NamedTuple):\n    \"\"\"Model for defining a file.\n\n    It is a `namedtuple`, therefore you can iterate over the object, or\n    access the parameters by name.\n\n    Args:\n        type (str, optional): The mimetype, defaults to \"text/plain\".\n        body (bytes): Bytes of the file.\n        name (str): The filename.\n    \"\"\"\n\n    type: str\n    body: bytes\n    name: str"
    },
    {
      "chunk_id": 370,
      "source": "__internal__/data_repo/sanic/sanic/request/form.py",
      "content": "def parse_multipart_form(body, boundary):\n    \"\"\"Parse a request body and returns fields and files\n\n    Args:\n        body (bytes): Bytes request body.\n        boundary (bytes): Bytes multipart boundary.\n\n    Returns:\n        Tuple[RequestParameters, RequestParameters]: A tuple containing fields and files as `RequestParameters`.\n    \"\"\"  # noqa: E501\n    files = {}\n    fields = {}\n\n    form_parts = body.split(boundary)\n    for form_part in form_parts[1:-1]:\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        while not line_end_index == -1:\n            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n            line_index = line_end_index + 2\n\n            if not form_line:\n                break\n\n            colon_index = form_line.index(\":\")\n            idx = colon_index + 2\n            form_header_field = form_line[0:colon_index].lower()\n            form_header_value, form_parameters = parse_content_header(\n                form_line[idx:]\n            )\n\n            if form_header_field == \"content-disposition\":\n                field_name = form_parameters.get(\"name\")\n                file_name = form_parameters.get(\"filename\")\n\n                # non-ASCII filenames in RFC2231, \"filename*\" format\n                if file_name is None and form_parameters.get(\"filename*\"):\n                    encoding, _, value = email.utils.decode_rfc2231(\n                        form_parameters[\"filename*\"]\n                    )\n                    file_name = unquote(value, encoding=encoding)\n\n                # Normalize to NFC (Apple MacOS/iOS send NFD)\n                # Notes:\n                # - No effect for Windows, Linux or Android clients which\n                #   already send NFC\n                # - Python open() is tricky (creates files in NFC no matter\n                #   which form you use)\n                if file_name is not None:\n                    file_name = unicodedata.normalize(\"NFC\", file_name)\n\n            elif form_header_field == \"content-type\":\n                content_type = form_header_value\n                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n\n        if field_name:\n            post_data = form_part[line_index:-4]\n            if file_name is None:\n                value = post_data.decode(content_charset)\n                if field_name in fields:\n                    fields[field_name].append(value)\n                else:\n                    fields[field_name] = [value]\n            else:\n                form_file = File(\n                    type=content_type, name=file_name, body=post_data\n                )\n                if field_name in files:\n                    files[field_name].append(form_file)\n                else:\n                    files[field_name] = [form_file]\n        else:\n            logger.debug(\n                \"Form-data field does not have a 'name' parameter \"\n                \"in the Content-Disposition header\"\n            )\n\n    return RequestParameters(fields), RequestParameters(files)"
    },
    {
      "chunk_id": 371,
      "source": "__internal__/data_repo/sanic/sanic/request/parameters.py",
      "content": "from __future__ import annotations\n\nfrom typing import Any, Optional"
    },
    {
      "chunk_id": 372,
      "source": "__internal__/data_repo/sanic/sanic/request/parameters.py",
      "content": "class RequestParameters(dict):\n    \"\"\"Hosts a dict with lists as values where get returns the first value of the list and getlist returns the whole shebang\"\"\"  # noqa: E501\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)"
    },
    {
      "chunk_id": 373,
      "source": "__internal__/data_repo/sanic/sanic/request/parameters.py",
      "content": "def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:\n        \"\"\"Return the first value, either the default or actual\n\n        Args:\n            name (str): The name of the parameter\n            default (Optional[Any], optional): The default value. Defaults to None.\n\n        Returns:\n            Optional[Any]: The first value of the list\n        \"\"\"  # noqa: E501\n        return super().get(name, [default])[0]"
    },
    {
      "chunk_id": 374,
      "source": "__internal__/data_repo/sanic/sanic/request/parameters.py",
      "content": "def getlist(\n        self, name: str, default: Optional[list[Any]] = None\n    ) -> list[Any]:\n        \"\"\"Return the entire list\n\n        Args:\n            name (str): The name of the parameter\n            default (Optional[List[Any]], optional): The default value. Defaults to None.\n\n        Returns:\n            list[Any]: The entire list of values or [] if not found\n        \"\"\"  # noqa: E501\n        return super().get(name, default) or []"
    },
    {
      "chunk_id": 375,
      "source": "__internal__/data_repo/sanic/sanic/cookies/__init__.py",
      "content": "from .response import Cookie, CookieJar"
    },
    {
      "chunk_id": 376,
      "source": "__internal__/data_repo/sanic/sanic/cookies/__init__.py",
      "content": "__all__ = (\"Cookie\", \"CookieJar\")"
    },
    {
      "chunk_id": 377,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "from __future__ import annotations\n\nimport re\nimport string\n\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Union\n\nfrom sanic.exceptions import ServerError\n\n\nif TYPE_CHECKING:\n    from sanic.compat import Header\n\nfrom typing import Literal"
    },
    {
      "chunk_id": 378,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "SameSite = Union[\n    Literal[\"Strict\"],\n    Literal[\"Lax\"],\n    Literal[\"None\"],\n    Literal[\"strict\"],\n    Literal[\"lax\"],\n    Literal[\"none\"],\n]\n\nDEFAULT_MAX_AGE = 0\nSAMESITE_VALUES = (\"strict\", \"lax\", \"none\")\n\nLEGAL_CHARS = string.ascii_letters + string.digits + \"!#$%&'*+-.^_`|~:\"\nUNESCAPED_CHARS = LEGAL_CHARS + \" ()/<=>?@[]{}\"\nTRANSLATOR = {ch: f\"\\\\{ch:03o}\" for ch in bytes(range(32)) + b'\";\\\\\\x7f'}"
    },
    {
      "chunk_id": 379,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def _quote(str):  # no cov\n    r\"\"\"Quote a string for use in a cookie header.\n    If the string does not need to be double-quoted, then just return the\n    string.  Otherwise, surround the string in doublequotes and quote\n    (with a \\) special characters.\n    \"\"\"\n    if str is None or _is_legal_key(str):\n        return str\n    else:\n        return f'\"{str.translate(TRANSLATOR)}\"'"
    },
    {
      "chunk_id": 380,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "_is_legal_key = re.compile(\"[%s]+\" % re.escape(LEGAL_CHARS)).fullmatch"
    },
    {
      "chunk_id": 381,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "class CookieJar:\n    \"\"\"A container to manipulate cookies.\n\n    CookieJar dynamically writes headers as cookies are added and removed\n    It gets around the limitation of one header per name by using the\n    MultiHeader class to provide a unique key that encodes to Set-Cookie.\n\n    Args:\n        headers (Header): The headers object to write cookies to.\n    \"\"\"\n\n    HEADER_KEY = \"Set-Cookie\"\n\n    def __init__(self, headers: Header):\n        self.headers = headers\n\n    def __len__(self):  # no cov\n        return len(self.cookies)\n\n    @property\n    def cookies(self) -> list[Cookie]:\n        \"\"\"A list of cookies in the CookieJar.\n\n        Returns:\n            List[Cookie]: A list of cookies in the CookieJar.\n        \"\"\"\n        return self.headers.getall(self.HEADER_KEY)"
    },
    {
      "chunk_id": 382,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def get_cookie(\n        self,\n        key: str,\n        path: str = \"/\",\n        domain: str | None = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> Cookie | None:\n        \"\"\"Fetch a cookie from the CookieJar.\n\n        Args:\n            key (str): The key of the cookie to fetch.\n            path (str, optional): The path of the cookie. Defaults to `\"/\"`.\n            domain (Optional[str], optional): The domain of the cookie.\n                Defaults to `None`.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key.\n                This requires that path=\"/\", domain=None, and secure=True.\n                Defaults to `False`.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key.\n                This requires that secure=True. Defaults to `False`.\n\n        Returns:\n            Optional[Cookie]: The cookie if it exists, otherwise `None`.\n        \"\"\"  # noqa: E501\n        for cookie in self.cookies:\n            if (\n                cookie.key == Cookie.make_key(key, host_prefix, secure_prefix)\n                and cookie.path == path\n                and cookie.domain == domain\n            ):\n                return cookie\n        return None"
    },
    {
      "chunk_id": 383,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def has_cookie(\n        self,\n        key: str,\n        path: str = \"/\",\n        domain: str | None = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> bool:\n        \"\"\"Check if a cookie exists in the CookieJar.\n\n        Args:\n            key (str): The key of the cookie to check.\n            path (str, optional): The path of the cookie. Defaults to `\"/\"`.\n            domain (Optional[str], optional): The domain of the cookie.\n                Defaults to `None`.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key.\n                This requires that path=\"/\", domain=None, and secure=True.\n                Defaults to `False`.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key.\n                This requires that secure=True. Defaults to `False`.\n\n        Returns:\n            bool: Whether the cookie exists.\n        \"\"\"  # noqa: E501\n        for cookie in self.cookies:\n            if (\n                cookie.key == Cookie.make_key(key, host_prefix, secure_prefix)\n                and cookie.path == path\n                and cookie.domain == domain\n            ):\n                return True\n        return False"
    },
    {
      "chunk_id": 384,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def add_cookie(\n        self,\n        key: str,\n        value: str,\n        *,\n        path: str = \"/\",\n        domain: str | None = None,\n        secure: bool = True,\n        max_age: int | None = None,\n        expires: datetime | None = None,\n        httponly: bool = False,\n        samesite: SameSite | None = \"Lax\",\n        partitioned: bool = False,\n        comment: str | None = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> Cookie:\n        \"\"\"Add a cookie to the CookieJar.\n\n        Args:\n            key (str): Key of the cookie.\n            value (str): Value of the cookie.\n            path (str, optional): Path of the cookie. Defaults to \"/\".\n            domain (Optional[str], optional): Domain of the cookie. Defaults to None.\n            secure (bool, optional): Whether to set it as a secure cookie. Defaults to True.\n            max_age (Optional[int], optional): Max age of the cookie in seconds; if set to 0 a\n                browser should delete it. Defaults to None.\n            expires (Optional[datetime], optional): When the cookie expires; if set to None browsers\n                should set it as a session cookie. Defaults to None.\n            httponly (bool, optional): Whether to set it as HTTP only. Defaults to False.\n            samesite (Optional[SameSite], optional): How to set the samesite property, should be\n                strict, lax, or none (case insensitive). Defaults to \"Lax\".\n            partitioned (bool, optional): Whether to set it as partitioned. Defaults to False.\n            comment (Optional[str], optional): A cookie comment. Defaults to None.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key.\n                This requires that path=\"/\", domain=None, and secure=True. Defaults to False.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key.\n                This requires that secure=True. Defaults to False.\n\n        Returns:\n            Cookie: The instance of the created cookie.\n\n        Raises:\n            ServerError: If host_prefix is set without secure=True.\n            ServerError: If host_prefix is set without path=\"/\" and domain=None.\n            ServerError: If host_prefix is set with domain.\n            ServerError: If secure_prefix is set without secure=True.\n            ServerError: If partitioned is set without host_prefix=True.\n\n        Examples:\n            Basic usage\n            ```python\n            cookie = add_cookie('name', 'value')\n            ```\n\n            Adding a cookie with a custom path and domain\n            ```python\n            cookie = add_cookie('name', 'value', path='/custom', domain='example.com')\n            ```\n\n            Adding a secure, HTTP-only cookie with a comment\n            ```python\n            cookie = add_cookie('name', 'value', secure=True, httponly=True, comment='My Cookie')\n            ```\n\n            Adding a cookie with a max age of 60 seconds\n            ```python\n            cookie = add_cookie('name', 'value', max_age=60)\n            ```\n        \"\"\"  # noqa: E501\n        cookie = Cookie(\n            key,\n            value,\n            path=path,\n            expires=expires,\n            comment=comment,\n            domain=domain,\n            max_age=max_age,\n            secure=secure,\n            httponly=httponly,\n            samesite=samesite,\n            partitioned=partitioned,\n            host_prefix=host_prefix,\n            secure_prefix=secure_prefix,\n        )\n        self.headers.add(self.HEADER_KEY, cookie)\n\n        return cookie"
    },
    {
      "chunk_id": 385,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def delete_cookie(\n        self,\n        key: str,\n        *,\n        path: str = \"/\",\n        domain: str | None = None,\n        secure: bool = True,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> None:\n        \"\"\"\n        Delete a cookie\n\n        This will effectively set it as Max-Age: 0, which a browser should\n        interpret it to mean: \"delete the cookie\".\n\n        Since it is a browser/client implementation, your results may vary\n        depending upon which client is being used.\n\n        :param key: The key to be deleted\n        :type key: str\n        :param path: Path of the cookie, defaults to None\n        :type path: Optional[str], optional\n        :param domain: Domain of the cookie, defaults to None\n        :type domain: Optional[str], optional\n        :param secure: Whether to delete a secure cookie. Defaults to True.\n        :param secure: bool\n        :param host_prefix: Whether to add __Host- as a prefix to the key.\n            This requires that path=\"/\", domain=None, and secure=True,\n            defaults to False\n        :type host_prefix: bool\n        :param secure_prefix: Whether to add __Secure- as a prefix to the key.\n            This requires that secure=True, defaults to False\n        :type secure_prefix: bool\n        \"\"\"\n        if host_prefix and not (secure and path == \"/\" and domain is None):\n            raise ServerError(\n                \"Cannot set host_prefix on a cookie without \"\n                \"path='/', domain=None, and secure=True\"\n            )\n        if secure_prefix and not secure:\n            raise ServerError(\n                \"Cannot set secure_prefix on a cookie without secure=True\"\n            )\n\n        cookies: list[Cookie] = self.headers.popall(self.HEADER_KEY, [])\n        existing_cookie = None\n        for cookie in cookies:\n            if (\n                cookie.key != Cookie.make_key(key, host_prefix, secure_prefix)\n                or cookie.path != path\n                or cookie.domain != domain\n            ):\n                self.headers.add(self.HEADER_KEY, cookie)\n            elif existing_cookie is None:\n                existing_cookie = cookie\n\n        if existing_cookie is not None:\n            # Use all the same values as the cookie to be deleted\n            # except value=\"\" and max_age=0\n            self.add_cookie(\n                key=key,\n                value=\"\",\n                path=existing_cookie.path,\n                domain=existing_cookie.domain,\n                secure=existing_cookie.secure,\n                max_age=0,\n                httponly=existing_cookie.httponly,\n                partitioned=existing_cookie.partitioned,\n                samesite=existing_cookie.samesite,\n                host_prefix=host_prefix,\n                secure_prefix=secure_prefix,\n            )\n        else:\n            self.add_cookie(\n                key=key,\n                value=\"\",\n                path=path,\n                domain=domain,\n                secure=secure,\n                max_age=0,\n                samesite=None,\n                host_prefix=host_prefix,\n                secure_prefix=secure_prefix,\n            )"
    },
    {
      "chunk_id": 386,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "class Cookie:\n    \"\"\"A representation of a HTTP cookie, providing an interface to manipulate cookie attributes intended for a response.\n\n    This class is a simplified representation of a cookie, similar to the Morsel SimpleCookie in Python's standard library.\n    It allows the manipulation of various cookie attributes including path, domain, security settings, and others.\n\n    Several \"smart defaults\" are provided to make it easier to create cookies that are secure by default. These include:\n\n    - Setting the `secure` flag to `True` by default\n    - Setting the `samesite` flag to `Lax` by default\n\n    Args:\n        key (str): The key (name) of the cookie.\n        value (str): The value of the cookie.\n        path (str, optional): The path for the cookie. Defaults to \"/\".\n        domain (Optional[str], optional): The domain for the cookie.\n            Defaults to `None`.\n        secure (bool, optional): Whether the cookie is secure.\n            Defaults to `True`.\n        max_age (Optional[int], optional): The maximum age of the cookie\n            in seconds. Defaults to `None`.\n        expires (Optional[datetime], optional): The expiration date of the\n            cookie. Defaults to `None`.\n        httponly (bool, optional): HttpOnly flag for the cookie.\n            Defaults to `False`.\n        samesite (Optional[SameSite], optional): The SameSite attribute for\n            the cookie. Defaults to `\"Lax\"`.\n        partitioned (bool, optional): Whether the cookie is partitioned.\n            Defaults to `False`.\n        comment (Optional[str], optional): A comment for the cookie.\n            Defaults to `None`.\n        host_prefix (bool, optional): Whether to use the host prefix.\n            Defaults to `False`.\n        secure_prefix (bool, optional): Whether to use the secure prefix.\n            Defaults to `False`.\n    \"\"\"  # noqa: E501\n\n    HOST_PREFIX = \"__Host-\"\n    SECURE_PREFIX = \"__Secure-\"\n\n    __slots__ = (\n        \"key\",\n        \"value\",\n        \"_path\",\n        \"_comment\",\n        \"_domain\",\n        \"_secure\",\n        \"_httponly\",\n        \"_partitioned\",\n        \"_expires\",\n        \"_max_age\",\n        \"_samesite\",\n    )\n\n    _keys = {\n        \"path\": \"Path\",\n        \"comment\": \"Comment\",\n        \"domain\": \"Domain\",\n        \"max-age\": \"Max-Age\",\n        \"expires\": \"expires\",\n        \"samesite\": \"SameSite\",\n        # \"version\": \"Version\",\n        \"secure\": \"Secure\",\n        \"httponly\": \"HttpOnly\",\n        \"partitioned\": \"Partitioned\",\n    }\n    _flags = {\"secure\", \"httponly\", \"partitioned\"}"
    },
    {
      "chunk_id": 387,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def __init__(\n        self,\n        key: str,\n        value: str,\n        *,\n        path: str = \"/\",\n        domain: str | None = None,\n        secure: bool = True,\n        max_age: int | None = None,\n        expires: datetime | None = None,\n        httponly: bool = False,\n        samesite: SameSite | None = \"Lax\",\n        partitioned: bool = False,\n        comment: str | None = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ):\n        if key in self._keys:\n            raise KeyError(\"Cookie name is a reserved word\")\n        if not _is_legal_key(key):\n            raise KeyError(\"Cookie key contains illegal characters\")\n        if host_prefix:\n            if not secure:\n                raise ServerError(\n                    \"Cannot set host_prefix on a cookie without secure=True\"\n                )\n            if path != \"/\":\n                raise ServerError(\n                    \"Cannot set host_prefix on a cookie unless path='/'\"\n                )\n            if domain:\n                raise ServerError(\n                    \"Cannot set host_prefix on a cookie with a defined domain\"\n                )\n        elif secure_prefix and not secure:\n            raise ServerError(\n                \"Cannot set secure_prefix on a cookie without secure=True\"\n            )\n        if partitioned and not host_prefix:\n            # This is technically possible, but it is not advisable so we will\n            # take a stand and say \"don't shoot yourself in the foot\"\n            raise ServerError(\n                \"Cannot create a partitioned cookie without \"\n                \"also setting host_prefix=True\"\n            )\n\n        self.key = self.make_key(key, host_prefix, secure_prefix)\n        self.value = value\n\n        self._path = path\n        self._comment = comment\n        self._domain = domain\n        self._secure = secure\n        self._httponly = httponly\n        self._partitioned = partitioned\n        self._expires = None\n        self._max_age = None\n        self._samesite = None\n\n        if expires is not None:\n            self.expires = expires\n        if max_age is not None:\n            self.max_age = max_age\n        if samesite is not None:\n            self.samesite = samesite"
    },
    {
      "chunk_id": 388,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "def __str__(self):\n        \"\"\"Format as a Set-Cookie header value.\"\"\"\n        output = [\"{}={}\".format(self.key, _quote(self.value))]\n        ordered_keys = list(self._keys.keys())\n        for key in sorted(\n            self._keys.keys(), key=lambda k: ordered_keys.index(k)\n        ):\n            value = getattr(self, key.replace(\"-\", \"_\"))\n            if value is not None and value is not False:\n                if key == \"max-age\":\n                    try:\n                        output.append(\"%s=%d\" % (self._keys[key], value))\n                    except TypeError:\n                        output.append(\"{}={}\".format(self._keys[key], value))\n                elif key == \"expires\":\n                    output.append(\n                        \"%s=%s\"\n                        % (\n                            self._keys[key],\n                            value.strftime(\"%a, %d-%b-%Y %T GMT\"),\n                        )\n                    )\n                elif key in self._flags:\n                    output.append(self._keys[key])\n                else:\n                    output.append(\"{}={}\".format(self._keys[key], value))\n\n        return \"; \".join(output)"
    },
    {
      "chunk_id": 389,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def path(self) -> str:  # no cov\n        \"\"\"The path of the cookie. Defaults to `\"/\"`.\"\"\"\n        return self._path\n\n    @path.setter\n    def path(self, value: str) -> None:  # no cov\n        self._path = value"
    },
    {
      "chunk_id": 390,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def expires(self) -> datetime | None:  # no cov\n        \"\"\"The expiration date of the cookie. Defaults to `None`.\"\"\"\n        return self._expires\n\n    @expires.setter\n    def expires(self, value: datetime) -> None:  # no cov\n        if not isinstance(value, datetime):\n            raise TypeError(\"Cookie 'expires' property must be a datetime\")\n        self._expires = value"
    },
    {
      "chunk_id": 391,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def comment(self) -> str | None:  # no cov\n        \"\"\"A comment for the cookie. Defaults to `None`.\"\"\"\n        return self._comment\n\n    @comment.setter\n    def comment(self, value: str) -> None:  # no cov\n        self._comment = value"
    },
    {
      "chunk_id": 392,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def domain(self) -> str | None:  # no cov\n        \"\"\"The domain of the cookie. Defaults to `None`.\"\"\"\n        return self._domain\n\n    @domain.setter\n    def domain(self, value: str) -> None:  # no cov\n        self._domain = value"
    },
    {
      "chunk_id": 393,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def max_age(self) -> int | None:  # no cov\n        \"\"\"The maximum age of the cookie in seconds. Defaults to `None`.\"\"\"\n        return self._max_age\n\n    @max_age.setter\n    def max_age(self, value: int) -> None:  # no cov\n        if not str(value).isdigit():\n            raise ValueError(\"Cookie max-age must be an integer\")\n        self._max_age = value"
    },
    {
      "chunk_id": 394,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def secure(self) -> bool:  # no cov\n        \"\"\"Whether the cookie is secure. Defaults to `True`.\"\"\"\n        return self._secure\n\n    @secure.setter\n    def secure(self, value: bool) -> None:  # no cov\n        self._secure = value"
    },
    {
      "chunk_id": 395,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def httponly(self) -> bool:  # no cov\n        \"\"\"Whether the cookie is HTTP only. Defaults to `False`.\"\"\"\n        return self._httponly\n\n    @httponly.setter\n    def httponly(self, value: bool) -> None:  # no cov\n        self._httponly = value"
    },
    {
      "chunk_id": 396,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def samesite(self) -> SameSite | None:  # no cov\n        \"\"\"The SameSite attribute for the cookie. Defaults to `\"Lax\"`.\"\"\"\n        return self._samesite\n\n    @samesite.setter\n    def samesite(self, value: SameSite) -> None:  # no cov\n        if value.lower() not in SAMESITE_VALUES:\n            raise TypeError(\n                \"Cookie 'samesite' property must \"\n                f\"be one of: {','.join(SAMESITE_VALUES)}\"\n            )\n        self._samesite = value.title()"
    },
    {
      "chunk_id": 397,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@property\n    def partitioned(self) -> bool:  # no cov\n        \"\"\"Whether the cookie is partitioned. Defaults to `False`.\"\"\"\n        return self._partitioned\n\n    @partitioned.setter\n    def partitioned(self, value: bool) -> None:  # no cov\n        self._partitioned = value"
    },
    {
      "chunk_id": 398,
      "source": "__internal__/data_repo/sanic/sanic/cookies/response.py",
      "content": "@classmethod\n    def make_key(\n        cls, key: str, host_prefix: bool = False, secure_prefix: bool = False\n    ) -> str:\n        \"\"\"Create a cookie key with the appropriate prefix.\n\n        Cookies can have one ow two prefixes. The first is `__Host-` which\n        requires that the cookie be set with `path=\"/\", domain=None, and\n        secure=True`. The second is `__Secure-` which requires that\n        `secure=True`.\n\n        They cannot be combined.\n\n        Args:\n            key (str): The key (name) of the cookie.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key.\n                This requires that path=\"/\", domain=None, and secure=True.\n                Defaults to `False`.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key.\n                This requires that secure=True. Defaults to `False`.\n\n        Raises:\n            ServerError: If both host_prefix and secure_prefix are set.\n\n        Returns:\n            str: The key with the appropriate prefix.\n        \"\"\"  # noqa: E501\n        if host_prefix and secure_prefix:\n            raise ServerError(\n                \"Both host_prefix and secure_prefix were requested. \"\n                \"A cookie should have only one prefix.\"\n            )\n        elif host_prefix:\n            key = cls.HOST_PREFIX + key\n        elif secure_prefix:\n            key = cls.SECURE_PREFIX + key\n        return key"
    },
    {
      "chunk_id": 399,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "import re\n\nfrom typing import Any, Optional\n\nfrom sanic.cookies.response import Cookie\nfrom sanic.request.parameters import RequestParameters"
    },
    {
      "chunk_id": 400,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "COOKIE_NAME_RESERVED_CHARS = re.compile(\n    '[\\x00-\\x1f\\x7f-\\xff()<>@,;:\\\\\\\\\"/[\\\\]?={} \\x09]'\n)\nOCTAL_PATTERN = re.compile(r\"\\\\[0-3][0-7][0-7]\")\nQUOTE_PATTERN = re.compile(r\"[\\\\].\")"
    },
    {
      "chunk_id": 401,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def _unquote(str):  # no cov\n    if str is None or len(str) < 2:\n        return str\n    if str[0] != '\"' or str[-1] != '\"':\n        return str\n\n    str = str[1:-1]\n\n    i = 0\n    n = len(str)\n    res = []\n    while 0 <= i < n:\n        o_match = OCTAL_PATTERN.search(str, i)\n        q_match = QUOTE_PATTERN.search(str, i)\n        if not o_match and not q_match:\n            res.append(str[i:])\n            break\n        # else:\n        j = k = -1\n        if o_match:\n            j = o_match.start(0)\n        if q_match:\n            k = q_match.start(0)\n        if q_match and (not o_match or k < j):\n            res.append(str[i:k])\n            res.append(str[k + 1])\n            i = k + 2\n        else:\n            res.append(str[i:j])\n            res.append(chr(int(str[j + 1 : j + 4], 8)))  # noqa: E203\n            i = j + 4\n    return \"\".join(res)"
    },
    {
      "chunk_id": 402,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def parse_cookie(raw: str) -> dict[str, list[str]]:\n    \"\"\"Parses a raw cookie string into a dictionary.\n\n    The function takes a raw cookie string (usually from HTTP headers) and\n    returns a dictionary where each key is a cookie name and the value is a\n    list of values for that cookie. The function handles quoted values and\n    skips invalid cookie names.\n\n    Args:\n        raw (str): The raw cookie string to be parsed.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary containing the cookie names as keys\n        and a list of values for each cookie.\n\n    Example:\n        ```python\n        raw = 'name1=value1; name2=\"value2\"; name3=value3'\n        cookies = parse_cookie(raw)\n        # cookies will be {'name1': ['value1'], 'name2': ['value2'], 'name3': ['value3']}\n        ```\n    \"\"\"  # noqa: E501\n    cookies: dict[str, list[str]] = {}\n\n    for token in raw.split(\";\"):\n        name, sep, value = token.partition(\"=\")\n        name = name.strip()\n        value = value.strip()\n\n        # Support cookies =value or plain value with no name\n        # https://github.com/httpwg/http-extensions/issues/159\n        if not sep:\n            if not name:\n                # Empty value like ;; or a cookie header with no value\n                continue\n            name, value = \"\", name\n\n        if COOKIE_NAME_RESERVED_CHARS.search(name):  # no cov\n            continue\n\n        if len(value) > 2 and value[0] == '\"' and value[-1] == '\"':  # no cov\n            value = _unquote(value)\n\n        if name in cookies:\n            cookies[name].append(value)\n        else:\n            cookies[name] = [value]\n\n    return cookies"
    },
    {
      "chunk_id": 403,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "class CookieRequestParameters(RequestParameters):\n    \"\"\"A container for accessing single and multiple cookie values.\n\n    Because the HTTP standard allows for multiple cookies with the same name,\n    a standard dictionary cannot be used to access cookie values. This class\n    provides a way to access cookie values in a way that is similar to a\n    dictionary, but also allows for accessing multiple values for a single\n    cookie name when necessary.\n\n    Args:\n        cookies (Dict[str, List[str]]): A dictionary containing the cookie\n            names as keys and a list of values for each cookie.\n\n    Example:\n        ```python\n        raw = 'name1=value1; name2=\"value2\"; name3=value3'\n        cookies = parse_cookie(raw)\n        # cookies will be {'name1': ['value1'], 'name2': ['value2'], 'name3': ['value3']}\n\n        request_cookies = CookieRequestParameters(cookies)\n        request_cookies['name1']  # 'value1'\n        request_cookies.get('name1')  # 'value1'\n        request_cookies.getlist('name1')  # ['value1']\n        ```\n    \"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 404,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def __getitem__(self, key: str) -> Optional[str]:\n        try:\n            value = self._get_prefixed_cookie(key)\n        except KeyError:\n            value = super().__getitem__(key)\n        return value"
    },
    {
      "chunk_id": 405,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def __getattr__(self, key: str) -> str:\n        if key.startswith(\"_\"):\n            return self.__getattribute__(key)\n        key = key.rstrip(\"_\").replace(\"_\", \"-\")\n        return str(self.get(key, \"\"))"
    },
    {
      "chunk_id": 406,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:\n        try:\n            return self._get_prefixed_cookie(name)[0]\n        except KeyError:\n            return super().get(name, default)"
    },
    {
      "chunk_id": 407,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def getlist(\n        self, name: str, default: Optional[list[Any]] = None\n    ) -> list[Any]:\n        try:\n            return self._get_prefixed_cookie(name)\n        except KeyError:\n            return super().getlist(name, default)"
    },
    {
      "chunk_id": 408,
      "source": "__internal__/data_repo/sanic/sanic/cookies/request.py",
      "content": "def _get_prefixed_cookie(self, name: str) -> Any:\n        getitem = super().__getitem__\n        try:\n            return getitem(f\"{Cookie.HOST_PREFIX}{name}\")\n        except KeyError:\n            return getitem(f\"{Cookie.SECURE_PREFIX}{name}\")"
    },
    {
      "chunk_id": 409,
      "source": "__internal__/data_repo/sanic/sanic/response/__init__.py",
      "content": "from .convenience import (\n    empty,\n    file,\n    file_stream,\n    html,\n    json,\n    raw,\n    redirect,\n    text,\n    validate_file,\n)\nfrom .types import (\n    BaseHTTPResponse,\n    HTTPResponse,\n    JSONResponse,\n    ResponseStream,\n    json_dumps,\n)"
    },
    {
      "chunk_id": 410,
      "source": "__internal__/data_repo/sanic/sanic/response/__init__.py",
      "content": "__all__ = (\n    \"BaseHTTPResponse\",\n    \"HTTPResponse\",\n    \"JSONResponse\",\n    \"ResponseStream\",\n    \"empty\",\n    \"json\",\n    \"text\",\n    \"raw\",\n    \"html\",\n    \"validate_file\",\n    \"file\",\n    \"redirect\",\n    \"file_stream\",\n    \"json_dumps\",\n)"
    },
    {
      "chunk_id": 411,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Coroutine, Iterator\nfrom datetime import datetime\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    AnyStr,\n    Callable,\n    Optional,\n    TypeVar,\n    Union,\n)\n\nfrom sanic.compat import Header\nfrom sanic.cookies import CookieJar\nfrom sanic.cookies.response import Cookie, SameSite\nfrom sanic.exceptions import SanicException, ServerError\nfrom sanic.helpers import Default, _default, has_message_body, json_dumps\nfrom sanic.http import Http\n\n\nif TYPE_CHECKING:\n    from sanic.asgi import ASGIApp\n    from sanic.http.http3 import HTTPReceiver\n    from sanic.request import Request\nelse:\n    Request = TypeVar(\"Request\")"
    },
    {
      "chunk_id": 412,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "class BaseHTTPResponse:\n    \"\"\"The base class for all HTTP Responses\"\"\"\n\n    __slots__ = (\n        \"asgi\",\n        \"body\",\n        \"content_type\",\n        \"stream\",\n        \"status\",\n        \"headers\",\n        \"_cookies\",\n    )\n\n    _dumps = json_dumps\n\n    def __init__(self):\n        self.asgi: bool = False\n        self.body: Optional[bytes] = None\n        self.content_type: Optional[str] = None\n        self.stream: Optional[Union[Http, ASGIApp, HTTPReceiver]] = None\n        self.status: int = None\n        self.headers = Header({})\n        self._cookies: Optional[CookieJar] = None"
    },
    {
      "chunk_id": 413,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def __repr__(self):\n        class_name = self.__class__.__name__\n        return f\"<{class_name}: {self.status} {self.content_type}>\""
    },
    {
      "chunk_id": 414,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def _encode_body(self, data: Optional[str | bytes]):\n        if data is None:\n            return b\"\"\n        return data.encode() if hasattr(data, \"encode\") else data  # type: ignore"
    },
    {
      "chunk_id": 415,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def cookies(self) -> CookieJar:\n        \"\"\"The response cookies.\n\n        See [Cookies](/en/guide/basics/cookies.html)\n\n        Returns:\n            CookieJar: The response cookies\n        \"\"\"\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies"
    },
    {
      "chunk_id": 416,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def processed_headers(self) -> Iterator[tuple[bytes, bytes]]:\n        \"\"\"Obtain a list of header tuples encoded in bytes for sending.\n\n        Add and remove headers based on status and content_type.\n\n        Returns:\n            Iterator[Tuple[bytes, bytes]]: A list of header tuples encoded in bytes for sending\n        \"\"\"  # noqa: E501\n        if has_message_body(self.status):\n            self.headers.setdefault(\"content-type\", self.content_type)\n        # Encode headers into bytes\n        return (\n            (name.encode(\"ascii\"), f\"{value}\".encode(errors=\"surrogateescape\"))\n            for name, value in self.headers.items()\n        )"
    },
    {
      "chunk_id": 417,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def send(\n        self,\n        data: Optional[AnyStr] = None,\n        end_stream: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Send any pending response headers and the given data as body.\n\n        Args:\n            data (Optional[AnyStr], optional): str or bytes to be written. Defaults to `None`.\n            end_stream (Optional[bool], optional): whether to close the stream after this block. Defaults to `None`.\n        \"\"\"  # noqa: E501\n        if data is None and end_stream is None:\n            end_stream = True\n        if self.stream is None:\n            raise SanicException(\n                \"No stream is connected to the response object instance.\"\n            )\n        if self.stream.send is None:\n            if end_stream and not data:\n                return\n            raise ServerError(\n                \"Response stream was ended, no more response data is \"\n                \"allowed to be sent.\"\n            )\n        data = data.encode() if hasattr(data, \"encode\") else data or b\"\"  # type: ignore\n        await self.stream.send(\n            data,  # type: ignore\n            end_stream=end_stream or False,\n        )"
    },
    {
      "chunk_id": 418,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def add_cookie(\n        self,\n        key: str,\n        value: str,\n        *,\n        path: str = \"/\",\n        domain: Optional[str] = None,\n        secure: bool = True,\n        max_age: Optional[int] = None,\n        expires: Optional[datetime] = None,\n        httponly: bool = False,\n        samesite: Optional[SameSite] = \"Lax\",\n        partitioned: bool = False,\n        comment: Optional[str] = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> Cookie:\n        \"\"\"Add a cookie to the CookieJar\n\n        See [Cookies](/en/guide/basics/cookies.html)\n\n        Args:\n            key (str): The key to be added\n            value (str): The value to be added\n            path (str, optional): Path of the cookie. Defaults to `\"/\"`.\n            domain (Optional[str], optional): Domain of the cookie. Defaults to `None`.\n            secure (bool, optional): Whether the cookie is secure. Defaults to `True`.\n            max_age (Optional[int], optional): Max age of the cookie. Defaults to `None`.\n            expires (Optional[datetime], optional): Expiry date of the cookie. Defaults to `None`.\n            httponly (bool, optional): Whether the cookie is http only. Defaults to `False`.\n            samesite (Optional[SameSite], optional): SameSite policy of the cookie. Defaults to `\"Lax\"`.\n            partitioned (bool, optional): Whether the cookie is partitioned. Defaults to `False`.\n            comment (Optional[str], optional): Comment of the cookie. Defaults to `None`.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key. This requires that path=\"/\", domain=None, and secure=True. Defaults to `False`.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key. This requires that secure=True. Defaults to `False`.\n\n        Returns:\n            Cookie: The cookie that was added\n        \"\"\"  # noqa: E501\n        return self.cookies.add_cookie(\n            key=key,\n            value=value,\n            path=path,\n            domain=domain,\n            secure=secure,\n            max_age=max_age,\n            expires=expires,\n            httponly=httponly,\n            samesite=samesite,\n            partitioned=partitioned,\n            comment=comment,\n            host_prefix=host_prefix,\n            secure_prefix=secure_prefix,\n        )"
    },
    {
      "chunk_id": 419,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def delete_cookie(\n        self,\n        key: str,\n        *,\n        path: str = \"/\",\n        domain: Optional[str] = None,\n        host_prefix: bool = False,\n        secure_prefix: bool = False,\n    ) -> None:\n        \"\"\"Delete a cookie\n\n        This will effectively set it as Max-Age: 0, which a browser should\n        interpret it to mean: \"delete the cookie\".\n\n        Since it is a browser/client implementation, your results may vary\n        depending upon which client is being used.\n\n        See [Cookies](/en/guide/basics/cookies.html)\n\n        Args:\n            key (str): The key to be deleted\n            path (str, optional): Path of the cookie. Defaults to `\"/\"`.\n            domain (Optional[str], optional): Domain of the cookie. Defaults to `None`.\n            host_prefix (bool, optional): Whether to add __Host- as a prefix to the key. This requires that path=\"/\", domain=None, and secure=True. Defaults to `False`.\n            secure_prefix (bool, optional): Whether to add __Secure- as a prefix to the key. This requires that secure=True. Defaults to `False`.\n        \"\"\"  # noqa: E501\n        self.cookies.delete_cookie(\n            key=key,\n            path=path,\n            domain=domain,\n            host_prefix=host_prefix,\n            secure_prefix=secure_prefix,\n        )"
    },
    {
      "chunk_id": 420,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "class HTTPResponse(BaseHTTPResponse):\n    \"\"\"HTTP response to be sent back to the client.\n\n    Args:\n        body (Optional[Any], optional): The body content to be returned. Defaults to `None`.\n        status (int, optional): HTTP response number. Defaults to `200`.\n        headers (Optional[Union[Header, Dict[str, str]]], optional): Headers to be returned. Defaults to `None`.\n        content_type (Optional[str], optional): Content type to be returned (as a header). Defaults to `None`.\n    \"\"\"  # noqa: E501\n\n    __slots__ = ()\n\n    def __init__(\n        self,\n        body: Optional[Any] = None,\n        status: int = 200,\n        headers: Optional[Union[Header, dict[str, str]]] = None,\n        content_type: Optional[str] = None,\n    ):\n        super().__init__()\n\n        self.content_type: Optional[str] = content_type\n        self.body = self._encode_body(body)\n        self.status = status\n        self.headers = Header(headers or {})\n        self._cookies = None"
    },
    {
      "chunk_id": 421,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def eof(self):\n        \"\"\"Send a EOF (End of File) message to the client.\"\"\"\n        await self.send(\"\", True)"
    },
    {
      "chunk_id": 422,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def __aenter__(self):\n        return self.send"
    },
    {
      "chunk_id": 423,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def __aexit__(self, *_):\n        await self.eof()"
    },
    {
      "chunk_id": 424,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "class JSONResponse(HTTPResponse):\n    \"\"\"Convenience class for JSON responses\n\n    HTTP response to be sent back to the client, when the response\n    is of json type. Offers several utilities to manipulate common\n    json data types.\n\n    Args:\n        body (Optional[Any], optional): The body content to be returned. Defaults to `None`.\n        status (int, optional): HTTP response number. Defaults to `200`.\n        headers (Optional[Union[Header, Dict[str, str]]], optional): Headers to be returned. Defaults to `None`.\n        content_type (str, optional): Content type to be returned (as a header). Defaults to `\"application/json\"`.\n        dumps (Optional[Callable[..., AnyStr]], optional): The function to use for json encoding. Defaults to `None`.\n        **kwargs (Any, optional): The kwargs to pass to the json encoding function. Defaults to `{}`.\n    \"\"\"  # noqa: E501\n\n    __slots__ = (\n        \"_body\",\n        \"_body_manually_set\",\n        \"_initialized\",\n        \"_raw_body\",\n        \"_use_dumps\",\n        \"_use_dumps_kwargs\",\n    )\n\n    def __init__(\n        self,\n        body: Optional[Any] = None,\n        status: int = 200,\n        headers: Optional[Union[Header, dict[str, str]]] = None,\n        content_type: str = \"application/json\",\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        **kwargs: Any,\n    ):\n        self._initialized = False\n        self._body_manually_set = False\n\n        self._use_dumps: Callable[..., str | bytes] = (\n            dumps or BaseHTTPResponse._dumps\n        )\n        self._use_dumps_kwargs = kwargs\n\n        self._raw_body = body\n\n        super().__init__(\n            self._encode_body(self._use_dumps(body, **self._use_dumps_kwargs)),\n            headers=headers,\n            status=status,\n            content_type=content_type,\n        )\n\n        self._initialized = True"
    },
    {
      "chunk_id": 425,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def _check_body_not_manually_set(self):\n        if self._body_manually_set:\n            raise SanicException(\n                \"Cannot use raw_body after body has been manually set.\"\n            )"
    },
    {
      "chunk_id": 426,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def raw_body(self) -> Optional[Any]:\n        \"\"\"Returns the raw body, as long as body has not been manually set previously.\n\n        NOTE: This object should not be mutated, as it will not be\n        reflected in the response body. If you need to mutate the\n        response body, consider using one of the provided methods in\n        this class or alternatively call set_body() with the mutated\n        object afterwards or set the raw_body property to it.\n\n        Returns:\n            Optional[Any]: The raw body\n        \"\"\"  # noqa: E501\n        self._check_body_not_manually_set()\n        return self._raw_body"
    },
    {
      "chunk_id": 427,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@raw_body.setter\n    def raw_body(self, value: Any):\n        self._body_manually_set = False\n        self._body = self._encode_body(\n            self._use_dumps(value, **self._use_dumps_kwargs)\n        )\n        self._raw_body = value"
    },
    {
      "chunk_id": 428,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property  # type: ignore\n    def body(self) -> Optional[bytes]:  # type: ignore\n        \"\"\"Returns the response body.\n\n        Returns:\n            Optional[bytes]: The response body\n        \"\"\"\n        return self._body"
    },
    {
      "chunk_id": 429,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@body.setter\n    def body(self, value: Optional[bytes]):\n        self._body = value\n        if not self._initialized:\n            return\n        self._body_manually_set = True"
    },
    {
      "chunk_id": 430,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def set_body(\n        self,\n        body: Any,\n        dumps: Optional[Callable[..., AnyStr]] = None,\n        **dumps_kwargs: Any,\n    ) -> None:\n        \"\"\"Set the response body to the given value, using the given dumps function\n\n        Sets a new response body using the given dumps function\n        and kwargs, or falling back to the defaults given when\n        creating the object if none are specified.\n\n        Args:\n            body (Any): The body to set\n            dumps (Optional[Callable[..., AnyStr]], optional): The function to use for json encoding. Defaults to `None`.\n            **dumps_kwargs (Any, optional): The kwargs to pass to the json encoding function. Defaults to `{}`.\n\n        Examples:\n            ```python\n            response = JSONResponse({\"foo\": \"bar\"})\n            response.set_body({\"bar\": \"baz\"})\n            assert response.body == b'{\"bar\": \"baz\"}'\n            ```\n        \"\"\"  # noqa: E501\n        self._body_manually_set = False\n        self._raw_body = body\n\n        use_dumps = dumps or self._use_dumps\n        use_dumps_kwargs = dumps_kwargs if dumps else self._use_dumps_kwargs\n\n        self._body = self._encode_body(use_dumps(body, **use_dumps_kwargs))"
    },
    {
      "chunk_id": 431,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def append(self, value: Any) -> None:\n        \"\"\"Appends a value to the response raw_body, ensuring that body is kept up to date.\n\n        This can only be used if raw_body is a list.\n\n        Args:\n            value (Any): The value to append\n\n        Raises:\n            SanicException: If the body is not a list\n        \"\"\"  # noqa: E501\n\n        self._check_body_not_manually_set()\n\n        if not isinstance(self._raw_body, list):\n            raise SanicException(\"Cannot append to a non-list object.\")\n\n        self._raw_body.append(value)\n        self.raw_body = self._raw_body"
    },
    {
      "chunk_id": 432,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def extend(self, value: Any) -> None:\n        \"\"\"Extends the response's raw_body with the given values, ensuring that body is kept up to date.\n\n        This can only be used if raw_body is a list.\n\n        Args:\n            value (Any): The values to extend with\n\n        Raises:\n            SanicException: If the body is not a list\n        \"\"\"  # noqa: E501\n\n        self._check_body_not_manually_set()\n\n        if not isinstance(self._raw_body, list):\n            raise SanicException(\"Cannot extend a non-list object.\")\n\n        self._raw_body.extend(value)\n        self.raw_body = self._raw_body"
    },
    {
      "chunk_id": 433,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def update(self, *args, **kwargs) -> None:\n        \"\"\"Updates the response's raw_body with the given values, ensuring that body is kept up to date.\n\n        This can only be used if raw_body is a dict.\n\n        Args:\n            *args: The args to update with\n            **kwargs: The kwargs to update with\n\n        Raises:\n            SanicException: If the body is not a dict\n        \"\"\"  # noqa: E501\n\n        self._check_body_not_manually_set()\n\n        if not isinstance(self._raw_body, dict):\n            raise SanicException(\"Cannot update a non-dict object.\")\n\n        self._raw_body.update(*args, **kwargs)\n        self.raw_body = self._raw_body"
    },
    {
      "chunk_id": 434,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def pop(self, key: Any, default: Any = _default) -> Any:\n        \"\"\"Pops a key from the response's raw_body, ensuring that body is kept up to date.\n\n        This can only be used if raw_body is a dict or a list.\n\n        Args:\n            key (Any): The key to pop\n            default (Any, optional): The default value to return if the key is not found. Defaults to `_default`.\n\n        Raises:\n            SanicException: If the body is not a dict or a list\n            TypeError: If the body is a list and a default value is provided\n\n        Returns:\n            Any: The value that was popped\n        \"\"\"  # noqa: E501\n\n        self._check_body_not_manually_set()\n\n        if not isinstance(self._raw_body, (list, dict)):\n            raise SanicException(\n                \"Cannot pop from a non-list and non-dict object.\"\n            )\n\n        if isinstance(default, Default):\n            value = self._raw_body.pop(key)\n        elif isinstance(self._raw_body, list):\n            raise TypeError(\"pop doesn't accept a default argument for lists\")\n        else:\n            value = self._raw_body.pop(key, default)\n\n        self.raw_body = self._raw_body\n\n        return value"
    },
    {
      "chunk_id": 435,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "class ResponseStream:\n    \"\"\"A compat layer to bridge the gap after the deprecation of StreamingHTTPResponse.\n\n    It will be removed when:\n    - file_stream is moved to new style streaming\n    - file and file_stream are combined into a single API\n    \"\"\"  # noqa: E501\n\n    __slots__ = (\n        \"_cookies\",\n        \"content_type\",\n        \"headers\",\n        \"request\",\n        \"response\",\n        \"status\",\n        \"streaming_fn\",\n    )\n\n    def __init__(\n        self,\n        streaming_fn: Callable[\n            [Union[BaseHTTPResponse, ResponseStream]],\n            Coroutine[Any, Any, None],\n        ],\n        status: int = 200,\n        headers: Optional[Union[Header, dict[str, str]]] = None,\n        content_type: Optional[str] = None,\n    ):\n        if headers is None:\n            headers = Header()\n        elif not isinstance(headers, Header):\n            headers = Header(headers)\n        self.streaming_fn = streaming_fn\n        self.status = status\n        self.headers = headers or Header()\n        self.content_type = content_type\n        self.request: Optional[Request] = None\n        self._cookies: Optional[CookieJar] = None"
    },
    {
      "chunk_id": 436,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def write(self, message: str):\n        await self.response.send(message)"
    },
    {
      "chunk_id": 437,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def stream(self) -> HTTPResponse:\n        if not self.request:\n            raise ServerError(\"Attempted response to unknown request\")\n        self.response = await self.request.respond(\n            headers=self.headers,\n            status=self.status,\n            content_type=self.content_type,\n        )\n        await self.streaming_fn(self)\n        return self.response"
    },
    {
      "chunk_id": 438,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "async def eof(self) -> None:\n        await self.response.eof()"
    },
    {
      "chunk_id": 439,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def cookies(self) -> CookieJar:\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies"
    },
    {
      "chunk_id": 440,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def processed_headers(self):\n        return self.response.processed_headers"
    },
    {
      "chunk_id": 441,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "@property\n    def body(self):\n        return self.response.body"
    },
    {
      "chunk_id": 442,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def __call__(self, request: Request) -> ResponseStream:\n        self.request = request\n        return self"
    },
    {
      "chunk_id": 443,
      "source": "__internal__/data_repo/sanic/sanic/response/types.py",
      "content": "def __await__(self):\n        return self.stream().__await__()"
    },
    {
      "chunk_id": 444,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "from __future__ import annotations\n\nfrom datetime import datetime, timezone\nfrom email.utils import formatdate, parsedate_to_datetime\nfrom mimetypes import guess_type\nfrom os import path\nfrom pathlib import PurePath\nfrom time import time\nfrom typing import Any, AnyStr, Callable, Optional, Union\nfrom urllib.parse import quote_plus\n\nfrom sanic.compat import Header, open_async, stat_async\nfrom sanic.constants import DEFAULT_HTTP_CONTENT_TYPE\nfrom sanic.helpers import Default, _default\nfrom sanic.log import logger\nfrom sanic.models.protocol_types import HTMLProtocol, Range\n\nfrom .types import HTTPResponse, JSONResponse, ResponseStream"
    },
    {
      "chunk_id": 445,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def empty(\n    status: int = 204, headers: Optional[dict[str, str]] = None\n) -> HTTPResponse:\n    \"\"\"Returns an empty response to the client.\n\n    Args:\n        status (int, optional): HTTP response code. Defaults to `204`.\n        headers ([type], optional): Custom HTTP headers. Defaults to `None`.\n\n    Returns:\n        HTTPResponse: An empty response to the client.\n    \"\"\"\n    return HTTPResponse(body=b\"\", status=status, headers=headers)"
    },
    {
      "chunk_id": 446,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def json(\n    body: Any,\n    status: int = 200,\n    headers: Optional[dict[str, str]] = None,\n    content_type: str = \"application/json\",\n    dumps: Optional[Callable[..., AnyStr]] = None,\n    **kwargs: Any,\n) -> JSONResponse:\n    \"\"\"Returns response object with body in json format.\n\n    Args:\n        body (Any): Response data to be serialized.\n        status (int, optional): HTTP response code. Defaults to `200`.\n        headers (Dict[str, str], optional): Custom HTTP headers. Defaults to `None`.\n        content_type (str, optional): The content type (string) of the response. Defaults to `\"application/json\"`.\n        dumps (Callable[..., AnyStr], optional): A custom json dumps function. Defaults to `None`.\n        **kwargs (Any): Remaining arguments that are passed to the json encoder.\n\n    Returns:\n        JSONResponse: A response object with body in json format.\n    \"\"\"  # noqa: E501\n    return JSONResponse(\n        body,\n        status=status,\n        headers=headers,\n        content_type=content_type,\n        dumps=dumps,\n        **kwargs,\n    )"
    },
    {
      "chunk_id": 447,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def text(\n    body: str,\n    status: int = 200,\n    headers: Optional[dict[str, str]] = None,\n    content_type: str = \"text/plain; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"Returns response object with body in text format.\n\n    Args:\n        body (str): Response data.\n        status (int, optional): HTTP response code. Defaults to `200`.\n        headers (Dict[str, str], optional): Custom HTTP headers. Defaults to `None`.\n        content_type (str, optional): The content type (string) of the response. Defaults to `\"text/plain; charset=utf-8\"`.\n\n    Returns:\n        HTTPResponse: A response object with body in text format.\n\n    Raises:\n        TypeError: If the body is not a string.\n    \"\"\"  # noqa: E501\n    if not isinstance(body, str):\n        raise TypeError(\n            f\"Bad body type. Expected str, got {type(body).__name__})\"\n        )\n\n    return HTTPResponse(\n        body, status=status, headers=headers, content_type=content_type\n    )"
    },
    {
      "chunk_id": 448,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def raw(\n    body: Optional[AnyStr],\n    status: int = 200,\n    headers: Optional[dict[str, str]] = None,\n    content_type: str = DEFAULT_HTTP_CONTENT_TYPE,\n) -> HTTPResponse:\n    \"\"\"Returns response object without encoding the body.\n\n    Args:\n        body (Optional[AnyStr]): Response data.\n        status (int, optional): HTTP response code. Defaults to `200`.\n        headers (Dict[str, str], optional): Custom HTTP headers. Defaults to `None`.\n        content_type (str, optional): The content type (string) of the response. Defaults to `\"application/octet-stream\"`.\n\n    Returns:\n        HTTPResponse: A response object without encoding the body.\n    \"\"\"  # noqa: E501\n    return HTTPResponse(\n        body=body,\n        status=status,\n        headers=headers,\n        content_type=content_type,\n    )"
    },
    {
      "chunk_id": 449,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def html(\n    body: Union[str, bytes, HTMLProtocol],\n    status: int = 200,\n    headers: Optional[dict[str, str]] = None,\n) -> HTTPResponse:\n    \"\"\"Returns response object with body in html format.\n\n    Body should be a `str` or `bytes` like object, or an object with `__html__` or `_repr_html_`.\n\n    Args:\n        body (Union[str, bytes, HTMLProtocol]): Response data.\n        status (int, optional): HTTP response code. Defaults to `200`.\n        headers (Dict[str, str], optional): Custom HTTP headers. Defaults to `None`.\n\n    Returns:\n        HTTPResponse: A response object with body in html format.\n    \"\"\"  # noqa: E501\n    if not isinstance(body, (str, bytes)):\n        if hasattr(body, \"__html__\"):\n            body = body.__html__()\n        elif hasattr(body, \"_repr_html_\"):\n            body = body._repr_html_()\n\n    return HTTPResponse(\n        body,\n        status=status,\n        headers=headers,\n        content_type=\"text/html; charset=utf-8\",\n    )"
    },
    {
      "chunk_id": 450,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "async def validate_file(\n    request_headers: Header, last_modified: Union[datetime, float, int]\n) -> Optional[HTTPResponse]:\n    \"\"\"Validate file based on request headers.\n\n    Args:\n        request_headers (Header): The request headers.\n        last_modified (Union[datetime, float, int]): The last modified date and time of the file.\n\n    Returns:\n        Optional[HTTPResponse]: A response object with status 304 if the file is not modified.\n    \"\"\"  # noqa: E501\n    try:\n        if_modified_since = request_headers.getone(\"If-Modified-Since\")\n    except KeyError:\n        return None\n    try:\n        if_modified_since = parsedate_to_datetime(if_modified_since)\n    except (TypeError, ValueError):\n        logger.warning(\n            \"Ignorning invalid If-Modified-Since header received: \" \"'%s'\",\n            if_modified_since,\n        )\n        return None\n    if not isinstance(last_modified, datetime):\n        last_modified = datetime.fromtimestamp(\n            float(last_modified), tz=timezone.utc\n        ).replace(microsecond=0)\n\n    if (\n        last_modified.utcoffset() is None\n        and if_modified_since.utcoffset() is not None\n    ):\n        logger.warning(\n            \"Cannot compare tz-aware and tz-naive datetimes. To avoid \"\n            \"this conflict Sanic is converting last_modified to UTC.\"\n        )\n        last_modified.replace(tzinfo=timezone.utc)\n    elif (\n        last_modified.utcoffset() is not None\n        and if_modified_since.utcoffset() is None\n    ):\n        logger.warning(\n            \"Cannot compare tz-aware and tz-naive datetimes. To avoid \"\n            \"this conflict Sanic is converting if_modified_since to UTC.\"\n        )\n        if_modified_since.replace(tzinfo=timezone.utc)\n    if last_modified.timestamp() <= if_modified_since.timestamp():\n        return HTTPResponse(status=304)\n\n    return None"
    },
    {
      "chunk_id": 451,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "async def file(\n    location: Union[str, PurePath],\n    status: int = 200,\n    request_headers: Optional[Header] = None,\n    validate_when_requested: bool = True,\n    mime_type: Optional[str] = None,\n    headers: Optional[dict[str, str]] = None,\n    filename: Optional[str] = None,\n    last_modified: Optional[Union[datetime, float, int, Default]] = _default,\n    max_age: Optional[Union[float, int]] = None,\n    no_store: Optional[bool] = None,\n    _range: Optional[Range] = None,\n) -> HTTPResponse:\n    \"\"\"Return a response object with file data.\n\n    Args:\n        location (Union[str, PurePath]): Location of file on system.\n        status (int, optional): HTTP response code. Won't enforce the passed in status if only a part of the content will be sent (206) or file is being validated (304). Defaults to 200.\n        request_headers (Optional[Header], optional): The request headers.\n        validate_when_requested (bool, optional): If `True`, will validate the file when requested. Defaults to True.\n        mime_type (Optional[str], optional): Specific mime_type.\n        headers (Optional[Dict[str, str]], optional): Custom Headers.\n        filename (Optional[str], optional): Override filename.\n        last_modified (Optional[Union[datetime, float, int, Default]], optional): The last modified date and time of the file.\n        max_age (Optional[Union[float, int]], optional): Max age for cache control.\n        no_store (Optional[bool], optional): Any cache should not store this response. Defaults to None.\n        _range (Optional[Range], optional):\n\n    Returns:\n        HTTPResponse: The response object with the file data.\n    \"\"\"  # noqa: E501\n\n    if isinstance(last_modified, datetime):\n        last_modified = last_modified.replace(microsecond=0).timestamp()\n    elif isinstance(last_modified, Default):\n        stat = await stat_async(location)\n        last_modified = stat.st_mtime\n\n    if (\n        validate_when_requested\n        and request_headers is not None\n        and last_modified\n    ):\n        response = await validate_file(request_headers, last_modified)\n        if response:\n            return response\n\n    headers = headers or {}\n    if last_modified:\n        headers.setdefault(\n            \"Last-Modified\", formatdate(last_modified, usegmt=True)\n        )\n\n    if filename:\n        headers.setdefault(\n            \"Content-Disposition\", f'attachment; filename=\"{filename}\"'\n        )\n\n    if no_store:\n        cache_control = \"no-store\"\n    elif max_age:\n        cache_control = f\"public, max-age={max_age}\"\n        headers.setdefault(\n            \"expires\",\n            formatdate(\n                time() + max_age,\n                usegmt=True,\n            ),\n        )\n    else:\n        cache_control = \"no-cache\"\n\n    headers.setdefault(\"cache-control\", cache_control)\n\n    filename = filename or path.split(location)[-1]\n\n    async with await open_async(location, mode=\"rb\") as f:\n        if _range:\n            await f.seek(_range.start)\n            out_stream = await f.read(_range.size)\n            headers[\"Content-Range\"] = (\n                f\"bytes {_range.start}-{_range.end}/{_range.total}\"\n            )\n            status = 206\n        else:\n            out_stream = await f.read()\n\n    mime_type = mime_type or guess_type(filename)[0] or \"text/plain\"\n    return HTTPResponse(\n        body=out_stream,\n        status=status,\n        headers=headers,\n        content_type=mime_type,\n    )"
    },
    {
      "chunk_id": 452,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "def redirect(\n    to: str,\n    headers: Optional[dict[str, str]] = None,\n    status: int = 302,\n    content_type: str = \"text/html; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"Cause a HTTP redirect (302 by default) by setting a Location header.\n\n    Args:\n        to (str): path or fully qualified URL to redirect to\n        headers (Optional[Dict[str, str]], optional): optional dict of headers to include in the new request. Defaults to None.\n        status (int, optional): status code (int) of the new request, defaults to 302. Defaults to 302.\n        content_type (str, optional): the content type (string) of the response. Defaults to \"text/html; charset=utf-8\".\n\n    Returns:\n        HTTPResponse: A response object with the redirect.\n    \"\"\"  # noqa: E501\n    headers = headers or {}\n\n    # URL Quote the URL before redirecting\n    safe_to = quote_plus(to, safe=\":/%#?&=@[]!$&'()*+,;\")\n\n    # According to RFC 7231, a relative URI is now permitted.\n    headers[\"Location\"] = safe_to\n\n    return HTTPResponse(\n        status=status, headers=headers, content_type=content_type\n    )"
    },
    {
      "chunk_id": 453,
      "source": "__internal__/data_repo/sanic/sanic/response/convenience.py",
      "content": "async def file_stream(\n    location: Union[str, PurePath],\n    status: int = 200,\n    chunk_size: int = 4096,\n    mime_type: Optional[str] = None,\n    headers: Optional[dict[str, str]] = None,\n    filename: Optional[str] = None,\n    _range: Optional[Range] = None,\n) -> ResponseStream:\n    \"\"\"Return a streaming response object with file data.\n\n    :param location: Location of file on system.\n    :param chunk_size: The size of each chunk in the stream (in bytes)\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param filename: Override filename.\n    :param _range:\n\n    Args:\n        location (Union[str, PurePath]): Location of file on system.\n        status (int, optional): HTTP response code. Won't enforce the passed in status if only a part of the content will be sent (206) or file is being validated (304). Defaults to `200`.\n        chunk_size (int, optional): The size of each chunk in the stream (in bytes). Defaults to `4096`.\n        mime_type (Optional[str], optional): Specific mime_type.\n        headers (Optional[Dict[str, str]], optional): Custom HTTP headers.\n        filename (Optional[str], optional): Override filename.\n        _range (Optional[Range], optional): The range of bytes to send.\n    \"\"\"  # noqa: E501\n    headers = headers or {}\n    if filename:\n        headers.setdefault(\n            \"Content-Disposition\", f'attachment; filename=\"{filename}\"'\n        )\n    filename = filename or path.split(location)[-1]\n    mime_type = mime_type or guess_type(filename)[0] or \"text/plain\"\n    if _range:\n        start = _range.start\n        end = _range.end\n        total = _range.total\n\n        headers[\"Content-Range\"] = f\"bytes {start}-{end}/{total}\"\n        status = 206\n\n    async def _streaming_fn(response):\n        async with await open_async(location, mode=\"rb\") as f:\n            if _range:\n                await f.seek(_range.start)\n                to_send = _range.size\n                while to_send > 0:\n                    content = await f.read(min((_range.size, chunk_size)))\n                    if len(content) < 1:\n                        break\n                    to_send -= len(content)\n                    await response.write(content)\n            else:\n                while True:\n                    content = await f.read(chunk_size)\n                    if len(content) < 1:\n                        break\n                    await response.write(content)\n\n    return ResponseStream(\n        streaming_fn=_streaming_fn,\n        status=status,\n        headers=headers,\n        content_type=mime_type,\n    )"
    },
    {
      "chunk_id": 454,
      "source": "__internal__/data_repo/sanic/sanic/http/__init__.py",
      "content": "from .constants import Stage\nfrom .http1 import Http\nfrom .http3 import Http3"
    },
    {
      "chunk_id": 455,
      "source": "__internal__/data_repo/sanic/sanic/http/__init__.py",
      "content": "__all__ = (\"Http\", \"Stage\", \"Http3\")"
    },
    {
      "chunk_id": 456,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Optional\n\n\nif TYPE_CHECKING:\n    from sanic.request import Request\n    from sanic.response import BaseHTTPResponse\n\nfrom asyncio import CancelledError, sleep\nfrom time import perf_counter\n\nfrom sanic.compat import Header\nfrom sanic.exceptions import (\n    BadRequest,\n    ExpectationFailed,\n    PayloadTooLarge,\n    RequestCancelled,\n    ServerError,\n    ServiceUnavailable,\n)\nfrom sanic.headers import format_http1_response\nfrom sanic.helpers import has_message_body\nfrom sanic.http.constants import Stage\nfrom sanic.http.stream import Stream\nfrom sanic.log import access_logger, error_logger, logger\nfrom sanic.touchup import TouchUpMeta\n\n\nHTTP_CONTINUE = b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\""
    },
    {
      "chunk_id": 457,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "class Http(Stream, metaclass=TouchUpMeta):\n    \"\"\" \"Internal helper for managing the HTTP/1.1 request/response cycle.\n\n    Raises:\n        BadRequest: If the request body is malformed.\n        Exception: If the request is malformed.\n        ExpectationFailed: If the request is malformed.\n        PayloadTooLarge: If the request body exceeds the size limit.\n        RuntimeError: If the response status is invalid.\n        ServerError: If the handler does not produce a response.\n        ServerError: If the response is bigger than the content-length.\n    \"\"\"\n\n    HEADER_CEILING = 16_384\n    HEADER_MAX_SIZE = 0\n    __touchup__ = (\n        \"http1_request_header\",\n        \"http1_response_header\",\n        \"read\",\n    )\n    __slots__ = [\n        \"_send\",\n        \"_receive_more\",\n        \"dispatch\",\n        \"recv_buffer\",\n        \"protocol\",\n        \"expecting_continue\",\n        \"stage\",\n        \"keep_alive\",\n        \"head_only\",\n        \"request\",\n        \"exception\",\n        \"url\",\n        \"request_body\",\n        \"request_bytes\",\n        \"request_bytes_left\",\n        \"response\",\n        \"response_func\",\n        \"response_size\",\n        \"response_bytes_left\",\n        \"upgrade_websocket\",\n        \"perft0\",\n    ]\n\n    def __init__(self, protocol):\n        self._send = protocol.send\n        self._receive_more = protocol.receive_more\n        self.recv_buffer = protocol.recv_buffer\n        self.protocol = protocol\n        self.keep_alive = True\n        self.stage: Stage = Stage.IDLE\n        self.dispatch = self.protocol.app.dispatch"
    },
    {
      "chunk_id": 458,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "def init_for_request(self):\n        \"\"\"Init/reset all per-request variables.\"\"\"\n        self.exception = None\n        self.expecting_continue: bool = False\n        self.head_only = None\n        self.request_body = None\n        self.request_bytes = None\n        self.request_bytes_left = None\n        self.request_max_size = self.protocol.request_max_size\n        self.request: Request = None\n        self.response: BaseHTTPResponse = None\n        self.upgrade_websocket = False\n        self.url = None\n        self.perft0 = None"
    },
    {
      "chunk_id": 459,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "def __bool__(self):\n        \"\"\"Test if request handling is in progress\"\"\"\n        return self.stage in (Stage.HANDLER, Stage.RESPONSE)"
    },
    {
      "chunk_id": 460,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def http1(self):\n        \"\"\"HTTP 1.1 connection handler\"\"\"\n        # Handle requests while the connection stays reusable\n        while self.keep_alive and self.stage is Stage.IDLE:\n            self.init_for_request()\n            # Wait for incoming bytes (in IDLE stage)\n            if not self.recv_buffer:\n                await self._receive_more()\n            self.stage = Stage.REQUEST\n            try:\n                # Receive and handle a request\n                self.response_func = self.http1_response_header\n\n                await self.http1_request_header()\n\n                self.stage = Stage.HANDLER\n                self.perft0 = perf_counter()\n                self.request.conn_info = self.protocol.conn_info\n                await self.protocol.request_handler(self.request)\n\n                # Handler finished, response should've been sent\n                if self.stage is Stage.HANDLER and not self.upgrade_websocket:\n                    raise ServerError(\"Handler produced no response\")\n\n                if self.stage is Stage.RESPONSE:\n                    await self.response.send(end_stream=True)\n            except CancelledError as exc:\n                # Write an appropriate response before exiting\n                if not self.protocol.transport:\n                    logger.info(\n                        f\"Request: {self.request.method} {self.request.url} \"\n                        \"stopped. Transport is closed.\"\n                    )\n                    return\n                e = (\n                    RequestCancelled()\n                    if self.protocol.conn_info.lost\n                    else (self.exception or exc)\n                )\n                self.exception = None\n                self.keep_alive = False\n                await self.error_response(e)\n            except Exception as e:\n                # Write an error response\n                await self.error_response(e)\n\n            # Try to consume any remaining request body\n            if self.request_body:\n                if self.response and 200 <= self.response.status < 300:\n                    error_logger.error(f\"{self.request} body not consumed.\")\n                # Limit the size because the handler may have set it infinite\n                self.request_max_size = min(\n                    self.request_max_size, self.protocol.request_max_size\n                )\n                try:\n                    async for _ in self:\n                        pass\n                except PayloadTooLarge:\n                    # We won't read the body and that may cause httpx and\n                    # tests to fail. This little delay allows clients to push\n                    # a small request into network buffers before we close the\n                    # socket, so that they are then able to read the response.\n                    await sleep(0.001)\n                    self.keep_alive = False\n\n            # Clean up to free memory and for the next request\n            if self.request:\n                self.request.stream = None\n                if self.response:\n                    self.response.stream = None"
    },
    {
      "chunk_id": 461,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def http1_request_header(self):  # no cov\n        \"\"\"Receive and parse request header into self.request.\"\"\"\n        # Receive until full header is in buffer\n        buf = self.recv_buffer\n        pos = 0\n\n        while True:\n            pos = buf.find(b\"\\r\\n\\r\\n\", pos)\n            if pos != -1:\n                break\n\n            pos = max(0, len(buf) - 3)\n            if pos >= self.HEADER_MAX_SIZE:\n                break\n\n            await self._receive_more()\n\n        if pos >= self.HEADER_MAX_SIZE:\n            raise PayloadTooLarge(\"Request header exceeds the size limit\")\n\n        # Parse header content\n        try:\n            head = buf[:pos]\n            raw_headers = head.decode(errors=\"surrogateescape\")\n            reqline, *split_headers = raw_headers.split(\"\\r\\n\")\n            method, self.url, protocol = reqline.split(\" \")\n\n            await self.dispatch(\n                \"http.lifecycle.read_head\",\n                inline=True,\n                context={\"head\": bytes(head)},\n            )\n\n            if protocol == \"HTTP/1.1\":\n                self.keep_alive = True\n            elif protocol == \"HTTP/1.0\":\n                self.keep_alive = False\n            else:\n                raise Exception  # Raise a Bad Request on try-except\n\n            self.head_only = method.upper() == \"HEAD\"\n            request_body = False\n            headers = []\n\n            for name, value in (h.split(\":\", 1) for h in split_headers):\n                name, value = h = name.lower(), value.lstrip()\n\n                if name in (\"content-length\", \"transfer-encoding\"):\n                    if request_body:\n                        raise ValueError(\n                            \"Duplicate Content-Length or Transfer-Encoding\"\n                        )\n                    request_body = True\n                elif name == \"connection\":\n                    self.keep_alive = value.lower() == \"keep-alive\"\n\n                headers.append(h)\n        except Exception:\n            raise BadRequest(\"Bad Request\")\n\n        headers_instance = Header(headers)\n        self.upgrade_websocket = (\n            headers_instance.getone(\"upgrade\", \"\").lower() == \"websocket\"\n        )\n\n        try:\n            url_bytes = self.url.encode(\"ASCII\")\n        except UnicodeEncodeError:\n            raise BadRequest(\"URL may only contain US-ASCII characters.\")\n\n        # Prepare a Request object\n        request = self.protocol.request_class(\n            url_bytes=url_bytes,\n            headers=headers_instance,\n            head=bytes(head),\n            version=protocol[5:],\n            method=method,\n            transport=self.protocol.transport,\n            app=self.protocol.app,\n        )\n        self.protocol.request_class._current.set(request)\n        await self.dispatch(\n            \"http.lifecycle.request\",\n            inline=True,\n            context={\"request\": request},\n        )\n\n        # Prepare for request body\n        self.request_bytes_left = self.request_bytes = 0\n        if request_body:\n            headers = request.headers\n            expect = headers.getone(\"expect\", None)\n\n            if expect is not None:\n                if expect.lower() == \"100-continue\":\n                    self.expecting_continue = True\n                else:\n                    raise ExpectationFailed(f\"Unknown Expect: {expect}\")\n\n            if headers.getone(\"transfer-encoding\", None) == \"chunked\":\n                self.request_body = \"chunked\"\n                pos -= 2  # One CRLF stays in buffer\n            else:\n                self.request_body = True\n                try:\n                    self.request_bytes_left = self.request_bytes = (\n                        self._safe_int(headers[\"content-length\"])\n                    )\n                except Exception:\n                    raise BadRequest(\"Bad content-length\")\n\n        # Remove header and its trailing CRLF\n        del buf[: pos + 4]\n        self.request, request.stream = request, self\n        self.protocol.state[\"requests_count\"] += 1"
    },
    {
      "chunk_id": 462,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def http1_response_header(\n        self, data: bytes, end_stream: bool\n    ) -> None:  # no cov\n        \"\"\"Format response header and send it.\"\"\"\n        res = self.response\n\n        # Compatibility with simple response body\n        if not data and getattr(res, \"body\", None):\n            data, end_stream = res.body, True  # type: ignore\n\n        size = len(data)\n        headers = res.headers\n        status = res.status\n        self.response_size = size\n\n        if not isinstance(status, int) or status < 200:\n            raise RuntimeError(f\"Invalid response status {status!r}\")\n\n        if not has_message_body(status):\n            # Header-only response status\n            self.response_func = None\n            if (\n                data\n                or not end_stream\n                or \"content-length\" in headers\n                or \"transfer-encoding\" in headers\n            ):\n                data, size, end_stream = b\"\", 0, True\n                headers.pop(\"content-length\", None)\n                headers.pop(\"transfer-encoding\", None)\n                logger.warning(\n                    f\"Message body set in response on {self.request.path}. \"\n                    f\"A {status} response may only have headers, no body.\"\n                )\n        elif self.head_only and \"content-length\" in headers:\n            self.response_func = None\n        elif end_stream:\n            # Non-streaming response (all in one block)\n            headers[\"content-length\"] = size\n            self.response_func = None\n        elif \"content-length\" in headers:\n            # Streaming response with size known in advance\n            self.response_bytes_left = int(headers[\"content-length\"]) - size\n            self.response_func = self.http1_response_normal\n        else:\n            # Length not known, use chunked encoding\n            headers[\"transfer-encoding\"] = \"chunked\"\n            data = b\"%x\\r\\n%b\\r\\n\" % (size, data) if size else b\"\"\n            self.response_func = self.http1_response_chunked\n\n        if self.head_only:\n            # Head request: don't send body\n            data = b\"\"\n            self.response_func = self.head_response_ignored\n\n        headers[\"connection\"] = \"keep-alive\" if self.keep_alive else \"close\"\n\n        # This header may be removed or modified by the AltSvcCheck Touchup\n        # service. At server start, we either remove this header from ever\n        # being assigned, or we change the value as required.\n        headers[\"alt-svc\"] = \"\"\n\n        ret = format_http1_response(status, res.processed_headers)\n        if data:\n            ret += data\n\n        # Send a 100-continue if expected and not Expectation Failed\n        if self.expecting_continue:\n            self.expecting_continue = False\n            if status != 417:\n                ret = HTTP_CONTINUE + ret\n\n        # Send response\n        if self.protocol.access_log:\n            self.log_response()\n\n        await self._send(ret)\n        self.stage = Stage.IDLE if end_stream else Stage.RESPONSE"
    },
    {
      "chunk_id": 463,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "def head_response_ignored(self, data: bytes, end_stream: bool) -> None:\n        \"\"\"HEAD response: body data silently ignored.\"\"\"\n        if end_stream:\n            self.response_func = None\n            self.stage = Stage.IDLE"
    },
    {
      "chunk_id": 464,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def http1_response_chunked(\n        self, data: bytes, end_stream: bool\n    ) -> None:\n        \"\"\"Format a part of response body in chunked encoding.\"\"\"\n        # Chunked encoding\n        size = len(data)\n        if end_stream:\n            await self._send(\n                b\"%x\\r\\n%b\\r\\n0\\r\\n\\r\\n\" % (size, data)\n                if size\n                else b\"0\\r\\n\\r\\n\"\n            )\n            self.response_func = None\n            self.stage = Stage.IDLE\n        elif size:\n            await self._send(b\"%x\\r\\n%b\\r\\n\" % (size, data))"
    },
    {
      "chunk_id": 465,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def http1_response_normal(\n        self, data: bytes, end_stream: bool\n    ) -> None:\n        \"\"\"Format / keep track of non-chunked response.\"\"\"\n        bytes_left = self.response_bytes_left - len(data)\n        if bytes_left <= 0:\n            if bytes_left < 0:\n                raise ServerError(\"Response was bigger than content-length\")\n\n            await self._send(data)\n            self.response_func = None\n            self.stage = Stage.IDLE\n        else:\n            if end_stream:\n                raise ServerError(\"Response was smaller than content-length\")\n\n            await self._send(data)\n        self.response_bytes_left = bytes_left"
    },
    {
      "chunk_id": 466,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def error_response(self, exception: Exception) -> None:\n        \"\"\"Handle response when exception encountered\"\"\"\n        # Disconnect after an error if in any other state than handler\n        if self.stage is not Stage.HANDLER:\n            self.keep_alive = False\n\n        # Request failure? Respond but then disconnect\n        if self.stage is Stage.REQUEST:\n            self.stage = Stage.HANDLER\n\n        # From request and handler states we can respond, otherwise be silent\n        if self.stage is Stage.HANDLER:\n            app = self.protocol.app\n\n            if self.request is None:\n                self.create_empty_request()\n\n            request_middleware = not isinstance(\n                exception, (ServiceUnavailable, RequestCancelled)\n            )\n            try:\n                await app.handle_exception(\n                    self.request, exception, request_middleware\n                )\n            except Exception as e:\n                await app.handle_exception(self.request, e, False)"
    },
    {
      "chunk_id": 467,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "def create_empty_request(self) -> None:\n        \"\"\"Create an empty request object for error handling use.\n\n        Current error handling code needs a request object that won't exist\n        if an error occurred during before a request was received. Create a\n        bogus response for error handling use.\n        \"\"\"\n\n        # Reformat any URL already received with \\xHH escapes for better logs\n        url_bytes = (\n            self.url.encode(errors=\"surrogateescape\")\n            .decode(\"ASCII\", errors=\"backslashreplace\")\n            .encode(\"ASCII\")\n            if self.url\n            else b\"*\"\n        )\n\n        # FIXME: Avoid this by refactoring error handling and response code\n        self.request = self.protocol.request_class(\n            url_bytes=url_bytes,\n            headers=Header({}),\n            version=\"1.1\",\n            method=\"NONE\",\n            transport=self.protocol.transport,\n            app=self.protocol.app,\n        )\n        self.request.stream = self"
    },
    {
      "chunk_id": 468,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "def log_response(self) -> None:\n        \"\"\"Helper method provided to enable the logging of responses in case if the `HttpProtocol.access_log` is enabled.\"\"\"  # noqa: E501\n        req, res = self.request, self.response\n        extra = {\n            \"status\": getattr(res, \"status\", 0),\n            \"byte\": res.headers.get(\"content-length\", 0)\n            if res.headers.get(\"transfer-encoding\") != \"chunked\"\n            else \"chunked\",\n            \"host\": f\"{id(self.protocol.transport):X}\"[-5:-1] + \"unx\",\n            \"request\": \"nil\",\n            \"duration\": (\n                f\" {1000 * (perf_counter() - self.perft0):.1f}ms\"\n                if self.perft0 is not None\n                else \"\"\n            ),\n        }\n        if ip := req.client_ip:\n            extra[\"host\"] = f\"{ip}:{req.port}\"\n        extra[\"request\"] = f\"{req.method} {req.url}\"\n        access_logger.info(\"\", extra=extra)"
    },
    {
      "chunk_id": 469,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "# Request methods\n\n    async def __aiter__(self):\n        \"\"\"Async iterate over request body.\"\"\"\n        while self.request_body:\n            data = await self.read()\n\n            if data:\n                yield data"
    },
    {
      "chunk_id": 470,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "async def read(self) -> Optional[bytes]:  # no cov\n        \"\"\"Read some bytes of request body.\"\"\"\n\n        # Send a 100-continue if needed\n        if self.expecting_continue:\n            self.expecting_continue = False\n            await self._send(HTTP_CONTINUE)\n\n        # Receive request body chunk\n        buf = self.recv_buffer\n        if self.request_bytes_left == 0 and self.request_body == \"chunked\":\n            # Process a chunk header: \\r\\n<size>[;<chunk extensions>]\\r\\n\n            while True:\n                pos = buf.find(b\"\\r\\n\", 3)\n\n                if pos != -1:\n                    break\n\n                if len(buf) > 64:\n                    self.keep_alive = False\n                    raise BadRequest(\"Bad chunked encoding\")\n\n                await self._receive_more()\n\n            try:\n                raw = buf[2:pos].split(b\";\", 1)[0].decode()\n                size = self._safe_int(raw, 16)\n            except Exception:\n                self.keep_alive = False\n                raise BadRequest(\"Bad chunked encoding\")\n\n            if size <= 0:\n                self.request_body = None\n\n                if size < 0:\n                    self.keep_alive = False\n                    raise BadRequest(\"Bad chunked encoding\")\n\n                # Consume CRLF, chunk size 0 and the two CRLF that follow\n                pos += 4\n                # Might need to wait for the final CRLF\n                while len(buf) < pos:\n                    await self._receive_more()\n                del buf[:pos]\n                return None\n\n            # Remove CRLF, chunk size and the CRLF that follows\n            del buf[: pos + 2]\n\n            self.request_bytes_left = size\n            self.request_bytes += size\n\n        # Request size limit\n        if self.request_bytes > self.request_max_size:\n            self.keep_alive = False\n            raise PayloadTooLarge(\"Request body exceeds the size limit\")\n\n        # End of request body?\n        if not self.request_bytes_left:\n            self.request_body = None\n            return None\n\n        # At this point we are good to read/return up to request_bytes_left\n        if not buf:\n            await self._receive_more()\n\n        data = bytes(buf[: self.request_bytes_left])\n        size = len(data)\n\n        del buf[:size]\n\n        self.request_bytes_left -= size\n\n        await self.dispatch(\n            \"http.lifecycle.read_body\",\n            inline=True,\n            context={\"body\": data},\n        )\n\n        return data"
    },
    {
      "chunk_id": 471,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "# Response methods\n\n    def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:\n        \"\"\"Initiate new streaming response.\n\n        Nothing is sent until the first send() call on the returned object, and\n        calling this function multiple times will just alter the response to be\n        given.\n        \"\"\"\n        if self.stage is not Stage.HANDLER:\n            self.stage = Stage.FAILED\n            raise RuntimeError(\"Response already started\")\n\n        # Disconnect any earlier but unused response object\n        if self.response is not None:\n            self.response.stream = None\n\n        # Connect and return the response\n        self.response, response.stream = response, self\n        return response"
    },
    {
      "chunk_id": 472,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "@property\n    def send(self):\n        return self.response_func"
    },
    {
      "chunk_id": 473,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "@classmethod\n    def set_header_max_size(cls, *sizes: int):\n        cls.HEADER_MAX_SIZE = min(\n            *sizes,\n            cls.HEADER_CEILING,\n        )"
    },
    {
      "chunk_id": 474,
      "source": "__internal__/data_repo/sanic/sanic/http/http1.py",
      "content": "@staticmethod\n    def _safe_int(value: str, base: int = 10) -> int:\n        if \"-\" in value or \"+\" in value or \"_\" in value:\n            raise ValueError\n        return int(value, base)"
    },
    {
      "chunk_id": 475,
      "source": "__internal__/data_repo/sanic/sanic/http/stream.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Optional, Union\n\nfrom sanic.http.constants import Stage\n\n\nif TYPE_CHECKING:\n    from sanic.response import BaseHTTPResponse\n    from sanic.server.protocols.http_protocol import HttpProtocol"
    },
    {
      "chunk_id": 476,
      "source": "__internal__/data_repo/sanic/sanic/http/stream.py",
      "content": "class Stream:\n    stage: Stage\n    response: Optional[BaseHTTPResponse]\n    protocol: HttpProtocol\n    url: Optional[str]\n    request_body: Optional[bytes]\n    request_max_size: Union[int, float]\n\n    __touchup__: tuple[str, ...] = tuple()\n    __slots__ = (\"request_max_size\",)"
    },
    {
      "chunk_id": 477,
      "source": "__internal__/data_repo/sanic/sanic/http/stream.py",
      "content": "def respond(\n        self, response: BaseHTTPResponse\n    ) -> BaseHTTPResponse:  # no cov\n        raise NotImplementedError(\"Not implemented\")"
    },
    {
      "chunk_id": 478,
      "source": "__internal__/data_repo/sanic/sanic/http/constants.py",
      "content": "from enum import Enum, IntEnum"
    },
    {
      "chunk_id": 479,
      "source": "__internal__/data_repo/sanic/sanic/http/constants.py",
      "content": "class Stage(Enum):\n    \"\"\"Enum for representing the stage of the request/response cycle\n\n    | ``IDLE``  Waiting for request\n    | ``REQUEST``  Request headers being received\n    | ``HANDLER``  Headers done, handler running\n    | ``RESPONSE``  Response headers sent, body in progress\n    | ``FAILED``  Unrecoverable state (error while sending response)\n    |\n    \"\"\"\n\n    IDLE = 0  # Waiting for request\n    REQUEST = 1  # Request headers being received\n    HANDLER = 3  # Headers done, handler running\n    RESPONSE = 4  # Response headers sent, body in progress\n    FAILED = 100  # Unrecoverable state (error while sending response)"
    },
    {
      "chunk_id": 480,
      "source": "__internal__/data_repo/sanic/sanic/http/constants.py",
      "content": "class HTTP(IntEnum):\n    \"\"\"Enum for representing HTTP versions\"\"\"\n\n    VERSION_1 = 1\n    VERSION_3 = 3"
    },
    {
      "chunk_id": 481,
      "source": "__internal__/data_repo/sanic/sanic/http/constants.py",
      "content": "def display(self) -> str:\n        value = 1.1 if self.value == 1 else self.value\n        return f\"HTTP/{value}\""
    },
    {
      "chunk_id": 482,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "from __future__ import annotations\n\nimport asyncio\n\nfrom abc import ABC, abstractmethod\nfrom ssl import SSLContext\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Optional,\n    Union,\n    cast,\n)\n\nfrom sanic.compat import Header\nfrom sanic.constants import LocalCertCreator\nfrom sanic.exceptions import (\n    BadRequest,\n    PayloadTooLarge,\n    SanicException,\n    ServerError,\n)\nfrom sanic.helpers import has_message_body\nfrom sanic.http.constants import Stage\nfrom sanic.http.stream import Stream\nfrom sanic.http.tls.context import CertSelector, SanicSSLContext\nfrom sanic.log import Colors, logger\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.models.server_types import ConnInfo\n\n\ntry:\n    from aioquic.h0.connection import H0_ALPN, H0Connection\n    from aioquic.h3.connection import H3_ALPN, H3Connection\n    from aioquic.h3.events import (\n        DatagramReceived,\n        DataReceived,\n        H3Event,\n        HeadersReceived,\n        WebTransportStreamDataReceived,\n    )\n    from aioquic.quic.configuration import QuicConfiguration\n    from aioquic.tls import SessionTicket\n\n    HTTP3_AVAILABLE = True\nexcept ModuleNotFoundError:  # no cov\n    HTTP3_AVAILABLE = False\n\nif TYPE_CHECKING:\n    from sanic import Sanic\n    from sanic.request import Request\n    from sanic.response import BaseHTTPResponse\n    from sanic.server.protocols.http_protocol import Http3Protocol\n\n    HttpConnection = Union[H0Connection, H3Connection]"
    },
    {
      "chunk_id": 483,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class HTTP3Transport(TransportProtocol):\n    \"\"\"HTTP/3 transport implementation.\"\"\"\n\n    __slots__ = (\"_protocol\",)\n\n    def __init__(self, protocol: Http3Protocol):\n        self._protocol = protocol\n\n    def get_protocol(self) -> Http3Protocol:\n        return self._protocol\n\n    def get_extra_info(self, info: str, default: Any = None) -> Any:\n        if (\n            info in (\"socket\", \"sockname\", \"peername\")\n            and self._protocol._transport\n        ):\n            return self._protocol._transport.get_extra_info(info, default)\n        elif info == \"network_paths\":\n            return self._protocol._quic._network_paths\n        elif info == \"ssl_context\":\n            return self._protocol.app.state.ssl\n        return default"
    },
    {
      "chunk_id": 484,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class Receiver(ABC):\n    \"\"\"HTTP/3 receiver base class.\"\"\"\n\n    future: asyncio.Future\n\n    def __init__(self, transmit, protocol, request: Request) -> None:\n        self.transmit = transmit\n        self.protocol = protocol\n        self.request = request\n\n    @abstractmethod\n    async def run(self):  # no cov\n        ..."
    },
    {
      "chunk_id": 485,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class HTTPReceiver(Receiver, Stream):\n    \"\"\"HTTP/3 receiver implementation.\"\"\"\n\n    stage: Stage\n    request: Request\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.request_body = None\n        self.stage = Stage.IDLE\n        self.headers_sent = False\n        self.response: Optional[BaseHTTPResponse] = None\n        self.request_max_size = self.protocol.request_max_size\n        self.request_bytes = 0\n\n    async def run(self, exception: Optional[Exception] = None):\n        \"\"\"Handle the request and response cycle.\"\"\"\n        self.stage = Stage.HANDLER\n        self.head_only = self.request.method.upper() == \"HEAD\"\n\n        if exception:\n            logger.info(  # no cov\n                f\"{Colors.BLUE}[exception]: \"\n                f\"{Colors.RED}{exception}{Colors.END}\",\n                exc_info=True,\n                extra={\"verbosity\": 1},\n            )\n            await self.error_response(exception)\n        else:\n            try:\n                logger.info(  # no cov\n                    f\"{Colors.BLUE}[request]:{Colors.END} {self.request}\",\n                    extra={\"verbosity\": 1},\n                )\n                await self.protocol.request_handler(self.request)\n            except Exception as e:  # no cov\n                # This should largely be handled within the request handler.\n                # But, just in case...\n                await self.run(e)\n        self.stage = Stage.IDLE"
    },
    {
      "chunk_id": 486,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "async def error_response(self, exception: Exception) -> None:\n        \"\"\"Handle response when exception encountered\"\"\"\n        # From request and handler states we can respond, otherwise be silent\n        app = self.protocol.app\n\n        await app.handle_exception(self.request, exception)"
    },
    {
      "chunk_id": 487,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def _prepare_headers(\n        self, response: BaseHTTPResponse\n    ) -> list[tuple[bytes, bytes]]:\n        size = len(response.body) if response.body else 0\n        headers = response.headers\n        status = response.status\n\n        if not has_message_body(status) and (\n            size\n            or \"content-length\" in headers\n            or \"transfer-encoding\" in headers\n        ):\n            headers.pop(\"content-length\", None)\n            headers.pop(\"transfer-encoding\", None)\n            logger.warning(  # no cov\n                f\"Message body set in response on {self.request.path}. \"\n                f\"A {status} response may only have headers, no body.\"\n            )\n        elif \"content-length\" not in headers:\n            if size:\n                headers[\"content-length\"] = size\n            else:\n                headers[\"transfer-encoding\"] = \"chunked\"\n\n        headers = [\n            (b\":status\", str(response.status).encode()),\n            *response.processed_headers,\n        ]\n        return headers"
    },
    {
      "chunk_id": 488,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def send_headers(self) -> None:\n        \"\"\"Send response headers to client\"\"\"\n        logger.debug(  # no cov\n            f\"{Colors.BLUE}[send]: {Colors.GREEN}HEADERS{Colors.END}\",\n            extra={\"verbosity\": 2},\n        )\n        if not self.response:\n            raise RuntimeError(\"no response\")\n\n        response = self.response\n        headers = self._prepare_headers(response)\n\n        self.protocol.connection.send_headers(\n            stream_id=self.request.stream_id,\n            headers=headers,\n        )\n        self.headers_sent = True\n        self.stage = Stage.RESPONSE\n\n        if self.response.body and not self.head_only:\n            self._send(self.response.body, False)\n        elif self.head_only:\n            self.future.cancel()"
    },
    {
      "chunk_id": 489,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:\n        \"\"\"Prepare response to client\"\"\"\n        logger.debug(  # no cov\n            f\"{Colors.BLUE}[respond]:{Colors.END} {response}\",\n            extra={\"verbosity\": 2},\n        )\n\n        if self.stage is not Stage.HANDLER:\n            self.stage = Stage.FAILED\n            raise RuntimeError(\"Response already started\")\n\n        # Disconnect any earlier but unused response object\n        if self.response is not None:\n            self.response.stream = None\n\n        self.response, response.stream = response, self\n\n        return response"
    },
    {
      "chunk_id": 490,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def receive_body(self, data: bytes) -> None:\n        \"\"\"Receive request body from client\"\"\"\n        self.request_bytes += len(data)\n        if self.request_bytes > self.request_max_size:\n            raise PayloadTooLarge(\"Request body exceeds the size limit\")\n\n        self.request.body += data"
    },
    {
      "chunk_id": 491,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "async def send(self, data: bytes, end_stream: bool) -> None:\n        \"\"\"Send data to client\"\"\"\n        logger.debug(  # no cov\n            f\"{Colors.BLUE}[send]: {Colors.GREEN}data={data.decode()} \"\n            f\"end_stream={end_stream}{Colors.END}\",\n            extra={\"verbosity\": 2},\n        )\n        self._send(data, end_stream)"
    },
    {
      "chunk_id": 492,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def _send(self, data: bytes, end_stream: bool) -> None:\n        if not self.headers_sent:\n            self.send_headers()\n        if self.stage is not Stage.RESPONSE:\n            raise ServerError(f\"not ready to send: {self.stage}\")\n\n        # Chunked\n        if (\n            self.response\n            and self.response.headers.get(\"transfer-encoding\") == \"chunked\"\n        ):\n            size = len(data)\n            if end_stream:\n                data = (\n                    b\"%x\\r\\n%b\\r\\n0\\r\\n\\r\\n\" % (size, data)\n                    if size\n                    else b\"0\\r\\n\\r\\n\"\n                )\n            elif size:\n                data = b\"%x\\r\\n%b\\r\\n\" % (size, data)\n\n        logger.debug(  # no cov\n            f\"{Colors.BLUE}[transmitting]{Colors.END}\",\n            extra={\"verbosity\": 2},\n        )\n        self.protocol.connection.send_data(\n            stream_id=self.request.stream_id,\n            data=data,\n            end_stream=end_stream,\n        )\n        self.transmit()\n\n        if end_stream:\n            self.stage = Stage.IDLE"
    },
    {
      "chunk_id": 493,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class WebsocketReceiver(Receiver):  # noqa\n    \"\"\"Websocket receiver implementation.\"\"\"\n\n    async def run(self): ..."
    },
    {
      "chunk_id": 494,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class WebTransportReceiver(Receiver):  # noqa\n    \"\"\"WebTransport receiver implementation.\"\"\"\n\n    async def run(self): ..."
    },
    {
      "chunk_id": 495,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class Http3:\n    \"\"\"Internal helper for managing the HTTP/3 request/response cycle\"\"\"\n\n    if HTTP3_AVAILABLE:\n        HANDLER_PROPERTY_MAPPING = {\n            DataReceived: \"stream_id\",\n            HeadersReceived: \"stream_id\",\n            DatagramReceived: \"flow_id\",\n            WebTransportStreamDataReceived: \"session_id\",\n        }\n\n    def __init__(\n        self,\n        protocol: Http3Protocol,\n        transmit: Callable[[], None],\n    ) -> None:\n        self.protocol = protocol\n        self.transmit = transmit\n        self.receivers: dict[int, Receiver] = {}"
    },
    {
      "chunk_id": 496,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def http_event_received(self, event: H3Event) -> None:\n        logger.debug(  # no cov\n            f\"{Colors.BLUE}[http_event_received]: \"\n            f\"{Colors.YELLOW}{event}{Colors.END}\",\n            extra={\"verbosity\": 2},\n        )\n        receiver, created_new = self.get_or_make_receiver(event)\n        receiver = cast(HTTPReceiver, receiver)\n\n        if isinstance(event, HeadersReceived) and created_new:\n            receiver.future = asyncio.ensure_future(receiver.run())\n        elif isinstance(event, DataReceived):\n            try:\n                receiver.receive_body(event.data)\n            except Exception as e:\n                receiver.future.cancel()\n                receiver.future = asyncio.ensure_future(receiver.run(e))\n        else:\n            ...  # Intentionally here to help out Touchup\n            logger.debug(  # no cov\n                f\"{Colors.RED}DOING NOTHING{Colors.END}\",\n                extra={\"verbosity\": 2},\n            )"
    },
    {
      "chunk_id": 497,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def get_or_make_receiver(self, event: H3Event) -> tuple[Receiver, bool]:\n        if (\n            isinstance(event, HeadersReceived)\n            and event.stream_id not in self.receivers\n        ):\n            request = self._make_request(event)\n            receiver = HTTPReceiver(self.transmit, self.protocol, request)\n            request.stream = receiver\n\n            self.receivers[event.stream_id] = receiver\n            return receiver, True\n        else:\n            ident = getattr(event, self.HANDLER_PROPERTY_MAPPING[type(event)])\n            return self.receivers[ident], False"
    },
    {
      "chunk_id": 498,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def get_receiver_by_stream_id(self, stream_id: int) -> Receiver:\n        return self.receivers[stream_id]"
    },
    {
      "chunk_id": 499,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def _make_request(self, event: HeadersReceived) -> Request:\n        try:\n            headers = Header(\n                (\n                    (k.decode(\"ASCII\"), v.decode(errors=\"surrogateescape\"))\n                    for k, v in event.headers\n                )\n            )\n        except UnicodeDecodeError:\n            raise BadRequest(\n                \"Header names may only contain US-ASCII characters.\"\n            )\n        method = headers[\":method\"]\n        path = headers[\":path\"]\n        scheme = headers.pop(\":scheme\", \"\")\n        authority = headers.pop(\":authority\", \"\")\n\n        if authority:\n            headers[\"host\"] = authority\n\n        try:\n            url_bytes = path.encode(\"ASCII\")\n        except UnicodeEncodeError:\n            raise BadRequest(\"URL may only contain US-ASCII characters.\")\n\n        transport = HTTP3Transport(self.protocol)\n        request = self.protocol.request_class(\n            url_bytes,\n            headers,\n            \"3\",\n            method,\n            transport,\n            self.protocol.app,\n            b\"\",\n        )\n        request.conn_info = ConnInfo(transport)\n        request._stream_id = event.stream_id\n        request._scheme = scheme\n\n        return request"
    },
    {
      "chunk_id": 500,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "class SessionTicketStore:\n    \"\"\"\n    Simple in-memory store for session tickets.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.tickets: dict[bytes, SessionTicket] = {}\n\n    def add(self, ticket: SessionTicket) -> None:\n        self.tickets[ticket.ticket] = ticket\n\n    def pop(self, label: bytes) -> Optional[SessionTicket]:\n        return self.tickets.pop(label, None)"
    },
    {
      "chunk_id": 501,
      "source": "__internal__/data_repo/sanic/sanic/http/http3.py",
      "content": "def get_config(\n    app: Sanic, ssl: Union[SanicSSLContext, CertSelector, SSLContext]\n):\n    # TODO:\n    # - proper selection needed if service with multiple certs insted of\n    #   just taking the first\n    if isinstance(ssl, CertSelector):\n        ssl = cast(SanicSSLContext, ssl.sanic_select[0])\n    if app.config.LOCAL_CERT_CREATOR is LocalCertCreator.TRUSTME:\n        raise SanicException(\n            \"Sorry, you cannot currently use trustme as a local certificate \"\n            \"generator for an HTTP/3 server. This is not yet supported. You \"\n            \"should be able to use mkcert instead. For more information, see: \"\n            \"https://github.com/aiortc/aioquic/issues/295.\"\n        )\n    if not isinstance(ssl, SanicSSLContext):\n        raise SanicException(\"SSLContext is not SanicSSLContext\")\n\n    config = QuicConfiguration(\n        alpn_protocols=H3_ALPN + H0_ALPN + [\"siduck\"],\n        is_client=False,\n        max_datagram_frame_size=65536,\n    )\n    password = app.config.TLS_CERT_PASSWORD or None\n\n    config.load_cert_chain(\n        ssl.sanic[\"cert\"], ssl.sanic[\"key\"], password=password\n    )\n\n    return config"
    },
    {
      "chunk_id": 502,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/__init__.py",
      "content": "from .context import process_to_context\nfrom .creators import get_ssl_context"
    },
    {
      "chunk_id": 503,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/__init__.py",
      "content": "__all__ = (\"get_ssl_context\", \"process_to_context\")"
    },
    {
      "chunk_id": 504,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "from __future__ import annotations\n\nimport os\nimport ssl\n\nfrom collections.abc import Iterable\nfrom typing import Any, Optional, Union\n\nfrom sanic.log import logger"
    },
    {
      "chunk_id": 505,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "CIPHERS_TLS12 = [\n    \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n    \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n    \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n    \"ECDHE-RSA-CHACHA20-POLY1305\",\n    \"ECDHE-RSA-AES256-GCM-SHA384\",\n    \"ECDHE-RSA-AES128-GCM-SHA256\",\n]"
    },
    {
      "chunk_id": 506,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def create_context(\n    certfile: Optional[str] = None,\n    keyfile: Optional[str] = None,\n    password: Optional[str] = None,\n    purpose: ssl.Purpose = ssl.Purpose.CLIENT_AUTH,\n) -> ssl.SSLContext:\n    \"\"\"Create a context with secure crypto and HTTP/1.1 in protocols.\"\"\"\n    context = ssl.create_default_context(purpose=purpose)\n    context.minimum_version = ssl.TLSVersion.TLSv1_2\n    context.set_ciphers(\":\".join(CIPHERS_TLS12))\n    context.set_alpn_protocols([\"http/1.1\"])\n    if purpose is ssl.Purpose.CLIENT_AUTH:\n        context.sni_callback = server_name_callback\n    if certfile and keyfile:\n        context.load_cert_chain(certfile, keyfile, password)\n    return context"
    },
    {
      "chunk_id": 507,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def shorthand_to_ctx(\n    ctxdef: Union[None, ssl.SSLContext, dict, str],\n) -> Optional[ssl.SSLContext]:\n    \"\"\"Convert an ssl argument shorthand to an SSLContext object.\"\"\"\n    if ctxdef is None or isinstance(ctxdef, ssl.SSLContext):\n        return ctxdef\n    if isinstance(ctxdef, str):\n        return load_cert_dir(ctxdef)\n    if isinstance(ctxdef, dict):\n        return CertSimple(**ctxdef)\n    raise ValueError(\n        f\"Invalid ssl argument {type(ctxdef)}.\"\n        \" Expecting a list of certdirs, a dict or an SSLContext.\"\n    )"
    },
    {
      "chunk_id": 508,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def process_to_context(\n    ssldef: Union[None, ssl.SSLContext, dict, str, list, tuple],\n) -> Optional[ssl.SSLContext]:\n    \"\"\"Process app.run ssl argument from easy formats to full SSLContext.\"\"\"\n    return (\n        CertSelector(map(shorthand_to_ctx, ssldef))\n        if isinstance(ssldef, (list, tuple))\n        else shorthand_to_ctx(ssldef)\n    )"
    },
    {
      "chunk_id": 509,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def load_cert_dir(p: str) -> ssl.SSLContext:\n    if os.path.isfile(p):\n        raise ValueError(f\"Certificate folder expected but {p} is a file.\")\n    keyfile = os.path.join(p, \"privkey.pem\")\n    certfile = os.path.join(p, \"fullchain.pem\")\n    if not os.access(keyfile, os.R_OK):\n        raise ValueError(\n            f\"Certificate not found or permission denied {keyfile}\"\n        )\n    if not os.access(certfile, os.R_OK):\n        raise ValueError(\n            f\"Certificate not found or permission denied {certfile}\"\n        )\n    return CertSimple(certfile, keyfile)"
    },
    {
      "chunk_id": 510,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def find_cert(self: CertSelector, server_name: str):\n    \"\"\"Find the first certificate that matches the given SNI.\n\n    :raises ssl.CertificateError: No matching certificate found.\n    :return: A matching ssl.SSLContext object if found.\"\"\"\n    if not server_name:\n        if self.sanic_fallback:\n            return self.sanic_fallback\n        raise ValueError(\n            \"The client provided no SNI to match for certificate.\"\n        )\n    for ctx in self.sanic_select:\n        if match_hostname(ctx, server_name):\n            return ctx\n    if self.sanic_fallback:\n        return self.sanic_fallback\n    raise ValueError(f\"No certificate found matching hostname {server_name!r}\")"
    },
    {
      "chunk_id": 511,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def match_hostname(\n    ctx: Union[ssl.SSLContext, CertSelector], hostname: str\n) -> bool:\n    \"\"\"Match names from CertSelector against a received hostname.\"\"\"\n    names = dict(getattr(ctx, \"sanic\", {})).get(\"names\", [])\n    hostname = hostname.lower()\n    for name in names:\n        if name.startswith(\"*.\"):\n            if hostname.split(\".\", 1)[-1] == name[2:]:\n                return True\n        elif name == hostname:\n            return True\n    return False"
    },
    {
      "chunk_id": 512,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def selector_sni_callback(\n    sslobj: ssl.SSLObject, server_name: str, ctx: CertSelector\n) -> Optional[int]:\n    \"\"\"Select a certificate matching the SNI.\"\"\"\n    server_name_callback(sslobj, server_name, ctx)\n    try:\n        sslobj.context = find_cert(ctx, server_name)\n    except ValueError as e:\n        logger.warning(f\"Rejecting TLS connection: {e}\")\n        return ssl.ALERT_DESCRIPTION_UNRECOGNIZED_NAME\n    return None"
    },
    {
      "chunk_id": 513,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "def server_name_callback(\n    sslobj: ssl.SSLObject, server_name: str, ctx: ssl.SSLContext\n) -> None:\n    \"\"\"Store the received SNI as sslobj.sanic_server_name.\"\"\"\n    sslobj.sanic_server_name = server_name  # type: ignore"
    },
    {
      "chunk_id": 514,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "class SanicSSLContext(ssl.SSLContext):\n    sanic: dict[str, os.PathLike]\n\n    @classmethod\n    def create_from_ssl_context(cls, context: ssl.SSLContext):\n        context.__class__ = cls\n        return context"
    },
    {
      "chunk_id": 515,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "class CertSimple(SanicSSLContext):\n    \"\"\"A wrapper for creating SSLContext with a sanic attribute.\"\"\"\n\n    sanic: dict[str, Any]\n\n    def __new__(cls, cert, key, **kw):\n        certfile = kw[\"cert\"] = kw.pop(\"certificate\", None) or cert\n        keyfile = kw[\"key\"] = kw.pop(\"keyfile\", None) or key\n        password = kw.get(\"password\", None)\n        if not certfile or not keyfile:\n            raise ValueError(\"SSL dict needs filenames for cert and key.\")\n        subject = {}\n        if \"names\" not in kw:\n            cert = ssl._ssl._test_decode_cert(certfile)  # type: ignore\n            kw[\"names\"] = [\n                name\n                for t, name in cert[\"subjectAltName\"]\n                if t in [\"DNS\", \"IP Address\"]\n            ]\n            subject = {k: v for item in cert[\"subject\"] for k, v in item}\n        self = create_context(certfile, keyfile, password)\n        self.__class__ = cls\n        self.sanic = {**subject, **kw}\n        return self\n\n    def __init__(self, cert, key, **kw):\n        pass  # Do not call super().__init__ because it is already initialized"
    },
    {
      "chunk_id": 516,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/context.py",
      "content": "class CertSelector(ssl.SSLContext):\n    \"\"\"Automatically select SSL certificate based on the hostname that the\n    client is trying to access, via SSL SNI. Paths to certificate folders\n    with privkey.pem and fullchain.pem in them should be provided, and\n    will be matched in the order given whenever there is a new connection.\n    \"\"\"\n\n    def __new__(cls, ctxs):\n        return super().__new__(cls)\n\n    def __init__(self, ctxs: Iterable[Optional[ssl.SSLContext]]):\n        super().__init__()\n        self.sni_callback = selector_sni_callback  # type: ignore\n        self.sanic_select = []\n        self.sanic_fallback = None\n        all_names = []\n        for i, ctx in enumerate(ctxs):\n            if not ctx:\n                continue\n            names = dict(getattr(ctx, \"sanic\", {})).get(\"names\", [])\n            all_names += names\n            self.sanic_select.append(ctx)\n            if i == 0:\n                self.sanic_fallback = ctx\n        if not all_names:\n            raise ValueError(\n                \"No certificates with SubjectAlternativeNames found.\"\n            )\n        logger.info(f\"Certificate vhosts: {', '.join(all_names)}\")"
    },
    {
      "chunk_id": 517,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "from __future__ import annotations\n\nimport ssl\nimport subprocess\nimport sys\n\nfrom abc import ABC, abstractmethod\nfrom contextlib import suppress\nfrom pathlib import Path\nfrom tempfile import mkdtemp\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, Optional, Union, cast\n\nfrom sanic.application.constants import Mode\nfrom sanic.application.spinner import loading\nfrom sanic.constants import (\n    DEFAULT_LOCAL_TLS_CERT,\n    DEFAULT_LOCAL_TLS_KEY,\n    LocalCertCreator,\n)\nfrom sanic.exceptions import SanicException\nfrom sanic.helpers import Default\nfrom sanic.http.tls.context import CertSimple, SanicSSLContext"
    },
    {
      "chunk_id": 518,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "try:\n    import trustme\n\n    TRUSTME_INSTALLED = True\nexcept (ImportError, ModuleNotFoundError):\n    trustme = ModuleType(\"trustme\")\n    TRUSTME_INSTALLED = False"
    },
    {
      "chunk_id": 519,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "CIPHERS_TLS12 = [\n    \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n    \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n    \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n    \"ECDHE-RSA-CHACHA20-POLY1305\",\n    \"ECDHE-RSA-AES256-GCM-SHA384\",\n    \"ECDHE-RSA-AES128-GCM-SHA256\",\n]"
    },
    {
      "chunk_id": 520,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "def _make_path(maybe_path: Union[Path, str], tmpdir: Optional[Path]) -> Path:\n    if isinstance(maybe_path, Path):\n        return maybe_path\n    else:\n        path = Path(maybe_path)\n        if not path.exists():\n            if not tmpdir:\n                raise RuntimeError(\"Reached an unknown state. No tmpdir.\")\n            return tmpdir / maybe_path\n\n    return path"
    },
    {
      "chunk_id": 521,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "def get_ssl_context(\n    app: Sanic, ssl: Optional[ssl.SSLContext]\n) -> ssl.SSLContext:\n    if ssl:\n        return ssl\n\n    if app.state.mode is Mode.PRODUCTION:\n        raise SanicException(\n            \"Cannot run Sanic as an HTTPS server in PRODUCTION mode \"\n            \"without passing a TLS certificate. If you are developing \"\n            \"locally, please enable DEVELOPMENT mode and Sanic will \"\n            \"generate a localhost TLS certificate. For more information \"\n            \"please see: https://sanic.dev/en/guide/deployment/development.\"\n            \"html#automatic-tls-certificate.\"\n        )\n\n    creator = CertCreator.select(\n        app,\n        cast(LocalCertCreator, app.config.LOCAL_CERT_CREATOR),\n        app.config.LOCAL_TLS_KEY,\n        app.config.LOCAL_TLS_CERT,\n    )\n    context = creator.generate_cert(app.config.LOCALHOST)\n    return context"
    },
    {
      "chunk_id": 522,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "class CertCreator(ABC):\n    def __init__(self, app, key, cert) -> None:\n        self.app = app\n        self.key = key\n        self.cert = cert\n        self.tmpdir = None\n\n        if isinstance(self.key, Default) or isinstance(self.cert, Default):\n            self.tmpdir = Path(mkdtemp())\n\n        key = (\n            DEFAULT_LOCAL_TLS_KEY\n            if isinstance(self.key, Default)\n            else self.key\n        )\n        cert = (\n            DEFAULT_LOCAL_TLS_CERT\n            if isinstance(self.cert, Default)\n            else self.cert\n        )\n\n        self.key_path = _make_path(key, self.tmpdir)\n        self.cert_path = _make_path(cert, self.tmpdir)\n\n    @abstractmethod\n    def check_supported(self) -> None:  # no cov\n        ...\n\n    @abstractmethod\n    def generate_cert(self, localhost: str) -> ssl.SSLContext:  # no cov\n        ...\n\n    @classmethod\n    def select(\n        cls,\n        app: Sanic,\n        cert_creator: LocalCertCreator,\n        local_tls_key,\n        local_tls_cert,\n    ) -> CertCreator:\n        creator: Optional[CertCreator] = None\n\n        cert_creator_options: tuple[\n            tuple[type[CertCreator], LocalCertCreator], ...\n        ] = (\n            (MkcertCreator, LocalCertCreator.MKCERT),\n            (TrustmeCreator, LocalCertCreator.TRUSTME),\n        )\n        for creator_class, local_creator in cert_creator_options:\n            creator = cls._try_select(\n                app,\n                creator,\n                creator_class,\n                local_creator,\n                cert_creator,\n                local_tls_key,\n                local_tls_cert,\n            )\n            if creator:\n                break\n\n        if not creator:\n            raise SanicException(\n                \"Sanic could not find package to create a TLS certificate. \"\n                \"You must have either mkcert or trustme installed. See \"\n                \"https://sanic.dev/en/guide/deployment/development.html\"\n                \"#automatic-tls-certificate for more details.\"\n            )\n\n        return creator\n\n    @staticmethod\n    def _try_select(\n        app: Sanic,\n        creator: Optional[CertCreator],\n        creator_class: type[CertCreator],\n        creator_requirement: LocalCertCreator,\n        creator_requested: LocalCertCreator,\n        local_tls_key,\n        local_tls_cert,\n    ):\n        if creator or (\n            creator_requested is not LocalCertCreator.AUTO\n            and creator_requested is not creator_requirement\n        ):\n            return creator\n\n        instance = creator_class(app, local_tls_key, local_tls_cert)\n        try:\n            instance.check_supported()\n        except SanicException:\n            if creator_requested is creator_requirement:\n                raise\n            else:\n                return None\n\n        return instance"
    },
    {
      "chunk_id": 523,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "class MkcertCreator(CertCreator):\n    def check_supported(self) -> None:\n        try:\n            subprocess.run(  # nosec B603 B607\n                [\"mkcert\", \"-help\"],\n                check=True,\n                stderr=subprocess.DEVNULL,\n                stdout=subprocess.DEVNULL,\n            )\n        except Exception as e:\n            raise SanicException(\n                \"Sanic is attempting to use mkcert to generate local TLS \"\n                \"certificates since you did not supply a certificate, but \"\n                \"one is required. Sanic cannot proceed since mkcert does not \"\n                \"appear to be installed. Alternatively, you can use trustme. \"\n                \"Please install mkcert, trustme, or supply TLS certificates \"\n                \"to proceed. Installation instructions can be found here: \"\n                \"https://github.com/FiloSottile/mkcert.\\n\"\n                \"Find out more information about your options here: \"\n                \"https://sanic.dev/en/guide/deployment/development.html#\"\n                \"automatic-tls-certificate\"\n            ) from e\n\n    def generate_cert(self, localhost: str) -> ssl.SSLContext:\n        try:\n            if not self.cert_path.exists():\n                message = \"Generating TLS certificate\"\n                # TODO: Validate input for security\n                with loading(message):\n                    cmd = [\n                        \"mkcert\",\n                        \"-key-file\",\n                        str(self.key_path),\n                        \"-cert-file\",\n                        str(self.cert_path),\n                        localhost,\n                    ]\n                    resp = subprocess.run(  # nosec B603\n                        cmd,\n                        check=True,\n                        stdout=subprocess.PIPE,\n                        stderr=subprocess.STDOUT,\n                        text=True,\n                    )\n                sys.stdout.write(\"\\r\" + \" \" * (len(message) + 4))\n                sys.stdout.flush()\n                sys.stdout.write(resp.stdout)\n        finally:\n\n            @self.app.main_process_stop\n            async def cleanup(*_):  # no cov\n                if self.tmpdir:\n                    with suppress(FileNotFoundError):\n                        self.key_path.unlink()\n                        self.cert_path.unlink()\n                    self.tmpdir.rmdir()\n\n        context = CertSimple(self.cert_path, self.key_path)\n        context.sanic[\"creator\"] = \"mkcert\"\n        context.sanic[\"localhost\"] = localhost\n        SanicSSLContext.create_from_ssl_context(context)\n\n        return context"
    },
    {
      "chunk_id": 524,
      "source": "__internal__/data_repo/sanic/sanic/http/tls/creators.py",
      "content": "class TrustmeCreator(CertCreator):\n    def check_supported(self) -> None:\n        if not TRUSTME_INSTALLED:\n            raise SanicException(\n                \"Sanic is attempting to use trustme to generate local TLS \"\n                \"certificates since you did not supply a certificate, but \"\n                \"one is required. Sanic cannot proceed since trustme does not \"\n                \"appear to be installed. Alternatively, you can use mkcert. \"\n                \"Please install mkcert, trustme, or supply TLS certificates \"\n                \"to proceed. Installation instructions can be found here: \"\n                \"https://github.com/python-trio/trustme.\\n\"\n                \"Find out more information about your options here: \"\n                \"https://sanic.dev/en/guide/deployment/development.html#\"\n                \"automatic-tls-certificate\"\n            )\n\n    def generate_cert(self, localhost: str) -> ssl.SSLContext:\n        context = SanicSSLContext.create_from_ssl_context(\n            ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        )\n        context.sanic = {\n            \"cert\": self.cert_path.absolute(),\n            \"key\": self.key_path.absolute(),\n        }\n        ca = trustme.CA()\n        server_cert = ca.issue_cert(localhost)\n        server_cert.configure_cert(context)\n        ca.configure_trust(context)\n\n        ca.cert_pem.write_to_path(str(self.cert_path.absolute()))\n        server_cert.private_key_and_cert_chain_pem.write_to_path(\n            str(self.key_path.absolute())\n        )\n        context.sanic[\"creator\"] = \"trustme\"\n        context.sanic[\"localhost\"] = localhost\n\n        return context"
    },
    {
      "chunk_id": 525,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 526,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 527,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 528,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 529,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 530,
      "source": "__internal__/data_repo/sanic/sanic/logging/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2\n```"
    },
    {
      "chunk_id": 531,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "import logging\n\nfrom sanic.logging.filter import VerbosityFilter"
    },
    {
      "chunk_id": 532,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "_verbosity_filter = VerbosityFilter()\n\nlogger = logging.getLogger(\"sanic.root\")  # no cov\n\"\"\"\nGeneral Sanic logger\n\"\"\"\nlogger.addFilter(_verbosity_filter)"
    },
    {
      "chunk_id": 533,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "error_logger = logging.getLogger(\"sanic.error\")  # no cov\n\"\"\"\nLogger used by Sanic for error logging\n\"\"\"\nerror_logger.addFilter(_verbosity_filter)"
    },
    {
      "chunk_id": 534,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "access_logger = logging.getLogger(\"sanic.access\")  # no cov\n\"\"\"\nLogger used by Sanic for access logging\n\"\"\"\naccess_logger.addFilter(_verbosity_filter)"
    },
    {
      "chunk_id": 535,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "server_logger = logging.getLogger(\"sanic.server\")  # no cov\n\"\"\"\nLogger used by Sanic for server related messages\n\"\"\"\nserver_logger.addFilter(_verbosity_filter)"
    },
    {
      "chunk_id": 536,
      "source": "__internal__/data_repo/sanic/sanic/logging/loggers.py",
      "content": "websockets_logger = logging.getLogger(\"sanic.websockets\")  # no cov\n\"\"\"\nLogger used by Sanic for websockets module and protocol related messages\n\"\"\"\nwebsockets_logger.addFilter(_verbosity_filter)\nwebsockets_logger.setLevel(logging.WARNING)  # Too noisy on debug/info"
    },
    {
      "chunk_id": 537,
      "source": "__internal__/data_repo/sanic/sanic/logging/deprecation.py",
      "content": "from warnings import warn\n\nfrom sanic.helpers import is_atty\nfrom sanic.logging.color import Colors"
    },
    {
      "chunk_id": 538,
      "source": "__internal__/data_repo/sanic/sanic/logging/deprecation.py",
      "content": "def deprecation(message: str, version: float):  # no cov\n    \"\"\"\n    Add a deprecation notice\n\n    Example when a feature is being removed. In this case, version\n    should be AT LEAST next version + 2\n\n    .. code-block:: python\n\n        deprecation(\"Helpful message\", 99.9)\n\n    Example when a feature is deprecated but not being removed:\n\n    .. code-block:: python\n\n        deprecation(\"Helpful message\", 0)\n\n    Args:\n        message (str): Deprecation message\n        version (float): Version when the feature will be removed\n    \"\"\"\n    version_display = f\" v{version}\" if version else \"\"\n    version_info = f\"[DEPRECATION{version_display}] \"\n    if is_atty():\n        version_info = f\"{Colors.RED}{version_info}\"\n        message = f\"{Colors.YELLOW}{message}{Colors.END}\"\n    warn(version_info + message, DeprecationWarning)"
    },
    {
      "chunk_id": 539,
      "source": "__internal__/data_repo/sanic/sanic/logging/color.py",
      "content": "import logging\nimport os\nimport sys\n\nfrom enum import Enum\nfrom typing import TYPE_CHECKING\n\nfrom sanic.helpers import is_atty\n\n\n# Python 3.11 changed the way Enum formatting works for mixed-in types.\nif sys.version_info < (3, 11, 0):\n\n    class StrEnum(str, Enum):\n        pass\n\nelse:\n    if not TYPE_CHECKING:\n        from enum import StrEnum"
    },
    {
      "chunk_id": 540,
      "source": "__internal__/data_repo/sanic/sanic/logging/color.py",
      "content": "COLORIZE = is_atty() and not os.environ.get(\"SANIC_NO_COLOR\")"
    },
    {
      "chunk_id": 541,
      "source": "__internal__/data_repo/sanic/sanic/logging/color.py",
      "content": "class Colors(StrEnum):  # no cov\n    \"\"\"\n    Colors for log messages. If the output is not a TTY, the colors will be\n    disabled.\n\n    Can be used like this:\n\n    .. code-block:: python\n\n        from sanic.log import logger, Colors\n\n        logger.info(f\"{Colors.GREEN}This is a green message{Colors.END}\")\n\n\n    Attributes:\n        END: Reset the color\n        BOLD: Bold text\n        BLUE: Blue text\n        GREEN: Green text\n        PURPLE: Purple text\n        RED: Red text\n        SANIC: Sanic pink\n        YELLOW: Yellow text\n        GREY: Grey text\n    \"\"\"\n\n    END = \"\\033[0m\" if COLORIZE else \"\"\n    BOLD = \"\\033[1m\" if COLORIZE else \"\"\n    BLUE = \"\\033[34m\" if COLORIZE else \"\"\n    GREEN = \"\\033[32m\" if COLORIZE else \"\"\n    PURPLE = \"\\033[35m\" if COLORIZE else \"\"\n    CYAN = \"\\033[36m\" if COLORIZE else \"\"\n    RED = \"\\033[31m\" if COLORIZE else \"\"\n    YELLOW = \"\\033[33m\" if COLORIZE else \"\"\n    GREY = \"\\033[38;5;240m\" if COLORIZE else \"\"\n    SANIC = \"\\033[38;2;255;13;104m\" if COLORIZE else \"\""
    },
    {
      "chunk_id": 542,
      "source": "__internal__/data_repo/sanic/sanic/logging/color.py",
      "content": "LEVEL_COLORS = {\n    logging.DEBUG: Colors.BLUE,\n    logging.WARNING: Colors.YELLOW,\n    logging.ERROR: Colors.RED,\n    logging.CRITICAL: Colors.RED + Colors.BOLD,\n}"
    },
    {
      "chunk_id": 543,
      "source": "__internal__/data_repo/sanic/sanic/logging/setup.py",
      "content": "import logging\nimport os\n\nfrom typing import Union\n\nfrom sanic.helpers import Default, _default\nfrom sanic.log import (\n    access_logger,\n    error_logger,\n    logger,\n    server_logger,\n    websockets_logger,\n)\nfrom sanic.logging.formatter import (\n    AutoAccessFormatter,\n    AutoFormatter,\n    DebugAccessFormatter,\n    DebugFormatter,\n    ProdAccessFormatter,\n    ProdFormatter,\n)"
    },
    {
      "chunk_id": 544,
      "source": "__internal__/data_repo/sanic/sanic/logging/setup.py",
      "content": "def setup_logging(\n    debug: bool,\n    no_color: bool = False,\n    log_extra: Union[bool, Default] = _default,\n) -> None:\n    if AutoFormatter.SETUP:\n        return\n\n    if isinstance(log_extra, Default):\n        log_extra = debug\n        os.environ[\"SANIC_LOG_EXTRA\"] = str(log_extra)\n    AutoFormatter.LOG_EXTRA = log_extra\n\n    if no_color:\n        os.environ[\"SANIC_NO_COLOR\"] = str(no_color)\n        AutoFormatter.NO_COLOR = no_color\n\n    AutoFormatter.SETUP = True\n\n    for lggr in (logger, server_logger, error_logger, websockets_logger):\n        _auto_format(\n            lggr,\n            AutoFormatter,\n            DebugFormatter if debug else ProdFormatter,\n        )\n    _auto_format(\n        access_logger,\n        AutoAccessFormatter,\n        DebugAccessFormatter if debug else ProdAccessFormatter,\n    )"
    },
    {
      "chunk_id": 545,
      "source": "__internal__/data_repo/sanic/sanic/logging/setup.py",
      "content": "def _auto_format(\n    logger: logging.Logger,\n    auto_class: type[AutoFormatter],\n    formatter_class: type[AutoFormatter],\n) -> None:\n    for handler in logger.handlers:\n        if type(handler.formatter) is auto_class:\n            handler.setFormatter(formatter_class())"
    },
    {
      "chunk_id": 546,
      "source": "__internal__/data_repo/sanic/sanic/logging/default.py",
      "content": "import sys"
    },
    {
      "chunk_id": 547,
      "source": "__internal__/data_repo/sanic/sanic/logging/default.py",
      "content": "from typing import Any"
    },
    {
      "chunk_id": 548,
      "source": "__internal__/data_repo/sanic/sanic/logging/default.py",
      "content": "LOGGING_CONFIG_DEFAULTS: dict[str, Any] = dict(  # no cov\n    version=1,\n    disable_existing_loggers=False,\n    loggers={\n        \"sanic.root\": {\"level\": \"INFO\", \"handlers\": [\"console\"]},\n        \"sanic.error\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"error_console\"],\n            \"propagate\": True,\n            \"qualname\": \"sanic.error\",\n        },\n        \"sanic.access\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"access_console\"],\n            \"propagate\": True,\n            \"qualname\": \"sanic.access\",\n        },\n        \"sanic.server\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\"],\n            \"propagate\": True,\n            \"qualname\": \"sanic.server\",\n        },\n        \"sanic.websockets\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\"],\n            \"propagate\": True,\n            \"qualname\": \"sanic.websockets\",\n        },\n    },\n    handlers={\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"generic\",\n            \"stream\": sys.stdout,\n        },\n        \"error_console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"generic\",\n            \"stream\": sys.stderr,\n        },\n        \"access_console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"access\",\n            \"stream\": sys.stdout,\n        },\n    },\n    formatters={\n        \"generic\": {\"class\": \"sanic.logging.formatter.AutoFormatter\"},\n        \"access\": {\"class\": \"sanic.logging.formatter.AutoAccessFormatter\"},\n    },\n)"
    },
    {
      "chunk_id": 549,
      "source": "__internal__/data_repo/sanic/sanic/logging/default.py",
      "content": "\"\"\"\nDefault logging configuration\n\"\"\""
    },
    {
      "chunk_id": 550,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport re\n\nfrom sanic.helpers import is_atty, json_dumps\nfrom sanic.logging.color import LEVEL_COLORS\nfrom sanic.logging.color import Colors as c"
    },
    {
      "chunk_id": 551,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "CONTROL_RE = re.compile(r\"\\033\\[[0-9;]*\\w\")\nCONTROL_LIMIT_IDENT = \"\\033[1000D\\033[{limit}C\"\nCONTROL_LIMIT_START = \"\\033[1000D\\033[{start}C\\033[K\"\nCONTROL_LIMIT_END = \"\\033[1000C\\033[{right}D\\033[K\"\nEXCEPTION_LINE_RE = re.compile(r\"^(?P<exc>.*?): (?P<message>.*)$\")\nFILE_LINE_RE = re.compile(\n    r\"File \\\"(?P<path>.*?)\\\", line (?P<line_num>\\d+), in (?P<location>.*)\"\n)\nDEFAULT_FIELDS = set(\n    logging.LogRecord(\"\", 0, \"\", 0, \"\", (), None).__dict__.keys()\n) | {\n    \"ident\",\n    \"message\",\n    \"asctime\",\n    \"right\",\n}"
    },
    {
      "chunk_id": 552,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class AutoFormatter(logging.Formatter):\n    \"\"\"\n    Automatically sets up the formatter based on the environment.\n\n    It will switch between the Debug and Production formatters based upon\n    how the environment is set up. Additionally, it will automatically\n    detect if the output is a TTY and colorize the output accordingly.\n    \"\"\"\n\n    SETUP = False\n    ATTY = is_atty()\n    NO_COLOR = os.environ.get(\"SANIC_NO_COLOR\", \"false\").lower() == \"true\"\n    LOG_EXTRA = os.environ.get(\"SANIC_LOG_EXTRA\", \"true\").lower() == \"true\"\n    IDENT = os.environ.get(\"SANIC_WORKER_IDENTIFIER\", \"Main \") or \"Main \"\n    DATE_FORMAT = \"%Y-%m-%d %H:%M:%S %z\"\n    IDENT_LIMIT = 5\n    MESSAGE_START = 42\n    PREFIX_FORMAT = (\n        f\"{c.GREY}%(ident)s{{limit}} %(asctime)s {c.END}\"\n        \"%(levelname)s: {start}\"\n    )\n    MESSAGE_FORMAT = \"%(message)s\"\n\n    def __init__(self, *args) -> None:\n        args_list = list(args)\n        if not args:\n            args_list.append(self._make_format())\n        elif args and not args[0]:\n            args_list[0] = self._make_format()\n        if len(args_list) < 2:\n            args_list.append(self.DATE_FORMAT)\n        elif not args[1]:\n            args_list[1] = self.DATE_FORMAT\n\n        super().__init__(*args_list)"
    },
    {
      "chunk_id": 553,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def format(self, record: logging.LogRecord) -> str:\n        record.ident = self.IDENT\n        self._set_levelname(record)\n        output = super().format(record)\n        if self.LOG_EXTRA:\n            output += self._log_extra(record)\n        return output"
    },
    {
      "chunk_id": 554,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _set_levelname(self, record: logging.LogRecord) -> None:\n        if (\n            self.ATTY\n            and not self.NO_COLOR\n            and (color := LEVEL_COLORS.get(record.levelno))\n        ):\n            record.levelname = f\"{color}{record.levelname}{c.END}\""
    },
    {
      "chunk_id": 555,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _make_format(self) -> str:\n        limit = CONTROL_LIMIT_IDENT.format(limit=self.IDENT_LIMIT)\n        start = CONTROL_LIMIT_START.format(start=self.MESSAGE_START)\n        base_format = self.PREFIX_FORMAT + self.MESSAGE_FORMAT\n        fmt = base_format.format(limit=limit, start=start)\n        if not self.ATTY or self.NO_COLOR:\n            return CONTROL_RE.sub(\"\", fmt)\n        return fmt"
    },
    {
      "chunk_id": 556,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _log_extra(self, record: logging.LogRecord, indent: int = 0) -> str:\n        extra_lines = [\"\"]\n\n        for key, value in record.__dict__.items():\n            if key not in DEFAULT_FIELDS:\n                extra_lines.append(self._format_key_value(key, value, indent))\n\n        return \"\\n\".join(extra_lines)"
    },
    {
      "chunk_id": 557,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _format_key_value(self, key, value, indent):\n        indentation = \" \" * indent\n        template = (\n            f\"{indentation}  {{c.YELLOW}}{{key}}{{c.END}}={{value}}\"\n            if self.ATTY and not self.NO_COLOR\n            else f\"{indentation}{{key}}={{value}}\"\n        )\n        if isinstance(value, dict):\n            nested_lines = [template.format(c=c, key=key, value=\"\")]\n            for nested_key, nested_value in value.items():\n                nested_lines.append(\n                    self._format_key_value(\n                        nested_key, nested_value, indent + 2\n                    )\n                )\n            return \"\\n\".join(nested_lines)\n        else:\n            return template.format(c=c, key=key, value=value)"
    },
    {
      "chunk_id": 558,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class DebugFormatter(AutoFormatter):\n    \"\"\"\n    The DebugFormatter is used for development and debugging purposes.\n\n    It can be used directly, or it will be automatically selected if the\n    environment is set up for development and is using the AutoFormatter.\n    \"\"\"\n\n    IDENT_LIMIT = 5\n    MESSAGE_START = 23\n    DATE_FORMAT = \"%H:%M:%S\""
    },
    {
      "chunk_id": 559,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _set_levelname(self, record: logging.LogRecord) -> None:\n        if len(record.levelname) > 5:\n            record.levelname = record.levelname[:4]\n        super()._set_levelname(record)"
    },
    {
      "chunk_id": 560,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def formatException(self, ei):  # no cov\n        orig = super().formatException(ei)\n        if not self.ATTY or self.NO_COLOR:\n            return orig\n        colored_traceback = []\n        lines = orig.splitlines()\n        for idx, line in enumerate(lines):\n            if line.startswith(\"  File\"):\n                line = self._color_file_line(line)\n            elif line.startswith(\"    \"):\n                line = self._color_code_line(line)\n            elif (\n                \"Error\" in line or \"Exception\" in line or len(lines) - 1 == idx\n            ):\n                line = self._color_exception_line(line)\n            colored_traceback.append(line)\n        return \"\\n\".join(colored_traceback)"
    },
    {
      "chunk_id": 561,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _color_exception_line(self, line: str) -> str:  # no cov\n        match = EXCEPTION_LINE_RE.match(line)\n        if not match:\n            return line\n        exc = match.group(\"exc\")\n        message = match.group(\"message\")\n        return f\"{c.SANIC}{c.BOLD}{exc}{c.END}: \" f\"{c.BOLD}{message}{c.END}\""
    },
    {
      "chunk_id": 562,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _color_file_line(self, line: str) -> str:  # no cov\n        match = FILE_LINE_RE.search(line)\n        if not match:\n            return line\n        path = match.group(\"path\")\n        line_num = match.group(\"line_num\")\n        location = match.group(\"location\")\n        return (\n            f'  File \"{path}\", line {c.CYAN}{c.BOLD}{line_num}{c.END}, '\n            f\"in {c.BLUE}{c.BOLD}{location}{c.END}\"\n        )"
    },
    {
      "chunk_id": 563,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _color_code_line(self, line: str) -> str:  # no cov\n        return f\"{c.YELLOW}{line}{c.END}\""
    },
    {
      "chunk_id": 564,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class ProdFormatter(AutoFormatter):\n    \"\"\"\n    The ProdFormatter is used for production environments.\n\n    It can be used directly, or it will be automatically selected if the\n    environment is set up for production and is using the AutoFormatter.\n    \"\"\""
    },
    {
      "chunk_id": 565,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class LegacyFormatter(AutoFormatter):\n    \"\"\"\n    The LegacyFormatter is used if you want to use the old style of logging.\n\n    You can use it as follows, typically in conjunction with the\n    LegacyAccessFormatter:\n\n    .. code-block:: python\n\n        from sanic.log import LOGGING_CONFIG_DEFAULTS\n\n        LOGGING_CONFIG_DEFAULTS[\"formatters\"] = {\n            \"generic\": {\n                \"class\": \"sanic.logging.formatter.LegacyFormatter\"\n            },\n            \"access\": {\n                \"class\": \"sanic.logging.formatter.LegacyAccessFormatter\"\n            },\n        }\n    \"\"\"\n\n    PREFIX_FORMAT = \"%(asctime)s [%(process)s] [%(levelname)s] \"\n    DATE_FORMAT = \"[%Y-%m-%d %H:%M:%S %z]\""
    },
    {
      "chunk_id": 566,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class AutoAccessFormatter(AutoFormatter):\n    MESSAGE_FORMAT = (\n        f\"{c.PURPLE}%(host)s \"\n        f\"{c.BLUE + c.BOLD}%(request)s{c.END} \"\n        f\"%(right)s%(status)s %(byte)s {c.GREY}%(duration)s{c.END}\"\n    )"
    },
    {
      "chunk_id": 567,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def format(self, record: logging.LogRecord) -> str:\n        status = len(str(getattr(record, \"status\", \"\")))\n        byte = len(str(getattr(record, \"byte\", \"\")))\n        duration = len(str(getattr(record, \"duration\", \"\")))\n        record.right = (\n            CONTROL_LIMIT_END.format(right=status + byte + duration + 1)\n            if self.ATTY\n            else \"\"\n        )\n        return super().format(record)"
    },
    {
      "chunk_id": 568,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def _set_levelname(self, record: logging.LogRecord) -> None:\n        if self.ATTY and record.levelno == logging.INFO:\n            record.levelname = f\"{c.SANIC}ACCESS{c.END}\""
    },
    {
      "chunk_id": 569,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class LegacyAccessFormatter(AutoAccessFormatter):\n    \"\"\"\n    The LegacyFormatter is used if you want to use the old style of logging.\n\n    You can use it as follows, typically in conjunction with the\n    LegacyFormatter:\n\n    .. code-block:: python\n\n        from sanic.log import LOGGING_CONFIG_DEFAULTS\n\n        LOGGING_CONFIG_DEFAULTS[\"formatters\"] = {\n            \"generic\": {\n                \"class\": \"sanic.logging.formatter.LegacyFormatter\"\n            },\n            \"access\": {\n                \"class\": \"sanic.logging.formatter.LegacyAccessFormatter\"\n            },\n        }\n    \"\"\"\n\n    PREFIX_FORMAT = \"%(asctime)s - (%(name)s)[%(levelname)s][%(host)s]: \"\n    MESSAGE_FORMAT = \"%(request)s %(message)s %(status)s %(byte)s\""
    },
    {
      "chunk_id": 570,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class DebugAccessFormatter(AutoAccessFormatter):\n    IDENT_LIMIT = 5\n    MESSAGE_START = 23\n    DATE_FORMAT = \"%H:%M:%S\"\n    LOG_EXTRA = False"
    },
    {
      "chunk_id": 571,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class ProdAccessFormatter(AutoAccessFormatter):\n    IDENT_LIMIT = 5\n    MESSAGE_START = 42\n    PREFIX_FORMAT = (\n        f\"{c.GREY}%(ident)s{{limit}}|%(asctime)s{c.END} \"\n        f\"%(levelname)s: {{start}}\"\n    )\n    MESSAGE_FORMAT = (\n        f\"{c.PURPLE}%(host)s {c.BLUE + c.BOLD}\"\n        f\"%(request)s{c.END} \"\n        f\"%(right)s%(status)s %(byte)s {c.GREY}%(duration)s{c.END}\"\n    )\n    LOG_EXTRA = False"
    },
    {
      "chunk_id": 572,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class JSONFormatter(AutoFormatter):\n    \"\"\"\n    The JSONFormatter is used to output logs in JSON format.\n\n    This is useful for logging to a file or to a log aggregator that\n    understands JSON. It will output all the fields from the LogRecord\n    as well as the extra fields that are passed in.\n\n    You can use it as follows:\n\n    .. code-block:: python\n\n        from sanic.log import LOGGING_CONFIG_DEFAULTS\n\n        LOGGING_CONFIG_DEFAULTS[\"formatters\"] = {\n            \"generic\": {\n                \"class\": \"sanic.logging.formatter.JSONFormatter\"\n            },\n            \"access\": {\n                \"class\": \"sanic.logging.formatter.JSONFormatter\"\n            },\n        }\n    \"\"\"\n\n    ATTY = False\n    NO_COLOR = True\n    FIELDS = [\n        \"name\",\n        \"levelno\",\n        \"pathname\",\n        \"module\",\n        \"filename\",\n        \"lineno\",\n    ]\n\n    dumps = json_dumps"
    },
    {
      "chunk_id": 573,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def format(self, record: logging.LogRecord) -> str:\n        return self.format_dict(self.to_dict(record))"
    },
    {
      "chunk_id": 574,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def to_dict(self, record: logging.LogRecord) -> dict:\n        base = {field: getattr(record, field, None) for field in self.FIELDS}\n        extra = {\n            key: value\n            for key, value in record.__dict__.items()\n            if key not in DEFAULT_FIELDS\n        }\n        info = {}\n        if record.exc_info:\n            info[\"exc_info\"] = self.formatException(record.exc_info)\n        if record.stack_info:\n            info[\"stack_info\"] = self.formatStack(record.stack_info)\n        return {\n            \"timestamp\": self.formatTime(record, self.datefmt),\n            \"level\": record.levelname,\n            \"message\": record.getMessage(),\n            **base,\n            **info,\n            **extra,\n        }"
    },
    {
      "chunk_id": 575,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def format_dict(self, record: dict) -> str:\n        return self.dumps(record)"
    },
    {
      "chunk_id": 576,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "class JSONAccessFormatter(JSONFormatter):\n    \"\"\"\n    The JSONAccessFormatter is used to output access logs in JSON format.\n\n    This is useful for logging to a file or to a log aggregator that\n    understands JSON. It will output all the fields from the LogRecord\n    as well as the extra fields that are passed in.\n\n    You can use it as follows:\n\n    .. code-block:: python\n\n        from sanic.log import LOGGING_CONFIG_DEFAULTS\n\n        LOGGING_CONFIG_DEFAULTS[\"formatters\"] = {\n            \"generic\": {\n                \"class\": \"sanic.logging.formatter.JSONFormatter\"\n            },\n            \"access\": {\n                \"class\": \"sanic.logging.formatter.JSONAccessFormatter\"\n            },\n        }\n    \"\"\"\n\n    FIELDS = [\n        \"host\",\n        \"request\",\n        \"status\",\n        \"byte\",\n        \"duration\",\n    ]"
    },
    {
      "chunk_id": 577,
      "source": "__internal__/data_repo/sanic/sanic/logging/formatter.py",
      "content": "def to_dict(self, record: logging.LogRecord) -> dict:\n        base = {field: getattr(record, field, None) for field in self.FIELDS}\n        return {\n            \"timestamp\": self.formatTime(record, self.datefmt),\n            \"level\": record.levelname,\n            \"message\": record.getMessage(),\n            **base,\n        }"
    },
    {
      "chunk_id": 578,
      "source": "__internal__/data_repo/sanic/sanic/logging/filter.py",
      "content": "import logging"
    },
    {
      "chunk_id": 579,
      "source": "__internal__/data_repo/sanic/sanic/logging/filter.py",
      "content": "class VerbosityFilter(logging.Filter):\n    \"\"\"\n    Filter log records based on verbosity level.\n    \"\"\"\n\n    verbosity: int = 0"
    },
    {
      "chunk_id": 580,
      "source": "__internal__/data_repo/sanic/sanic/logging/filter.py",
      "content": "def filter(self, record: logging.LogRecord) -> bool:\n        verbosity = getattr(record, \"verbosity\", 0)\n        return verbosity <= self.verbosity"
    },
    {
      "chunk_id": 581,
      "source": "__internal__/data_repo/sanic/sanic/models/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 582,
      "source": "__internal__/data_repo/sanic/sanic/models/http_types.py",
      "content": "from __future__ import annotations\n\nfrom base64 import b64decode\nfrom dataclasses import dataclass, field\nfrom typing import Optional"
    },
    {
      "chunk_id": 583,
      "source": "__internal__/data_repo/sanic/sanic/models/http_types.py",
      "content": "@dataclass()\nclass Credentials:\n    auth_type: Optional[str]\n    token: Optional[str]\n    _username: Optional[str] = field(default=None)\n    _password: Optional[str] = field(default=None)\n\n    def __post_init__(self):\n        if self._auth_is_basic:\n            self._username, self._password = (\n                b64decode(self.token.encode(\"utf-8\")).decode().split(\":\")\n            )"
    },
    {
      "chunk_id": 584,
      "source": "__internal__/data_repo/sanic/sanic/models/http_types.py",
      "content": "@property\n    def username(self):\n        if not self._auth_is_basic:\n            raise AttributeError(\"Username is available for Basic Auth only\")\n        return self._username"
    },
    {
      "chunk_id": 585,
      "source": "__internal__/data_repo/sanic/sanic/models/http_types.py",
      "content": "@property\n    def password(self):\n        if not self._auth_is_basic:\n            raise AttributeError(\"Password is available for Basic Auth only\")\n        return self._password"
    },
    {
      "chunk_id": 586,
      "source": "__internal__/data_repo/sanic/sanic/models/http_types.py",
      "content": "@property\n    def _auth_is_basic(self) -> bool:\n        return self.auth_type == \"Basic\""
    },
    {
      "chunk_id": 587,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "import asyncio\n\nfrom collections.abc import Awaitable, MutableMapping\nfrom typing import Any, Callable, Optional, Union\n\nfrom sanic.exceptions import BadRequest\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.server.websockets.connection import WebSocketConnection\n\n\nASGIScope = MutableMapping[str, Any]\nASGIMessage = MutableMapping[str, Any]\nASGISend = Callable[[ASGIMessage], Awaitable[None]]\nASGIReceive = Callable[[], Awaitable[ASGIMessage]]"
    },
    {
      "chunk_id": 588,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "class MockProtocol:  # no cov\n    def __init__(self, transport: \"MockTransport\", loop):\n        self.transport = transport\n        self._not_paused = asyncio.Event()\n        self._not_paused.set()\n        self._complete = asyncio.Event()"
    },
    {
      "chunk_id": 589,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def pause_writing(self) -> None:\n        self._not_paused.clear()"
    },
    {
      "chunk_id": 590,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def resume_writing(self) -> None:\n        self._not_paused.set()"
    },
    {
      "chunk_id": 591,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "async def complete(self) -> None:\n        self._not_paused.set()\n        await self.transport.send(\n            {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n        )"
    },
    {
      "chunk_id": 592,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "@property\n    def is_complete(self) -> bool:\n        return self._complete.is_set()"
    },
    {
      "chunk_id": 593,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "async def push_data(self, data: bytes) -> None:\n        if not self.is_complete:\n            await self.transport.send(\n                {\"type\": \"http.response.body\", \"body\": data, \"more_body\": True}\n            )"
    },
    {
      "chunk_id": 594,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "async def drain(self) -> None:\n        await self._not_paused.wait()"
    },
    {
      "chunk_id": 595,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "class MockTransport(TransportProtocol):  # no cov\n    _protocol: Optional[MockProtocol]\n\n    def __init__(\n        self, scope: ASGIScope, receive: ASGIReceive, send: ASGISend\n    ) -> None:\n        self.scope = scope\n        self._receive = receive\n        self._send = send\n        self._protocol = None\n        self.loop: Optional[asyncio.AbstractEventLoop] = None"
    },
    {
      "chunk_id": 596,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def get_protocol(self) -> MockProtocol:  # type: ignore\n        if not self._protocol:\n            self._protocol = MockProtocol(self, self.loop)\n        return self._protocol"
    },
    {
      "chunk_id": 597,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def get_extra_info(\n        self, info: str, default=None\n    ) -> Optional[Union[str, bool]]:\n        if info == \"peername\":\n            return self.scope.get(\"client\")\n        elif info == \"sslcontext\":\n            return self.scope.get(\"scheme\") in [\"https\", \"wss\"]\n        return default"
    },
    {
      "chunk_id": 598,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def get_websocket_connection(self) -> WebSocketConnection:\n        try:\n            return self._websocket_connection\n        except AttributeError:\n            raise BadRequest(\"Improper websocket connection.\")"
    },
    {
      "chunk_id": 599,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def create_websocket_connection(\n        self, send: ASGISend, receive: ASGIReceive\n    ) -> WebSocketConnection:\n        self._websocket_connection = WebSocketConnection(\n            send, receive, self.scope.get(\"subprotocols\", [])\n        )\n        return self._websocket_connection"
    },
    {
      "chunk_id": 600,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "def add_task(self) -> None:\n        raise NotImplementedError"
    },
    {
      "chunk_id": 601,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "async def send(self, data) -> None:\n        # TODO:\n        # - Validation on data and that it is formatted properly and is valid\n        await self._send(data)"
    },
    {
      "chunk_id": 602,
      "source": "__internal__/data_repo/sanic/sanic/models/asgi.py",
      "content": "async def receive(self) -> ASGIMessage:\n        return await self._receive()"
    },
    {
      "chunk_id": 603,
      "source": "__internal__/data_repo/sanic/sanic/models/server_types.py",
      "content": "from __future__ import annotations\n\nfrom ssl import SSLContext, SSLObject\nfrom types import SimpleNamespace\nfrom typing import Any, Optional\n\nfrom sanic.models.protocol_types import TransportProtocol"
    },
    {
      "chunk_id": 604,
      "source": "__internal__/data_repo/sanic/sanic/models/server_types.py",
      "content": "class Signal:\n    stopped = False"
    },
    {
      "chunk_id": 605,
      "source": "__internal__/data_repo/sanic/sanic/models/server_types.py",
      "content": "class ConnInfo:\n    \"\"\"\n    Local and remote addresses and SSL status info.\n    \"\"\"\n\n    __slots__ = (\n        \"client_port\",\n        \"client\",\n        \"client_ip\",\n        \"ctx\",\n        \"lost\",\n        \"peername\",\n        \"server_port\",\n        \"server\",\n        \"server_name\",\n        \"sockname\",\n        \"ssl\",\n        \"cert\",\n        \"network_paths\",\n    )\n\n    def __init__(self, transport: TransportProtocol, unix=None):\n        self.ctx = SimpleNamespace()\n        self.lost = False\n        self.peername: Optional[tuple[str, int]] = None\n        self.server = self.client = \"\"\n        self.server_port = self.client_port = 0\n        self.client_ip = \"\"\n        self.sockname = addr = transport.get_extra_info(\"sockname\")\n        self.ssl = False\n        self.server_name = \"\"\n        self.cert: dict[str, Any] = {}\n        self.network_paths: list[Any] = []\n        sslobj: Optional[SSLObject] = transport.get_extra_info(\"ssl_object\")  # type: ignore\n        sslctx: Optional[SSLContext] = transport.get_extra_info(\"ssl_context\")  # type: ignore\n        if sslobj:\n            self.ssl = True\n            self.server_name = getattr(sslobj, \"sanic_server_name\", None) or \"\"\n            self.cert = dict(getattr(sslobj.context, \"sanic\", {}))\n        if sslctx and not self.cert:\n            self.cert = dict(getattr(sslctx, \"sanic\", {}))\n        if isinstance(addr, str):  # UNIX socket\n            self.server = unix or addr\n            return\n        # IPv4 (ip, port) or IPv6 (ip, port, flowinfo, scopeid)\n        if isinstance(addr, tuple):\n            self.server = addr[0] if len(addr) == 2 else f\"[{addr[0]}]\"\n            self.server_port = addr[1]\n            # self.server gets non-standard port appended\n            if addr[1] != (443 if self.ssl else 80):\n                self.server = f\"{self.server}:{addr[1]}\"\n        self.peername = addr = transport.get_extra_info(\"peername\")\n        self.network_paths = transport.get_extra_info(\"network_paths\")  # type: ignore"
    },
    {
      "chunk_id": 606,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "from collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Callable, NamedTuple, Optional, Union\n\nfrom sanic.handlers.directory import DirectoryHandler\nfrom sanic.models.handler_types import (\n    ErrorMiddlewareType,\n    ListenerType,\n    MiddlewareType,\n    SignalHandler,\n)\nfrom sanic.types import HashableDict"
    },
    {
      "chunk_id": 607,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureRoute(NamedTuple):\n    handler: str\n    uri: str\n    methods: Optional[Iterable[str]]\n    host: Union[str, list[str]]\n    strict_slashes: bool\n    stream: bool\n    version: Optional[int]\n    name: str\n    ignore_body: bool\n    websocket: bool\n    subprotocols: Optional[list[str]]\n    unquote: bool\n    static: bool\n    version_prefix: str\n    error_format: Optional[str]\n    route_context: HashableDict"
    },
    {
      "chunk_id": 608,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureListener(NamedTuple):\n    listener: ListenerType\n    event: str\n    priority: int"
    },
    {
      "chunk_id": 609,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureMiddleware(NamedTuple):\n    middleware: MiddlewareType\n    attach_to: str"
    },
    {
      "chunk_id": 610,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureException(NamedTuple):\n    handler: ErrorMiddlewareType\n    exceptions: list[BaseException]"
    },
    {
      "chunk_id": 611,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureStatic(NamedTuple):\n    uri: str\n    file_or_directory: Path\n    pattern: str\n    use_modified_since: bool\n    use_content_range: bool\n    stream_large_files: Union[bool, int]\n    name: str\n    host: Optional[str]\n    strict_slashes: Optional[bool]\n    content_type: Optional[str]\n    resource_type: Optional[str]\n    directory_handler: DirectoryHandler"
    },
    {
      "chunk_id": 612,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureSignal(NamedTuple):\n    handler: SignalHandler\n    event: str\n    condition: Optional[dict[str, str]]\n    exclusive: bool\n    priority: int"
    },
    {
      "chunk_id": 613,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureRegistry(set): ..."
    },
    {
      "chunk_id": 614,
      "source": "__internal__/data_repo/sanic/sanic/models/futures.py",
      "content": "class FutureCommand(NamedTuple):\n    name: str\n    func: Callable"
    },
    {
      "chunk_id": 615,
      "source": "__internal__/data_repo/sanic/sanic/models/protocol_types.py",
      "content": "from __future__ import annotations\n\nfrom asyncio import BaseTransport\nfrom typing import TYPE_CHECKING, Optional, Union\n\n\nif TYPE_CHECKING:\n    from sanic.http.constants import HTTP\n    from sanic.models.asgi import ASGIScope\n\n\n# Protocol is a 3.8+ feature\nfrom typing import Protocol"
    },
    {
      "chunk_id": 616,
      "source": "__internal__/data_repo/sanic/sanic/models/protocol_types.py",
      "content": "class HTMLProtocol(Protocol):\n    def __html__(self) -> Union[str, bytes]: ...\n\n    def _repr_html_(self) -> Union[str, bytes]: ..."
    },
    {
      "chunk_id": 617,
      "source": "__internal__/data_repo/sanic/sanic/models/protocol_types.py",
      "content": "class Range(Protocol):\n    start: Optional[int]\n    end: Optional[int]\n    size: Optional[int]\n    total: Optional[int]\n    __slots__ = ()"
    },
    {
      "chunk_id": 618,
      "source": "__internal__/data_repo/sanic/sanic/models/protocol_types.py",
      "content": "class TransportProtocol(BaseTransport):\n    scope: ASGIScope\n    version: HTTP\n    __slots__ = ()"
    },
    {
      "chunk_id": 619,
      "source": "__internal__/data_repo/sanic/sanic/models/handler_types.py",
      "content": "from asyncio.events import AbstractEventLoop\nfrom collections.abc import Coroutine\nfrom typing import Any, Callable, Optional, TypeVar, Union\n\nimport sanic\n\nfrom sanic import request\nfrom sanic.response import BaseHTTPResponse, HTTPResponse"
    },
    {
      "chunk_id": 620,
      "source": "__internal__/data_repo/sanic/sanic/models/handler_types.py",
      "content": "Sanic = TypeVar(\"Sanic\", bound=\"sanic.Sanic\")\nRequest = TypeVar(\"Request\", bound=\"request.Request\")\n\nMiddlewareResponse = Union[\n    Optional[HTTPResponse], Coroutine[Any, Any, Optional[HTTPResponse]]\n]\nRequestMiddlewareType = Callable[[Request], MiddlewareResponse]\nResponseMiddlewareType = Callable[\n    [Request, BaseHTTPResponse], MiddlewareResponse\n]\nErrorMiddlewareType = Callable[\n    [Request, BaseException], Optional[Coroutine[Any, Any, None]]\n]\nMiddlewareType = Union[RequestMiddlewareType, ResponseMiddlewareType]\nListenerType = Union[\n    Callable[[Sanic], Optional[Coroutine[Any, Any, None]]],\n    Callable[[Sanic, AbstractEventLoop], Optional[Coroutine[Any, Any, None]]],\n]\nRouteHandler = Callable[..., Coroutine[Any, Any, Optional[HTTPResponse]]]\nSignalHandler = Callable[..., Coroutine[Any, Any, None]]"
    },
    {
      "chunk_id": 621,
      "source": "__internal__/data_repo/sanic/sanic/mixins/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 622,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "from collections import deque\nfrom functools import partial\nfrom operator import attrgetter\nfrom typing import Callable, Union, overload\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.middleware import Middleware, MiddlewareLocation\nfrom sanic.models.futures import FutureMiddleware, MiddlewareType\nfrom sanic.router import Router"
    },
    {
      "chunk_id": 623,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "class MiddlewareMixin(metaclass=SanicMeta):\n    \"\"\"Middleware mixin for Sanic applications.\"\"\"\n    \n    router: Router\n\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_middleware: list[FutureMiddleware] = []"
    },
    {
      "chunk_id": 624,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "def _apply_middleware(self, middleware: FutureMiddleware):\n        raise NotImplementedError  # noqa"
    },
    {
      "chunk_id": 625,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "@overload\n    def middleware(\n        self,\n        middleware_or_request: MiddlewareType,\n        attach_to: str = \"request\",\n        apply: bool = True,\n        *,\n        priority: int = 0,\n    ) -> MiddlewareType: ..."
    },
    {
      "chunk_id": 626,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "@overload\n    def middleware(\n        self,\n        middleware_or_request: str,\n        attach_to: str = \"request\",\n        apply: bool = True,\n        *,\n        priority: int = 0,\n    ) -> Callable[[MiddlewareType], MiddlewareType]: ..."
    },
    {
      "chunk_id": 627,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "def middleware(\n        self,\n        middleware_or_request: Union[MiddlewareType, str],\n        attach_to: str = \"request\",\n        apply: bool = True,\n        *,\n        priority: int = 0,\n    ) -> Union[MiddlewareType, Callable[[MiddlewareType], MiddlewareType]]:\n        \"\"\"Decorator for registering middleware.\"\"\"\n        \n        def register_middleware(middleware, attach_to=\"request\"):\n            nonlocal apply\n\n            location = (\n                MiddlewareLocation.REQUEST\n                if attach_to == \"request\"\n                else MiddlewareLocation.RESPONSE\n            )\n            middleware = Middleware(middleware, location, priority=priority)\n            future_middleware = FutureMiddleware(middleware, attach_to)\n            self._future_middleware.append(future_middleware)\n            if apply:\n                self._apply_middleware(future_middleware)\n            return middleware\n\n        if callable(middleware_or_request):\n            return register_middleware(\n                middleware_or_request, attach_to=attach_to\n            )\n        else:\n            return partial(\n                register_middleware, attach_to=middleware_or_request\n            )"
    },
    {
      "chunk_id": 628,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "def on_request(self, middleware=None, *, priority=0) -> MiddlewareType:\n        \"\"\"Register a middleware to be called before a request is handled.\"\"\"\n        \n        if callable(middleware):\n            return self.middleware(middleware, \"request\", priority=priority)\n        else:\n            return partial(  # type: ignore\n                self.middleware, attach_to=\"request\", priority=priority\n            )"
    },
    {
      "chunk_id": 629,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "def on_response(self, middleware=None, *, priority=0):\n        \"\"\"Register a middleware to be called after a response is created.\"\"\"\n        \n        if callable(middleware):\n            return self.middleware(middleware, \"response\", priority=priority)\n        else:\n            return partial(\n                self.middleware, attach_to=\"response\", priority=priority\n            )"
    },
    {
      "chunk_id": 630,
      "source": "__internal__/data_repo/sanic/sanic/mixins/middleware.py",
      "content": "def finalize_middleware(self) -> None:\n        \"\"\"Finalize the middleware configuration for the Sanic application.\"\"\"\n        \n        for route in self.router.routes:\n            request_middleware = Middleware.convert(\n                self.request_middleware,  # type: ignore\n                self.named_request_middleware.get(route.name, deque()),  # type: ignore  # noqa: E501\n                location=MiddlewareLocation.REQUEST,\n            )\n            response_middleware = Middleware.convert(\n                self.response_middleware,  # type: ignore\n                self.named_response_middleware.get(route.name, deque()),  # type: ignore  # noqa: E501\n                location=MiddlewareLocation.RESPONSE,\n            )\n            route.extra.request_middleware = deque(\n                sorted(\n                    request_middleware,\n                    key=attrgetter(\"order\"),\n                    reverse=True,\n                )\n            )\n            route.extra.response_middleware = deque(\n                sorted(\n                    response_middleware,\n                    key=attrgetter(\"order\"),\n                    reverse=True,\n                )[::-1]\n            )\n        request_middleware = Middleware.convert(\n            self.request_middleware,  # type: ignore\n            location=MiddlewareLocation.REQUEST,\n        )\n        response_middleware = Middleware.convert(\n            self.response_middleware,  # type: ignore\n            location=MiddlewareLocation.RESPONSE,\n        )\n        self.request_middleware = deque(\n            sorted(\n                request_middleware,\n                key=attrgetter(\"order\"),\n                reverse=True,\n            )\n        )\n        self.response_middleware = deque(\n            sorted(\n                response_middleware,\n                key=attrgetter(\"order\"),\n                reverse=True,\n            )[::-1]\n        )"
    },
    {
      "chunk_id": 631,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "from enum import Enum, auto\nfrom functools import partial\nfrom typing import Callable, Optional, Union, cast, overload\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.exceptions import BadRequest\nfrom sanic.models.futures import FutureListener\nfrom sanic.models.handler_types import ListenerType, Sanic"
    },
    {
      "chunk_id": 632,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "class ListenerEvent(str, Enum):\n    def _generate_next_value_(name: str, *args) -> str:  # type: ignore\n        return name.lower()\n\n    BEFORE_SERVER_START = \"server.init.before\"\n    AFTER_SERVER_START = \"server.init.after\"\n    BEFORE_SERVER_STOP = \"server.shutdown.before\"\n    AFTER_SERVER_STOP = \"server.shutdown.after\"\n    MAIN_PROCESS_START = auto()\n    MAIN_PROCESS_READY = auto()\n    MAIN_PROCESS_STOP = auto()\n    RELOAD_PROCESS_START = auto()\n    RELOAD_PROCESS_STOP = auto()\n    BEFORE_RELOAD_TRIGGER = auto()\n    AFTER_RELOAD_TRIGGER = auto()"
    },
    {
      "chunk_id": 633,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "class ListenerMixin(metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_listeners: list[FutureListener] = []"
    },
    {
      "chunk_id": 634,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def _apply_listener(self, listener: FutureListener):\n        raise NotImplementedError  # noqa"
    },
    {
      "chunk_id": 635,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "@overload\n    def listener(\n        self,\n        listener_or_event: ListenerType[Sanic],\n        event_or_none: str,\n        apply: bool = ...,\n        *,\n        priority: int = 0,\n    ) -> ListenerType[Sanic]: ..."
    },
    {
      "chunk_id": 636,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "@overload\n    def listener(\n        self,\n        listener_or_event: str,\n        event_or_none: None = ...,\n        apply: bool = ...,\n        *,\n        priority: int = 0,\n    ) -> Callable[[ListenerType[Sanic]], ListenerType[Sanic]]: ..."
    },
    {
      "chunk_id": 637,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def listener(\n        self,\n        listener_or_event: Union[ListenerType[Sanic], str],\n        event_or_none: Optional[str] = None,\n        apply: bool = True,\n        *,\n        priority: int = 0,\n    ) -> Union[\n        ListenerType[Sanic],\n        Callable[[ListenerType[Sanic]], ListenerType[Sanic]],\n    ]:\n        \"\"\"Create a listener for a specific event in the application's lifecycle.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        .. note::\n            Overloaded signatures allow for different ways of calling this method, depending on the types of the arguments.\n\n            Usually, it is prederred to use one of the convenience methods such as `before_server_start` or `after_server_stop` instead of calling this method directly.\n\n            ```python\n            @app.before_server_start\n            async def prefered_method(_):\n                ...\n\n            @app.listener(\"before_server_start\")\n            async def not_prefered_method(_):\n                ...\n\n        Args:\n            listener_or_event (Union[ListenerType[Sanic], str]): A listener function or an event name.\n            event_or_none (Optional[str]): The event name to listen for if `listener_or_event` is a function. Defaults to `None`.\n            apply (bool): Whether to apply the listener immediately. Defaults to `True`.\n            priority (int): The priority of the listener. Defaults to `0`.\n\n        Returns:\n            Union[ListenerType[Sanic], Callable[[ListenerType[Sanic]], ListenerType[Sanic]]]: The listener or a callable that takes a listener.\n\n        Example:\n            The following code snippet shows how you can use this method as a decorator:\n\n            ```python\n            @bp.listener(\"before_server_start\")\n            async def before_server_start(app, loop):\n                ...\n            ```\n        \"\"\"  # noqa: E501"
    },
    {
      "chunk_id": 638,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def register_listener(\n            listener: ListenerType[Sanic], event: str, priority: int = 0\n        ) -> ListenerType[Sanic]:\n            \"\"\"A helper function to register a listener for an event.\n\n            Typically will not be called directly.\n\n            Args:\n                listener (ListenerType[Sanic]): The listener function to\n                    register.\n                event (str): The event name to listen for.\n\n            Returns:\n                ListenerType[Sanic]: The listener function that was registered.\n            \"\"\"\n            nonlocal apply\n\n            future_listener = FutureListener(listener, event, priority)\n            self._future_listeners.append(future_listener)\n            if apply:\n                self._apply_listener(future_listener)\n            return listener"
    },
    {
      "chunk_id": 639,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "if callable(listener_or_event):\n            if event_or_none is None:\n                raise BadRequest(\n                    \"Invalid event registration: Missing event name.\"\n                )\n            return register_listener(\n                listener_or_event, event_or_none, priority\n            )\n        else:\n            return partial(\n                register_listener, event=listener_or_event, priority=priority\n            )"
    },
    {
      "chunk_id": 640,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def _setup_listener(\n        self,\n        listener: Optional[ListenerType[Sanic]],\n        event: str,\n        priority: int,\n    ) -> ListenerType[Sanic]:\n        if listener is not None:\n            return self.listener(listener, event, priority=priority)\n        return cast(\n            ListenerType[Sanic],\n            partial(self.listener, event_or_none=event, priority=priority),\n        )"
    },
    {
      "chunk_id": 641,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def main_process_start(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the main_process_start event.\n\n        This event is fired only on the main process and **NOT** on any\n        worker processes. You should typically use this event to initialize\n        resources that are shared across workers, or to initialize resources\n        that are not safe to be initialized in a worker process.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.main_process_start\n            async def on_main_process_start(app: Sanic):\n                print(\"Main process started\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"main_process_start\", priority)"
    },
    {
      "chunk_id": 642,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def main_process_ready(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the main_process_ready event.\n\n        This event is fired only on the main process and **NOT** on any\n        worker processes. It is fired after the main process has started and\n        the Worker Manager has been initialized (ie, you will have access to\n        `app.manager` instance). The typical use case for this event is to\n        add a managed process to the Worker Manager.\n\n        See [Running custom processes](/en/guide/deployment/manager.html#running-custom-processes) and [Listeners](/en/guide/basics/listeners.html) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.main_process_ready\n            async def on_main_process_ready(app: Sanic):\n                print(\"Main process ready\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"main_process_ready\", priority)"
    },
    {
      "chunk_id": 643,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def main_process_stop(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the main_process_stop event.\n\n        This event is fired only on the main process and **NOT** on any\n        worker processes. You should typically use this event to clean up\n        resources that were initialized in the main_process_start event.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.main_process_stop\n            async def on_main_process_stop(app: Sanic):\n                print(\"Main process stopped\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"main_process_stop\", priority)"
    },
    {
      "chunk_id": 644,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def reload_process_start(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the reload_process_start event.\n\n        This event is fired only on the reload process and **NOT** on any\n        worker processes. This is similar to the main_process_start event,\n        except that it is fired only when the reload process is started.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.reload_process_start\n            async def on_reload_process_start(app: Sanic):\n                print(\"Reload process started\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"reload_process_start\", priority)"
    },
    {
      "chunk_id": 645,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def reload_process_stop(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the reload_process_stop event.\n\n        This event is fired only on the reload process and **NOT** on any\n        worker processes. This is similar to the main_process_stop event,\n        except that it is fired only when the reload process is stopped.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.reload_process_stop\n            async def on_reload_process_stop(app: Sanic):\n                print(\"Reload process stopped\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"reload_process_stop\", priority)"
    },
    {
      "chunk_id": 646,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def before_reload_trigger(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the before_reload_trigger event.\n\n        This event is fired only on the reload process and **NOT** on any\n        worker processes. This event is fired before the reload process\n        triggers the reload. A change event has been detected and the reload\n        process is about to be triggered.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.before_reload_trigger\n            async def on_before_reload_trigger(app: Sanic):\n                print(\"Before reload trigger\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(\n            listener, \"before_reload_trigger\", priority\n        )"
    },
    {
      "chunk_id": 647,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def after_reload_trigger(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the after_reload_trigger event.\n\n        This event is fired only on the reload process and **NOT** on any\n        worker processes. This event is fired after the reload process\n        triggers the reload. A change event has been detected and the reload\n        process has been triggered.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.after_reload_trigger\n            async def on_after_reload_trigger(app: Sanic, changed: set[str]):\n                print(\"After reload trigger, changed files: \", changed)\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"after_reload_trigger\", priority)"
    },
    {
      "chunk_id": 648,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def before_server_start(\n        self,\n        listener: Optional[ListenerType[Sanic]] = None,\n        *,\n        priority: int = 0,\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the before_server_start event.\n\n        This event is fired on all worker processes. You should typically\n        use this event to initialize resources that are global in nature, or\n        will be shared across requests and various parts of the application.\n\n        A common use case for this event is to initialize a database connection\n        pool, or to initialize a cache client.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.before_server_start\n            async def on_before_server_start(app: Sanic):\n                print(\"Before server start\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"before_server_start\", priority)"
    },
    {
      "chunk_id": 649,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def after_server_start(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the after_server_start event.\n\n        This event is fired on all worker processes. You should typically\n        use this event to run background tasks, or perform other actions that\n        are not directly related to handling requests. In theory, it is\n        possible that some requests may be handled before this event is fired,\n        so you should not use this event to initialize resources that are\n        required for handling requests.\n\n        A common use case for this event is to start a background task that\n        periodically performs some action, such as clearing a cache or\n        performing a health check.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.after_server_start\n            async def on_after_server_start(app: Sanic):\n                print(\"After server start\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"after_server_start\", priority)"
    },
    {
      "chunk_id": 650,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def before_server_stop(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the before_server_stop event.\n\n        This event is fired on all worker processes. This event is fired\n        before the server starts shutting down. You should not use this event\n        to perform any actions that are required for handling requests, as\n        some requests may continue to be handled after this event is fired.\n\n        A common use case for this event is to stop a background task that\n        was started in the after_server_start event.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.before_server_stop\n            async def on_before_server_stop(app: Sanic):\n                print(\"Before server stop\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"before_server_stop\", priority)"
    },
    {
      "chunk_id": 651,
      "source": "__internal__/data_repo/sanic/sanic/mixins/listeners.py",
      "content": "def after_server_stop(\n        self, listener: Optional[ListenerType[Sanic]], *, priority: int = 0\n    ) -> ListenerType[Sanic]:\n        \"\"\"Decorator for registering a listener for the after_server_stop event.\n\n        This event is fired on all worker processes. This event is fired\n        after the server has stopped shutting down, and all requests have\n        been handled. You should typically use this event to clean up\n        resources that were initialized in the before_server_start event.\n\n        A common use case for this event is to close a database connection\n        pool, or to close a cache client.\n\n        See [Listeners](/en/guide/basics/listeners) for more details.\n\n        Args:\n            listener (ListenerType[Sanic]): The listener handler to attach.\n\n        Examples:\n            ```python\n            @app.after_server_stop\n            async def on_after_server_stop(app: Sanic):\n                print(\"After server stop\")\n            ```\n        \"\"\"  # noqa: E501\n        return self._setup_listener(listener, \"after_server_stop\", priority)"
    },
    {
      "chunk_id": 652,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "from typing import Optional, Protocol, Union\n\nfrom sanic.base.meta import SanicMeta"
    },
    {
      "chunk_id": 653,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "class NameProtocol(Protocol):\n    name: str"
    },
    {
      "chunk_id": 654,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "class DunderNameProtocol(Protocol):\n    __name__: str"
    },
    {
      "chunk_id": 655,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "class BaseMixin(metaclass=SanicMeta):\n    \"\"\"Base class for various mixins.\"\"\"\n\n    name: str\n    strict_slashes: Optional[bool]"
    },
    {
      "chunk_id": 656,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "def _generate_name(\n        self, *objects: Union[NameProtocol, DunderNameProtocol, str]\n    ) -> str:\n        name: Optional[str] = None\n        for obj in objects:\n            if not obj:\n                continue\n            if isinstance(obj, str):\n                name = obj\n            else:\n                name = getattr(obj, \"name\", getattr(obj, \"__name__\", None))\n\n            if name:\n                break\n        if not name or not isinstance(name, str):\n            raise ValueError(\"Could not generate a name for handler\")\n\n        if not name.startswith(f\"{self.name}.\"):\n            name = f\"{self.name}.{name}\"\n\n        return name"
    },
    {
      "chunk_id": 657,
      "source": "__internal__/data_repo/sanic/sanic/mixins/base.py",
      "content": "def generate_name(self, *objects) -> str:\n        return self._generate_name(*objects)"
    },
    {
      "chunk_id": 658,
      "source": "__internal__/data_repo/sanic/sanic/mixins/commands.py",
      "content": "from __future__ import annotations\n\nfrom functools import wraps\nfrom inspect import isawaitable\nfrom typing import Callable, Optional, Union\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.models.futures import FutureCommand"
    },
    {
      "chunk_id": 659,
      "source": "__internal__/data_repo/sanic/sanic/mixins/commands.py",
      "content": "class CommandMixin(metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_commands: set[FutureCommand] = set()"
    },
    {
      "chunk_id": 660,
      "source": "__internal__/data_repo/sanic/sanic/mixins/commands.py",
      "content": "def command(\n        self, maybe_func: Optional[Callable] = None, *, name: str = \"\"\n    ) -> Union[Callable, Callable[[Callable], Callable]]:\n        def decorator(f):\n            @wraps(f)\n            async def decorated_function(*args, **kwargs):\n                response = f(*args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n                return response\n\n            self._future_commands.add(\n                FutureCommand(name or f.__name__, decorated_function)\n            )\n            return decorated_function\n\n        return decorator(maybe_func) if maybe_func else decorator"
    },
    {
      "chunk_id": 661,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "from ast import NodeVisitor, Return, parse\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom inspect import getsource, signature\nfrom textwrap import dedent\nfrom typing import (\n    Any,\n    Callable,\n    Optional,\n    Union,\n    cast,\n)\n\nfrom sanic_routing.route import Route\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.constants import HTTP_METHODS\nfrom sanic.errorpages import RESPONSE_MAPPING\nfrom sanic.mixins.base import BaseMixin\nfrom sanic.models.futures import FutureRoute, FutureStatic\nfrom sanic.models.handler_types import RouteHandler\nfrom sanic.types import HashableDict"
    },
    {
      "chunk_id": 662,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "RouteWrapper = Callable[\n    [RouteHandler], Union[RouteHandler, tuple[Route, RouteHandler]]\n]"
    },
    {
      "chunk_id": 663,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "class RouteMixin(BaseMixin, metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_routes: set[FutureRoute] = set()\n        self._future_statics: set[FutureStatic] = set()"
    },
    {
      "chunk_id": 664,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def _apply_route(self, route: FutureRoute) -> list[Route]:\n        raise NotImplementedError  # noqa"
    },
    {
      "chunk_id": 665,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def route(\n        self,\n        uri: str,\n        methods: Optional[Iterable[str]] = None,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = False,\n        apply: bool = True,\n        subprotocols: Optional[list[str]] = None,\n        websocket: bool = False,\n        unquote: bool = False,\n        static: bool = False,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteWrapper:\n        \"\"\"Decorate a function to be registered as a route.\n\n        Args:\n            uri (str): Path of the URL.\n            methods (Optional[Iterable[str]]): List or tuple of\n                methods allowed.\n            host (Optional[Union[str, List[str]]]): The host, if required.\n            strict_slashes (Optional[bool]): Whether to apply strict slashes\n                to the route.\n            stream (bool): Whether to allow the request to stream its body.\n            version (Optional[Union[int, str, float]]): Route specific\n                versioning.\n            name (Optional[str]): User-defined route name for url_for.\n            ignore_body (bool): Whether the handler should ignore request\n                body (e.g. `GET` requests).\n            apply (bool): Apply middleware to the route.\n            subprotocols (Optional[List[str]]): List of subprotocols.\n            websocket (bool): Enable WebSocket support.\n            unquote (bool): Unquote special characters in the URL path.\n            static (bool): Enable static route.\n            version_prefix (str): URL path that should be before the version\n                 value; default: `\"/v\"`.\n            error_format (Optional[str]): Error format for the route.\n            ctx_kwargs (Any): Keyword arguments that begin with a `ctx_*`\n                prefix will be appended to the route context (`route.ctx`).\n\n        Returns:\n            RouteWrapper: Tuple of routes, decorated function.\n\n        Examples:\n            Using the method to define a GET endpoint:\n\n            ```python\n            @app.route(\"/hello\")\n            async def hello(request: Request):\n                return text(\"Hello, World!\")\n            ```\n\n            Adding context kwargs to the route:\n\n            ```python\n            @app.route(\"/greet\", ctx_name=\"World\")\n            async def greet(request: Request):\n                name = request.route.ctx.name\n                return text(f\"Hello, {name}!\")\n            ```\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\") and (uri or hasattr(self, \"router\")):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        if not methods and not websocket:\n            methods = frozenset({\"GET\"})\n\n        route_context = self._build_route_context(ctx_kwargs)\n\n        def decorator(handler):\n            nonlocal uri\n            nonlocal methods\n            nonlocal host\n            nonlocal strict_slashes\n            nonlocal stream\n            nonlocal version\n            nonlocal name\n            nonlocal ignore_body\n            nonlocal subprotocols\n            nonlocal websocket\n            nonlocal static\n            nonlocal version_prefix\n            nonlocal error_format\n\n            if isinstance(handler, tuple):\n                # if a handler fn is already wrapped in a route, the handler\n                # variable will be a tuple of (existing routes, handler fn)\n                _, handler = handler\n\n            name = self.generate_name(name, handler)\n\n            if isinstance(host, str):\n                host = frozenset([host])\n            elif host and not isinstance(host, frozenset):\n                try:\n                    host = frozenset(host)\n                except TypeError:\n                    raise ValueError(\n                        \"Expected either string or Iterable of host strings, \"\n                        \"not %s\" % host\n                    )\n            if isinstance(subprotocols, list):\n                # Ordered subprotocols, maintain order\n                subprotocols = tuple(subprotocols)\n            elif isinstance(subprotocols, set):\n                # subprotocol is unordered, keep it unordered\n                subprotocols = frozenset(subprotocols)\n\n            if not error_format or error_format == \"auto\":\n                error_format = self._determine_error_format(handler)\n\n            route = FutureRoute(\n                handler,\n                uri,\n                None if websocket else frozenset([x.upper() for x in methods]),\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n                ignore_body,\n                websocket,\n                subprotocols,\n                unquote,\n                static,\n                version_prefix,\n                error_format,\n                route_context,\n            )\n            overwrite = getattr(self, \"_allow_route_overwrite\", False)\n            if overwrite:\n                self._future_routes = set(\n                    filter(lambda x: x.uri != uri, self._future_routes)\n                )\n            self._future_routes.add(route)\n\n            args = list(signature(handler).parameters.keys())\n            if websocket and len(args) < 2:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` and/or `ws` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n            elif not args:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n\n            if not websocket and stream:\n                handler.is_stream = stream\n\n            if apply:\n                self._apply_route(route, overwrite=overwrite)\n\n            if static:\n                return route, handler\n            return handler\n\n        return decorator"
    },
    {
      "chunk_id": 666,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def add_route(\n        self,\n        handler: RouteHandler,\n        uri: str,\n        methods: Iterable[str] = frozenset({\"GET\"}),\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        stream: bool = False,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        unquote: bool = False,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"A helper method to register class-based view or functions as a handler to the application url routes.\n\n        Args:\n            handler (RouteHandler): Function or class-based view used as a route handler.\n            uri (str): Path of the URL.\n            methods (Iterable[str]): List or tuple of methods allowed; these are overridden if using an HTTPMethodView.\n            host (Optional[Union[str, List[str]]]): Hostname or hostnames to match for this route.\n            strict_slashes (Optional[bool]): If set, a route's slashes will be strict. E.g. `/foo` will not match `/foo/`.\n            version (Optional[Union[int, str, float]]): Version of the API for this route.\n            name (Optional[str]): User-defined route name for `url_for`.\n            stream (bool): Boolean specifying if the handler is a stream handler.\n            version_prefix (str): URL path that should be before the version value; default: ``/v``.\n            error_format (Optional[str]): Custom error format string.\n            unquote (bool): Boolean specifying if the handler requires unquoting.\n            ctx_kwargs (Any): Keyword arguments that begin with a `ctx_*` prefix will be appended to the route context (``route.ctx``). See below for examples.\n\n        Returns:\n            RouteHandler: The route handler.\n\n        Examples:\n            ```python\n            from sanic import Sanic, text\n\n            app = Sanic(\"test\")\n\n            async def handler(request):\n                return text(\"OK\")\n\n            app.add_route(handler, \"/test\", methods=[\"GET\", \"POST\"])\n            ```\n\n            You can use `ctx_kwargs` to add custom context to the route. This\n            can often be useful when wanting to add metadata to a route that\n            can be used by other parts of the application (like middleware).\n\n            ```python\n            from sanic import Sanic, text\n\n            app = Sanic(\"test\")\n\n            async def handler(request):\n                return text(\"OK\")\n\n            async def custom_middleware(request):\n                if request.route.ctx.monitor:\n                    do_some_monitoring()\n\n            app.add_route(handler, \"/test\", methods=[\"GET\", \"POST\"], ctx_monitor=True)\n            ```\n\n        \"\"\"  # noqa: E501\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                view_class = getattr(handler, \"view_class\")\n                _handler = getattr(view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n            version_prefix=version_prefix,\n            error_format=error_format,\n            unquote=unquote,\n            **ctx_kwargs,\n        )(handler)\n        return handler"
    },
    {
      "chunk_id": 667,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def get(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **GET** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to GET method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            ignore_body (bool): Whether the handler should ignore request\n                body. This means the body of the request, if sent, will not\n                be consumed. In that instance, you will see a warning in\n                the logs. Defaults to `True`, meaning do not consume the body.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_* prefix` will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"GET\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n                ignore_body=ignore_body,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 668,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def post(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **POST** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to POST method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            stream (bool): Whether or not to stream the request body.\n                Defaults to `False`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_*` prefix will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"POST\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                stream=stream,\n                version=version,\n                name=name,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 669,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def put(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **PUT** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to PUT method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            stream (bool): Whether or not to stream the request body.\n                Defaults to `False`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_*` prefix will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"PUT\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                stream=stream,\n                version=version,\n                name=name,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 670,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def head(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **HEAD** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to HEAD method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            ignore_body (bool): Whether the handler should ignore request\n                body. This means the body of the request, if sent, will not\n                be consumed. In that instance, you will see a warning in\n                the logs. Defaults to `True`, meaning do not consume the body.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_* prefix` will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"HEAD\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n                ignore_body=ignore_body,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 671,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def options(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **OPTIONS** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to OPTIONS method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            ignore_body (bool): Whether the handler should ignore request\n                body. This means the body of the request, if sent, will not\n                be consumed. In that instance, you will see a warning in\n                the logs. Defaults to `True`, meaning do not consume the body.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_*` prefix will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"OPTIONS\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n                ignore_body=ignore_body,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 672,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def patch(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        stream=False,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **PATCH** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to PATCH method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for\n                the service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            stream (bool): Set to `True` if full request streaming is needed,\n                `False` otherwise. Defaults to `False`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the route.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a\n                `ctx_*` prefix will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"PATCH\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                stream=stream,\n                version=version,\n                name=name,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 673,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def delete(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = False,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ) -> RouteHandler:\n        \"\"\"Decorate a function handler to create a route definition using the **DELETE** HTTP method.\n\n        Args:\n            uri (str): URL to be tagged to the DELETE method of HTTP.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN for the\n                service to use.\n            strict_slashes (Optional[bool]): Instruct Sanic to check if the\n                request URLs need to terminate with a `/`.\n            version (Optional[Union[int, str, float]]): API Version.\n            name (Optional[str]): Unique name that can be used to identify\n                the Route.\n            ignore_body (bool): Whether or not to ignore the body in the\n                request. Defaults to `False`.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with a `ctx_*`\n                prefix will be appended to the route context (`route.ctx`).\n\n        Returns:\n            RouteHandler: Object decorated with route method.\n        \"\"\"  # noqa: E501\n        return cast(\n            RouteHandler,\n            self.route(\n                uri,\n                methods=frozenset({\"DELETE\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n                ignore_body=ignore_body,\n                version_prefix=version_prefix,\n                error_format=error_format,\n                **ctx_kwargs,\n            ),\n        )"
    },
    {
      "chunk_id": 674,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def websocket(\n        self,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols: Optional[list[str]] = None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        apply: bool = True,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ):\n        \"\"\"Decorate a function to be registered as a websocket route.\n\n        Args:\n            uri (str): Path of the URL.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN details.\n            strict_slashes (Optional[bool]): If the API endpoint needs to\n                terminate with a `\"/\"` or not.\n            subprotocols (Optional[List[str]]): Optional list of str with\n                supported subprotocols.\n            version (Optional[Union[int, str, float]]): WebSocket\n                protocol version.\n            name (Optional[str]): A unique name assigned to the URL so that\n                it can be used with url_for.\n            apply (bool): If set to False, it doesn't apply the route to the\n                app. Default is `True`.\n            version_prefix (str): URL path that should be before the version\n                value. Defaults to `\"/v\"`.\n            error_format (Optional[str]): Custom error format string.\n            **ctx_kwargs (Any): Keyword arguments that begin with\n                a `ctx_* prefix` will be appended to the route\n                context (`route.ctx`).\n\n        Returns:\n            tuple: Tuple of routes, decorated function.\n        \"\"\"\n        return self.route(\n            uri=uri,\n            host=host,\n            methods=None,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            apply=apply,\n            subprotocols=subprotocols,\n            websocket=True,\n            version_prefix=version_prefix,\n            error_format=error_format,\n            **ctx_kwargs,\n        )"
    },
    {
      "chunk_id": 675,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def add_websocket_route(\n        self,\n        handler,\n        uri: str,\n        host: Optional[Union[str, list[str]]] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols=None,\n        version: Optional[Union[int, str, float]] = None,\n        name: Optional[str] = None,\n        version_prefix: str = \"/v\",\n        error_format: Optional[str] = None,\n        **ctx_kwargs: Any,\n    ):\n        \"\"\"A helper method to register a function as a websocket route.\n\n        Args:\n            handler (Callable): A callable function or instance of a class\n                that can handle the websocket request.\n            uri (str): URL path that will be mapped to the websocket handler.\n            host (Optional[Union[str, List[str]]]): Host IP or FQDN details.\n            strict_slashes (Optional[bool]): If the API endpoint needs to\n                terminate with a `\"/\"` or not.\n            subprotocols (Optional[List[str]]): Subprotocols to be used with\n                websocket handshake.\n            version (Optional[Union[int, str, float]]): Versioning information.\n            name (Optional[str]): A unique name assigned to the URL.\n            version_prefix (str): URL path before the version value.\n                Defaults to `\"/v\"`.\n            error_format (Optional[str]): Format for error handling.\n            **ctx_kwargs (Any): Keyword arguments beginning with `ctx_*`\n                prefix will be appended to the route context (`route.ctx`).\n\n        Returns:\n            Callable: Object passed as the handler.\n        \"\"\"\n        return self.websocket(\n            uri=uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            version=version,\n            name=name,\n            version_prefix=version_prefix,\n            error_format=error_format,\n            **ctx_kwargs,\n        )(handler)"
    },
    {
      "chunk_id": 676,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def _determine_error_format(self, handler) -> str:\n        with suppress(OSError, TypeError):\n            src = dedent(getsource(handler))\n            tree = parse(src)\n            http_response_types = self._get_response_types(tree)\n\n            if len(http_response_types) == 1:\n                return next(iter(http_response_types))\n\n        return \"\""
    },
    {
      "chunk_id": 677,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def _get_response_types(self, node):\n        types = set()\n\n        class HttpResponseVisitor(NodeVisitor):\n            def visit_Return(self, node: Return) -> Any:\n                nonlocal types\n\n                with suppress(AttributeError):\n                    checks = [node.value.func.id]  # type: ignore\n                    if node.value.keywords:  # type: ignore\n                        checks += [\n                            k.value\n                            for k in node.value.keywords  # type: ignore\n                            if k.arg == \"content_type\"\n                        ]\n\n                    for check in checks:\n                        if check in RESPONSE_MAPPING:\n                            types.add(RESPONSE_MAPPING[check])\n\n        HttpResponseVisitor().visit(node)\n\n        return types"
    },
    {
      "chunk_id": 678,
      "source": "__internal__/data_repo/sanic/sanic/mixins/routes.py",
      "content": "def _build_route_context(self, raw: dict[str, Any]) -> HashableDict:\n        ctx_kwargs = {\n            key.replace(\"ctx_\", \"\"): raw.pop(key)\n            for key in {**raw}.keys()\n            if key.startswith(\"ctx_\")\n        }\n        if raw:\n            unexpected_arguments = \", \".join(raw.keys())\n            raise TypeError(\n                f\"Unexpected keyword arguments: {unexpected_arguments}\"\n            )\n        return HashableDict(ctx_kwargs)"
    },
    {
      "chunk_id": 679,
      "source": "__internal__/data_repo/sanic/sanic/mixins/startup.py",
      "content": "```python"
    },
    {
      "chunk_id": 680,
      "source": "__internal__/data_repo/sanic/sanic/mixins/startup.py",
      "content": "from __future__ import annotations\n\nimport os\nimport platform\n\nfrom asyncio import (\n    AbstractEventLoop,\n    CancelledError,\n    Protocol,\n    all_tasks,\n    get_event_loop,\n    get_running_loop,\n    new_event_loop,\n)\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom functools import partial\nfrom importlib import import_module\nfrom multiprocessing import (\n    Manager,\n    Pipe,\n    get_context,\n    get_start_method,\n    set_start_method,\n)\nfrom multiprocessing.context import BaseContext\nfrom pathlib import Path\nfrom socket import SHUT_RDWR, socket\nfrom ssl import SSLContext\nfrom time import sleep\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    ClassVar,\n    Literal,\n    Optional,\n    Union,\n    cast,\n)\n\nfrom sanic.application.ext import setup_ext\nfrom sanic.application.logo import get_logo\nfrom sanic.application.motd import MOTD\nfrom sanic.application.state import ApplicationServerInfo, Mode, ServerStage\nfrom sanic.base.meta import SanicMeta\nfrom sanic.compat import OS_IS_WINDOWS, StartMethod\nfrom sanic.exceptions import ServerKilled\nfrom sanic.helpers import Default, _default, is_atty\nfrom sanic.http.constants import HTTP\nfrom sanic.http.tls import get_ssl_context, process_to_context\nfrom sanic.http.tls.context import SanicSSLContext\nfrom sanic.log import Colors, deprecation, error_logger, logger\nfrom sanic.logging.setup import setup_logging\nfrom sanic.models.handler_types import ListenerType\nfrom sanic.server import Signal as ServerSignal\nfrom sanic.server import try_use_uvloop\nfrom sanic.server.async_server import AsyncioServer\nfrom sanic.server.events import trigger_events\nfrom sanic.server.goodbye import get_goodbye\nfrom sanic.server.loop import try_windows_loop\nfrom sanic.server.protocols.http_protocol import HttpProtocol\nfrom sanic.server.protocols.websocket_protocol import WebSocketProtocol\nfrom sanic.server.runners import serve\nfrom sanic.server.socket import configure_socket, remove_unix_socket\nfrom sanic.worker.loader import AppLoader\nfrom sanic.worker.manager import WorkerManager\nfrom sanic.worker.multiplexer import WorkerMultiplexer\nfrom sanic.worker.reloader import Reloader\nfrom sanic.worker.serve import worker_serve\n\n\nif TYPE_CHECKING:\n    from sanic import Sanic\n    from sanic.application.state import ApplicationState\n    from sanic.config import Config\n\nSANIC_PACKAGES = (\"sanic-routing\", \"sanic-testing\", \"sanic-ext\")\n\n\nHTTPVersion = Union[HTTP, Literal[1], Literal[3]]"
    },
    {
      "chunk_id": 681,
      "source": "__internal__/data_repo/sanic/sanic/mixins/startup.py",
      "content": "class StartupMixin(metaclass=SanicMeta):\n    _app_registry: ClassVar[dict[str, Sanic]]\n    name: str\n    asgi: bool\n    config: Config\n    listeners: dict[str, list[ListenerType[Any]]]\n    state: ApplicationState\n    websocket_enabled: bool\n    multiplexer: WorkerMultiplexer\n\n    test_mode: ClassVar[bool]\n    start_method: ClassVar[StartMethod] = _default\n    START_METHOD_SET: ClassVar[bool] = False\n\n    def setup_loop(self) -> None:\n        \"\"\"Set up the event loop.\n\n        An internal method that sets up the event loop to uvloop if\n        possible, or a Windows selector loop if on Windows.\n\n        Returns:\n            None\n        \"\"\"\n        if not self.asgi:\n            if self.config.USE_UVLOOP is True or (\n                isinstance(self.config.USE_UVLOOP, Default)\n                and not OS_IS_WINDOWS\n            ):\n                try_use_uvloop()\n            elif OS_IS_WINDOWS:\n                try_windows_loop()\n\n    @property\n    def m(self) -> WorkerMultiplexer:\n        \"\"\"Interface for interacting with the worker processes\n\n        This is a shortcut for `app.multiplexer`. It is available only in a\n        worker process using the Sanic server. It allows you to interact with\n        the worker processes, such as sending messages and commands.\n\n        See [Access to the multiplexer](/en/guide/deployment/manager#access-to-the-multiplexer) for more information.\n\n        Returns:\n            WorkerMultiplexer: The worker multiplexer instance\n\n        Examples:\n            ```python\n            app.m.restart()    # restarts the worker\n            app.m.terminate()  # terminates the worker\n            app.m.scale(4)     # scales the number of workers to 4\n            ```\n        \"\"\"  # noqa: E501\n        return self.multiplexer\n\n    def make_coffee(self, *args, **kwargs):\n        \"\"\"\n        Try for yourself! `sanic server:app --coffee`\n\n         ```\n         \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\n        \u2588\u2588       \u2588\u2588\u2580\u2580\u2584\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2584\u2580\n         \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\n\n         ```\n        \"\"\"\n        self.state.coffee = True\n        self.run(*args, **kwargs)\n\n    def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        *,\n        dev: bool = False,\n        debug: bool = False,\n        auto_reload: Optional[bool] = None,\n        version: HTTPVersion = HTTP.VERSION_1,\n        ssl: Union[None, SSLContext, dict, str, list, tuple] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Optional[type[Protocol]] = None,\n        backlog: int = 100,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        unix: Optional[str] = None,\n        loop: Optional[AbstractEventLoop] = None,\n        reload_dir: Optional[Union[list[str], str]] = None,\n        noisy_exceptions: Optional[bool] = None,\n        motd: bool = True,\n        fast: bool = False,\n        verbosity: int = 0,\n        motd_display: Optional[dict[str, str]] = None,\n        auto_tls: bool = False,\n        single_process: bool = False,\n    ) -> None:\n        \"\"\"Run the HTTP Server and listen until keyboard interrupt or term signal. On termination, drain connections before closing.\n\n        .. note::\n            When you need control over running the Sanic instance, this is the method to use.\n            However, in most cases the preferred method is to use the CLI command:\n\n            ```sh\n            sanic server:app`\n            ```\n\n        If you are using this method to run Sanic, make sure you do the following:\n\n        1. Use `if __name__ == \"__main__\"` to guard the code.\n        2. Do **NOT** define the app instance inside the `if` block.\n\n        See [Dynamic Applications](/en/guide/deployment/app-loader) for more information about the second point.\n\n        Args:\n            host (Optional[str]): Address to host on.\n            port (Optional[int]): Port to host on.\n            dev (bool): Run the server in development mode.\n            debug (bool): Enables debug output (slows server).\n            auto_reload (Optional[bool]): Reload app whenever its source code is changed.\n                Enabled by default in debug mode.\n            version (HTTPVersion): HTTP Version.\n            ssl (Union[None, SSLContext, dict, str, list, tuple]): SSLContext, or location of certificate and key\n                for SSL encryption of worker(s).\n            sock (Optional[socket]): Socket for the server to accept connections from.\n            workers (int): Number of processes received before it is respected.\n            protocol (Optional[Type[Protocol]]): Subclass of asyncio Protocol class.\n            backlog (int): A number of unaccepted connections that the system will allow\n                before refusing new connections.\n            register_sys_signals (bool): Register SIG* events.\n            access_log (Optional[bool]): Enables writing access logs (slows server).\n            unix (Optional[str]): Unix socket to listen on instead of TCP port.\n            loop (Optional[AbstractEventLoop]): AsyncIO event loop.\n            reload_dir (Optional[Union[List[str], str]]): Directory to watch for code changes, if auto_reload is True.\n            noisy_exceptions (Optional[bool]): Log exceptions that are normally considered to be quiet/silent.\n            motd (bool): Display Message of the Day.\n            fast (bool): Enable fast mode.\n            verbosity (int): Verbosity level.\n            motd_display (Optional[Dict[str, str]]): Customize Message of the Day display.\n            auto_tls (bool): Enable automatic TLS certificate handling.\n            single_process (bool): Enable single process mode.\n\n        Returns:\n            None\n\n        Raises:\n            RuntimeError: Raised when attempting to serve HTTP/3 as a secondary server.\n            RuntimeError: Raised when attempting to use both `fast` and `workers`.\n            RuntimeError: Raised when attempting to use `single_process` with `fast`, `workers`, or `auto_reload`.\n            TypeError: Raised when attempting to use `loop` with `create_server`.\n            ValueError: Raised when `PROXIES_COUNT` is negative.\n\n        Examples:\n            ```python\n            from sanic import Sanic, Request, json\n\n            app = Sanic(\"TestApp\")\n\n\n            @app.get(\"/\")\n            async def handler(request: Request):\n                return json({\"foo\": \"bar\"})\n\n\n            if __name__ == \"__main__\":\n                app.run(port=9999, dev=True)\n            ```\n        \"\"\"  # noqa: E501\n        self.prepare(\n            host=host,\n            port=port,\n            dev=dev,\n            debug=debug,\n            auto_reload=auto_reload,\n            version=version,\n            ssl=ssl,\n            sock=sock,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            access_log=access_log,\n            unix=unix,\n            loop=loop,\n            reload_dir=reload_dir,\n            noisy_exceptions=noisy_exceptions,\n            motd=motd,\n            fast=fast,\n            verbosity=verbosity,\n            motd_display=motd_display,\n            auto_tls=auto_tls,\n            single_process=single_process,\n        )\n\n        if single_process:\n            serve = self.__class__.serve_single\n        else:\n            serve = self.__class__.serve\n        serve(primary=self)  # type: ignore\n\n    def prepare(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        *,\n        dev: bool = False,\n        debug: bool = False,\n        auto_reload: Optional[bool] = None,\n        version: HTTPVersion = HTTP.VERSION_1,\n        ssl: Union[None, SSLContext, dict, str, list, tuple] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Optional[type[Protocol]] = None,\n        backlog: int = 100,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        unix: Optional[str] = None,\n        loop: Optional[AbstractEventLoop] = None,\n        reload_dir: Optional[Union[list[str], str]] = None,\n        noisy_exceptions: Optional[bool] = None,\n        motd: bool = True,\n        fast: bool = False,\n        verbosity: int = 0,\n        motd_display: Optional[dict[str, str]] = None,\n        coffee: bool = False,\n        auto_tls: bool = False,\n        single_process: bool = False,\n    ) -> None:\n        \"\"\"Prepares one or more Sanic applications to be served simultaneously.\n\n        This low-level API is typically used when you need to run multiple Sanic applications at the same time. Once prepared, `Sanic.serve()` should be called in the `if __name__ == \"__main__\"` block.\n\n        .. note::\n            \"Preparing\" and \"serving\" with this function is equivalent to using `app.run` for a single instance. This should only be used when running multiple applications at the same time.\n\n        Args:\n            host (Optional[str], optional): Hostname to listen on. Defaults to `None`.\n            port (Optional[int], optional): Port to listen on. Defaults to `None`.\n            dev (bool, optional): Development mode. Defaults to `False`.\n            debug (bool, optional): Debug mode. Defaults to `False`.\n            auto_reload (Optional[bool], optional): Auto reload feature. Defaults to `None`.\n            version (HTTPVersion, optional): HTTP version to use. Defaults to `HTTP.VERSION_1`.\n            ssl (Union[None, SSLContext, dict, str, list, tuple], optional): SSL configuration. Defaults to `None`.\n            sock (Optional[socket], optional): Socket to bind to. Defaults to `None`.\n            workers (int, optional): Number of worker processes. Defaults to `1`.\n            protocol (Optional[Type[Protocol]], optional): Custom protocol class. Defaults to `None`.\n            backlog (int, optional): Maximum number of pending connections. Defaults to `100`.\n            register_sys_signals (bool, optional): Register system signals. Defaults to `True`.\n            access_log (Optional[bool], optional): Access log. Defaults to `None`.\n            unix (Optional[str], optional): Unix socket. Defaults to `None`.\n            loop (Optional[AbstractEventLoop], optional): Event loop. Defaults to `None`.\n            reload_dir (Optional[Union[List[str], str]], optional): Reload directory. Defaults to `None`.\n            noisy_exceptions (Optional[bool], optional): Display exceptions. Defaults to `None`.\n            motd (bool, optional): Display message of the day. Defaults to `True`.\n            fast (bool, optional): Fast mode. Defaults to `False`.\n            verbosity (int, optional): Verbosity level. Defaults to `0`.\n            motd_display (Optional[Dict[str, str]], optional): Custom MOTD display. Defaults to `None`.\n            coffee (bool, optional): Coffee mode. Defaults to `False`.\n            auto_tls (bool, optional): Auto TLS. Defaults to `False`.\n            single_process (bool, optional): Single process mode. Defaults to `False`.\n\n        Raises:\n            RuntimeError: Raised when attempting to serve HTTP/3 as a secondary server.\n            RuntimeError: Raised when attempting to use both `fast` and `workers`.\n            RuntimeError: Raised when attempting to use `single_process` with `fast`, `workers`, or `auto_reload`.\n            TypeError: Raised when attempting to use `loop` with `create_server`.\n            ValueError: Raised when `PROXIES_COUNT` is negative.\n\n        Examples:\n            ```python\n            if __name__ == \"__main__\":\n                app.prepare()\n                app.serve()\n            ```\n        \"\"\"  # noqa: E501\n        if version == 3 and self.state.server_info:\n            raise RuntimeError(\n                \"Serving HTTP/3 instances as a secondary server is \"\n                \"not supported. There can only be a single HTTP/3 worker \"\n                \"and it must be the first instance prepared.\"\n            )\n\n        if dev:\n            debug = True\n            auto_reload = True\n\n        if debug and access_log is None:\n            access_log = True\n\n        self.state.verbosity = verbosity\n        if not self.state.auto_reload:\n            self.state.auto_reload = bool(auto_reload)\n\n        if fast and workers != 1:\n            raise RuntimeError(\"You cannot use both fast=True and workers=X\")\n\n        if single_process and (fast or (workers > 1) or auto_reload):\n            raise RuntimeError(\n                \"Single process cannot be run with multiple workers \"\n                \"or auto-reload\"\n            )\n\n        if register_sys_signals is False and not single_process:\n            raise RuntimeError(\n                \"Cannot run Sanic.serve with register_sys_signals=False. \"\n                \"Use Sanic.serve_single.\"\n            )\n\n        if motd_display:\n            self.config.MOTD_DISPLAY.update(motd_display)\n\n        if reload_dir:\n            if isinstance(reload_dir, str):\n                reload_dir = [reload_dir]\n\n            for directory in reload_dir:\n                direc = Path(directory)\n                if not direc.is_dir():\n                    logger.warning(\n                        f\"Directory {directory} could not be located\"\n                    )\n                self.state.reload_dirs.add(Path(directory))\n\n        if loop is not None:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        if sock is None:\n            host, port = self.get_address(host, port, version, auto_tls)\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n\n        # Set explicitly passed configuration values\n        for attribute, value in {\n            \"ACCESS_LOG\": access_log,\n            \"AUTO_RELOAD\": auto_reload,\n            \"MOTD\": motd,\n            \"NOISY_EXCEPTIONS\": noisy_exceptions,\n        }.items():\n            if value is not None:\n                setattr(self.config, attribute, value)\n\n        if fast:\n            self.state.fast = True\n            try:\n                workers = len(os.sched_getaffinity(0))\n            except AttributeError:  # no cov\n                workers = os.cpu_count() or 1\n\n        if coffee:\n            self.state.coffee = True\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            version=version,\n            ssl=ssl,\n            sock=sock,\n            unix=unix,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_tls=auto_tls,\n        )\n        self.state.server_info.append(\n            ApplicationServerInfo(settings=server_settings)\n        )\n\n        # if self.config.USE_UVLOOP is True or (\n        #     self.config.USE_UVLOOP is _default and not OS_IS_WINDOWS\n        # ):\n        #     try_use_uvloop()\n\n    async def create_server(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        *,\n        debug: bool = False,\n        ssl: Union[None, SSLContext, dict, str, list, tuple] = None,\n        sock: Optional[socket] = None,\n        protocol: Optional[type[Protocol]] = None,\n        backlog: int = 100,\n        access_log: Optional[bool] = None,\n        unix: Optional[str] = None,\n        return_asyncio_server: bool = True,\n        asyncio_server_kwargs: Optional[dict[str, Any]] = None,\n        noisy_exceptions: Optional[bool] = None,\n    ) -> Optional[AsyncioServer]:\n        \"\"\"\n        Low level API for creating a Sanic Server instance.\n\n        This method will create a Sanic Server instance, but will not start\n        it. This is useful for integrating Sanic into other systems. But, you\n        should take caution when using it as it is a low level API and does\n        not perform any of the lifecycle events.\n\n        .. note::\n            This does not support multiprocessing and is not the preferred\n            way to run a Sanic application. Proceed with caution.\n\n        You will need to start the server yourself as shown in the example\n        below. You are responsible for the lifecycle of the server, including\n        app startup using `await app.startup()`. No events will be triggered\n        for you, so you will need to trigger them yourself if wanted.\n\n        Args:\n            host (Optional[str]): Address to host on.\n            port (Optional[int]): Port to host on.\n            debug (bool): Enables debug output (slows server).\n            ssl (Union[None, SSLContext, dict, str, list, tuple]): SSLContext,\n                or location of certificate and key for SSL encryption\n                of worker(s).\n            sock (Optional[socket]): Socket for the server to accept\n                connections from.\n            protocol (Optional[Type[Protocol]]): Subclass of\n                `asyncio.Protocol` class.\n            backlog (int): Number of unaccepted connections that the system\n                will allow before refusing new connections.\n            access_log (Optional[bool]): Enables writing access logs\n                (slows server).\n            return_asyncio_server (bool): _DEPRECATED_\n            asyncio_server_kwargs (Optional[Dict[str, Any]]): Key-value\n                arguments for asyncio/uvloop `create_server` method.\n            noisy_exceptions (Optional[bool]): Log exceptions that are normally\n                considered to be quiet/silent.\n\n        Returns:\n            Optional[AsyncioServer]: AsyncioServer if `return_asyncio_server`\n                is `True` else `None`.\n\n        Examples:\n            ```python\n            import asyncio\n            import uvloop\n            from sanic import Sanic, response\n\n\n            app = Sanic(\"Example\")\n\n\n            @app.route(\"/\")\n            async def test(request):\n                return response.json({\"answer\": \"42\"})\n\n\n            async def main():\n                server = await app.create_server()\n                await server.startup()\n                await server.serve_forever()\n\n\n            if __name__ == \"__main__\":\n                asyncio.set_event_loop(uvloop.new_event_loop())\n                asyncio.run(main())\n            ```\n        \"\"\"\n\n        if sock is None:\n            host, port = host, port = self.get_address(host, port)\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n\n        # Set explicitly passed configuration values\n        for attribute, value in {\n            \"ACCESS_LOG\": access_log,\n            \"NOISY_EXCEPTIONS\": noisy_exceptions,\n        }.items():\n            if value is not None:\n                setattr(self.config, attribute, value)\n\n        if not return_asyncio_server:\n            return_asyncio_server = True\n            deprecation(\n                \"The `return_asyncio_server` argument is deprecated and \"\n                \"ignored. It will be removed in v24.3.\",\n                24.3,\n            )\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            unix=unix,\n            loop=get_event_loop(),\n            protocol=protocol,\n            backlog=backlog,\n            run_async=return_asyncio_server,\n        )\n\n        if not isinstance(self.config.USE_UVLOOP, Default):\n            error_logger.warning(\n                \"You are trying to change the uvloop configuration, but \"\n                \"this is only effective when using the run(...) method. \"\n                \"When using the create_server(...) method Sanic will use \"\n                \"the already existing loop.\"\n            )\n\n        main_start = server_settings.pop(\"main_start\", None)\n        main_stop = server_settings.pop(\"main_stop\", None)\n        if main_start or main_stop:\n            logger.warning(\n                \"Listener events for the main process are not available \"\n                \"with create_server()\"\n            )\n\n        return await serve(\n            asyncio_server_kwargs=asyncio_server_kwargs, **server_settings\n        )\n\n    def stop(self, terminate: bool = True, unregister: bool = False) -> None:\n        \"\"\"This kills the Sanic server, cleaning up after itself.\n\n        Args:\n            terminate (bool): Force kill all requests immediately without\n                allowing them to finish processing.\n            unregister (bool): Unregister the app from the global registry.\n\n        Returns:\n            None\n        \"\"\"\n        if terminate and hasattr(self, \"multiplexer\"):\n            self.multiplexer.terminate()\n        if self.state.stage is not ServerStage.STOPPED:\n            self.shutdown_tasks(timeout=0)  # type: ignore\n            for task in all_tasks():\n                with suppress(AttributeError):\n                    if task.get_name() == \"RunServer\":\n                        task.cancel()\n            get_event_loop().stop()\n\n        if unregister:\n            self.__class__.unregister_app(self)  # type: ignore\n\n    def _helper(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        version: HTTPVersion = HTTP.VERSION_1,\n        ssl: Union[None, SSLContext, dict, str, list, tuple] = None,\n        sock: Optional[socket] = None,\n        unix: Optional[str] = None,\n        workers: int = 1,\n        loop: Optional[AbstractEventLoop] = None,\n        protocol: type[Protocol] = HttpProtocol,\n        backlog: int = 100,\n        register_sys_signals: bool = True,\n        run_async: bool = False,\n        auto_tls: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        if not self.state.is_debug:\n            self.state.mode = Mode.DEBUG if debug else Mode.PRODUCTION\n\n        setup_logging(self.state.is_debug, self.config.NO_COLOR)\n\n        if isinstance(version, int):\n            version = HTTP(version)\n\n        ssl = process_to_context(ssl)\n        if version is HTTP.VERSION_3 or auto_tls:\n            if TYPE_CHECKING:\n                self = cast(Sanic, self)\n            ssl = get_ssl_context(self, ssl)\n\n        self.state.host = host or \"\"\n        self.state.port = port or 0\n        self.state.workers = workers\n        self.state.ssl = ssl\n        self.state.unix = unix\n        self.state.sock = sock\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"host\": host,\n            \"port\": port,\n            \"version\": version,\n            \"sock\": sock,\n            \"unix\": unix,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": ServerSignal(),\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n        }\n\n        self.motd(server_settings=server_settings)\n\n        if (\n            is_atty()\n            and not self.state.is_debug\n            and not os.environ.get(\"SANIC_IGNORE_PRODUCTION_WARNING\")\n        ):\n            error_logger.warning(\n                f\"{Colors.YELLOW}Sanic is running in PRODUCTION mode. \"\n                \"Consider using '--debug' or '--dev' while actively \"\n                f\"developing your application.{Colors.END}\"\n            )\n\n        # Register start/stop events\n        for event_name, settings_name, reverse in (\n            (\"main_process_start\", \"main_start\", False),\n            (\"main_process_stop\", \"main_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners  # type: ignore\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        return server_settings\n\n    def motd(\n        self,\n        server_settings: Optional[dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"Outputs the message of the day (MOTD).\n\n        It generally can only be called once per process, and is usually\n        called by the `run` method in the main process.\n\n        Args:\n            server_settings (Optional[Dict[str, Any]], optional): Settings for\n                the server. Defaults to `None`.\n\n        Returns:\n            None\n        \"\"\"\n        if (\n            os.environ.get(\"SANIC_WORKER_NAME\")\n            or os.environ.get(\"SANIC_MOTD_OUTPUT\")\n            or os.environ.get(\"SANIC_WORKER_PROCESS\")\n            or os.environ.get(\"SANIC_SERVER_RUNNING\")\n        ):\n            return\n        serve_location = self.get_server_location(server_settings)\n        if self.config.MOTD:\n            logo = get_logo(coffee=self.state.coffee)\n            display, extra = self.get_motd_data(server_settings)\n\n            MOTD.output(logo, serve_location, display, extra)\n\n    def get_motd_data(\n        self, server_settings: Optional[dict[str, Any]] = None\n    ) -> tuple[dict[str, Any], dict[str, Any]]:\n        \"\"\"Retrieves the message of the day (MOTD) data.\n\n        Args:\n            server_settings (Optional[Dict[str, Any]], optional): Settings for\n                the server. Defaults to `None`.\n\n        Returns:\n            Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing two\n                dictionaries with the relevant MOTD data.\n        \"\"\"\n\n        mode = [f\"{self.state.mode},\"]\n        if self.state.fast:\n            mode.append(\"goin' fast\")\n        if self.state.asgi:\n            mode.append(\"ASGI\")\n        else:\n            if self.state.workers == 1:\n                mode.append(\"single worker\")\n            else:\n                mode.append(f\"w/ {self.state.workers} workers\")\n\n        if server_settings:\n            server = \", \".join(\n                (\n                    self.state.server,\n                    server_settings[\"version\"].display(),  # type: ignore\n                )\n            )\n        else:\n            server = \"ASGI\" if self.asgi else \"unknown\"  # type: ignore\n\n        display = {\n            \"app\": self.name,\n            \"mode\": \" \".join(mode),\n            \"server\": server,\n            \"python\": platform.python_version(),\n            \"platform\": platform.platform(),\n        }\n        extra = {}\n        if self.config.AUTO_RELOAD:\n            reload_display = \"enabled\"\n            if self.state.reload_dirs:\n                reload_display += \", \".join(\n                    [\n                        \"\",\n                        *(\n                            str(path.absolute())\n                            for path in self.state.reload_dirs\n                        ),\n                    ]\n                )\n            display[\"auto-reload\"] = reload_display\n\n        packages = []\n        for package_name in SANIC_PACKAGES:\n            module_name = package_name.replace(\"-\", \"_\")\n            try:\n                module = import_module(module_name)\n                packages.append(f\"{package_name}=={module.__version__}\")  # type: ignore\n            except ImportError:  # no cov\n                ...\n\n        if packages:\n            display[\"packages\"] = \", \".join(packages)\n\n        if self.config.MOTD_DISPLAY:\n            extra.update(self.config.MOTD_DISPLAY)\n\n        return display, extra\n\n    @property\n    def serve_location(self) -> str:\n        \"\"\"Retrieve the server location.\n\n        Returns:\n            str: The server location.\n        \"\"\"\n        try:\n            server_settings = self.state.server_info[0].settings\n            return self.get_server_location(server_settings)\n        except IndexError:\n            location = \"ASGI\" if self.asgi else \"unknown\"  # type: ignore\n            return f\"http://<{location}>\"\n\n    @staticmethod\n    def get_server_location(\n        server_settings: Optional[dict[str, Any]] = None,\n    ) -> str:\n        \"\"\"Using the server settings, retrieve the server location.\n\n        Args:\n            server_settings (Optional[Dict[str, Any]], optional): Settings for\n                the server. Defaults to `None`.\n\n        Returns:\n            str: The server location.\n        \"\"\"\n        serve_location = \"\"\n        proto = \"http\"\n        if not server_settings:\n            return serve_location\n\n        host = server_settings[\"host\"]\n        port = server_settings[\"port\"]\n\n        if server_settings.get(\"ssl\") is not None:\n            proto = \"https\"\n        if server_settings.get(\"unix\"):\n            serve_location = f'{server_settings[\"unix\"]} {proto}://...'\n        elif server_settings.get(\"sock\"):\n            host, port, *_ = server_settings[\"sock\"].getsockname()\n\n        if not serve_location and host and port:\n            # colon(:) is legal for a host only in an ipv6 address\n            display_host = f\"[{host}]\" if \":\" in host else host\n            serve_location = f\"{proto}://{display_host}:{port}\"\n\n        return serve_location\n\n    @staticmethod\n    def get_address(\n        host: Optional[str],\n        port: Optional[int],\n        version: HTTPVersion = HTTP.VERSION_1,\n        auto_tls: bool = False,\n    ) -> tuple[str, int]:\n        \"\"\"Retrieve the host address and port, with default values based on the given parameters.\n\n        Args:\n            host (Optional[str]): Host IP or FQDN for the service to use. Defaults to `\"127.0.0.1\"`.\n            port (Optional[int]): Port number. Defaults to `8443` if version is 3 or `auto_tls=True`, else `8000`\n            version (HTTPVersion, optional): HTTP Version. Defaults to `HTTP.VERSION_1` (HTTP/1.1).\n            auto_tls (bool, optional): Automatic TLS flag. Defaults to `False`.\n\n        Returns:\n            Tuple[str, int]: Tuple containing the host and port\n        \"\"\"  # noqa: E501\n        host = host or \"127.0.0.1\"\n        port = port or (8443 if (version == 3 or auto_tls) else 8000)\n        return host, port\n\n    @classmethod\n    def should_auto_reload(cls) -> bool:\n        \"\"\"Check if any applications have auto-reload enabled.\n\n        Returns:\n            bool: `True` if any applications have auto-reload enabled, else\n                `False`.\n        \"\"\"\n        return any(app.state.auto_reload for app in cls._app_registry.values())\n\n    @classmethod\n    def _get_startup_method(cls) -> str:\n        return (\n            cls.start_method\n            if not isinstance(cls.start_method, Default)\n            else \"spawn\"\n        )\n\n    @classmethod\n    def _set_startup_method(cls) -> None:\n        if cls.START_METHOD_SET and not cls.test_mode:\n            return\n\n        method = cls._get_startup_method()\n        try:\n            set_start_method(method, force=cls.test_mode)\n        except RuntimeError:\n            ctx = get_context()\n            actual = ctx.get_start_method()\n            if actual != method:\n                raise RuntimeError(\n                    f\"Start method '{method}' was requested, but '{actual}' \"\n                    \"was already set.\\nFor more information, see: \"\n                    \"https://sanic.dev/en/guide/running/manager.html#overcoming-a-coderuntimeerrorcode\"\n                ) from None\n            else:\n                raise\n        cls.START_METHOD_SET = True\n\n    @classmethod\n    def _get_context(cls) -> BaseContext:\n        method = cls._get_startup_method()\n        logger.debug(\"Creating multiprocessing context using '%s'\", method)\n        actual = get_start_method()\n        if method != actual:\n            raise RuntimeError(\n                f\"Start method '{method}' was requested, but '{actual}' \"\n                \"was already set.\\nFor more information, see: \"\n                \"https://sanic.dev/en/guide/running/manager.html#overcoming-a-coderuntimeerrorcode\"\n            ) from None\n        return get_context()\n\n    @classmethod\n    def serve(\n        cls,\n        primary: Optional[Sanic] = None,\n        *,\n        app_loader: Optional[AppLoader] = None,\n        factory: Optional[Callable[[], Sanic]] = None,\n    ) -> None:\n        \"\"\"Serve one or more Sanic applications.\n\n        This is the main entry point for running Sanic applications. It\n        should be called in the `if __name__ == \"__main__\"` block.\n\n        Args:\n            primary (Optional[Sanic], optional): The primary Sanic application\n                to serve. Defaults to `None`.\n            app_loader (Optional[AppLoader], optional): An AppLoader instance\n                to use for loading applications. Defaults to `None`.\n            factory (Optional[Callable[[], Sanic]], optional): A factory\n                function to use for loading applications. Defaults to `None`.\n\n        Raises:\n            RuntimeError: Raised when no applications are found.\n            RuntimeError: Raised when no server information is found for the\n                primary application.\n            RuntimeError: Raised when attempting to use `loop` with\n                `create_server`.\n            RuntimeError: Raised when attempting to use `single_process` with\n                `fast`, `workers`, or `auto_reload`.\n            RuntimeError: Raised when attempting to serve HTTP/3 as a\n                secondary server.\n            RuntimeError: Raised when attempting to use both `fast` and\n                `workers`.\n            TypeError: Raised when attempting to use `loop` with\n                `create_server`.\n            ValueError: Raised when `PROXIES_COUNT` is negative.\n\n        Examples:\n            ```python\n            if __name__ == \"__main__\":\n                app.prepare()\n                Sanic.serve()\n            ```\n        \"\"\"\n        cls._set_startup_method()\n        os.environ[\"SANIC_MOTD_OUTPUT\"] = \"true\"\n        apps = list(cls._app_registry.values())\n        if factory:\n            primary = factory()\n        else:\n            if not primary:\n                if app_loader:\n                    primary = app_loader.load()\n                if not primary:\n                    try:\n                        primary = apps[0]\n                    except IndexError:\n                        raise RuntimeError(\n                            \"Did not find any applications.\"\n                        ) from None\n\n            # This exists primarily for unit testing\n            if not primary.state.server_info:  # no cov\n                for app in apps:\n                    app.state.server_info.clear()\n                return\n\n        try:\n            primary_server_info = primary.state.server_info[0]\n        except IndexError:\n            raise RuntimeError(\n                f\"No server information found for {primary.name}. Perhaps you \"\n                \"need to run app.prepare(...)?\"\n            ) from None\n\n        socks = []\n        sync_manager = Manager()\n        worker_state: Mapping[str, Any] = {\"state\": \"NONE\"}\n        setup_ext(primary)\n        exit_code = 0\n        try:\n            primary_server_info.settings.pop(\"main_start\", None)\n            primary_server_info.settings.pop(\"main_stop\", None)\n            main_start = primary.listeners.get(\"main_process_start\")\n            main_stop = primary.listeners.get(\"main_process_stop\")\n            app = primary_server_info.settings.pop(\"app\")\n            app.setup_loop()\n            loop = new_event_loop()\n            trigger_events(main_start, loop, primary)\n\n            socks = [\n                sock\n                for sock in [\n                    configure_socket(server_info.settings)\n                    for app in apps\n                    for server_info in app.state.server_info\n                ]\n                if sock\n            ]\n            primary_server_info.settings[\"run_multiple\"] = True\n            monitor_sub, monitor_pub = Pipe(True)\n            worker_state = sync_manager.dict()\n            kwargs: dict[str, Any] = {\n                **primary_server_info.settings,\n                \"monitor_publisher\": monitor_pub,\n                \"worker_state\": worker_state,\n            }\n\n            if not app_loader:\n                if factory:\n                    app_loader = AppLoader(factory=factory)\n                else:\n                    app_loader = AppLoader(\n                        factory=partial(cls.get_app, app.name)  # type: ignore\n                    )\n            kwargs[\"app_name\"] = app.name\n            kwargs[\"app_loader\"] = app_loader\n            kwargs[\"server_info\"] = {}\n            kwargs[\"passthru\"] = {\n                \"auto_reload\": app.auto_reload,\n                \"state\": {\n                    \"verbosity\": app.state.verbosity,\n                    \"mode\": app.state.mode,\n                },\n                \"config\": {\n                    \"ACCESS_LOG\": app.config.ACCESS_LOG,\n                    \"NOISY_EXCEPTIONS\": app.config.NOISY_EXCEPTIONS,\n                },\n                \"shared_ctx\": app.shared_ctx.__dict__,\n            }\n            for app in apps:\n                kwargs[\"server_info\"][app.name] = []\n                for server_info in app.state.server_info:\n                    server_info.settings = {\n                        k: v\n                        for k, v in server_info.settings.items()\n                        if k not in (\"main_start\", \"main_stop\", \"app\", \"ssl\")\n                    }\n                    kwargs[\"server_info\"][app.name].append(server_info)\n\n            ssl = kwargs.get(\"ssl\")\n\n            if isinstance(ssl, SanicSSLContext):\n                kwargs[\"ssl\"] = ssl.sanic\n\n            manager = WorkerManager(\n                primary.state.workers,\n                worker_serve,\n                kwargs,\n                cls._get_context(),\n                (monitor_pub, monitor_sub),\n                worker_state,\n            )\n            if cls.should_auto_reload():\n                reload_dirs: set[Path] = primary.state.reload_dirs.union(\n                    *(app.state.reload_dirs for app in apps)\n                )\n                reloader = Reloader(monitor_pub, 0, reload_dirs, app_loader)\n                manager.manage(\"Reloader\", reloader, {}, transient=False)\n\n            inspector = None\n            if primary.config.INSPECTOR:\n                display, extra = primary.get_motd_data()\n                packages = [\n                    pkg.strip() for pkg in display[\"packages\"].split(\",\")\n                ]\n                module = import_module(\"sanic\")\n                sanic_version = f\"sanic=={module.__version__}\"  # type: ignore\n                app_info = {\n                    **display,\n                    \"packages\": [sanic_version, *packages],\n                    \"extra\": extra,\n                }\n                inspector = primary.inspector_class(\n                    monitor_pub,\n                    app_info,\n                    worker_state,\n                    primary.config.INSPECTOR_HOST,\n                    primary.config.INSPECTOR_PORT,\n                    primary.config.INSPECTOR_API_KEY,\n                    primary.config.INSPECTOR_TLS_KEY,\n                    primary.config.INSPECTOR_TLS_CERT,\n                )\n                manager.manage(\"Inspector\", inspector, {}, transient=False)\n\n            primary._inspector = inspector\n            primary._manager = manager\n\n            ready = primary.listeners[\"main_process_ready\"]\n            trigger_events(ready, loop, primary)\n\n            manager.run()\n        except ServerKilled:\n            exit_code = 1\n        except BaseException:\n            kwargs = primary_server_info.settings\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            logger.info(\"Server Stopped\")\n            for app in apps:\n                app.state.server_info.clear()\n                app.router.reset()\n                app.signal_router.reset()\n\n            for sock in socks:\n                try:\n                    sock.shutdown(SHUT_RDWR)\n                except OSError:\n                    ...\n                sock.close()\n            socks = []\n\n            trigger_events(main_stop, loop, primary)\n\n            loop.close()\n            cls._cleanup_env_vars()\n            cls._cleanup_apps()\n\n            limit = 100\n            while cls._get_process_states(worker_state):\n                sleep(0.1)\n                limit -= 1\n                if limit <= 0:\n                    error_logger.warning(\n                        \"Worker shutdown timed out. \"\n                        \"Some processes may still be running.\"\n                    )\n                    break\n            sync_manager.shutdown()\n            unix = kwargs.get(\"unix\")\n            if unix:\n                remove_unix_socket(unix)\n            logger.debug(get_goodbye())\n        if exit_code:\n            os._exit(exit_code)\n\n    @staticmethod\n    def _get_process_states(worker_state) -> list[str]:\n        return [\n            state\n            for s in worker_state.values()\n            if (\n                (state := s.get(\"state\"))\n                and state not in (\"TERMINATED\", \"FAILED\", \"COMPLETED\", \"NONE\")\n            )\n        ]\n\n    @classmethod\n    def serve_single(cls, primary: Optional[Sanic] = None) -> None:\n        \"\"\"Serve a single process of a Sanic application.\n\n        Similar to `serve`, but only serves a single process. When used,\n        certain features are disabled, such as `fast`, `workers`,\n        `multiplexer`, `auto_reload`, and the Inspector. It is almost\n        never needed to use this method directly. Instead, you should\n        use the CLI:\n\n        ```sh\n        sanic app.sanic:app --single-process\n        ```\n\n        Or, if you need to do it programmatically, you should use the\n        `single_process` argument of `run`:\n\n        ```python\n        app.run(single_process=True)\n        ```\n\n        Args:\n            primary (Optional[Sanic], optional): The primary Sanic application\n                to serve. Defaults to `None`.\n\n        Raises:\n            RuntimeError: Raised when no applications are found.\n            RuntimeError: Raised when no server information is found for the\n                primary application.\n            RuntimeError: Raised when attempting to serve HTTP/3 as a\n                secondary server.\n            RuntimeError: Raised when attempting to use both `fast` and\n                `workers`.\n            ValueError: Raised when `PROXIES_COUNT` is negative.\n        \"\"\"\n        os.environ[\"SANIC_MOTD_OUTPUT\"] = \"true\"\n        apps = list(cls._app_registry.values())\n\n        if not primary:\n            try:\n                primary = apps[0]\n            except IndexError:\n                raise RuntimeError(\"Did not find any applications.\")\n\n        # This exists primarily for unit testing\n        if not primary.state.server_info:  # no cov\n            for app in apps:\n                app.state.server_info.clear()\n            return\n\n        primary_server_info = primary.state.server_info[0]\n        primary.before_server_start(partial(primary._start_servers, apps=apps))\n        kwargs = {\n            k: v\n            for k, v in primary_server_info.settings.items()\n            if k\n            not in (\n                \"main_start\",\n                \"main_stop\",\n                \"app\",\n            )\n        }\n        kwargs[\"app_name\"] = primary.name\n        kwargs[\"app_loader\"] = None\n        sock = configure_socket(kwargs)\n\n        kwargs[\"server_info\"] = {}\n        kwargs[\"server_info\"][primary.name] = []\n        for server_info in primary.state.server_info:\n            server_info.settings = {\n                k: v\n                for k, v in server_info.settings.items()\n                if k not in (\"main_start\", \"main_stop\", \"app\")\n            }\n            kwargs[\"server_info\"][primary.name].append(server_info)\n\n        try:\n            worker_serve(monitor_publisher=None, **kwargs)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            logger.info(\"Server Stopped\")\n            for app in apps:\n                app.state.server_info.clear()\n                app.router.reset()\n                app.signal_router.reset()\n\n            if sock:\n                sock.close()\n\n            cls._cleanup_env_vars()\n            cls._cleanup_apps()\n\n    async def _start_servers(\n        self,\n        primary: Sanic,\n        _,\n        apps: list[Sanic],\n    ) -> None:\n        for app in apps:\n            if (\n                app.name is not primary.name\n                and app.state.workers != primary.state.workers\n                and app.state.server_info\n            ):\n                message = (\n                    f\"The primary application {repr(primary)} is running \"\n                    f\"with {primary.state.workers} worker(s). All \"\n                    \"application instances will run with the same number. \"\n                    f\"You requested {repr(app)} to run with \"\n                    f\"{app.state.workers} worker(s), which will be ignored \"\n                    \"in favor of the primary application.\"\n                )\n                if is_atty():\n                    message = \"\".join(\n                        [\n                            Colors.YELLOW,\n                            message,\n                            Colors.END,\n                        ]\n                    )\n                error_logger.warning(message, exc_info=True)\n            for server_info in app.state.server_info:\n                if server_info.stage is not ServerStage.SERVING:\n                    app.state.primary = False\n                    handlers = [\n                        *server_info.settings.pop(\"main_start\", []),\n                        *server_info.settings.pop(\"main_stop\", []),\n                    ]\n                    if handlers:  # no cov\n                        error_logger.warning(\n                            f\"Sanic found {len(handlers)} listener(s) on \"\n                            \"secondary applications attached to the main \"\n                            \"process. These will be ignored since main \"\n                            \"process listeners can only be attached to your \"\n                            \"primary application: \"\n                            f\"{repr(primary)}\"\n                        )\n\n                    if not server_info.settings[\"loop\"]:\n                        server_info.settings[\"loop\"] = get_running_loop()\n\n                    serve_args: dict[str, Any] = {\n                        **server_info.settings,\n                        \"run_async\": True,\n                        \"reuse_port\": bool(primary.state.workers - 1),\n                    }\n                    if \"app\" not in serve_args:\n                        serve_args[\"app\"] = app\n                    try:\n                        server_info.server = await serve(**serve_args)\n                    except OSError as e:  # no cov\n                        first_message = (\n                            \"An OSError was detected on startup. \"\n                            \"The encountered error was: \"\n                        )\n                        second_message = str(e)\n                        if is_atty():\n                            message_parts = [\n                                Colors.YELLOW,\n                                first_message,\n                                Colors.RED,\n                                second_message,\n                                Colors.END,\n                            ]\n                        else:\n                            message_parts = [first_message, second_message]\n                        message = \"\".join(message_parts)\n                        error_logger.warning(message, exc_info=True)\n                        continue\n                    primary.add_task(\n                        self._run_server(app, server_info), name=\"RunServer\"\n                    )\n\n    async def _run_server(\n        self,\n        app: StartupMixin,\n        server_info: ApplicationServerInfo,\n    ) -> None:  # no cov\n        try:\n            # We should never get to this point without a server\n            # This is primarily to keep mypy happy\n            if not server_info.server:  # no cov\n                raise RuntimeError(\"Could not locate AsyncioServer\")\n            if app.state.stage is ServerStage.STOPPED:\n                server_info.stage = ServerStage.SERVING\n                await server_info.server.startup()\n                await server_info.server.before_start()\n                await server_info.server.after_start()\n            await server_info.server.serve_forever()\n        except CancelledError:\n            # We should never get to this point without a server\n            # This is primarily to keep mypy happy\n            if not server_info.server:  # no cov\n                raise RuntimeError(\"Could not locate AsyncioServer\")\n            await server_info.server.before_stop()\n            await server_info.server.close()\n            await server_info.server.after_stop()\n        finally:\n            server_info.stage = ServerStage.STOPPED\n            server_info.server = None\n\n    @staticmethod\n    def _cleanup_env_vars():\n        variables = (\n            \"SANIC_RELOADER_PROCESS\",\n            \"SANIC_IGNORE_PRODUCTION_WARNING\",\n            \"SANIC_WORKER_NAME\",\n            \"SANIC_MOTD_OUTPUT\",\n            \"SANIC_WORKER_PROCESS\",\n            \"SANIC_SERVER_RUNNING\",\n        )\n        for var in variables:\n            try:\n                del os.environ[var]\n            except KeyError:\n                ...\n\n    @classmethod\n    def _cleanup_apps(cls):\n        for app in cls._app_registry.values():\n            app.state.server_info.clear()\n            app.router.reset()\n            app.signal_router.reset()\n```"
    },
    {
      "chunk_id": 682,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Coroutine\nfrom enum import Enum\nfrom typing import Any, Callable, Optional, Union\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.handler_types import SignalHandler\nfrom sanic.signals import Event, Signal\nfrom sanic.types import HashableDict"
    },
    {
      "chunk_id": 683,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "class SignalMixin(metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_signals: set[FutureSignal] = set()"
    },
    {
      "chunk_id": 684,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "def _apply_signal(self, signal: FutureSignal) -> Signal:\n        raise NotImplementedError  # noqa"
    },
    {
      "chunk_id": 685,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "def signal(\n        self,\n        event: Union[str, Enum],\n        *,\n        apply: bool = True,\n        condition: Optional[dict[str, Any]] = None,\n        exclusive: bool = True,\n        priority: int = 0,\n    ) -> Callable[[SignalHandler], SignalHandler]:\n        \"\"\"\n        For creating a signal handler, used similar to a route handler:\n\n        .. code-block:: python\n\n            @app.signal(\"foo.bar.<thing>\")\n            async def signal_handler(thing, **kwargs):\n                print(f\"[signal_handler] {thing=}\", kwargs)\n\n        :param event: Representation of the event in ``one.two.three`` form\n        :type event: str\n        :param apply: For lazy evaluation, defaults to ``True``\n        :type apply: bool, optional\n        :param condition: For use with the ``condition`` argument in dispatch\n            filtering, defaults to ``None``\n        :param exclusive: When ``True``, the signal can only be dispatched\n            when the condition has been met. When ``False``, the signal can\n            be dispatched either with or without it. *THIS IS INAPPLICABLE TO\n            BLUEPRINT SIGNALS. THEY ARE ALWAYS NON-EXCLUSIVE*, defaults\n            to ``True``\n        :type condition: Dict[str, Any], optional\n        \"\"\"\n        event_value = str(event.value) if isinstance(event, Enum) else event\n\n        def decorator(handler: SignalHandler):\n            future_signal = FutureSignal(\n                handler,\n                event_value,\n                HashableDict(condition or {}),\n                exclusive,\n                priority,\n            )\n            self._future_signals.add(future_signal)\n\n            if apply:\n                self._apply_signal(future_signal)\n\n            return handler\n\n        return decorator"
    },
    {
      "chunk_id": 686,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "def add_signal(\n        self,\n        handler: Optional[Callable[..., Any]],\n        event: Union[str, Enum],\n        condition: Optional[dict[str, Any]] = None,\n        exclusive: bool = True,\n    ) -> Callable[..., Any]:\n        \"\"\"Registers a signal handler for a specific event.\n\n        Args:\n            handler (Optional[Callable[..., Any]]): The function to be called\n                when the event occurs. Defaults to a noop if not provided.\n            event (str): The name of the event to listen for.\n            condition (Optional[Dict[str, Any]]): Optional condition to filter\n                the event triggering. Defaults to `None`.\n            exclusive (bool): Whether or not the handler is exclusive. When\n                `True`, the signal can only be dispatched when the\n                `condition` has been met. *This is inapplicable to blueprint\n                signals, which are **ALWAYS** non-exclusive.* Defaults\n                to `True`.\n\n        Returns:\n            Callable[..., Any]: The handler that was registered.\n        \"\"\"\n        if not handler:\n\n            async def noop(**context): ...\n\n            handler = noop\n        self.signal(event=event, condition=condition, exclusive=exclusive)(\n            handler\n        )\n        return handler"
    },
    {
      "chunk_id": 687,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "def event(self, event: str):\n        raise NotImplementedError"
    },
    {
      "chunk_id": 688,
      "source": "__internal__/data_repo/sanic/sanic/mixins/signals.py",
      "content": "def catch_exception(\n        self,\n        handler: Callable[[SignalMixin, Exception], Coroutine[Any, Any, None]],\n    ) -> None:\n        \"\"\"Register an exception handler for logging or processing.\n\n        This method allows the registration of a custom exception handler to\n        catch and process exceptions that occur in the application. Unlike a\n        typical exception handler that might modify the response to the client,\n        this is intended to capture exceptions for logging or other internal\n        processing, such as sending them to an error reporting utility.\n\n        Args:\n            handler (Callable): A coroutine function that takes the application\n                instance and the exception as arguments. It will be called when\n                an exception occurs within the application's lifecycle.\n\n        Example:\n            ```python\n            app = Sanic(\"TestApp\")\n\n            @app.catch_exception\n            async def report_exception(app: Sanic, exception: Exception):\n                logging.error(f\"An exception occurred: {exception}\")\n\n                # Send to an error reporting service\n                await error_service.report(exception)\n\n            # Any unhandled exceptions within the application will now be\n            # logged and reported to the error service.\n            ```\n        \"\"\"  # noqa: E501\n\n        async def signal_handler(exception: Exception):\n            await handler(self, exception)\n\n        self.signal(Event.SERVER_EXCEPTION_REPORT)(signal_handler)"
    },
    {
      "chunk_id": 689,
      "source": "__internal__/data_repo/sanic/sanic/mixins/static.py",
      "content": "from collections.abc import Sequence\nfrom email.utils import formatdate\nfrom functools import partial, wraps\nfrom mimetypes import guess_type\nfrom os import PathLike, path\nfrom pathlib import Path, PurePath\nfrom typing import Optional, Union\nfrom urllib.parse import unquote\n\nfrom sanic_routing.route import Route\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.compat import stat_async\nfrom sanic.constants import DEFAULT_HTTP_CONTENT_TYPE\nfrom sanic.exceptions import FileNotFound, HeaderNotFound, RangeNotSatisfiable\nfrom sanic.handlers import ContentRangeHandler\nfrom sanic.handlers.directory import DirectoryHandler\nfrom sanic.log import error_logger\nfrom sanic.mixins.base import BaseMixin\nfrom sanic.models.futures import FutureStatic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse, file, file_stream, validate_file"
    },
    {
      "chunk_id": 690,
      "source": "__internal__/data_repo/sanic/sanic/mixins/static.py",
      "content": "class StaticMixin(BaseMixin, metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_statics: set[FutureStatic] = set()\n\n    def _apply_static(self, static: FutureStatic) -> Route:\n        raise NotImplementedError  # noqa\n\n    def static(\n        self,\n        uri: str,\n        file_or_directory: Union[PathLike, str],\n        pattern: str = r\"/?.+\",\n        use_modified_since: bool = True,\n        use_content_range: bool = False,\n        stream_large_files: Union[bool, int] = False,\n        name: str = \"static\",\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        content_type: Optional[str] = None,\n        apply: bool = True,\n        resource_type: Optional[str] = None,\n        index: Optional[Union[str, Sequence[str]]] = None,\n        directory_view: bool = False,\n        directory_handler: Optional[DirectoryHandler] = None,\n    ):\n        \"\"\"Register a root to serve files from. The input can either be a file or a directory.\n\n        This method provides an easy and simple way to set up the route necessary to serve static files.\n\n        Args:\n            uri (str): URL path to be used for serving static content.\n            file_or_directory (Union[PathLike, str]): Path to the static file\n                or directory with static files.\n            pattern (str, optional): Regex pattern identifying the valid\n                static files. Defaults to `r\"/?.+\"`.\n            use_modified_since (bool, optional): If true, send file modified\n                time, and return not modified if the browser's matches the\n                server's. Defaults to `True`.\n            use_content_range (bool, optional): If true, process header for\n                range requests and sends  the file part that is requested.\n                Defaults to `False`.\n            stream_large_files (Union[bool, int], optional): If `True`, use\n                the `StreamingHTTPResponse.file_stream` handler rather than\n                the `HTTPResponse.file handler` to send the file. If this\n                is an integer, it represents the threshold size to switch\n                to `StreamingHTTPResponse.file_stream`. Defaults to `False`,\n                which means that the response will not be streamed.\n            name (str, optional): User-defined name used for url_for.\n                Defaults to `\"static\"`.\n            host (Optional[str], optional): Host IP or FQDN for the\n                service to use.\n            strict_slashes (Optional[bool], optional): Instruct Sanic to\n                check if the request URLs need to terminate with a slash.\n            content_type (Optional[str], optional): User-defined content type\n                for header.\n            apply (bool, optional): If true, will register the route\n                immediately. Defaults to `True`.\n            resource_type (Optional[str], optional): Explicitly declare a\n                resource to be a `\"file\"` or a `\"dir\"`.\n            index (Optional[Union[str, Sequence[str]]], optional): When\n                exposing against a directory, index is  the name that will\n                be served as the default file. When multiple file names are\n                passed, then they will be tried in order.\n            directory_view (bool, optional): Whether to fallback to showing\n                the directory viewer when exposing a directory. Defaults\n                to `False`.\n            directory_handler (Optional[DirectoryHandler], optional): An\n                instance of DirectoryHandler that can be used for explicitly\n                controlling and subclassing the behavior of the default\n                directory handler.\n\n        Returns:\n            List[sanic.router.Route]: Routes registered on the router.\n\n        Examples:\n            Serving a single file:\n            ```python\n            app.static('/foo', 'path/to/static/file.txt')\n            ```\n\n            Serving all files from a directory:\n            ```python\n            app.static('/static', 'path/to/static/directory')\n            ```\n\n            Serving large files with a specific threshold:\n            ```python\n            app.static('/static', 'path/to/large/files', stream_large_files=1000000)\n            ```\n        \"\"\"  # noqa: E501\n\n        name = self.generate_name(name)\n\n        if strict_slashes is None and self.strict_slashes is not None:\n            strict_slashes = self.strict_slashes\n\n        if not isinstance(file_or_directory, (str, bytes, PurePath)):\n            raise ValueError(\n                f\"Static route must be a valid path, not {file_or_directory}\"\n            )\n\n        try:\n            file_or_directory = Path(file_or_directory).resolve()\n        except TypeError:\n            raise TypeError(\n                \"Static file or directory must be a path-like object or string\"\n            )\n\n        if directory_handler and (directory_view or index):\n            raise ValueError(\n                \"When explicitly setting directory_handler, you cannot \"\n                \"set either directory_view or index. Instead, pass \"\n                \"these arguments to your DirectoryHandler instance.\"\n            )\n\n        if not directory_handler:\n            directory_handler = DirectoryHandler(\n                uri=uri,\n                directory=file_or_directory,\n                directory_view=directory_view,\n                index=index,\n            )\n\n        static = FutureStatic(\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n            resource_type,\n            directory_handler,\n        )\n        self._future_statics.add(static)\n\n        if apply:\n            self._apply_static(static)"
    },
    {
      "chunk_id": 691,
      "source": "__internal__/data_repo/sanic/sanic/mixins/static.py",
      "content": "class StaticHandleMixin(metaclass=SanicMeta):\n    def _apply_static(self, static: FutureStatic) -> Route:\n        return self._register_static(static)\n\n    def _register_static(\n        self,\n        static: FutureStatic,\n    ):\n        # TODO: Though sanic is not a file server, I feel like we should\n        # at least make a good effort here.  Modified-since is nice, but\n        # we could also look into etags, expires, and caching\n        \"\"\"\n        Register a static directory handler with Sanic by adding a route to the\n        router and registering a handler.\n        \"\"\"\n        file_or_directory: PathLike\n\n        if isinstance(static.file_or_directory, bytes):\n            file_or_directory = Path(static.file_or_directory.decode(\"utf-8\"))\n        elif isinstance(static.file_or_directory, PurePath):\n            file_or_directory = static.file_or_directory\n        elif isinstance(static.file_or_directory, str):\n            file_or_directory = Path(static.file_or_directory)\n        else:\n            raise ValueError(\"Invalid file path string.\")\n\n        uri = static.uri\n        name = static.name\n        # If we're not trying to match a file directly,\n        # serve from the folder\n        if not static.resource_type:\n            if not path.isfile(file_or_directory):\n                uri = uri.rstrip(\"/\")\n                uri += \"/<__file_uri__:path>\"\n        elif static.resource_type == \"dir\":\n            if path.isfile(file_or_directory):\n                raise TypeError(\n                    \"Resource type improperly identified as directory. \"\n                    f\"'{file_or_directory}'\"\n                )\n            uri = uri.rstrip(\"/\")\n            uri += \"/<__file_uri__:path>\"\n        elif static.resource_type == \"file\" and not path.isfile(\n            file_or_directory\n        ):\n            raise TypeError(\n                \"Resource type improperly identified as file. \"\n                f\"'{file_or_directory}'\"\n            )\n        elif static.resource_type != \"file\":\n            raise ValueError(\n                \"The resource_type should be set to 'file' or 'dir'\"\n            )\n\n        # special prefix for static files\n        # if not static.name.startswith(\"_static_\"):\n        #     name = f\"_static_{static.name}\"\n\n        _handler = wraps(self._static_request_handler)(\n            partial(\n                self._static_request_handler,\n                file_or_directory=str(file_or_directory),\n                use_modified_since=static.use_modified_since,\n                use_content_range=static.use_content_range,\n                stream_large_files=static.stream_large_files,\n                content_type=static.content_type,\n                directory_handler=static.directory_handler,\n            )\n        )\n\n        route, _ = self.route(  # type: ignore\n            uri=uri,\n            methods=[\"GET\", \"HEAD\"],\n            name=name,\n            host=static.host,\n            strict_slashes=static.strict_slashes,\n            static=True,\n        )(_handler)\n\n        return route"
    },
    {
      "chunk_id": 692,
      "source": "__internal__/data_repo/sanic/sanic/mixins/static.py",
      "content": "async def _static_request_handler(\n        self,\n        request: Request,\n        *,\n        file_or_directory: str,\n        use_modified_since: bool,\n        use_content_range: bool,\n        stream_large_files: Union[bool, int],\n        directory_handler: DirectoryHandler,\n        content_type: Optional[str] = None,\n        __file_uri__: Optional[str] = None,\n    ):\n        not_found = FileNotFound(\n            \"File not found\",\n            path=Path(file_or_directory),\n            relative_url=__file_uri__,\n        )\n\n        # Merge served directory and requested file if provided\n        file_path = await self._get_file_path(\n            file_or_directory, __file_uri__, not_found\n        )\n\n        try:\n            headers = {}\n            # Check if the client has been sent this file before\n            # and it has not been modified since\n            stats = None\n            if use_modified_since:\n                stats = await stat_async(file_path)\n                modified_since = stats.st_mtime\n                response = await validate_file(request.headers, modified_since)\n                if response:\n                    return response\n                headers[\"Last-Modified\"] = formatdate(\n                    modified_since, usegmt=True\n                )\n            _range = None\n            if use_content_range:\n                _range = None\n                if not stats:\n                    stats = await stat_async(file_path)\n                headers[\"Accept-Ranges\"] = \"bytes\"\n                headers[\"Content-Length\"] = str(stats.st_size)\n                if request.method != \"HEAD\":\n                    try:\n                        _range = ContentRangeHandler(request, stats)\n                    except HeaderNotFound:\n                        pass\n                    else:\n                        del headers[\"Content-Length\"]\n                        headers.update(_range.headers)\n\n            if \"content-type\" not in headers:\n                content_type = (\n                    content_type\n                    or guess_type(file_path)[0]\n                    or DEFAULT_HTTP_CONTENT_TYPE\n                )\n\n                if \"charset=\" not in content_type and (\n                    content_type.startswith(\"text/\")\n                    or content_type == \"application/javascript\"\n                ):\n                    content_type += \"; charset=utf-8\"\n\n                headers[\"Content-Type\"] = content_type\n\n            if request.method == \"HEAD\":\n                return HTTPResponse(headers=headers)\n            else:\n                if stream_large_files:\n                    if isinstance(stream_large_files, bool):\n                        threshold = 1024 * 1024\n                    else:\n                        threshold = stream_large_files\n\n                    if not stats:\n                        stats = await stat_async(file_path)\n                    if stats.st_size >= threshold:\n                        return await file_stream(\n                            file_path, headers=headers, _range=_range\n                        )\n                return await file(file_path, headers=headers, _range=_range)\n        except (IsADirectoryError, PermissionError):\n            return await directory_handler.handle(request, request.path)\n        except RangeNotSatisfiable:\n            raise\n        except FileNotFoundError:\n            raise not_found\n        except Exception:\n            error_logger.exception(\n                \"Exception in static request handler: \"\n                f\"path={file_or_directory}, \"\n                f\"relative_url={__file_uri__}\"\n            )\n            raise"
    },
    {
      "chunk_id": 693,
      "source": "__internal__/data_repo/sanic/sanic/mixins/static.py",
      "content": "async def _get_file_path(self, file_or_directory, __file_uri__, not_found):\n        file_path_raw = Path(unquote(file_or_directory))\n        root_path = file_path = file_path_raw.resolve()\n\n        if __file_uri__:\n            # Strip all / that in the beginning of the URL to help prevent\n            # python from herping a derp and treating the uri as an\n            # absolute path\n            unquoted_file_uri = unquote(__file_uri__).lstrip(\"/\")\n            file_path_raw = Path(file_or_directory, unquoted_file_uri)\n            file_path = file_path_raw.resolve()\n            if (\n                file_path < root_path and not file_path_raw.is_symlink()\n            ) or \"..\" in file_path_raw.parts:\n                error_logger.exception(\n                    f\"File not found: path={file_or_directory}, \"\n                    f\"relative_url={__file_uri__}\"\n                )\n                raise not_found\n\n        try:\n            file_path.relative_to(root_path)\n        except ValueError:\n            if not file_path_raw.is_symlink():\n                error_logger.exception(\n                    f\"File not found: path={file_or_directory}, \"\n                    f\"relative_url={__file_uri__}\"\n                )\n                raise not_found\n        return file_path"
    },
    {
      "chunk_id": 694,
      "source": "__internal__/data_repo/sanic/sanic/mixins/exceptions.py",
      "content": "from typing import Any, Callable, Union\n\nfrom sanic.base.meta import SanicMeta\nfrom sanic.models.futures import FutureException"
    },
    {
      "chunk_id": 695,
      "source": "__internal__/data_repo/sanic/sanic/mixins/exceptions.py",
      "content": "class ExceptionMixin(metaclass=SanicMeta):\n    def __init__(self, *args, **kwargs) -> None:\n        self._future_exceptions: set[FutureException] = set()"
    },
    {
      "chunk_id": 696,
      "source": "__internal__/data_repo/sanic/sanic/mixins/exceptions.py",
      "content": "def _apply_exception_handler(self, handler: FutureException):\n        raise NotImplementedError  # noqa"
    },
    {
      "chunk_id": 697,
      "source": "__internal__/data_repo/sanic/sanic/mixins/exceptions.py",
      "content": "def exception(\n        self,\n        *exceptions: Union[type[Exception], list[type[Exception]]],\n        apply: bool = True,\n    ) -> Callable:\n        \"\"\"Decorator used to register an exception handler for the current application or blueprint instance.\n\n        This method allows you to define a handler for specific exceptions that\n        may be raised within the routes of this blueprint. You can specify one\n        or more exception types to catch, and the handler will be applied to\n        those exceptions.\n\n        When used on a Blueprint, the handler will only be applied to routes\n        registered under that blueprint. That means they only apply to\n        requests that have been matched, and the exception is raised within\n        the handler function (or middleware) for that route.\n\n        A general exception like `NotFound` should only be registered on the\n        application instance, not on a blueprint.\n\n        See [Exceptions](/en/guide/best-practices/exceptions.html) for more information.\n\n        Args:\n            exceptions (Union[Type[Exception], List[Type[Exception]]]): List of\n                Python exceptions to be caught by the handler.\n            apply (bool, optional): Whether the exception handler should be\n                applied. Defaults to True.\n\n        Returns:\n            Callable: A decorated method to handle global exceptions for any route\n                registered under this blueprint.\n\n        Example:\n            ```python\n            from sanic import Blueprint, text\n\n            bp = Blueprint('my_blueprint')\n\n            @bp.exception(Exception)\n            def handle_exception(request, exception):\n                return text(\"Oops, something went wrong!\", status=500)\n            ```\n\n            ```python\n            from sanic import Sanic, NotFound, text\n\n            app = Sanic('MyApp')\n\n            @app.exception(NotFound)\n            def ignore_404s(request, exception):\n                return text(f\"Yep, I totally found the page: {request.url}\")\n        \"\"\"  # noqa: E501\n\n        def decorator(handler):\n            nonlocal apply\n            nonlocal exceptions\n\n            if isinstance(exceptions[0], list):\n                exceptions = tuple(*exceptions)\n\n            future_exception = FutureException(handler, exceptions)\n            self._future_exceptions.add(future_exception)\n            if apply:\n                self._apply_exception_handler(future_exception)\n            return handler\n\n        return decorator"
    },
    {
      "chunk_id": 698,
      "source": "__internal__/data_repo/sanic/sanic/mixins/exceptions.py",
      "content": "def all_exceptions(\n        self, handler: Callable[..., Any]\n    ) -> Callable[..., Any]:\n        \"\"\"Enables the process of creating a global exception handler as a convenience.\n\n        This following two examples are equivalent:\n\n        ```python\n        @app.exception(Exception)\n        async def handler(request: Request, exception: Exception) -> HTTPResponse:\n            return text(f\"Exception raised: {exception}\")\n        ```\n\n        ```python\n        @app.all_exceptions\n        async def handler(request: Request, exception: Exception) -> HTTPResponse:\n            return text(f\"Exception raised: {exception}\")\n        ```\n\n        Args:\n            handler (Callable[..., Any]): A coroutine function to handle exceptions.\n\n        Returns:\n            Callable[..., Any]: A decorated method to handle global exceptions for\n                any route registered under this blueprint.\n        \"\"\"  # noqa: E501\n        return self.exception(Exception)(handler)"
    },
    {
      "chunk_id": 699,
      "source": "__internal__/data_repo/sanic/sanic/pages/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 700,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "from abc import ABC, abstractmethod\n\nfrom html5tagger import HTML, Builder, Document\n\nfrom sanic import __version__ as VERSION\nfrom sanic.application.logo import SVG_LOGO_SIMPLE\nfrom sanic.pages.css import CSS"
    },
    {
      "chunk_id": 701,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "class BasePage(ABC, metaclass=CSS):  # no cov\n    \"\"\"Base page for Sanic pages.\"\"\"\n\n    TITLE = \"Sanic\"\n    HEADING = None\n    CSS: str\n    doc: Builder\n\n    def __init__(self, debug: bool = True) -> None:\n        self.debug = debug"
    },
    {
      "chunk_id": 702,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "@property\n    def style(self) -> str:\n        \"\"\"Returns the CSS for the page.\n\n        Returns:\n            str: The CSS for the page.\n        \"\"\"\n        return self.CSS"
    },
    {
      "chunk_id": 703,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "def render(self) -> str:\n        \"\"\"Renders the page.\n\n        Returns:\n            str: The rendered page.\n        \"\"\"\n        self.doc = Document(self.TITLE, lang=\"en\", id=\"sanic\")\n        self._head()\n        self._body()\n        self._foot()\n        return str(self.doc)"
    },
    {
      "chunk_id": 704,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "def _head(self) -> None:\n        self.doc.style(HTML(self.style))\n        with self.doc.header:\n            self.doc.div(self.HEADING or self.TITLE)"
    },
    {
      "chunk_id": 705,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "def _foot(self) -> None:\n        with self.doc.footer:\n            self.doc.div(\"powered by\")\n            with self.doc.div:\n                self._sanic_logo()\n            if self.debug:\n                self.doc.div(f\"Version {VERSION}\")\n                with self.doc.div:\n                    for idx, (title, href) in enumerate(\n                        (\n                            (\"Docs\", \"https://sanic.dev\"),\n                            (\"Help\", \"https://sanic.dev/en/help.html\"),\n                            (\"GitHub\", \"https://github.com/sanic-org/sanic\"),\n                        )\n                    ):\n                        if idx > 0:\n                            self.doc(\" | \")\n                        self.doc.a(\n                            title,\n                            href=href,\n                            target=\"_blank\",\n                            referrerpolicy=\"no-referrer\",\n                        )\n                self.doc.div(\"DEBUG mode\")"
    },
    {
      "chunk_id": 706,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "@abstractmethod\n    def _body(self) -> None: ..."
    },
    {
      "chunk_id": 707,
      "source": "__internal__/data_repo/sanic/sanic/pages/base.py",
      "content": "def _sanic_logo(self) -> None:\n        self.doc.a(\n            HTML(SVG_LOGO_SIMPLE),\n            href=\"https://sanic.dev\",\n            target=\"_blank\",\n            referrerpolicy=\"no-referrer\",\n        )"
    },
    {
      "chunk_id": 708,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "from collections.abc import Iterable\nfrom typing import TypedDict\n\nfrom html5tagger import E\n\nfrom .base import BasePage"
    },
    {
      "chunk_id": 709,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "class FileInfo(TypedDict):\n    \"\"\"Type for file info.\"\"\"\n\n    icon: str\n    file_name: str\n    file_access: str\n    file_size: str"
    },
    {
      "chunk_id": 710,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "class DirectoryPage(BasePage):  # no cov\n    \"\"\"Page for viewing a directory.\"\"\"\n\n    TITLE = \"Directory Viewer\"\n\n    def __init__(\n        self, files: Iterable[FileInfo], url: str, debug: bool\n    ) -> None:\n        super().__init__(debug)\n        self.files = files\n        self.url = url"
    },
    {
      "chunk_id": 711,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "def _body(self) -> None:\n        with self.doc.main:\n            self._headline()\n            files = list(self.files)\n            if files:\n                self._file_table(files)\n            else:\n                self.doc.p(\"The folder is empty.\")"
    },
    {
      "chunk_id": 712,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "def _headline(self):\n        \"\"\"Implement a heading with the current path, combined with\n        breadcrumb links\"\"\"\n        with self.doc.h1(id=\"breadcrumbs\"):\n            p = self.url.split(\"/\")[:-1]\n\n            for i, part in enumerate(p):\n                path = \"/\".join(p[: i + 1]) + \"/\"\n                with self.doc.a(href=path):\n                    self.doc.span(part, class_=\"dir\").span(\"/\", class_=\"sep\")"
    },
    {
      "chunk_id": 713,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "def _file_table(self, files: Iterable[FileInfo]):\n        with self.doc.table(class_=\"autoindex container\"):\n            for f in files:\n                self._file_row(**f)"
    },
    {
      "chunk_id": 714,
      "source": "__internal__/data_repo/sanic/sanic/pages/directory_page.py",
      "content": "def _file_row(\n        self,\n        icon: str,\n        file_name: str,\n        file_access: str,\n        file_size: str,\n    ):\n        first = E.span(icon, class_=\"icon\").a(file_name, href=file_name)\n        self.doc.tr.td(first).td(file_size).td(file_access)"
    },
    {
      "chunk_id": 715,
      "source": "__internal__/data_repo/sanic/sanic/pages/error.py",
      "content": "from collections.abc import Mapping\nfrom typing import Any\n\nimport tracerite.html\n\nfrom html5tagger import E\nfrom tracerite import html_traceback, inspector\n\nfrom sanic.request import Request\n\nfrom .base import BasePage\n\n\n# Avoid showing the request in the traceback variable inspectors\ninspector.blacklist_types += (Request,)\n\nENDUSER_TEXT = \"\"\"\\\nWe're sorry, but it looks like something went wrong. Please try refreshing \\\nthe page or navigating back to the homepage. If the issue persists, our \\\ntechnical team is working to resolve it as soon as possible. We apologize \\\nfor the inconvenience and appreciate your patience.\\\n\"\"\""
    },
    {
      "chunk_id": 716,
      "source": "__internal__/data_repo/sanic/sanic/pages/error.py",
      "content": "class ErrorPage(BasePage):\n    \"\"\"Page for displaying an error.\"\"\"\n\n    STYLE_APPEND = tracerite.html.style\n\n    def __init__(\n        self,\n        debug: bool,\n        title: str,\n        text: str,\n        request: Request,\n        exc: Exception,\n    ) -> None:\n        super().__init__(debug)\n        name = request.app.name.replace(\"_\", \" \").strip()\n        if name.islower():\n            name = name.title()\n        self.TITLE = f\"Application {name} cannot handle your request\"\n        self.HEADING = E(\"Application \").strong(name)(\n            \" cannot handle your request\"\n        )\n        self.title = title\n        self.text = text\n        self.request = request\n        self.exc = exc\n        self.details_open = not getattr(exc, \"quiet\", False)"
    },
    {
      "chunk_id": 717,
      "source": "__internal__/data_repo/sanic/sanic/pages/error.py",
      "content": "def _head(self) -> None:\n        self.doc._script(tracerite.html.javascript)\n        super()._head()"
    },
    {
      "chunk_id": 718,
      "source": "__internal__/data_repo/sanic/sanic/pages/error.py",
      "content": "def _body(self) -> None:\n        debug = self.request.app.debug\n        route_name = self.request.name or \"[route not found]\"\n        with self.doc.main:\n            self.doc.h1(f\"\u26a0\ufe0f {self.title}\").p(self.text)\n            # Show context details if available on the exception\n            context = getattr(self.exc, \"context\", None)\n            if context:\n                self._key_value_table(\n                    \"Issue context\", \"exception-context\", context\n                )\n\n            if not debug:\n                with self.doc.div(id=\"enduser\"):\n                    self.doc.p(ENDUSER_TEXT).p.a(\"Front Page\", href=\"/\")\n                return\n            # Show additional details in debug mode,\n            # open by default for 500 errors\n            with self.doc.details(open=self.details_open, class_=\"smalltext\"):\n                # Show extra details if available on the exception\n                extra = getattr(self.exc, \"extra\", None)\n                if extra:\n                    self._key_value_table(\n                        \"Issue extra data\", \"exception-extra\", extra\n                    )\n\n                self.doc.summary(\n                    \"Details for developers (Sanic debug mode only)\"\n                )\n                if self.exc:\n                    with self.doc.div(class_=\"exception-wrapper\"):\n                        self.doc.h2(f\"Exception in {route_name}:\")\n                        self.doc(\n                            html_traceback(self.exc, include_js_css=False)\n                        )\n\n                self._key_value_table(\n                    f\"{self.request.method} {self.request.path}\",\n                    \"request-headers\",\n                    self.request.headers,\n                )"
    },
    {
      "chunk_id": 719,
      "source": "__internal__/data_repo/sanic/sanic/pages/error.py",
      "content": "def _key_value_table(\n        self, title: str, table_id: str, data: Mapping[str, Any]\n    ) -> None:\n        with self.doc.div(class_=\"key-value-display\"):\n            self.doc.h2(title)\n            with self.doc.dl(id=table_id, class_=\"key-value-table smalltext\"):\n                for key, value in data.items():\n                    # Reading values may cause a new exception, so suppress it\n                    try:\n                        value = str(value)\n                    except Exception:\n                        value = E.em(\"Unable to display value\")\n                    self.doc.dt.span(key, class_=\"nobr key\").span(\": \").dd(\n                        value\n                    )"
    },
    {
      "chunk_id": 720,
      "source": "__internal__/data_repo/sanic/sanic/pages/css.py",
      "content": "from abc import ABCMeta\nfrom pathlib import Path\nfrom typing import Optional"
    },
    {
      "chunk_id": 721,
      "source": "__internal__/data_repo/sanic/sanic/pages/css.py",
      "content": "CURRENT_DIR = Path(__file__).parent"
    },
    {
      "chunk_id": 722,
      "source": "__internal__/data_repo/sanic/sanic/pages/css.py",
      "content": "def _extract_style(maybe_style: Optional[str], name: str) -> str:\n    if maybe_style is not None:\n        maybe_path = Path(maybe_style)\n        if maybe_path.exists():\n            return maybe_path.read_text(encoding=\"UTF-8\")\n        return maybe_style\n    maybe_path = CURRENT_DIR / \"styles\" / f\"{name}.css\"\n    if maybe_path.exists():\n        return maybe_path.read_text(encoding=\"UTF-8\")\n    return \"\""
    },
    {
      "chunk_id": 723,
      "source": "__internal__/data_repo/sanic/sanic/pages/css.py",
      "content": "class CSS(ABCMeta):\n    \"\"\"Cascade stylesheets, i.e. combine all ancestor styles\"\"\"\n\n    def __new__(cls, name, bases, attrs):\n        Page = super().__new__(cls, name, bases, attrs)\n        # Use a locally defined STYLE or the one from styles directory\n        Page.STYLE = _extract_style(attrs.get(\"STYLE_FILE\"), name)\n        Page.STYLE += attrs.get(\"STYLE_APPEND\", \"\")\n        # Combine with all ancestor styles\n        Page.CSS = \"\".join(\n            Class.STYLE\n            for Class in reversed(Page.__mro__)\n            if type(Class) is CSS\n        )\n        return Page"
    },
    {
      "chunk_id": 724,
      "source": "__internal__/data_repo/sanic/sanic/worker/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 725,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "from multiprocessing.connection import Connection\nfrom os import environ, getpid\nfrom typing import Any, Callable, Optional\n\nfrom sanic.log import Colors, logger\nfrom sanic.worker.process import ProcessState\nfrom sanic.worker.state import WorkerState"
    },
    {
      "chunk_id": 726,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "class WorkerMultiplexer:\n    \"\"\"Multiplexer for Sanic workers.\n\n    This is instantiated inside of worker porocesses only. It is used to\n    communicate with the monitor process.\n\n    Args:\n        monitor_publisher (Connection): The connection to the monitor.\n        worker_state (Dict[str, Any]): The state of the worker.\n    \"\"\"\n\n    def __init__(\n        self,\n        monitor_publisher: Connection,\n        worker_state: dict[str, Any],\n    ):\n        self._monitor_publisher = monitor_publisher\n        self._state = WorkerState(worker_state, self.name)"
    },
    {
      "chunk_id": 727,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def ack(self):\n        \"\"\"Acknowledge the worker is ready.\"\"\"\n        logger.debug(\n            f\"{Colors.BLUE}Process ack: {Colors.BOLD}{Colors.SANIC}\"\n            f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n            self.name,\n            self.pid,\n        )\n        self._state._state[self.name] = {\n            **self._state._state[self.name],\n            \"state\": ProcessState.ACKED.name,\n        }"
    },
    {
      "chunk_id": 728,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def manage(\n        self,\n        ident: str,\n        func: Callable[..., Any],\n        kwargs: dict[str, Any],\n        transient: bool = False,\n        restartable: Optional[bool] = None,\n        tracked: bool = False,\n        auto_start: bool = True,\n        workers: int = 1,\n    ) -> None:\n        \"\"\"Manages the initiation and monitoring of a worker process.\n\n        Args:\n            ident (str): A unique identifier for the worker process.\n            func (Callable[..., Any]): The function to be executed in the worker process.\n            kwargs (Dict[str, Any]): A dictionary of arguments to be passed to `func`.\n            transient (bool, optional): Flag to mark the process as transient. If `True`,\n                the Worker Manager will restart the process with any global restart\n                (e.g., auto-reload). Defaults to `False`.\n            restartable (Optional[bool], optional): Flag to mark the process as restartable. If `True`,\n                the Worker Manager can restart the process if prompted. Defaults to `None`.\n            tracked (bool, optional): Flag to indicate whether the process should be tracked\n                after its completion. Defaults to `False`.\n            auto_start (bool, optional): Flag to indicate whether the process should be started\n            workers (int, optional): The number of worker processes to run. Defaults to 1.\n\n        This method packages the provided arguments into a bundle and sends them back to the\n        main process to be managed by the Worker Manager.\n        \"\"\"  # noqa: E501\n        bundle = (\n            ident,\n            func,\n            kwargs,\n            transient,\n            restartable,\n            tracked,\n            auto_start,\n            workers,\n        )\n        self._monitor_publisher.send(bundle)"
    },
    {
      "chunk_id": 729,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def set_serving(self, serving: bool) -> None:\n        \"\"\"Set the worker to serving.\n\n        Args:\n            serving (bool): Whether the worker is serving.\n        \"\"\"\n        self._state._state[self.name] = {\n            **self._state._state[self.name],\n            \"serving\": serving,\n        }"
    },
    {
      "chunk_id": 730,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def exit(self):\n        \"\"\"Run cleanup at worker exit.\"\"\"\n        try:\n            del self._state._state[self.name]\n        except ConnectionRefusedError:\n            logger.debug(\"Monitor process has already exited.\")"
    },
    {
      "chunk_id": 731,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def restart(\n        self,\n        name: str = \"\",\n        all_workers: bool = False,\n        zero_downtime: bool = False,\n    ):\n        \"\"\"Restart the worker.\n\n        Args:\n            name (str): The name of the process to restart.\n            all_workers (bool): Whether to restart all workers.\n            zero_downtime (bool): Whether to restart with zero downtime.\n        \"\"\"\n        if name and all_workers:\n            raise ValueError(\n                \"Ambiguous restart with both a named process and\"\n                \" all_workers=True\"\n            )\n        if not name:\n            name = \"__ALL_PROCESSES__:\" if all_workers else self.name\n        if not name.endswith(\":\"):\n            name += \":\"\n        if zero_downtime:\n            name += \":STARTUP_FIRST\"\n        self._monitor_publisher.send(name)"
    },
    {
      "chunk_id": 732,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "reload = restart  # no cov\n    \"\"\"Alias for restart.\"\"\""
    },
    {
      "chunk_id": 733,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def scale(self, num_workers: int):\n        \"\"\"Scale the number of workers.\n\n        Args:\n            num_workers (int): The number of workers to scale to.\n        \"\"\"\n        message = f\"__SCALE__:{num_workers}\"\n        self._monitor_publisher.send(message)"
    },
    {
      "chunk_id": 734,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "def terminate(self, early: bool = False):\n        \"\"\"Terminate the worker.\n\n        Args:\n            early (bool): Whether to terminate early.\n        \"\"\"\n        message = \"__TERMINATE_EARLY__\" if early else \"__TERMINATE__\"\n        self._monitor_publisher.send(message)"
    },
    {
      "chunk_id": 735,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "@property\n    def pid(self) -> int:\n        \"\"\"The process ID of the worker.\"\"\"\n        return getpid()"
    },
    {
      "chunk_id": 736,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "@property\n    def name(self) -> str:\n        \"\"\"The name of the worker.\"\"\"\n        return environ.get(\"SANIC_WORKER_NAME\", \"\")"
    },
    {
      "chunk_id": 737,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "@property\n    def state(self):\n        \"\"\"The state of the worker.\"\"\"\n        return self._state"
    },
    {
      "chunk_id": 738,
      "source": "__internal__/data_repo/sanic/sanic/worker/multiplexer.py",
      "content": "@property\n    def workers(self) -> dict[str, Any]:\n        \"\"\"The state of all workers.\"\"\"\n        return self.state.full()"
    },
    {
      "chunk_id": 739,
      "source": "__internal__/data_repo/sanic/sanic/worker/loader.py",
      "content": "from __future__ import annotations\n\nimport os\nimport sys\n\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom inspect import isfunction\nfrom pathlib import Path\nfrom ssl import SSLContext\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Union, cast\n\nfrom sanic.http.tls.context import process_to_context\nfrom sanic.http.tls.creators import MkcertCreator, TrustmeCreator\n\n\nif TYPE_CHECKING:\n    from sanic import Sanic as SanicApp\n\nDEFAULT_APP_NAME = \"app\""
    },
    {
      "chunk_id": 740,
      "source": "__internal__/data_repo/sanic/sanic/worker/loader.py",
      "content": "class AppLoader:\n    \"\"\"A helper to load application instances.\n\n    Generally used by the worker to load the application instance.\n\n    See [Dynamic Applications](/en/guide/deployment/app-loader) for information on when you may need to use this.\n\n    Args:\n        module_input (str): The module to load the application from.\n        as_factory (bool): Whether the application is a factory.\n        as_simple (bool): Whether the application is a simple server.\n        args (Any): Arguments to pass to the application factory.\n        factory (Callable[[], SanicApp]): A callable that returns a Sanic application instance.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        module_input: str = \"\",\n        as_factory: bool = False,\n        as_simple: bool = False,\n        args: Any = None,\n        factory: Optional[Callable[[], SanicApp]] = None,\n    ) -> None:\n        self.module_input = module_input\n        self.module_name = \"\"\n        self.app_name = \"\"\n        self.as_factory = as_factory\n        self.as_simple = as_simple\n        self.args = args\n        self.factory = factory\n        self.cwd = os.getcwd()\n\n        if module_input:\n            delimiter = \":\" if \":\" in module_input else \".\"\n            if (\n                delimiter in module_input\n                and \"\\\\\" not in module_input\n                and \"/\" not in module_input\n            ):\n                module_name, app_name = module_input.rsplit(delimiter, 1)\n                self.module_name = module_name\n                self.app_name = app_name\n                if self.app_name.endswith(\"()\"):\n                    self.as_factory = True\n                    self.app_name = self.app_name[:-2]"
    },
    {
      "chunk_id": 741,
      "source": "__internal__/data_repo/sanic/sanic/worker/loader.py",
      "content": "def load(self) -> SanicApp:\n        module_path = os.path.abspath(self.cwd)\n        if module_path not in sys.path:\n            sys.path.append(module_path)\n\n        if self.factory:\n            return self.factory()\n        else:\n            from sanic.app import Sanic\n            from sanic.simple import create_simple_server\n\n            maybe_path = Path(self.module_input)\n            if self.as_simple or (\n                maybe_path.is_dir()\n                and (\"\\\\\" in self.module_input or \"/\" in self.module_input)\n            ):\n                app = create_simple_server(maybe_path)\n            else:\n                implied_app_name = False\n                if not self.module_name and not self.app_name:\n                    self.module_name = self.module_input\n                    self.app_name = DEFAULT_APP_NAME\n                    implied_app_name = True\n                module = import_module(self.module_name)\n                app = getattr(module, self.app_name, None)\n                if not app and implied_app_name:\n                    raise ValueError(\n                        \"Looks like you only supplied a module name. Sanic \"\n                        \"tried to locate an application instance named \"\n                        f\"{self.module_name}:app, but was unable to locate \"\n                        \"an application instance. Please provide a path \"\n                        \"to a global instance of Sanic(), or a callable that \"\n                        \"will return a Sanic() application instance.\"\n                    )\n                if self.as_factory or isfunction(app):\n                    try:\n                        app = app(self.args)\n                    except TypeError:\n                        app = app()\n\n                app_type_name = type(app).__name__\n\n                if (\n                    not isinstance(app, Sanic)\n                    and self.args\n                    and hasattr(self.args, \"target\")\n                ):\n                    with suppress(ModuleNotFoundError):\n                        maybe_module = import_module(self.module_input)\n                        app = getattr(maybe_module, \"app\", None)\n                    if not app:\n                        message = (\n                            \"Module is not a Sanic app, \"\n                            f\"it is a {app_type_name}\\n\"\n                            f\"  Perhaps you meant {self.args.target}:app?\"\n                        )\n                        raise ValueError(message)\n        return app"
    },
    {
      "chunk_id": 742,
      "source": "__internal__/data_repo/sanic/sanic/worker/loader.py",
      "content": "class CertLoader:\n    _creators = {\n        \"mkcert\": MkcertCreator,\n        \"trustme\": TrustmeCreator,\n    }\n\n    def __init__(\n        self,\n        ssl_data: Optional[\n            Union[SSLContext, dict[str, Union[str, os.PathLike]]]\n        ],\n    ):\n        self._ssl_data = ssl_data\n        self._creator_class = None\n        if not ssl_data or not isinstance(ssl_data, dict):\n            return\n\n        creator_name = cast(str, ssl_data.get(\"creator\"))\n\n        self._creator_class = self._creators.get(creator_name)\n        if not creator_name:\n            return\n\n        if not self._creator_class:\n            raise RuntimeError(f\"Unknown certificate creator: {creator_name}\")\n\n        self._key = ssl_data[\"key\"]\n        self._cert = ssl_data[\"cert\"]\n        self._localhost = cast(str, ssl_data[\"localhost\"])"
    },
    {
      "chunk_id": 743,
      "source": "__internal__/data_repo/sanic/sanic/worker/loader.py",
      "content": "def load(self, app: SanicApp):\n        if not self._creator_class:\n            return process_to_context(self._ssl_data)\n\n        creator = self._creator_class(app, self._key, self._cert)\n        return creator.generate_cert(self._localhost)"
    },
    {
      "chunk_id": 744,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "from __future__ import annotations\n\nimport os\nimport sys\n\nfrom asyncio import new_event_loop\nfrom itertools import chain\nfrom multiprocessing.connection import Connection\nfrom pathlib import Path\nfrom signal import SIGINT, SIGTERM\nfrom signal import signal as signal_func\nfrom time import sleep\n\nfrom sanic.server.events import trigger_events\nfrom sanic.worker.loader import AppLoader"
    },
    {
      "chunk_id": 745,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "class Reloader:\n    INTERVAL = 1.0  # seconds\n\n    def __init__(\n        self,\n        publisher: Connection,\n        interval: float,\n        reload_dirs: set[Path],\n        app_loader: AppLoader,\n    ):\n        self._publisher = publisher\n        self.interval = interval or self.INTERVAL\n        self.reload_dirs = reload_dirs\n        self.run = True\n        self.app_loader = app_loader"
    },
    {
      "chunk_id": 746,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "def __call__(self) -> None:\n        app = self.app_loader.load()\n        signal_func(SIGINT, self.stop)\n        signal_func(SIGTERM, self.stop)\n        mtimes: dict[str, float] = {}\n\n        reloader_start = app.listeners.get(\"reload_process_start\")\n        reloader_stop = app.listeners.get(\"reload_process_stop\")\n        before_trigger = app.listeners.get(\"before_reload_trigger\")\n        after_trigger = app.listeners.get(\"after_reload_trigger\")\n        loop = new_event_loop()\n        if reloader_start:\n            trigger_events(reloader_start, loop, app)\n\n        while self.run:\n            changed = set()\n            for filename in self.files():\n                try:\n                    if self.check_file(filename, mtimes):\n                        path = (\n                            filename\n                            if isinstance(filename, str)\n                            else filename.resolve()\n                        )\n                        changed.add(str(path))\n                except OSError:\n                    continue\n            if changed:\n                if before_trigger:\n                    trigger_events(before_trigger, loop, app)\n                self.reload(\",\".join(changed) if changed else \"unknown\")\n                if after_trigger:\n                    trigger_events(after_trigger, loop, app, changed=changed)\n            sleep(self.interval)\n        else:\n            if reloader_stop:\n                trigger_events(reloader_stop, loop, app)"
    },
    {
      "chunk_id": 747,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "def stop(self, *_):\n        self.run = False"
    },
    {
      "chunk_id": 748,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "def reload(self, reloaded_files):\n        message = f\"__ALL_PROCESSES__:{reloaded_files}\"\n        self._publisher.send(message)"
    },
    {
      "chunk_id": 749,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "def files(self):\n        return chain(\n            self.python_files(),\n            *(d.glob(\"**/*\") for d in self.reload_dirs),\n        )"
    },
    {
      "chunk_id": 750,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "def python_files(self):  # no cov\n        \"\"\"This iterates over all relevant Python files.\n\n        It goes through all\n        loaded files from modules, all files in folders of already loaded\n        modules as well as all files reachable through a package.\n        \"\"\"\n        # The list call is necessary on Python 3 in case the module\n        # dictionary modifies during iteration.\n        for module in list(sys.modules.values()):\n            if module is None:\n                continue\n            filename = getattr(module, \"__file__\", None)\n            if filename:\n                old = None\n                while not os.path.isfile(filename):\n                    old = filename\n                    filename = os.path.dirname(filename)\n                    if filename == old:\n                        break\n                else:\n                    if filename[-4:] in (\".pyc\", \".pyo\"):\n                        filename = filename[:-1]\n                    yield filename"
    },
    {
      "chunk_id": 751,
      "source": "__internal__/data_repo/sanic/sanic/worker/reloader.py",
      "content": "@staticmethod\n    def check_file(filename, mtimes) -> bool:\n        need_reload = False\n\n        mtime = os.stat(filename).st_mtime\n        old_time = mtimes.get(filename)\n        if old_time is None:\n            mtimes[filename] = mtime\n        elif mtime > old_time:\n            mtimes[filename] = mtime\n            need_reload = True\n\n        return need_reload"
    },
    {
      "chunk_id": 752,
      "source": "__internal__/data_repo/sanic/sanic/worker/constants.py",
      "content": "from enum import IntEnum, auto"
    },
    {
      "chunk_id": 753,
      "source": "__internal__/data_repo/sanic/sanic/worker/constants.py",
      "content": "from sanic.compat import UpperStrEnum"
    },
    {
      "chunk_id": 754,
      "source": "__internal__/data_repo/sanic/sanic/worker/constants.py",
      "content": "class RestartOrder(UpperStrEnum):\n    \"\"\"Available restart orders.\"\"\"\n\n    SHUTDOWN_FIRST = auto()\n    STARTUP_FIRST = auto()"
    },
    {
      "chunk_id": 755,
      "source": "__internal__/data_repo/sanic/sanic/worker/constants.py",
      "content": "class ProcessState(IntEnum):\n    \"\"\"Process states.\"\"\"\n\n    NONE = auto()\n    IDLE = auto()\n    RESTARTING = auto()\n    STARTING = auto()\n    STARTED = auto()\n    ACKED = auto()\n    JOINED = auto()\n    TERMINATED = auto()\n    FAILED = auto()\n    COMPLETED = auto()"
    },
    {
      "chunk_id": 756,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom inspect import isawaitable\nfrom multiprocessing.connection import Connection\nfrom os import environ\nfrom pathlib import Path\nfrom typing import Any, Union\n\nfrom sanic.exceptions import Unauthorized\nfrom sanic.helpers import Default\nfrom sanic.log import logger\nfrom sanic.request import Request\nfrom sanic.response import json"
    },
    {
      "chunk_id": 757,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "class Inspector:\n    \"\"\"Inspector for Sanic workers.\n\n    This class is used to create an inspector for Sanic workers. It is\n    instantiated by the worker class and is used to create a Sanic app\n    that can be used to inspect and control the workers and the server.\n\n    It is not intended to be used directly by the user.\n\n    See [Inspector](/en/guide/deployment/inspector) for more information.\n\n    Args:\n        publisher (Connection): The connection to the worker.\n        app_info (Dict[str, Any]): Information about the app.\n        worker_state (Mapping[str, Any]): The state of the worker.\n        host (str): The host to bind the inspector to.\n        port (int): The port to bind the inspector to.\n        api_key (str): The API key to use for authentication.\n        tls_key (Union[Path, str, Default]): The path to the TLS key file.\n        tls_cert (Union[Path, str, Default]): The path to the TLS cert file.\n    \"\"\"\n\n    def __init__(\n        self,\n        publisher: Connection,\n        app_info: dict[str, Any],\n        worker_state: Mapping[str, Any],\n        host: str,\n        port: int,\n        api_key: str,\n        tls_key: Union[Path, str, Default],\n        tls_cert: Union[Path, str, Default],\n    ):\n        self._publisher = publisher\n        self.app_info = app_info\n        self.worker_state = worker_state\n        self.host = host\n        self.port = port\n        self.api_key = api_key\n        self.tls_key = tls_key\n        self.tls_cert = tls_cert"
    },
    {
      "chunk_id": 758,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def __call__(self, run=True, **_) -> Inspector:\n        from sanic import Sanic\n\n        self.app = Sanic(\"Inspector\")\n        self._setup()\n        if run:\n            self.app.run(\n                host=self.host,\n                port=self.port,\n                single_process=True,\n                ssl={\"key\": self.tls_key, \"cert\": self.tls_cert}\n                if not isinstance(self.tls_key, Default)\n                and not isinstance(self.tls_cert, Default)\n                else None,\n            )\n        return self"
    },
    {
      "chunk_id": 759,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def _setup(self):\n        self.app.get(\"/\")(self._info)\n        self.app.post(\"/<action:str>\")(self._action)\n        if self.api_key:\n            self.app.on_request(self._authentication)\n        environ[\"SANIC_IGNORE_PRODUCTION_WARNING\"] = \"true\""
    },
    {
      "chunk_id": 760,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def _authentication(self, request: Request) -> None:\n        if request.token != self.api_key:\n            raise Unauthorized(\"Bad API key\")"
    },
    {
      "chunk_id": 761,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "async def _action(self, request: Request, action: str):\n        logger.info(\"Incoming inspector action: %s\", action)\n        output: Any = None\n        method = getattr(self, action, None)\n        if method:\n            kwargs = {}\n            if request.body:\n                kwargs = request.json\n            args = kwargs.pop(\"args\", ())\n            output = method(*args, **kwargs)\n            if isawaitable(output):\n                output = await output\n\n        return await self._respond(request, output)"
    },
    {
      "chunk_id": 762,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "async def _info(self, request: Request):\n        return await self._respond(request, self._state_to_json())"
    },
    {
      "chunk_id": 763,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "async def _respond(self, request: Request, output: Any):\n        name = request.match_info.get(\"action\", \"info\")\n        return json({\"meta\": {\"action\": name}, \"result\": output})"
    },
    {
      "chunk_id": 764,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def _state_to_json(self) -> dict[str, Any]:\n        output = {\"info\": self.app_info}\n        output[\"workers\"] = self._make_safe(dict(self.worker_state))\n        return output"
    },
    {
      "chunk_id": 765,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "@staticmethod\n    def _make_safe(obj: dict[str, Any]) -> dict[str, Any]:\n        for key, value in obj.items():\n            if isinstance(value, dict):\n                obj[key] = Inspector._make_safe(value)\n            elif isinstance(value, datetime):\n                obj[key] = value.isoformat()\n        return obj"
    },
    {
      "chunk_id": 766,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def reload(self, zero_downtime: bool = False) -> None:\n        \"\"\"Reload the workers\n\n        Args:\n            zero_downtime (bool, optional): Whether to use zero downtime\n                reload. Defaults to `False`.\n        \"\"\"\n        message = \"__ALL_PROCESSES__:\"\n        if zero_downtime:\n            message += \":STARTUP_FIRST\"\n        self._publisher.send(message)"
    },
    {
      "chunk_id": 767,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def scale(self, replicas: Union[str, int]) -> str:\n        \"\"\"Scale the number of workers\n\n        Args:\n            replicas (Union[str, int]): The number of workers to scale to.\n\n        Returns:\n            str: A log message.\n        \"\"\"\n        num_workers = 1\n        if replicas:\n            num_workers = int(replicas)\n        log_msg = f\"Scaling to {num_workers}\"\n        logger.info(log_msg)\n        message = f\"__SCALE__:{num_workers}\"\n        self._publisher.send(message)\n        return log_msg"
    },
    {
      "chunk_id": 768,
      "source": "__internal__/data_repo/sanic/sanic/worker/inspector.py",
      "content": "def shutdown(self) -> None:\n        \"\"\"Shutdown the workers\"\"\"\n        message = \"__TERMINATE__\"\n        self._publisher.send(message)"
    },
    {
      "chunk_id": 769,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "from collections.abc import ItemsView, Iterator, KeysView, Mapping, ValuesView\nfrom collections.abc import Mapping as MappingType\nfrom typing import Any"
    },
    {
      "chunk_id": 770,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "class WorkerState(Mapping):\n    RESTRICTED = (\n        \"health\",\n        \"pid\",\n        \"requests\",\n        \"restart_at\",\n        \"server\",\n        \"start_at\",\n        \"starts\",\n        \"state\",\n    )\n\n    def __init__(self, state: dict[str, Any], current: str) -> None:\n        self._name = current\n        self._state = state"
    },
    {
      "chunk_id": 771,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __getitem__(self, key: str) -> Any:\n        return self._state[self._name][key]"
    },
    {
      "chunk_id": 772,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __setitem__(self, key: str, value: Any) -> None:\n        if key in self.RESTRICTED:\n            self._write_error([key])\n        self._state[self._name] = {\n            **self._state[self._name],\n            key: value,\n        }"
    },
    {
      "chunk_id": 773,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __delitem__(self, key: str) -> None:\n        if key in self.RESTRICTED:\n            self._write_error([key])\n        self._state[self._name] = {\n            k: v for k, v in self._state[self._name].items() if k != key\n        }"
    },
    {
      "chunk_id": 774,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __iter__(self) -> Iterator[Any]:\n        return iter(self._state[self._name])"
    },
    {
      "chunk_id": 775,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __len__(self) -> int:\n        return len(self._state[self._name])"
    },
    {
      "chunk_id": 776,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __repr__(self) -> str:\n        return repr(self._state[self._name])"
    },
    {
      "chunk_id": 777,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def __eq__(self, other: object) -> bool:\n        return self._state[self._name] == other"
    },
    {
      "chunk_id": 778,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def keys(self) -> KeysView[str]:\n        return self._state[self._name].keys()"
    },
    {
      "chunk_id": 779,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def values(self) -> ValuesView[Any]:\n        return self._state[self._name].values()"
    },
    {
      "chunk_id": 780,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def items(self) -> ItemsView[str, Any]:\n        return self._state[self._name].items()"
    },
    {
      "chunk_id": 781,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def update(self, mapping: MappingType[str, Any]) -> None:\n        if any(k in self.RESTRICTED for k in mapping.keys()):\n            self._write_error(\n                [k for k in mapping.keys() if k in self.RESTRICTED]\n            )\n        self._state[self._name] = {\n            **self._state[self._name],\n            **mapping,\n        }"
    },
    {
      "chunk_id": 782,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def pop(self) -> None:\n        raise NotImplementedError"
    },
    {
      "chunk_id": 783,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def full(self) -> dict[str, Any]:\n        return dict(self._state)"
    },
    {
      "chunk_id": 784,
      "source": "__internal__/data_repo/sanic/sanic/worker/state.py",
      "content": "def _write_error(self, keys: list[str]) -> None:\n        raise LookupError(\n            f\"Cannot set restricted key{'s' if len(keys) > 1 else ''} on \"\n            f\"WorkerState: {', '.join(keys)}\"\n        )"
    },
    {
      "chunk_id": 785,
      "source": "__internal__/data_repo/sanic/sanic/worker/serve.py",
      "content": "import asyncio\nimport os\nimport socket\nimport warnings\n\nfrom functools import partial\nfrom multiprocessing.connection import Connection\nfrom ssl import SSLContext\nfrom typing import Any, Optional, Union\n\nfrom sanic.application.constants import ServerStage\nfrom sanic.application.state import ApplicationServerInfo\nfrom sanic.http.constants import HTTP\nfrom sanic.log import error_logger\nfrom sanic.logging.setup import setup_logging\nfrom sanic.models.server_types import Signal\nfrom sanic.server.protocols.http_protocol import HttpProtocol\nfrom sanic.server.runners import _serve_http_1, _serve_http_3\nfrom sanic.worker.loader import AppLoader, CertLoader\nfrom sanic.worker.multiplexer import WorkerMultiplexer\nfrom sanic.worker.process import Worker, WorkerProcess"
    },
    {
      "chunk_id": 786,
      "source": "__internal__/data_repo/sanic/sanic/worker/serve.py",
      "content": "def worker_serve(\n    host,\n    port,\n    app_name: str,\n    monitor_publisher: Optional[Connection],\n    app_loader: AppLoader,\n    worker_state: Optional[dict[str, Any]] = None,\n    server_info: Optional[dict[str, list[ApplicationServerInfo]]] = None,\n    ssl: Optional[\n        Union[SSLContext, dict[str, Union[str, os.PathLike]]]\n    ] = None,\n    sock: Optional[socket.socket] = None,\n    unix: Optional[str] = None,\n    reuse_port: bool = False,\n    loop=None,\n    protocol: type[asyncio.Protocol] = HttpProtocol,\n    backlog: int = 100,\n    register_sys_signals: bool = True,\n    run_multiple: bool = False,\n    run_async: bool = False,\n    connections=None,\n    signal=Signal(),\n    state=None,\n    asyncio_server_kwargs=None,\n    version=HTTP.VERSION_1,\n    config=None,\n    passthru: Optional[dict[str, Any]] = None,\n):\n    try:\n        from sanic import Sanic\n\n        if app_loader:\n            app = app_loader.load()\n        else:\n            app = Sanic.get_app(app_name)\n\n        app.refresh(passthru)\n        app.setup_loop()\n        setup_logging(\n            app.state.is_debug, app.config.NO_COLOR, app.config.LOG_EXTRA\n        )\n\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        # Hydrate server info if needed\n        if server_info:\n            for app_name, server_info_objects in server_info.items():\n                a = Sanic.get_app(app_name)\n                if not a.state.server_info:\n                    a.state.server_info = []\n                    for info in server_info_objects:\n                        if not info.settings.get(\"app\"):\n                            info.settings[\"app\"] = a\n                        a.state.server_info.append(info)\n\n        if isinstance(ssl, dict) or app.certloader_class is not CertLoader:\n            cert_loader = app.certloader_class(ssl or {})\n            ssl = cert_loader.load(app)\n            for info in app.state.server_info:\n                info.settings[\"ssl\"] = ssl\n\n        # When in a worker process, do some init\n        worker_name = os.environ.get(\"SANIC_WORKER_NAME\")\n        if worker_name and worker_name.startswith(\n            \"-\".join([Worker.WORKER_PREFIX, WorkerProcess.SERVER_LABEL])\n        ):\n            # Hydrate apps with any passed server info\n\n            if monitor_publisher is None:\n                raise RuntimeError(\n                    \"No restart publisher found in worker process\"\n                )\n            if worker_state is None:\n                raise RuntimeError(\"No worker state found in worker process\")\n\n            # Run secondary servers\n            apps = list(Sanic._app_registry.values())\n            app.before_server_start(partial(app._start_servers, apps=apps))\n            for a in apps:\n                a.multiplexer = WorkerMultiplexer(\n                    monitor_publisher, worker_state\n                )\n\n        if app.debug:\n            loop.set_debug(app.debug)\n\n        app.asgi = False\n\n        if app.state.server_info:\n            primary_server_info = app.state.server_info[0]\n            primary_server_info.stage = ServerStage.SERVING\n        if config:\n            app.update_config(config)\n\n        if version is HTTP.VERSION_3:\n            return _serve_http_3(host, port, app, loop, ssl)\n        return _serve_http_1(\n            host,\n            port,\n            app,\n            ssl,\n            sock,\n            unix,\n            reuse_port,\n            loop,\n            protocol,\n            backlog,\n            register_sys_signals,\n            run_multiple,\n            run_async,\n            connections,\n            signal,\n            state,\n            asyncio_server_kwargs,\n        )\n    except Exception as e:\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        if monitor_publisher:\n            error_logger.exception(e)\n            multiplexer = WorkerMultiplexer(monitor_publisher, {})\n            multiplexer.terminate(True)\n        else:\n            raise e"
    },
    {
      "chunk_id": 787,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "import os\n\nfrom datetime import datetime, timezone\nfrom inspect import signature\nfrom multiprocessing.context import BaseContext\nfrom signal import SIGINT\nfrom threading import Thread\nfrom time import sleep\nfrom typing import Any\n\nfrom sanic.log import Colors, logger\nfrom sanic.worker.constants import ProcessState, RestartOrder"
    },
    {
      "chunk_id": 788,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def get_now():\n    now = datetime.now(tz=timezone.utc)\n    return now"
    },
    {
      "chunk_id": 789,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "class WorkerProcess:\n    \"\"\"A worker process.\"\"\"\n\n    THRESHOLD = 300  # == 30 seconds\n    SERVER_LABEL = \"Server\"\n    SERVER_IDENTIFIER = \"Srv\"\n\n    def __init__(\n        self,\n        factory,\n        name,\n        ident,\n        target,\n        kwargs,\n        worker_state,\n        restartable: bool = False,\n    ):\n        self.state = ProcessState.IDLE\n        self.factory = factory\n        self.name = name\n        self.ident = ident\n        self.target = target\n        self.kwargs = kwargs\n        self.worker_state = worker_state\n        self.restartable = restartable\n        if self.name not in self.worker_state:\n            self.worker_state[self.name] = {\n                \"server\": self.SERVER_LABEL in self.name\n            }\n        self.spawn()"
    },
    {
      "chunk_id": 790,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def set_state(self, state: ProcessState, force=False):\n        if not force and state < self.state:\n            raise Exception(\"...\")\n        self.state = state\n        self.worker_state[self.name] = {\n            **self.worker_state[self.name],\n            \"state\": self.state.name,\n        }"
    },
    {
      "chunk_id": 791,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def start(self):\n        os.environ[\"SANIC_WORKER_NAME\"] = self.name\n        os.environ[\"SANIC_WORKER_IDENTIFIER\"] = self.ident\n        logger.debug(\n            f\"{Colors.BLUE}Starting a process: {Colors.BOLD}\"\n            f\"{Colors.SANIC}%s{Colors.END}\",\n            self.name,\n        )\n        self.set_state(ProcessState.STARTING)\n        self._current_process.start()\n        self.set_state(ProcessState.STARTED)\n        if not self.worker_state[self.name].get(\"starts\"):\n            self.worker_state[self.name] = {\n                **self.worker_state[self.name],\n                \"pid\": self.pid,\n                \"start_at\": get_now(),\n                \"starts\": 1,\n            }\n        del os.environ[\"SANIC_WORKER_NAME\"]\n        del os.environ[\"SANIC_WORKER_IDENTIFIER\"]"
    },
    {
      "chunk_id": 792,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def join(self):\n        self.set_state(ProcessState.JOINED)\n        self._current_process.join()"
    },
    {
      "chunk_id": 793,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def exit(self):\n        limit = 100\n        while self.is_alive() and limit > 0:\n            sleep(0.1)\n            limit -= 1\n\n        if not self.is_alive():\n            try:\n                del self.worker_state[self.name]\n            except ConnectionRefusedError:\n                logger.debug(\"Monitor process has already exited.\")\n            except KeyError:\n                logger.debug(\"Could not find worker state to delete.\")"
    },
    {
      "chunk_id": 794,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def terminate(self):\n        if self.state is not ProcessState.TERMINATED:\n            logger.debug(\n                f\"{Colors.BLUE}Terminating a process: \"\n                f\"{Colors.BOLD}{Colors.SANIC}\"\n                f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n                self.name,\n                self.pid,\n            )\n            self.set_state(ProcessState.TERMINATED, force=True)\n            try:\n                os.kill(self.pid, SIGINT)\n            except (KeyError, AttributeError, ProcessLookupError):\n                ..."
    },
    {
      "chunk_id": 795,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def restart(self, restart_order=RestartOrder.SHUTDOWN_FIRST, **kwargs):\n        logger.debug(\n            f\"{Colors.BLUE}Restarting a process: {Colors.BOLD}{Colors.SANIC}\"\n            f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n            self.name,\n            self.pid,\n        )\n        self.set_state(ProcessState.RESTARTING, force=True)\n        if restart_order is RestartOrder.SHUTDOWN_FIRST:\n            self._terminate_now()\n        else:\n            self._old_process = self._current_process\n        if self._add_config():\n            self.kwargs.update(\n                {\"config\": {k.upper(): v for k, v in kwargs.items()}}\n            )\n        try:\n            self.spawn()\n            self.start()\n        except AttributeError:\n            raise RuntimeError(\"Restart failed\")\n\n        if restart_order is RestartOrder.STARTUP_FIRST:\n            self._terminate_soon()\n\n        self.worker_state[self.name] = {\n            **self.worker_state[self.name],\n            \"pid\": self.pid,\n            \"starts\": self.worker_state[self.name][\"starts\"] + 1,\n            \"restart_at\": get_now(),\n        }"
    },
    {
      "chunk_id": 796,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def is_alive(self):\n        try:\n            return self._current_process.is_alive()\n        except AssertionError:\n            return False"
    },
    {
      "chunk_id": 797,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def spawn(self):\n        if self.state not in (ProcessState.IDLE, ProcessState.RESTARTING):\n            raise Exception(\"Cannot spawn a worker process until it is idle.\")\n        self._current_process = self.factory(\n            name=self.name,\n            target=self.target,\n            kwargs=self.kwargs,\n            daemon=True,\n        )"
    },
    {
      "chunk_id": 798,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "@property\n    def pid(self):\n        return self._current_process.pid"
    },
    {
      "chunk_id": 799,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "@property\n    def exitcode(self):\n        return self._current_process.exitcode"
    },
    {
      "chunk_id": 800,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def _terminate_now(self):\n        if not self._current_process.is_alive():\n            return\n        logger.debug(\n            f\"{Colors.BLUE}Begin restart termination: \"\n            f\"{Colors.BOLD}{Colors.SANIC}\"\n            f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n            self.name,\n            self._current_process.pid,\n        )\n        self._current_process.terminate()"
    },
    {
      "chunk_id": 801,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def _terminate_soon(self):\n        logger.debug(\n            f\"{Colors.BLUE}Begin restart termination: \"\n            f\"{Colors.BOLD}{Colors.SANIC}\"\n            f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n            self.name,\n            self._current_process.pid,\n        )\n        termination_thread = Thread(target=self._wait_to_terminate)\n        termination_thread.start()"
    },
    {
      "chunk_id": 802,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def _wait_to_terminate(self):\n        logger.debug(\n            f\"{Colors.BLUE}Waiting for process to be acked: \"\n            f\"{Colors.BOLD}{Colors.SANIC}\"\n            f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n            self.name,\n            self._old_process.pid,\n        )\n        misses = 0\n        while self.state is not ProcessState.ACKED:\n            sleep(0.1)\n            misses += 1\n            if misses > self.THRESHOLD:\n                raise TimeoutError(\n                    f\"Worker {self.name} failed to come ack within \"\n                    f\"{self.THRESHOLD / 10} seconds\"\n                )\n        else:\n            logger.debug(\n                f\"{Colors.BLUE}Process acked. Terminating: \"\n                f\"{Colors.BOLD}{Colors.SANIC}\"\n                f\"%s {Colors.BLUE}[%s]{Colors.END}\",\n                self.name,\n                self._old_process.pid,\n            )\n            self._old_process.terminate()\n        delattr(self, \"_old_process\")"
    },
    {
      "chunk_id": 803,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def _add_config(self) -> bool:\n        sig = signature(self.target)\n        if \"config\" in sig.parameters or any(\n            param.kind == param.VAR_KEYWORD\n            for param in sig.parameters.values()\n        ):\n            return True\n        return False"
    },
    {
      "chunk_id": 804,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "class Worker:\n    WORKER_PREFIX = \"Sanic\"\n\n    def __init__(\n        self,\n        ident: str,\n        name: str,\n        serve,\n        server_settings,\n        context: BaseContext,\n        worker_state: dict[str, Any],\n        num: int = 1,\n        restartable: bool = False,\n        tracked: bool = True,\n        auto_start: bool = True,\n    ):\n        self.ident = ident\n        self.name = name\n        self.num = num\n        self.context = context\n        self.serve = serve\n        self.server_settings = server_settings\n        self.worker_state = worker_state\n        self.processes: set[WorkerProcess] = set()\n        self.restartable = restartable\n        self.tracked = tracked\n        self.auto_start = auto_start\n        for _ in range(num):\n            self.create_process()"
    },
    {
      "chunk_id": 805,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def create_process(self) -> WorkerProcess:\n        process = WorkerProcess(\n            # Need to ignore this typing error - The problem is the\n            # BaseContext itself has no Process. But, all of its\n            # implementations do. We can safely ignore as it is a typing\n            # issue in the standard lib.\n            factory=self.context.Process,  # type: ignore\n            name=\"-\".join(\n                [self.WORKER_PREFIX, self.name, str(len(self.processes))]\n            ),\n            ident=self.ident,\n            target=self.serve,\n            kwargs={**self.server_settings},\n            worker_state=self.worker_state,\n            restartable=self.restartable,\n        )\n        self.processes.add(process)\n        return process"
    },
    {
      "chunk_id": 806,
      "source": "__internal__/data_repo/sanic/sanic/worker/process.py",
      "content": "def has_alive_processes(self) -> bool:\n        return any(process.is_alive() for process in self.processes)"
    },
    {
      "chunk_id": 807,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "from typing import Optional\n\nfrom sanic.log import error_logger\nfrom sanic.worker.constants import RestartOrder\nfrom sanic.worker.process import ProcessState, WorkerProcess"
    },
    {
      "chunk_id": 808,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "class Restarter:\n    def __init__(self):\n        \"\"\"Restarter class to manage the restarting of worker processes.\"\"\"\n        pass"
    },
    {
      "chunk_id": 809,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "def restart(\n        self,\n        transient_processes: list[WorkerProcess],\n        durable_processes: list[WorkerProcess],\n        process_names: Optional[list[str]] = None,\n        restart_order=RestartOrder.SHUTDOWN_FIRST,\n        **kwargs,\n    ) -> None:\n        \"\"\"Restart the worker processes.\n\n        Args:\n            process_names (Optional[List[str]], optional): The names of the processes to restart.\n                If `None`, then all processes will be restarted. Defaults to `None`.\n            restart_order (RestartOrder, optional): The order in which to restart the processes.\n                Defaults to `RestartOrder.SHUTDOWN_FIRST`.\n        \"\"\"  # noqa: E501\n        restarted = self._restart_transient(\n            transient_processes,\n            process_names or [],\n            restart_order,\n            **kwargs,\n        )\n        restarted |= self._restart_durable(\n            durable_processes,\n            process_names or [],\n            restart_order,\n            **kwargs,\n        )\n\n        if process_names and not restarted:\n            error_logger.error(\n                f\"Failed to restart processes: {', '.join(process_names)}\"\n            )"
    },
    {
      "chunk_id": 810,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "def _restart_transient(\n        self,\n        processes: list[WorkerProcess],\n        process_names: list[str],\n        restart_order: RestartOrder,\n        **kwargs,\n    ) -> set[str]:\n        restarted: set[str] = set()\n        for process in processes:\n            if not process.restartable or (\n                process_names and process.name not in process_names\n            ):\n                continue\n            self._restart_process(process, restart_order, **kwargs)\n            restarted.add(process.name)\n        return restarted"
    },
    {
      "chunk_id": 811,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "def _restart_durable(\n        self,\n        processes: list[WorkerProcess],\n        process_names: list[str],\n        restart_order: RestartOrder,\n        **kwargs,\n    ) -> set[str]:\n        restarted: set[str] = set()\n        if not process_names:\n            return restarted\n        for process in processes:\n            if not process.restartable or process.name not in process_names:\n                continue\n            if process.state not in (\n                ProcessState.COMPLETED,\n                ProcessState.FAILED,\n                ProcessState.NONE,\n            ):\n                error_logger.error(\n                    f\"Cannot restart process {process.name} because \"\n                    \"it is not in a final state. Current state is: \"\n                    f\"{process.state.name}.\"\n                )\n                continue\n            self._restart_process(process, restart_order, **kwargs)\n            restarted.add(process.name)\n\n        return restarted"
    },
    {
      "chunk_id": 812,
      "source": "__internal__/data_repo/sanic/sanic/worker/restarter.py",
      "content": "def _restart_process(self, process, restart_order, **kwargs):\n        process.restart(restart_order=restart_order, **kwargs)"
    },
    {
      "chunk_id": 813,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "import os\n\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom enum import IntEnum, auto\nfrom itertools import chain, count\nfrom random import choice\nfrom signal import SIGINT, SIGTERM, Signals\nfrom signal import signal as signal_func\nfrom typing import Any, Callable, Optional\n\nfrom sanic.compat import OS_IS_WINDOWS\nfrom sanic.exceptions import ServerKilled\nfrom sanic.log import error_logger, logger\nfrom sanic.worker.constants import RestartOrder\nfrom sanic.worker.process import ProcessState, Worker, WorkerProcess\nfrom sanic.worker.restarter import Restarter\n\n\nif not OS_IS_WINDOWS:\n    from signal import SIGKILL\nelse:\n    SIGKILL = SIGINT"
    },
    {
      "chunk_id": 814,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "class MonitorCycle(IntEnum):\n    BREAK = auto()\n    CONTINUE = auto()"
    },
    {
      "chunk_id": 815,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "class WorkerManager:\n    \"\"\"Manage all of the processes.\n\n    This class is used to manage all of the processes. It is instantiated\n    by Sanic when in multiprocess mode (which is OOTB default) and is used\n    to start, stop, and restart the worker processes.\n\n    You can access it to interact with it **ONLY** when on the main process.\n\n    Therefore, you should really only access it from within the\n    `main_process_ready` event listener.\n\n    ```python\n    from sanic import Sanic\n\n    app = Sanic(\"MyApp\")\n\n    @app.main_process_ready\n    async def ready(app: Sanic, _):\n        app.manager.manage(\"MyProcess\", my_process, {\"foo\": \"bar\"})\n    ```\n\n    See [Worker Manager](/en/guide/deployment/manager) for more information.\n    \"\"\"\n\n    THRESHOLD = WorkerProcess.THRESHOLD\n    MAIN_NAME = \"Sanic-Main\"\n\n    def __init__(\n        self,\n        number: int,\n        serve,\n        server_settings,\n        context,\n        monitor_pubsub,\n        worker_state,\n    ):\n        self.num_server = number\n        self.context = context\n        self.transient: dict[str, Worker] = {}\n        self.durable: dict[str, Worker] = {}\n        self.restarter = Restarter()\n        self.monitor_publisher, self.monitor_subscriber = monitor_pubsub\n        self.worker_state = worker_state\n        self.worker_state[self.MAIN_NAME] = {\"pid\": self.pid}\n        self._shutting_down = False\n        self._serve = serve\n        self._server_settings = server_settings\n        self._server_count = count()\n\n        if number == 0:\n            raise RuntimeError(\"Cannot serve with no workers\")\n\n        for _ in range(number):\n            self.create_server()\n\n        signal_func(SIGINT, self.shutdown_signal)\n        signal_func(SIGTERM, self.shutdown_signal)"
    },
    {
      "chunk_id": 816,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def manage(\n        self,\n        name: str,\n        func: Callable[..., Any],\n        kwargs: dict[str, Any],\n        transient: bool = False,\n        restartable: Optional[bool] = None,\n        tracked: bool = True,\n        auto_start: bool = True,\n        workers: int = 1,\n        ident: str = \"\",\n    ) -> Worker:\n        \"\"\"Instruct Sanic to manage a custom process.\n\n        Args:\n            name (str): A name for the worker process\n            func (Callable[..., Any]): The function to call in the background process\n            kwargs (Dict[str, Any]): Arguments to pass to the function\n            transient (bool, optional): Whether to mark the process as transient. If `True`\n                then the Worker Manager will restart the process along\n                with any global restart (ex: auto-reload), defaults to `False`\n            restartable (Optional[bool], optional): Whether to mark the process as restartable. If\n                `True` then the Worker Manager will be able to restart the process\n                if prompted. If `transient=True`, this property will be implied\n                to be `True`, defaults to `None`\n            tracked (bool, optional): Whether to track the process after completion,\n                defaults to `True`\n            auto_start (bool, optional): Whether to start the process immediately, defaults to `True`\n            workers (int, optional): The number of worker processes to run. Defaults to `1`.\n            ident (str, optional): The identifier for the worker. If not provided, the name\n                passed will be used. Defaults to `\"\"`.\n\n        Returns:\n            Worker: The Worker instance\n        \"\"\"  # noqa: E501\n        if name in self.transient or name in self.durable:\n            raise ValueError(f\"Worker {name} already exists\")\n        restartable = restartable if restartable is not None else transient\n        if transient and not restartable:\n            raise ValueError(\n                \"Cannot create a transient worker that is not restartable\"\n            )\n        container = self.transient if transient else self.durable\n        worker = Worker(\n            ident or name,\n            name,\n            func,\n            kwargs,\n            self.context,\n            self.worker_state,\n            workers,\n            restartable,\n            tracked,\n            auto_start,\n        )\n        container[worker.name] = worker\n        return worker"
    },
    {
      "chunk_id": 817,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def create_server(self) -> Worker:\n        \"\"\"Create a new server process.\n\n        Returns:\n            Worker: The Worker instance\n        \"\"\"\n        server_number = next(self._server_count)\n        return self.manage(\n            f\"{WorkerProcess.SERVER_LABEL}-{server_number}\",\n            self._serve,\n            self._server_settings,\n            transient=True,\n            restartable=True,\n            ident=f\"{WorkerProcess.SERVER_IDENTIFIER}{server_number:2}\",\n        )"
    },
    {
      "chunk_id": 818,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def shutdown_server(self, name: Optional[str] = None) -> None:\n        \"\"\"Shutdown a server process.\n\n        Args:\n            name (Optional[str], optional): The name of the server process to shutdown.\n                If `None` then a random server will be chosen. Defaults to `None`.\n        \"\"\"  # noqa: E501\n        if not name:\n            servers = [\n                worker\n                for worker in self.transient.values()\n                if worker.name.startswith(WorkerProcess.SERVER_LABEL)\n            ]\n            if not servers:\n                error_logger.error(\n                    \"Server shutdown failed because a server was not found.\"\n                )\n                return\n            worker = choice(servers)  # nosec B311\n        else:\n            worker = self.transient[name]\n\n        for process in worker.processes:\n            process.terminate()\n\n        del self.transient[worker.name]"
    },
    {
      "chunk_id": 819,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def run(self):\n        \"\"\"Run the worker manager.\"\"\"\n        self.start()\n        self.monitor()\n        self.join()\n        self.terminate()\n        self.cleanup()"
    },
    {
      "chunk_id": 820,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def start(self):\n        \"\"\"Start the worker processes.\"\"\"\n        for worker in self.workers:\n            for process in worker.processes:\n                if not worker.auto_start:\n                    process.set_state(ProcessState.NONE, True)\n                    continue\n                process.start()"
    },
    {
      "chunk_id": 821,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def join(self):\n        \"\"\"Join the worker processes.\"\"\"\n        logger.debug(\"Joining processes\", extra={\"verbosity\": 1})\n        joined = set()\n        for process in self.processes:\n            logger.debug(\n                f\"Found {process.pid} - {process.state.name}\",\n                extra={\"verbosity\": 1},\n            )\n            if process.state < ProcessState.JOINED:\n                logger.debug(f\"Joining {process.pid}\", extra={\"verbosity\": 1})\n                joined.add(process.pid)\n                process.join()\n        if joined:\n            self.join()"
    },
    {
      "chunk_id": 822,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def terminate(self):\n        \"\"\"Terminate the worker processes.\"\"\"\n        if not self._shutting_down:\n            for process in self.processes:\n                process.terminate()"
    },
    {
      "chunk_id": 823,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def cleanup(self):\n        \"\"\"Cleanup the worker processes.\"\"\"\n        for process in self.processes:\n            process.exit()"
    },
    {
      "chunk_id": 824,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def restart(\n        self,\n        process_names: Optional[list[str]] = None,\n        restart_order=RestartOrder.SHUTDOWN_FIRST,\n        **kwargs,\n    ):\n        \"\"\"Restart the worker processes.\n\n        Args:\n            process_names (Optional[List[str]], optional): The names of the processes to restart.\n                If `None` then all processes will be restarted. Defaults to `None`.\n            restart_order (RestartOrder, optional): The order in which to restart the processes.\n                Defaults to `RestartOrder.SHUTDOWN_FIRST`.\n        \"\"\"  # noqa: E501\n        self.restarter.restart(\n            transient_processes=list(self.transient_processes),\n            durable_processes=list(self.durable_processes),\n            process_names=process_names,\n            restart_order=restart_order,\n            **kwargs,\n        )"
    },
    {
      "chunk_id": 825,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def scale(self, num_worker: int):\n        if num_worker <= 0:\n            raise ValueError(\"Cannot scale to 0 workers.\")\n\n        change = num_worker - self.num_server\n        if change == 0:\n            logger.info(\n                f\"No change needed. There are already {num_worker} workers.\"\n            )\n            return\n\n        logger.info(f\"Scaling from {self.num_server} to {num_worker} workers\")\n        if change > 0:\n            for _ in range(change):\n                worker = self.create_server()\n                for process in worker.processes:\n                    process.start()\n        else:\n            for _ in range(abs(change)):\n                self.shutdown_server()\n        self.num_server = num_worker"
    },
    {
      "chunk_id": 826,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def monitor(self):\n        \"\"\"Monitor the worker processes.\n\n        First, wait for all of the workers to acknowledge that they are ready.\n        Then, wait for messages from the workers. If a message is received\n        then it is processed and the state of the worker is updated.\n\n        Also used to restart, shutdown, and scale the workers.\n\n        Raises:\n            ServerKilled: Raised when a worker fails to come online.\n        \"\"\"\n        self.wait_for_ack()\n        while True:\n            try:\n                cycle = self._poll_monitor()\n                if cycle is MonitorCycle.BREAK:\n                    break\n                elif cycle is MonitorCycle.CONTINUE:\n                    continue\n                self._sync_states()\n                self._cleanup_non_tracked_workers()\n            except InterruptedError:\n                if not OS_IS_WINDOWS:\n                    raise\n                break"
    },
    {
      "chunk_id": 827,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def wait_for_ack(self):  # no cov\n        \"\"\"Wait for all of the workers to acknowledge that they are ready.\"\"\"\n        misses = 0\n        message = (\n            \"It seems that one or more of your workers failed to come \"\n            \"online in the allowed time. Sanic is shutting down to avoid a \"\n            f\"deadlock. The current threshold is {self.THRESHOLD / 10}s. \"\n            \"If this problem persists, please check out the documentation \"\n            \"https://sanic.dev/en/guide/deployment/manager.html#worker-ack.\"\n        )\n        while not self._all_workers_ack():\n            if self.monitor_subscriber.poll(0.1):\n                monitor_msg = self.monitor_subscriber.recv()\n                if monitor_msg != \"__TERMINATE_EARLY__\":\n                    self.monitor_publisher.send(monitor_msg)\n                    continue\n                misses = self.THRESHOLD\n                message = (\n                    \"One of your worker processes terminated before startup \"\n                    \"was completed. Please solve any errors experienced \"\n                    \"during startup. If you do not see an exception traceback \"\n                    \"in your error logs, try running Sanic in a single \"\n                    \"process using --single-process or single_process=True. \"\n                    \"Once you are confident that the server is able to start \"\n                    \"without errors you can switch back to multiprocess mode.\"\n                )\n            misses += 1\n            if misses > self.THRESHOLD:\n                error_logger.error(\n                    \"Not all workers acknowledged a successful startup. \"\n                    \"Shutting down.\\n\\n\" + message\n                )\n                self.kill()"
    },
    {
      "chunk_id": 828,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def workers(self) -> list[Worker]:\n        \"\"\"Get all of the workers.\"\"\"\n        return list(self.transient.values()) + list(self.durable.values())"
    },
    {
      "chunk_id": 829,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def all_workers(self) -> Iterable[tuple[str, Worker]]:\n        return chain(self.transient.items(), self.durable.items())"
    },
    {
      "chunk_id": 830,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def processes(self):\n        \"\"\"Get all of the processes.\"\"\"\n        for worker in self.workers:\n            for process in worker.processes:\n                if not process.pid:\n                    continue\n                yield process"
    },
    {
      "chunk_id": 831,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def transient_processes(self):\n        \"\"\"Get all of the transient processes.\"\"\"\n        for worker in self.transient.values():\n            yield from worker.processes"
    },
    {
      "chunk_id": 832,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def durable_processes(self):\n        for worker in self.durable.values():\n            yield from worker.processes"
    },
    {
      "chunk_id": 833,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def kill(self):\n        \"\"\"Kill all of the processes.\"\"\"\n        for process in self.processes:\n            logger.info(\"Killing %s [%s]\", process.name, process.pid)\n            with suppress(ProcessLookupError):\n                try:\n                    os.killpg(os.getpgid(process.pid), SIGKILL)\n                except OSError:\n                    os.kill(process.pid, SIGKILL)\n        raise ServerKilled"
    },
    {
      "chunk_id": 834,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def shutdown_signal(self, signal, frame):\n        \"\"\"Handle the shutdown signal.\"\"\"\n        if self._shutting_down:\n            logger.info(\"Shutdown interrupted. Killing.\")\n            with suppress(ServerKilled):\n                self.kill()\n            return\n\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        self.monitor_publisher.send(None)\n        self.shutdown()"
    },
    {
      "chunk_id": 835,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def shutdown(self):\n        \"\"\"Shutdown the worker manager.\"\"\"\n        for process in self.processes:\n            if process.is_alive():\n                process.terminate()\n        self._shutting_down = True"
    },
    {
      "chunk_id": 836,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def remove_worker(self, worker: Worker) -> None:\n        if worker.tracked:\n            error_logger.error(\n                f\"Worker {worker.name} is tracked and cannot be removed.\"\n            )\n            return\n        if worker.has_alive_processes():\n            error_logger.error(\n                f\"Worker {worker.name} has alive processes and cannot be \"\n                \"removed.\"\n            )\n            return\n        self.transient.pop(worker.name, None)\n        self.durable.pop(worker.name, None)\n        for process in worker.processes:\n            self.worker_state.pop(process.name, None)\n        logger.info(\"Removed worker %s\", worker.name)\n        del worker"
    },
    {
      "chunk_id": 837,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "@property\n    def pid(self):\n        \"\"\"Get the process ID of the main process.\"\"\"\n        return os.getpid()"
    },
    {
      "chunk_id": 838,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _all_workers_ack(self):\n        acked = [\n            worker_state.get(\"state\") == ProcessState.ACKED.name\n            for worker_state in self.worker_state.values()\n            if worker_state.get(\"server\")\n        ]\n        return all(acked) and len(acked) == self.num_server"
    },
    {
      "chunk_id": 839,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _sync_states(self):\n        for process in self.processes:\n            try:\n                state = self.worker_state[process.name].get(\"state\")\n            except KeyError:\n                process.set_state(ProcessState.TERMINATED, True)\n                continue\n            if not process.is_alive():\n                state = \"FAILED\" if process.exitcode else \"COMPLETED\"\n            if state and process.state.name != state:\n                process.set_state(ProcessState[state], True)"
    },
    {
      "chunk_id": 840,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _cleanup_non_tracked_workers(self) -> None:\n        to_remove = [\n            worker\n            for worker in self.workers\n            if not worker.tracked and not worker.has_alive_processes()\n        ]\n\n        for worker in to_remove:\n            self.remove_worker(worker)"
    },
    {
      "chunk_id": 841,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _poll_monitor(self) -> Optional[MonitorCycle]:\n        if self.monitor_subscriber.poll(0.1):\n            message = self.monitor_subscriber.recv()\n            logger.debug(f\"Monitor message: {message}\", extra={\"verbosity\": 2})\n            if not message:\n                return MonitorCycle.BREAK\n            elif message == \"__TERMINATE__\":\n                self._handle_terminate()\n                return MonitorCycle.BREAK\n            elif isinstance(message, tuple) and (\n                len(message) == 7 or len(message) == 8\n            ):\n                self._handle_manage(*message)  # type: ignore\n                return MonitorCycle.CONTINUE\n            elif not isinstance(message, str):\n                error_logger.error(\n                    \"Monitor received an invalid message: %s\", message\n                )\n                return MonitorCycle.CONTINUE\n            return self._handle_message(message)\n        return None"
    },
    {
      "chunk_id": 842,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _handle_terminate(self) -> None:\n        self.shutdown()"
    },
    {
      "chunk_id": 843,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _handle_message(self, message: str) -> Optional[MonitorCycle]:\n        logger.debug(\n            \"Incoming monitor message: %s\",\n            message,\n            extra={\"verbosity\": 1},\n        )\n        split_message = message.split(\":\", 2)\n        if message.startswith(\"__SCALE__\"):\n            self.scale(int(split_message[-1]))\n            return MonitorCycle.CONTINUE\n\n        processes = split_message[0]\n        reloaded_files = split_message[1] if len(split_message) > 1 else None\n        process_names: Optional[list[str]] = [\n            name.strip() for name in processes.split(\",\")\n        ]\n        if process_names and \"__ALL_PROCESSES__\" in process_names:\n            process_names = None\n        order = (\n            RestartOrder.STARTUP_FIRST\n            if \"STARTUP_FIRST\" in split_message\n            else RestartOrder.SHUTDOWN_FIRST\n        )\n        self.restart(\n            process_names=process_names,\n            reloaded_files=reloaded_files,\n            restart_order=order,\n        )\n\n        return None"
    },
    {
      "chunk_id": 844,
      "source": "__internal__/data_repo/sanic/sanic/worker/manager.py",
      "content": "def _handle_manage(\n        self,\n        name: str,\n        func: Callable[..., Any],\n        kwargs: dict[str, Any],\n        transient: bool,\n        restartable: Optional[bool],\n        tracked: bool,\n        auto_start: bool,\n        workers: int,\n    ) -> None:\n        try:\n            worker = self.manage(\n                name,\n                func,\n                kwargs,\n                transient=transient,\n                restartable=restartable,\n                tracked=tracked,\n                auto_start=auto_start,\n                workers=workers,\n            )\n        except Exception:\n            error_logger.exception(\"Failed to manage worker %s\", name)\n        else:\n            if not auto_start:\n                return\n            for process in worker.processes:\n                process.start()"
    },
    {
      "chunk_id": 845,
      "source": "__internal__/data_repo/sanic/sanic/touchup/__init__.py",
      "content": "from .meta import TouchUpMeta\nfrom .service import TouchUp"
    },
    {
      "chunk_id": 846,
      "source": "__internal__/data_repo/sanic/sanic/touchup/__init__.py",
      "content": "__all__ = (\n    \"TouchUp\",\n    \"TouchUpMeta\",\n)"
    },
    {
      "chunk_id": 847,
      "source": "__internal__/data_repo/sanic/sanic/touchup/meta.py",
      "content": "from sanic.base.meta import SanicMeta\nfrom sanic.exceptions import SanicException\n\nfrom .service import TouchUp"
    },
    {
      "chunk_id": 848,
      "source": "__internal__/data_repo/sanic/sanic/touchup/meta.py",
      "content": "class TouchUpMeta(SanicMeta):\n    def __new__(cls, name, bases, attrs, **kwargs):\n        gen_class = super().__new__(cls, name, bases, attrs, **kwargs)\n\n        methods = attrs.get(\"__touchup__\")\n        attrs[\"__touched__\"] = False\n        if methods:\n            for method in methods:\n                if method not in attrs:\n                    raise SanicException(\n                        \"Cannot perform touchup on non-existent method: \"\n                        f\"{name}.{method}\"\n                    )\n                TouchUp.register(gen_class, method)\n\n        return gen_class"
    },
    {
      "chunk_id": 849,
      "source": "__internal__/data_repo/sanic/sanic/touchup/service.py",
      "content": "from inspect import getmembers, getmodule\n\nfrom .schemes import BaseScheme"
    },
    {
      "chunk_id": 850,
      "source": "__internal__/data_repo/sanic/sanic/touchup/service.py",
      "content": "class TouchUp:\n    _registry: set[tuple[type, str]] = set()\n\n    @classmethod\n    def run(cls, app):\n        for target, method_name in cls._registry:\n            method = getattr(target, method_name)\n\n            if app.test_mode:\n                placeholder = f\"_{method_name}\"\n                if hasattr(target, placeholder):\n                    method = getattr(target, placeholder)\n                else:\n                    setattr(target, placeholder, method)\n\n            module = getmodule(target)\n            module_globals = dict(getmembers(module))\n            modified = BaseScheme.build(method, module_globals, app)\n            setattr(target, method_name, modified)\n\n            target.__touched__ = True"
    },
    {
      "chunk_id": 851,
      "source": "__internal__/data_repo/sanic/sanic/touchup/service.py",
      "content": "@classmethod\n    def register(cls, target, method_name):\n        cls._registry.add((target, method_name))"
    },
    {
      "chunk_id": 852,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/__init__.py",
      "content": "from .altsvc import AltSvcCheck  # noqa\nfrom .base import BaseScheme\nfrom .ode import OptionalDispatchEvent  # noqa"
    },
    {
      "chunk_id": 853,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/__init__.py",
      "content": "__all__ = (\"BaseScheme\",)"
    },
    {
      "chunk_id": 854,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/base.py",
      "content": "from abc import ABC, abstractmethod\nfrom ast import NodeTransformer, parse\nfrom inspect import getsource\nfrom textwrap import dedent\nfrom typing import Any"
    },
    {
      "chunk_id": 855,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/base.py",
      "content": "class BaseScheme(ABC):\n    ident: str\n    _registry: set[type] = set()\n\n    def __init__(self, app) -> None:\n        self.app = app\n\n    @abstractmethod\n    def visitors(self) -> list[NodeTransformer]: ...\n\n    def __init_subclass__(cls):\n        BaseScheme._registry.add(cls)"
    },
    {
      "chunk_id": 856,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/base.py",
      "content": "def __call__(self):\n        return self.visitors()"
    },
    {
      "chunk_id": 857,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/base.py",
      "content": "@classmethod\n    def build(cls, method, module_globals, app):\n        raw_source = getsource(method)\n        src = dedent(raw_source)\n        node = parse(src)\n\n        for scheme in cls._registry:\n            for visitor in scheme(app)():\n                node = visitor.visit(node)\n\n        compiled_src = compile(node, method.__name__, \"exec\")\n        exec_locals: dict[str, Any] = {}\n        exec(compiled_src, module_globals, exec_locals)  # nosec\n        return exec_locals[method.__name__]"
    },
    {
      "chunk_id": 858,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "from ast import Attribute, Await, Expr, NodeTransformer\nfrom typing import Any\n\nfrom sanic.log import logger\n\nfrom .base import BaseScheme"
    },
    {
      "chunk_id": 859,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "class OptionalDispatchEvent(BaseScheme):\n    ident = \"ODE\"\n    SYNC_SIGNAL_NAMESPACES = \"http.\"\n\n    def __init__(self, app) -> None:\n        super().__init__(app)\n\n        self._sync_events()\n        self._registered_events = [\n            signal.name for signal in app.signal_router.routes\n        ]"
    },
    {
      "chunk_id": 860,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "def visitors(self) -> list[NodeTransformer]:\n        return [RemoveDispatch(self._registered_events)]"
    },
    {
      "chunk_id": 861,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "def _sync_events(self):\n        all_events = set()\n        app_events = {}\n        for app in self.app.__class__._app_registry.values():\n            if app.state.server_info:\n                app_events[app] = {\n                    signal.name for signal in app.signal_router.routes\n                }\n                all_events.update(app_events[app])\n\n        for app, events in app_events.items():\n            missing = {\n                x\n                for x in all_events.difference(events)\n                if any(x.startswith(y) for y in self.SYNC_SIGNAL_NAMESPACES)\n            }\n            if missing:\n                was_finalized = app.signal_router.finalized\n                if was_finalized:  # no cov\n                    app.signal_router.reset()\n                for event in missing:\n                    app.signal(event)(self.noop)\n                if was_finalized:  # no cov\n                    app.signal_router.finalize()"
    },
    {
      "chunk_id": 862,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "@staticmethod\n    async def noop(**_):  # no cov\n        ..."
    },
    {
      "chunk_id": 863,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "class RemoveDispatch(NodeTransformer):\n    def __init__(self, registered_events) -> None:\n        self._registered_events = registered_events"
    },
    {
      "chunk_id": 864,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "def visit_Expr(self, node: Expr) -> Any:\n        call = node.value\n        if isinstance(call, Await):\n            call = call.value\n\n        func = getattr(call, \"func\", None)\n        args = getattr(call, \"args\", None)\n        if not func or not args:\n            return node\n\n        if isinstance(func, Attribute) and func.attr == \"dispatch\":\n            event = args[0]\n            if event_name := getattr(event, \"value\", None):\n                if self._not_registered(event_name):\n                    logger.debug(\n                        f\"Disabling event: {event_name}\",\n                        extra={\"verbosity\": 2},\n                    )\n                    return None\n        return node"
    },
    {
      "chunk_id": 865,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/ode.py",
      "content": "def _not_registered(self, event_name):\n        dynamic = []\n        for event in self._registered_events:\n            if event.endswith(\">\"):\n                namespace_concern, _ = event.rsplit(\".\", 1)\n                dynamic.append(namespace_concern)\n\n        namespace_concern, _ = event_name.rsplit(\".\", 1)\n        return (\n            event_name not in self._registered_events\n            and namespace_concern not in dynamic\n        )"
    },
    {
      "chunk_id": 866,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "from __future__ import annotations\n\nfrom ast import Assign, Constant, NodeTransformer, Subscript\nfrom typing import TYPE_CHECKING, Any\n\nfrom sanic.http.constants import HTTP\n\nfrom .base import BaseScheme"
    },
    {
      "chunk_id": 867,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "class AltSvcCheck(BaseScheme):\n    ident = \"ALTSVC\"\n\n    def visitors(self) -> list[NodeTransformer]:\n        return [RemoveAltSvc(self.app, self.app.state.verbosity)]"
    },
    {
      "chunk_id": 868,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "class RemoveAltSvc(NodeTransformer):\n    def __init__(self, app: Sanic, verbosity: int = 0) -> None:\n        self._app = app\n        self._verbosity = verbosity\n        self._versions = {\n            info.settings[\"version\"] for info in app.state.server_info\n        }"
    },
    {
      "chunk_id": 869,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "def visit_Assign(self, node: Assign) -> Any:\n        if any(self._matches(target) for target in node.targets):\n            if self._should_remove():\n                return None\n            assert isinstance(node.value, Constant)\n            node.value.value = self.value()\n        return node"
    },
    {
      "chunk_id": 870,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "def _should_remove(self) -> bool:\n        return len(self._versions) == 1"
    },
    {
      "chunk_id": 871,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "@staticmethod\n    def _matches(node) -> bool:\n        return (\n            isinstance(node, Subscript)\n            and isinstance(node.slice, Constant)\n            and node.slice.value == \"alt-svc\"\n        )"
    },
    {
      "chunk_id": 872,
      "source": "__internal__/data_repo/sanic/sanic/touchup/schemes/altsvc.py",
      "content": "def value(self):\n        values = []\n        for info in self._app.state.server_info:\n            port = info.settings[\"port\"]\n            version = info.settings[\"version\"]\n            if version is HTTP.VERSION_3:\n                values.append(f'h3=\":{port}\"')\n        return \", \".join(values)"
    },
    {
      "chunk_id": 873,
      "source": "__internal__/data_repo/sanic/sanic/base/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 874,
      "source": "__internal__/data_repo/sanic/sanic/base/meta.py",
      "content": "class SanicMeta(type):\n    @classmethod\n    def __prepare(metaclass, name, bases, **kwds):\n        cls = super().__prepare__(metaclass, name, bases, **kwds)\n        cls[\"__slots__\"] = ()\n        return cls"
    },
    {
      "chunk_id": 875,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "import re"
    },
    {
      "chunk_id": 876,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "from typing import Any, Optional"
    },
    {
      "chunk_id": 877,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "from sanic.base.meta import SanicMeta\nfrom sanic.exceptions import SanicException\nfrom sanic.mixins.commands import CommandMixin\nfrom sanic.mixins.exceptions import ExceptionMixin\nfrom sanic.mixins.listeners import ListenerMixin\nfrom sanic.mixins.middleware import MiddlewareMixin\nfrom sanic.mixins.routes import RouteMixin\nfrom sanic.mixins.signals import SignalMixin\nfrom sanic.mixins.static import StaticMixin"
    },
    {
      "chunk_id": 878,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "VALID_NAME = re.compile(r\"^[a-zA-Z_][a-zA-Z0-9_\\-]*$\")"
    },
    {
      "chunk_id": 879,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "class BaseSanic(\n    RouteMixin,\n    StaticMixin,\n    MiddlewareMixin,\n    ListenerMixin,\n    ExceptionMixin,\n    SignalMixin,\n    CommandMixin,\n    metaclass=SanicMeta,\n):\n    __slots__ = (\"name\",)\n\n    def __init__(\n        self, name: Optional[str] = None, *args: Any, **kwargs: Any\n    ) -> None:\n        class_name = self.__class__.__name__\n\n        if name is None:\n            raise SanicException(\n                f\"{class_name} instance cannot be unnamed. \"\n                \"Please use Sanic(name='your_application_name') instead.\",\n            )\n\n        if not VALID_NAME.match(name):\n            raise SanicException(\n                f\"{class_name} instance named '{name}' uses an invalid \"\n                \"format. Names must begin with a character and may only \"\n                \"contain alphanumeric characters, _, or -.\"\n            )\n\n        self.name = name\n\n        for base in BaseSanic.__bases__:\n            base.__init__(self, *args, **kwargs)  # type: ignore"
    },
    {
      "chunk_id": 880,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "def __str__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\""
    },
    {
      "chunk_id": 881,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(name=\"{self.name}\")'"
    },
    {
      "chunk_id": 882,
      "source": "__internal__/data_repo/sanic/sanic/base/root.py",
      "content": "def __setattr__(self, name: str, value: Any) -> None:\n        try:\n            super().__setattr__(name, value)\n        except AttributeError as e:\n            raise AttributeError(\n                f\"Setting variables on {self.__class__.__name__} instances is \"\n                \"not allowed. You should change your \"\n                f\"{self.__class__.__name__} instance to use \"\n                f\"instance.ctx.{name} instead.\",\n            ) from e"
    },
    {
      "chunk_id": 883,
      "source": "__internal__/data_repo/sanic/sanic/cli/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 884,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "from __future__ import annotations\n\nimport sys\n\nfrom http.client import RemoteDisconnected\nfrom textwrap import indent\nfrom typing import Any, Optional\nfrom urllib.error import URLError\nfrom urllib.request import Request as URequest\nfrom urllib.request import urlopen\n\nfrom sanic.application.logo import get_logo\nfrom sanic.application.motd import MOTDTTY\nfrom sanic.log import Colors\n\n\ntry:  # no cov\n    from ujson import dumps, loads\nexcept ModuleNotFoundError:  # no cov\n    from json import dumps, loads  # type: ignore"
    },
    {
      "chunk_id": 885,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "class InspectorClient:\n    def __init__(\n        self,\n        host: str,\n        port: int,\n        secure: bool,\n        raw: bool,\n        api_key: Optional[str],\n    ) -> None:\n        self.scheme = \"https\" if secure else \"http\"\n        self.host = host\n        self.port = port\n        self.raw = raw\n        self.api_key = api_key\n\n        for scheme in (\"http\", \"https\"):\n            full = f\"{scheme}://\"\n            if self.host.startswith(full):\n                self.scheme = scheme\n                self.host = self.host[len(full) :]  # noqa E203"
    },
    {
      "chunk_id": 886,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "def do(self, action: str, **kwargs: Any) -> None:\n        if action == \"info\":\n            self.info()\n            return\n        result = self.request(action, **kwargs).get(\"result\")\n        if result:\n            out = (\n                dumps(result)\n                if isinstance(result, (list, dict))\n                else str(result)\n            )\n            sys.stdout.write(out + \"\\n\")"
    },
    {
      "chunk_id": 887,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "def info(self) -> None:\n        out = sys.stdout.write\n        response = self.request(\"\", \"GET\")\n        if self.raw or not response:\n            return\n        data = response[\"result\"]\n        display = data.pop(\"info\")\n        extra = display.pop(\"extra\", {})\n        display[\"packages\"] = \", \".join(display[\"packages\"])\n        MOTDTTY(get_logo(), self.base_url, display, extra).display(\n            version=False,\n            action=\"Inspecting\",\n            out=out,\n        )\n        for name, info in data[\"workers\"].items():\n            info = \"\\n\".join(\n                f\"\\t{key}: {Colors.BLUE}{value}{Colors.END}\"\n                for key, value in info.items()\n            )\n            out(\n                \"\\n\"\n                + indent(\n                    \"\\n\".join(\n                        [\n                            f\"{Colors.BOLD}{Colors.SANIC}{name}{Colors.END}\",\n                            info,\n                        ]\n                    ),\n                    \"  \",\n                )\n                + \"\\n\"\n            )"
    },
    {
      "chunk_id": 888,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "def request(self, action: str, method: str = \"POST\", **kwargs: Any) -> Any:\n        url = f\"{self.base_url}/{action}\"\n        params: dict[str, Any] = {\"method\": method, \"headers\": {}}\n        if kwargs:\n            params[\"data\"] = dumps(kwargs).encode()\n            params[\"headers\"][\"content-type\"] = \"application/json\"\n        if self.api_key:\n            params[\"headers\"][\"authorization\"] = f\"Bearer {self.api_key}\"\n        request = URequest(url, **params)\n\n        try:\n            with urlopen(request) as response:  # nosec B310\n                raw = response.read()\n                loaded = loads(raw)\n                if self.raw:\n                    sys.stdout.write(dumps(loaded.get(\"result\")) + \"\\n\")\n                    return {}\n                return loaded\n        except (URLError, RemoteDisconnected) as e:\n            sys.stderr.write(\n                f\"{Colors.RED}Could not connect to inspector at: \"\n                f\"{Colors.YELLOW}{self.base_url}{Colors.END}\\n\"\n                \"Either the application is not running, or it did not start \"\n                f\"an inspector instance.\\n{e}\\n\"\n            )\n            sys.exit(1)"
    },
    {
      "chunk_id": 889,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector_client.py",
      "content": "@property\n    def base_url(self):\n        return f\"{self.scheme}://{self.host}:{self.port}\""
    },
    {
      "chunk_id": 890,
      "source": "__internal__/data_repo/sanic/sanic/cli/base.py",
      "content": "from argparse import (\n    SUPPRESS,\n    Action,\n    ArgumentParser,\n    RawTextHelpFormatter,\n    _SubParsersAction,\n)\nfrom typing import Any"
    },
    {
      "chunk_id": 891,
      "source": "__internal__/data_repo/sanic/sanic/cli/base.py",
      "content": "class SanicArgumentParser(ArgumentParser):\n    def _check_value(self, action: Action, value: Any) -> None:\n        if isinstance(action, SanicSubParsersAction):\n            return\n        super()._check_value(action, value)"
    },
    {
      "chunk_id": 892,
      "source": "__internal__/data_repo/sanic/sanic/cli/base.py",
      "content": "class SanicHelpFormatter(RawTextHelpFormatter):\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if not usage:\n            usage = SUPPRESS\n            # Add one linebreak, but not two\n            self.add_text(\"\\x1b[1A\")\n        super().add_usage(usage, actions, groups, prefix)"
    },
    {
      "chunk_id": 893,
      "source": "__internal__/data_repo/sanic/sanic/cli/base.py",
      "content": "class SanicSubParsersAction(_SubParsersAction):\n    def __call__(self, parser, namespace, values, option_string=None):\n        self._name_parser_map\n        parser_name = values[0]\n        if parser_name not in self._name_parser_map:\n            self._name_parser_map[parser_name] = parser\n            values = [\"<custom>\", *values]\n\n        super().__call__(parser, namespace, values, option_string)"
    },
    {
      "chunk_id": 894,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "import concurrent.futures\nimport sys\nimport threading\nimport time\nimport traceback\n\nfrom ast import PyCF_ALLOW_TOP_LEVEL_AWAIT\nfrom asyncio import iscoroutine, new_event_loop\nfrom code import InteractiveConsole\nfrom collections.abc import Sequence\nfrom types import FunctionType\nfrom typing import Any, NamedTuple, Optional, Union\n\nimport sanic\n\nfrom sanic import Request, Sanic\nfrom sanic.compat import Header\nfrom sanic.helpers import Default\nfrom sanic.http.constants import Stage\nfrom sanic.log import Colors\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.response.types import HTTPResponse"
    },
    {
      "chunk_id": 895,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "try:\n    from httpx import Client\n\n    HTTPX_AVAILABLE = True\n\n    class SanicClient(Client):\n        def __init__(self, app: Sanic):\n            base_url = app.get_server_location(\n                app.state.server_info[0].settings\n            )\n            super().__init__(base_url=base_url)\n\nexcept ImportError:\n    HTTPX_AVAILABLE = False"
    },
    {
      "chunk_id": 896,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "try:\n    import readline  # noqa\nexcept ImportError:\n    print(\n        \"Module 'readline' not available. History navigation will be limited.\",\n        file=sys.stderr,\n    )"
    },
    {
      "chunk_id": 897,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "repl_app: Optional[Sanic] = None\nrepl_response: Optional[HTTPResponse] = None"
    },
    {
      "chunk_id": 898,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "class REPLProtocol(TransportProtocol):\n    def __init__(self):\n        self.stage = Stage.IDLE\n        self.request_body = True\n\n    def respond(self, response):\n        global repl_response\n        repl_response = response\n        response.stream = self\n        return response\n\n    async def send(self, data, end_stream): ..."
    },
    {
      "chunk_id": 899,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "class Result(NamedTuple):\n    request: Request\n    response: HTTPResponse"
    },
    {
      "chunk_id": 900,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def make_request(\n    url: str = \"/\",\n    headers: Optional[Union[dict[str, Any], Sequence[tuple[str, str]]]] = None,\n    method: str = \"GET\",\n    body: Optional[str] = None,\n):\n    assert repl_app, \"No Sanic app has been registered.\"\n    headers = headers or {}\n    protocol = REPLProtocol()\n    request = Request(  # type: ignore\n        url.encode(),\n        Header(headers),\n        \"1.1\",\n        method,\n        protocol,\n        repl_app,\n    )\n    if body is not None:\n        request.body = body.encode()\n    request.stream = protocol  # type: ignore\n    request.conn_info = None\n    return request"
    },
    {
      "chunk_id": 901,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "async def respond(request) -> HTTPResponse:\n    assert repl_app, \"No Sanic app has been registered.\"\n    await repl_app.handle_request(request)\n    assert repl_response\n    return repl_response"
    },
    {
      "chunk_id": 902,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "async def do(\n    url: str = \"/\",\n    headers: Optional[Union[dict[str, Any], Sequence[tuple[str, str]]]] = None,\n    method: str = \"GET\",\n    body: Optional[str] = None,\n) -> Result:\n    request = make_request(url, headers, method, body)\n    response = await respond(request)\n    return Result(request, response)"
    },
    {
      "chunk_id": 903,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "class SanicREPL(InteractiveConsole):\n    def __init__(self, app: Sanic, start: Optional[Default] = None):\n        global repl_app\n        repl_app = app\n        locals_available = {\n            \"app\": app,\n            \"sanic\": sanic,\n            \"do\": do,\n        }\n        client_availability = \"\"\n        variable_descriptions = [\n            f\"  - {Colors.BOLD + Colors.SANIC}app{Colors.END}: The Sanic application instance - {Colors.BOLD + Colors.BLUE}{str(app)}{Colors.END}\",  # noqa: E501\n            f\"  - {Colors.BOLD + Colors.SANIC}sanic{Colors.END}: The Sanic module - {Colors.BOLD + Colors.BLUE}import sanic{Colors.END}\",  # noqa: E501\n            f\"  - {Colors.BOLD + Colors.SANIC}do{Colors.END}: An async function to fake a request to the application - {Colors.BOLD + Colors.BLUE}Result(request, response){Colors.END}\",  # noqa: E501\n        ]\n        if HTTPX_AVAILABLE:\n            locals_available[\"client\"] = SanicClient(app)\n            variable_descriptions.append(\n                f\"  - {Colors.BOLD + Colors.SANIC}client{Colors.END}: A client to access the Sanic app instance using httpx - {Colors.BOLD + Colors.BLUE}from httpx import Client{Colors.END}\",  # noqa: E501\n            )\n        else:\n            client_availability = (\n                f\"\\n{Colors.YELLOW}The HTTP client has been disabled. \"\n                \"To enable it, install httpx:\\n\\t\"\n                f\"pip install httpx{Colors.END}\\n\"\n            )\n        super().__init__(locals=locals_available)\n        self.compile.compiler.flags |= PyCF_ALLOW_TOP_LEVEL_AWAIT\n        self.loop = new_event_loop()\n        self._start = start\n        self._pause_event = threading.Event()\n        self._started_event = threading.Event()\n        self._interact_thread = threading.Thread(\n            target=self._console,\n            daemon=True,\n        )\n        self._monitor_thread = threading.Thread(\n            target=self._monitor,\n            daemon=True,\n        )\n        self._async_thread = threading.Thread(\n            target=self.loop.run_forever,\n            daemon=True,\n        )\n        self.app = app\n        self.resume()\n        self.exit_message = \"Closing the REPL.\"\n        self.banner_message = \"\\n\".join(\n            [\n                f\"\\n{Colors.BOLD}Welcome to the Sanic interactive console{Colors.END}\",  # noqa: E501\n                client_availability,\n                \"The following objects are available for your convenience:\",  # noqa: E501\n                *variable_descriptions,\n                \"\\nThe async/await keywords are available for use here.\",  # noqa: E501\n                f\"To exit, press {Colors.BOLD}CTRL+C{Colors.END}, \"\n                f\"{Colors.BOLD}CTRL+D{Colors.END}, or type {Colors.BOLD}exit(){Colors.END}.\\n\",  # noqa: E501\n            ]\n        )"
    },
    {
      "chunk_id": 904,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def pause(self):\n        if self.is_paused():\n            return\n        self._pause_event.clear()"
    },
    {
      "chunk_id": 905,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def resume(self):\n        self._pause_event.set()"
    },
    {
      "chunk_id": 906,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def runsource(self, source, filename=\"<input>\", symbol=\"single\"):\n        if source.strip() == \"exit()\":\n            self._shutdown()\n            return False\n\n        if self.is_paused():\n            print(\"Console is paused. Please wait for it to be resumed.\")\n            return False\n\n        return super().runsource(source, filename, symbol)"
    },
    {
      "chunk_id": 907,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def runcode(self, code):\n        future = concurrent.futures.Future()\n\n        async def callback():\n            func = FunctionType(code, self.locals)\n            try:\n                result = func()\n                if iscoroutine(result):\n                    result = await result\n            except BaseException:\n                traceback.print_exc()\n                result = False\n            future.set_result(result)\n\n        self.loop.call_soon_threadsafe(self.loop.create_task, callback())\n        return future.result()"
    },
    {
      "chunk_id": 908,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def is_paused(self):\n        return not self._pause_event.is_set()"
    },
    {
      "chunk_id": 909,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def _console(self):\n        self._started_event.set()\n        self.interact(banner=self.banner_message, exitmsg=self.exit_message)\n        self._shutdown()"
    },
    {
      "chunk_id": 910,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def _monitor(self):\n        if isinstance(self._start, Default):\n            enter = f\"{Colors.BOLD + Colors.SANIC}ENTER{Colors.END}\"\n            start = input(f\"\\nPress {enter} at anytime to start the REPL.\\n\\n\")\n            if start:\n                return\n        try:\n            while True:\n                if not self._started_event.is_set():\n                    self.app.manager.wait_for_ack()\n                    self._interact_thread.start()\n                elif self.app.manager._all_workers_ack() and self.is_paused():\n                    self.resume()\n                    print(sys.ps1, end=\"\", flush=True)\n                elif (\n                    not self.app.manager._all_workers_ack()\n                    and not self.is_paused()\n                ):\n                    self.pause()\n                time.sleep(0.1)\n        except (ConnectionResetError, BrokenPipeError):\n            pass"
    },
    {
      "chunk_id": 911,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def _shutdown(self):\n        self.app.manager.monitor_publisher.send(\"__TERMINATE__\")"
    },
    {
      "chunk_id": 912,
      "source": "__internal__/data_repo/sanic/sanic/cli/console.py",
      "content": "def run(self):\n        self._monitor_thread.start()\n        self._async_thread.start()"
    },
    {
      "chunk_id": 913,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "import os\nimport shutil\nimport sys\n\nfrom argparse import Namespace\nfrom functools import partial\nfrom textwrap import indent\nfrom typing import Union\n\nfrom sanic.app import Sanic\nfrom sanic.application.logo import get_logo\nfrom sanic.cli.arguments import Group\nfrom sanic.cli.base import SanicArgumentParser, SanicHelpFormatter\nfrom sanic.cli.console import SanicREPL\nfrom sanic.cli.executor import Executor, make_executor_parser\nfrom sanic.cli.inspector import make_inspector_parser\nfrom sanic.cli.inspector_client import InspectorClient\nfrom sanic.helpers import _default, is_atty\nfrom sanic.log import error_logger\nfrom sanic.worker.loader import AppLoader"
    },
    {
      "chunk_id": 914,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "class SanicCLI:\n    DESCRIPTION = indent(\n        f\"\"\"\n{get_logo(True)}\n\nTo start running a Sanic application, provide a path to the module, where\napp is a Sanic() instance in the global scope:\n\n    $ sanic path.to.server:app\n\nIf the Sanic instance variable is called 'app', you can leave off the last\npart, and only provide a path to the module where the instance is:\n\n    $ sanic path.to.server\n\nOr, a path to a callable that returns a Sanic() instance:\n\n    $ sanic path.to.factory:create_app\n\nOr, a path to a directory to run as a simple HTTP server:\n\n    $ sanic ./path/to/static\n\"\"\",\n        prefix=\" \",\n    )\n\n    def __init__(self) -> None:\n        width = shutil.get_terminal_size().columns\n        self.parser = SanicArgumentParser(\n            prog=\"sanic\",\n            description=self.DESCRIPTION,\n            formatter_class=lambda prog: SanicHelpFormatter(\n                prog,\n                max_help_position=36 if width > 96 else 24,\n                indent_increment=4,\n                width=None,\n            ),\n        )\n        self.parser._positionals.title = \"Required\\n========\\n  Positional\"\n        self.parser._optionals.title = \"Optional\\n========\\n  General\"\n        self.main_process = (\n            os.environ.get(\"SANIC_RELOADER_PROCESS\", \"\") != \"true\"\n        )\n        self.args: Namespace = Namespace()\n        self.groups: list[Group] = []\n        self.run_mode = \"serve\""
    },
    {
      "chunk_id": 915,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def attach(self):\n        if len(sys.argv) > 1 and sys.argv[1] == \"inspect\":\n            self.run_mode = \"inspect\"\n            self.parser.description = get_logo(True)\n            make_inspector_parser(self.parser)\n            return\n\n        for group in Group._registry:\n            instance = group.create(self.parser)\n            instance.attach()\n            self.groups.append(instance)\n\n        if len(sys.argv) > 2 and sys.argv[2] == \"exec\":\n            self.run_mode = \"exec\"\n            self.parser.description = get_logo(True)\n            make_executor_parser(self.parser)"
    },
    {
      "chunk_id": 916,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def run(self, parse_args=None):\n        if self.run_mode == \"inspect\":\n            self._inspector()\n            return\n\n        legacy_version = False\n        if not parse_args:\n            # This is to provide backwards compat -v to display version\n            legacy_version = len(sys.argv) == 2 and sys.argv[-1] == \"-v\"\n            parse_args = [\"--version\"] if legacy_version else None\n        elif parse_args == [\"-v\"]:\n            parse_args = [\"--version\"]\n\n        if not legacy_version:\n            if self.run_mode == \"exec\":\n                parse_args = [\n                    a\n                    for a in (parse_args or sys.argv[1:])\n                    if a not in \"-h --help\".split()\n                ]\n            parsed, unknown = self.parser.parse_known_args(args=parse_args)\n            if unknown and parsed.factory:\n                for arg in unknown:\n                    if arg.startswith(\"--\"):\n                        self.parser.add_argument(arg.split(\"=\")[0])\n\n        if self.run_mode == \"exec\":\n            self.args, _ = self.parser.parse_known_args(args=parse_args)\n        else:\n            self.args = self.parser.parse_args(args=parse_args)\n        self._precheck()\n        app_loader = AppLoader(\n            self.args.target, self.args.factory, self.args.simple, self.args\n        )\n\n        try:\n            app = self._get_app(app_loader)\n            kwargs = self._build_run_kwargs()\n        except ValueError as e:\n            error_logger.exception(f\"Failed to run app: {e}\")\n        else:\n            if self.run_mode == \"exec\":\n                self._executor(app, kwargs)\n                return\n            elif self.run_mode != \"serve\":\n                raise ValueError(f\"Unknown run mode: {self.run_mode}\")\n\n            if self.args.repl:\n                self._repl(app)\n            for http_version in self.args.http:\n                app.prepare(**kwargs, version=http_version)\n            if self.args.single:\n                serve = Sanic.serve_single\n            else:\n                serve = partial(Sanic.serve, app_loader=app_loader)\n            serve(app)"
    },
    {
      "chunk_id": 917,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _inspector(self):\n        args = sys.argv[2:]\n        self.args, unknown = self.parser.parse_known_args(args=args)\n        if unknown:\n            for arg in unknown:\n                if arg.startswith(\"--\"):\n                    try:\n                        key, value = arg.split(\"=\")\n                        key = key.lstrip(\"-\")\n                    except ValueError:\n                        value = False if arg.startswith(\"--no-\") else True\n                        key = (\n                            arg.replace(\"--no-\", \"\")\n                            .lstrip(\"-\")\n                            .replace(\"-\", \"_\")\n                        )\n                    setattr(self.args, key, value)\n\n        kwargs = {**self.args.__dict__}\n        host = kwargs.pop(\"host\")\n        port = kwargs.pop(\"port\")\n        secure = kwargs.pop(\"secure\")\n        raw = kwargs.pop(\"raw\")\n        action = kwargs.pop(\"action\") or \"info\"\n        api_key = kwargs.pop(\"api_key\")\n        positional = kwargs.pop(\"positional\", None)\n        if action == \"<custom>\" and positional:\n            action = positional[0]\n            if len(positional) > 1:\n                kwargs[\"args\"] = positional[1:]\n        InspectorClient(host, port, secure, raw, api_key).do(action, **kwargs)"
    },
    {
      "chunk_id": 918,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _executor(self, app: Sanic, kwargs: dict):\n        args = sys.argv[3:]\n        Executor(app, kwargs).run(self.args.command, args)"
    },
    {
      "chunk_id": 919,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _repl(self, app: Sanic):\n        if is_atty():\n\n            @app.main_process_ready\n            async def start_repl(app):\n                SanicREPL(app, self.args.repl).run()\n                await app._startup()\n\n        elif self.args.repl is True:\n            error_logger.error(\n                \"Can't start REPL in non-interactive mode. \"\n                \"You can only run with --repl in a TTY.\"\n            )"
    },
    {
      "chunk_id": 920,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _precheck(self):\n        # Custom TLS mismatch handling for better diagnostics\n        if self.main_process and (\n            # one of cert/key missing\n            bool(self.args.cert) != bool(self.args.key)\n            # new and old style self.args used together\n            or self.args.tls\n            and self.args.cert\n            # strict host checking without certs would always fail\n            or self.args.tlshost\n            and not self.args.tls\n            and not self.args.cert\n        ):\n            self.parser.print_usage(sys.stderr)\n            message = (\n                \"TLS certificates must be specified by either of:\\n\"\n                \"  --cert certdir/fullchain.pem --key certdir/privkey.pem\\n\"\n                \"  --tls certdir  (equivalent to the above)\"\n            )\n            error_logger.error(message)\n            sys.exit(1)"
    },
    {
      "chunk_id": 921,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _get_app(self, app_loader: AppLoader):\n        try:\n            app = app_loader.load()\n        except ImportError as e:\n            if app_loader.module_name.startswith(e.name):  # type: ignore\n                error_logger.error(\n                    f\"No module named {e.name} found.\\n\"\n                    \"  Example File: project/sanic_server.py -> app\\n\"\n                    \"  Example Module: project.sanic_server.app\"\n                )\n                error_logger.error(\n                    \"\\nThe error below might have caused the above one:\\n\"\n                    f\"{e.msg}\"\n                )\n                sys.exit(1)\n            else:\n                raise e\n        return app"
    },
    {
      "chunk_id": 922,
      "source": "__internal__/data_repo/sanic/sanic/cli/app.py",
      "content": "def _build_run_kwargs(self):\n        for group in self.groups:\n            group.prepare(self.args)\n        ssl: Union[None, dict, str, list] = []\n        if self.args.tlshost:\n            ssl.append(None)\n        if self.args.cert is not None or self.args.key is not None:\n            ssl.append(dict(cert=self.args.cert, key=self.args.key))\n        if self.args.tls:\n            ssl += self.args.tls\n        if not ssl:\n            ssl = None\n        elif len(ssl) == 1 and ssl[0] is not None:\n            # Use only one cert, no TLSSelector.\n            ssl = ssl[0]\n\n        kwargs = {\n            \"access_log\": self.args.access_log,\n            \"coffee\": self.args.coffee,\n            \"debug\": self.args.debug,\n            \"fast\": self.args.fast,\n            \"host\": self.args.host,\n            \"motd\": self.args.motd,\n            \"noisy_exceptions\": self.args.noisy_exceptions,\n            \"port\": self.args.port,\n            \"ssl\": ssl,\n            \"unix\": self.args.unix,\n            \"verbosity\": self.args.verbosity or 0,\n            \"workers\": self.args.workers,\n            \"auto_tls\": self.args.auto_tls,\n            \"single_process\": self.args.single,\n        }\n\n        for maybe_arg in (\"auto_reload\", \"dev\"):\n            if getattr(self.args, maybe_arg, False):\n                kwargs[maybe_arg] = True\n\n        if self.args.dev and all(\n            arg not in sys.argv for arg in (\"--repl\", \"--no-repl\")\n        ):\n            self.args.repl = _default\n\n        if self.args.path:\n            kwargs[\"auto_reload\"] = True\n            kwargs[\"reload_dir\"] = self.args.path\n\n        return kwargs"
    },
    {
      "chunk_id": 923,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "import shutil\n\nfrom argparse import ArgumentParser\nfrom asyncio import run\nfrom inspect import signature\nfrom typing import Callable\n\nfrom sanic import Sanic\nfrom sanic.application.logo import get_logo\nfrom sanic.cli.base import (\n    SanicArgumentParser,\n    SanicHelpFormatter,\n)"
    },
    {
      "chunk_id": 924,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "def make_executor_parser(parser: ArgumentParser) -> None:\n    parser.add_argument(\n        \"command\",\n        help=\"Command to execute\",\n    )"
    },
    {
      "chunk_id": 925,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "class ExecutorSubParser(ArgumentParser):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.description:\n            self.description = \"\"\n        self.description = get_logo(True) + self.description"
    },
    {
      "chunk_id": 926,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "class Executor:\n    def __init__(self, app: Sanic, kwargs: dict) -> None:\n        self.app = app\n        self.kwargs = kwargs\n        self.commands = self._make_commands()\n        self.parser = self._make_parser()"
    },
    {
      "chunk_id": 927,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "def run(self, command: str, args: list[str]) -> None:\n        if command == \"exec\":\n            args = [\"--help\"]\n        parsed_args = self.parser.parse_args(args)\n        if command not in self.commands:\n            raise ValueError(f\"Unknown command: {command}\")\n        parsed_kwargs = vars(parsed_args)\n        parsed_kwargs.pop(\"command\")\n        run(self.commands[command](**parsed_kwargs))"
    },
    {
      "chunk_id": 928,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "def _make_commands(self) -> dict[str, Callable]:\n        commands = {c.name: c.func for c in self.app._future_commands}\n        return commands"
    },
    {
      "chunk_id": 929,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "def _make_parser(self) -> SanicArgumentParser:\n        width = shutil.get_terminal_size().columns\n        parser = SanicArgumentParser(\n            prog=\"sanic\",\n            description=get_logo(True),\n            formatter_class=lambda prog: SanicHelpFormatter(\n                prog,\n                max_help_position=36 if width > 96 else 24,\n                indent_increment=4,\n                width=None,\n            ),\n        )\n\n        subparsers = parser.add_subparsers(\n            dest=\"command\",\n            title=\"  Commands\",\n            parser_class=ExecutorSubParser,\n        )\n        for command in self.app._future_commands:\n            sub = subparsers.add_parser(\n                command.name,\n                help=command.func.__doc__ or f\"Execute {command.name}\",\n                formatter_class=SanicHelpFormatter,\n            )\n            self._add_arguments(sub, command.func)\n\n        return parser"
    },
    {
      "chunk_id": 930,
      "source": "__internal__/data_repo/sanic/sanic/cli/executor.py",
      "content": "def _add_arguments(self, parser: ArgumentParser, func: Callable) -> None:\n        sig = signature(func)\n        for param in sig.parameters.values():\n            kwargs = {}\n            if param.default is not param.empty:\n                kwargs[\"default\"] = param.default\n            parser.add_argument(\n                f\"--{param.name}\",\n                help=param.annotation,\n                **kwargs,\n            )"
    },
    {
      "chunk_id": 931,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector.py",
      "content": "from argparse import ArgumentParser\n\nfrom sanic.application.logo import get_logo\nfrom sanic.cli.base import SanicHelpFormatter, SanicSubParsersAction"
    },
    {
      "chunk_id": 932,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector.py",
      "content": "def _add_shared(parser: ArgumentParser) -> None:\n    parser.add_argument(\n        \"--host\",\n        \"-H\",\n        default=\"localhost\",\n        help=\"Inspector host address [default 127.0.0.1]\",\n    )\n    parser.add_argument(\n        \"--port\",\n        \"-p\",\n        default=6457,\n        type=int,\n        help=\"Inspector port [default 6457]\",\n    )\n    parser.add_argument(\n        \"--secure\",\n        \"-s\",\n        action=\"store_true\",\n        help=\"Whether to access the Inspector via TLS encryption\",\n    )\n    parser.add_argument(\"--api-key\", \"-k\", help=\"Inspector authentication key\")\n    parser.add_argument(\n        \"--raw\",\n        action=\"store_true\",\n        help=\"Whether to output the raw response information\",\n    )"
    },
    {
      "chunk_id": 933,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector.py",
      "content": "class InspectorSubParser(ArgumentParser):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        _add_shared(self)\n        if not self.description:\n            self.description = \"\"\n        self.description = get_logo(True) + self.description"
    },
    {
      "chunk_id": 934,
      "source": "__internal__/data_repo/sanic/sanic/cli/inspector.py",
      "content": "def make_inspector_parser(parser: ArgumentParser) -> None:\n    _add_shared(parser)\n    subparsers = parser.add_subparsers(\n        action=SanicSubParsersAction,\n        dest=\"action\",\n        description=(\n            \"Run one or none of the below subcommands. Using inspect without \"\n            \"a subcommand will fetch general information about the state \"\n            \"of the application instance.\\n\\n\"\n            \"Or, you can optionally follow inspect with a subcommand. \"\n            \"If you have created a custom \"\n            \"Inspector instance, then you can run custom commands. See \"\n            \"https://sanic.dev/en/guide/deployment/inspector.html \"\n            \"for more details.\"\n        ),\n        title=\"  Subcommands\",\n        parser_class=InspectorSubParser,\n    )\n    reloader = subparsers.add_parser(\n        \"reload\",\n        help=\"Trigger a reload of the server workers\",\n        formatter_class=SanicHelpFormatter,\n    )\n    reloader.add_argument(\n        \"--zero-downtime\",\n        action=\"store_true\",\n        help=(\n            \"Whether to wait for the new process to be online before \"\n            \"terminating the old\"\n        ),\n    )\n    subparsers.add_parser(\n        \"shutdown\",\n        help=\"Shutdown the application and all processes\",\n        formatter_class=SanicHelpFormatter,\n    )\n    scale = subparsers.add_parser(\n        \"scale\",\n        help=\"Scale the number of workers\",\n        formatter_class=SanicHelpFormatter,\n    )\n    scale.add_argument(\n        \"replicas\",\n        type=int,\n        help=\"Number of workers requested\",\n    )\n\n    custom = subparsers.add_parser(\n        \"<custom>\",\n        help=\"Run a custom command\",\n        description=(\n            \"keyword arguments:\\n  When running a custom command, you can \"\n            \"add keyword arguments by appending them to your command\\n\\n\"\n            \"\\tsanic inspect foo --one=1 --two=2\"\n        ),\n        formatter_class=SanicHelpFormatter,\n    )\n    custom.add_argument(\n        \"positional\",\n        nargs=\"*\",\n        help=\"Add one or more non-keyword args to your custom command\",\n    )"
    },
    {
      "chunk_id": 935,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "from __future__ import annotations\n\nfrom argparse import ArgumentParser, _ArgumentGroup\nfrom typing import Optional, Union\n\nfrom sanic_routing import __version__ as __routing_version__\n\nfrom sanic import __version__\nfrom sanic.http.constants import HTTP"
    },
    {
      "chunk_id": 936,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class Group:\n    name: Optional[str]\n    container: Union[ArgumentParser, _ArgumentGroup]\n    _registry: list[type[Group]] = []\n\n    def __init_subclass__(cls) -> None:\n        Group._registry.append(cls)\n\n    def __init__(self, parser: ArgumentParser, title: Optional[str]):\n        self.parser = parser\n\n        if title:\n            self.container = self.parser.add_argument_group(title=f\"  {title}\")\n        else:\n            self.container = self.parser"
    },
    {
      "chunk_id": 937,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "@classmethod\n    def create(cls, parser: ArgumentParser):\n        instance = cls(parser, cls.name)\n        return instance"
    },
    {
      "chunk_id": 938,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "def add_bool_arguments(self, *args, nullable=False, **kwargs):\n        group = self.container.add_mutually_exclusive_group()\n        kwargs[\"help\"] = kwargs[\"help\"].capitalize()\n        group.add_argument(*args, action=\"store_true\", **kwargs)\n        kwargs[\"help\"] = f\"no {kwargs['help'].lower()}\".capitalize()\n        group.add_argument(\n            \"--no-\" + args[0][2:], *args[1:], action=\"store_false\", **kwargs\n        )\n        if nullable:\n            params = {args[0][2:].replace(\"-\", \"_\"): None}\n            group.set_defaults(**params)"
    },
    {
      "chunk_id": 939,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "def prepare(self, args) -> None: ..."
    },
    {
      "chunk_id": 940,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class GeneralGroup(Group):\n    name = None\n\n    def attach(self):\n        self.container.add_argument(\n            \"--version\",\n            action=\"version\",\n            version=f\"Sanic {__version__}; Routing {__routing_version__}\",\n        )\n\n        self.container.add_argument(\n            \"target\",\n            help=(\n                \"Path to your Sanic app instance.\\n\"\n                \"\\tExample: path.to.server:app\\n\"\n                \"If running a Simple Server, path to directory to serve.\\n\"\n                \"\\tExample: ./\\n\"\n                \"Additionally, this can be a path to a factory function\\n\"\n                \"that returns a Sanic app instance.\\n\"\n                \"\\tExample: path.to.server:create_app\\n\"\n            ),\n        )\n\n        self.container.add_argument(\n            \"action\",\n            nargs=\"?\",\n            default=\"serve\",\n            choices=[\n                \"serve\",\n                \"exec\",\n            ],\n            help=(\n                \"Action to perform.\\n\"\n                \"\\tserve: Run the Sanic app\\n\"\n                \"\\texec: Execute a command in the Sanic app context\\n\"\n            ),\n        )"
    },
    {
      "chunk_id": 941,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class ApplicationGroup(Group):\n    name = \"Application\"\n\n    def attach(self):\n        group = self.container.add_mutually_exclusive_group()\n        group.add_argument(\n            \"--factory\",\n            action=\"store_true\",\n            help=(\n                \"Treat app as an application factory, \"\n                \"i.e. a () -> <Sanic app> callable\"\n            ),\n        )\n        group.add_argument(\n            \"-s\",\n            \"--simple\",\n            dest=\"simple\",\n            action=\"store_true\",\n            help=(\n                \"Run Sanic as a Simple Server, and serve the contents of \"\n                \"a directory\\n(module arg should be a path)\"\n            ),\n        )\n        self.add_bool_arguments(\n            \"--repl\",\n            help=\"Run the server with an interactive shell session\",\n        )"
    },
    {
      "chunk_id": 942,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class HTTPVersionGroup(Group):\n    name = \"HTTP version\"\n\n    def attach(self):\n        http_values = [http.value for http in HTTP.__members__.values()]\n\n        self.container.add_argument(\n            \"--http\",\n            dest=\"http\",\n            action=\"append\",\n            choices=http_values,\n            type=int,\n            help=(\n                \"Which HTTP version to use: HTTP/1.1 or HTTP/3. Value should\\n\"\n                \"be either 1, or 3. [default 1]\"\n            ),\n        )\n        self.container.add_argument(\n            \"-1\",\n            dest=\"http\",\n            action=\"append_const\",\n            const=1,\n            help=(\"Run Sanic server using HTTP/1.1\"),\n        )\n        self.container.add_argument(\n            \"-3\",\n            dest=\"http\",\n            action=\"append_const\",\n            const=3,\n            help=(\"Run Sanic server using HTTP/3\"),\n        )"
    },
    {
      "chunk_id": 943,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "def prepare(self, args):\n        if not args.http:\n            args.http = [1]\n        args.http = tuple(sorted(set(map(HTTP, args.http)), reverse=True))"
    },
    {
      "chunk_id": 944,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class SocketGroup(Group):\n    name = \"Socket binding\"\n\n    def attach(self):\n        self.container.add_argument(\n            \"-H\",\n            \"--host\",\n            dest=\"host\",\n            type=str,\n            help=\"Host address [default 127.0.0.1]\",\n        )\n        self.container.add_argument(\n            \"-p\",\n            \"--port\",\n            dest=\"port\",\n            type=int,\n            help=\"Port to serve on [default 8000]\",\n        )\n        self.container.add_argument(\n            \"-u\",\n            \"--unix\",\n            dest=\"unix\",\n            type=str,\n            default=\"\",\n            help=\"location of unix socket\",\n        )"
    },
    {
      "chunk_id": 945,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class TLSGroup(Group):\n    name = \"TLS certificate\"\n\n    def attach(self):\n        self.container.add_argument(\n            \"--cert\",\n            dest=\"cert\",\n            type=str,\n            help=\"Location of fullchain.pem, bundle.crt or equivalent\",\n        )\n        self.container.add_argument(\n            \"--key\",\n            dest=\"key\",\n            type=str,\n            help=\"Location of privkey.pem or equivalent .key file\",\n        )\n        self.container.add_argument(\n            \"--tls\",\n            metavar=\"DIR\",\n            type=str,\n            action=\"append\",\n            help=(\n                \"TLS certificate folder with fullchain.pem and privkey.pem\\n\"\n                \"May be specified multiple times to choose multiple \"\n                \"certificates\"\n            ),\n        )\n        self.container.add_argument(\n            \"--tls-strict-host\",\n            dest=\"tlshost\",\n            action=\"store_true\",\n            help=\"Only allow clients that send an SNI matching server certs\",\n        )"
    },
    {
      "chunk_id": 946,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class WorkerGroup(Group):\n    name = \"Worker\"\n\n    def attach(self):\n        group = self.container.add_mutually_exclusive_group()\n        group.add_argument(\n            \"-w\",\n            \"--workers\",\n            dest=\"workers\",\n            type=int,\n            default=1,\n            help=\"Number of worker processes [default 1]\",\n        )\n        group.add_argument(\n            \"--fast\",\n            dest=\"fast\",\n            action=\"store_true\",\n            help=\"Set the number of workers to max allowed\",\n        )\n        group.add_argument(\n            \"--single-process\",\n            dest=\"single\",\n            action=\"store_true\",\n            help=\"Do not use multiprocessing, run server in a single process\",\n        )\n        self.add_bool_arguments(\n            \"--access-logs\",\n            dest=\"access_log\",\n            help=\"display access logs\",\n            default=None,\n        )"
    },
    {
      "chunk_id": 947,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class DevelopmentGroup(Group):\n    name = \"Development\"\n\n    def attach(self):\n        self.container.add_argument(\n            \"--debug\",\n            dest=\"debug\",\n            action=\"store_true\",\n            help=\"Run the server in debug mode\",\n        )\n        self.container.add_argument(\n            \"-r\",\n            \"--reload\",\n            \"--auto-reload\",\n            dest=\"auto_reload\",\n            action=\"store_true\",\n            help=(\n                \"Watch source directory for file changes and reload on \"\n                \"changes\"\n            ),\n        )\n        self.container.add_argument(\n            \"-R\",\n            \"--reload-dir\",\n            dest=\"path\",\n            action=\"append\",\n            help=\"Extra directories to watch and reload on changes\",\n        )\n        self.container.add_argument(\n            \"-d\",\n            \"--dev\",\n            dest=\"dev\",\n            action=\"store_true\",\n            help=(\"debug + auto reload\"),\n        )\n        self.container.add_argument(\n            \"--auto-tls\",\n            dest=\"auto_tls\",\n            action=\"store_true\",\n            help=(\n                \"Create a temporary TLS certificate for local development \"\n                \"(requires mkcert or trustme)\"\n            ),\n        )"
    },
    {
      "chunk_id": 948,
      "source": "__internal__/data_repo/sanic/sanic/cli/arguments.py",
      "content": "class OutputGroup(Group):\n    name = \"Output\"\n\n    def attach(self):\n        self.add_bool_arguments(\n            \"--coffee\",\n            dest=\"coffee\",\n            default=False,\n            help=\"Uhm, coffee?\",\n        )\n        self.add_bool_arguments(\n            \"--motd\",\n            dest=\"motd\",\n            default=True,\n            help=\"Show the startup display\",\n        )\n        self.container.add_argument(\n            \"-v\",\n            \"--verbosity\",\n            action=\"count\",\n            help=\"Control logging noise, eg. -vv or --verbosity=2 [default 0]\",\n        )\n        self.add_bool_arguments(\n            \"--noisy-exceptions\",\n            dest=\"noisy_exceptions\",\n            help=\"Output stack traces for all exceptions\",\n            default=None,\n        )"
    },
    {
      "chunk_id": 949,
      "source": "__internal__/data_repo/sanic/sanic/types/__init__.py",
      "content": "from .hashable_dict import HashableDict"
    },
    {
      "chunk_id": 950,
      "source": "__internal__/data_repo/sanic/sanic/types/__init__.py",
      "content": "__all__ = (\"HashableDict\",)"
    },
    {
      "chunk_id": 951,
      "source": "__internal__/data_repo/sanic/sanic/types/hashable_dict.py",
      "content": "class HashableDict(dict):\n    \"\"\"A hashable dictionary that can be used as a key in other dictionaries or sets.\"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)"
    },
    {
      "chunk_id": 952,
      "source": "__internal__/data_repo/sanic/sanic/types/hashable_dict.py",
      "content": "def __hash__(self):\n        return hash(tuple(sorted(self.items())))"
    },
    {
      "chunk_id": 953,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "import os"
    },
    {
      "chunk_id": 954,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "from collections.abc import Iterable\nfrom types import SimpleNamespace\nfrom typing import Any"
    },
    {
      "chunk_id": 955,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "from sanic.log import Colors, error_logger"
    },
    {
      "chunk_id": 956,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "class SharedContext(SimpleNamespace):\n    SAFE = (\"_lock\",)\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self._lock = False"
    },
    {
      "chunk_id": 957,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "def __setattr__(self, name: str, value: Any) -> None:\n        if self.is_locked:\n            raise RuntimeError(\n                f\"Cannot set {name} on locked SharedContext object\"\n            )\n        if not os.environ.get(\"SANIC_WORKER_NAME\"):\n            to_check: Iterable[Any]\n            if not isinstance(value, (tuple, frozenset)):\n                to_check = [value]\n            else:\n                to_check = value\n            for item in to_check:\n                self._check(name, item)\n        super().__setattr__(name, value)"
    },
    {
      "chunk_id": 958,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "def _check(self, name: str, value: Any) -> None:\n        if name in self.SAFE:\n            return\n        try:\n            module = value.__module__\n        except AttributeError:\n            module = \"\"\n        if not any(\n            module.startswith(prefix)\n            for prefix in (\"multiprocessing\", \"ctypes\")\n        ):\n            error_logger.warning(\n                f\"{Colors.YELLOW}Unsafe object {Colors.PURPLE}{name} \"\n                f\"{Colors.YELLOW}with type {Colors.PURPLE}{type(value)} \"\n                f\"{Colors.YELLOW}was added to shared_ctx. It may not \"\n                \"not function as intended. Consider using the regular \"\n                f\"ctx.\\nFor more information, please see https://sanic.dev/en\"\n                \"/guide/deployment/manager.html#using-shared-context-between-\"\n                f\"worker-processes.{Colors.END}\"\n            )"
    },
    {
      "chunk_id": 959,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "@property\n    def is_locked(self) -> bool:\n        return getattr(self, \"_lock\", False)"
    },
    {
      "chunk_id": 960,
      "source": "__internal__/data_repo/sanic/sanic/types/shared_ctx.py",
      "content": "def lock(self) -> None:\n        self._lock = True"
    },
    {
      "chunk_id": 961,
      "source": "__internal__/data_repo/sanic/sanic/handlers/__init__.py",
      "content": "from .content_range import ContentRangeHandler\nfrom .directory import DirectoryHandler\nfrom .error import ErrorHandler"
    },
    {
      "chunk_id": 962,
      "source": "__internal__/data_repo/sanic/sanic/handlers/__init__.py",
      "content": "__all__ = (\n    \"ContentRangeHandler\",\n    \"DirectoryHandler\",\n    \"ErrorHandler\",\n)"
    },
    {
      "chunk_id": 963,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "from __future__ import annotations\n\nfrom typing import Optional\n\nfrom sanic.errorpages import BaseRenderer, TextRenderer, exception_response\nfrom sanic.exceptions import ServerError\nfrom sanic.log import error_logger\nfrom sanic.models.handler_types import RouteHandler\nfrom sanic.request.types import Request\nfrom sanic.response import text\nfrom sanic.response.types import HTTPResponse"
    },
    {
      "chunk_id": 964,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "class ErrorHandler:\n    \"\"\"Process and handle all uncaught exceptions.\n\n    This error handling framework is built into the core that can be extended\n    by the developers to perform a wide range of tasks from recording the error\n    stats to reporting them to an external service that can be used for\n    realtime alerting system.\n\n    Args:\n        base (BaseRenderer): The renderer to use for the error pages.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        base: type[BaseRenderer] = TextRenderer,\n    ):\n        self.cached_handlers: dict[\n            tuple[type[BaseException], Optional[str]], Optional[RouteHandler]\n        ] = {}\n        self.debug = False\n        self.base = base"
    },
    {
      "chunk_id": 965,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def _full_lookup(self, exception, route_name: Optional[str] = None):\n        return self.lookup(exception, route_name)"
    },
    {
      "chunk_id": 966,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def _add(\n        self,\n        key: tuple[type[BaseException], Optional[str]],\n        handler: RouteHandler,\n    ) -> None:\n        if key in self.cached_handlers:\n            exc, name = key\n            if name is None:\n                name = \"__ALL_ROUTES__\"\n\n            message = (\n                f\"Duplicate exception handler definition on: route={name} \"\n                f\"and exception={exc}\"\n            )\n            raise ServerError(message)\n        self.cached_handlers[key] = handler"
    },
    {
      "chunk_id": 967,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def add(self, exception, handler, route_names: Optional[list[str]] = None):\n        \"\"\"Add a new exception handler to an already existing handler object.\n\n        Args:\n            exception (sanic.exceptions.SanicException or Exception): Type\n                of exception that needs to be handled.\n            handler (function): Reference to the function that will\n                handle the exception.\n\n        Returns:\n            None\n\n        \"\"\"  # noqa: E501\n        if route_names:\n            for route in route_names:\n                self._add((exception, route), handler)\n        else:\n            self._add((exception, None), handler)"
    },
    {
      "chunk_id": 968,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def lookup(self, exception, route_name: Optional[str] = None):\n        \"\"\"Lookup the existing instance of `ErrorHandler` and fetch the registered handler for a specific type of exception.\n\n        This method leverages a dict lookup to speedup the retrieval process.\n\n        Args:\n            exception (sanic.exceptions.SanicException or Exception): Type\n                of exception.\n\n        Returns:\n            Registered function if found, ``None`` otherwise.\n\n        \"\"\"  # noqa: E501\n        exception_class = type(exception)\n\n        for name in (route_name, None):\n            exception_key = (exception_class, name)\n            handler = self.cached_handlers.get(exception_key)\n            if handler:\n                return handler\n\n        for name in (route_name, None):\n            for ancestor in type.mro(exception_class):\n                exception_key = (ancestor, name)\n                if exception_key in self.cached_handlers:\n                    handler = self.cached_handlers[exception_key]\n                    self.cached_handlers[(exception_class, route_name)] = (\n                        handler\n                    )\n                    return handler\n\n                if ancestor is BaseException:\n                    break\n        self.cached_handlers[(exception_class, route_name)] = None\n        handler = None\n        return handler"
    },
    {
      "chunk_id": 969,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "_lookup = _full_lookup"
    },
    {
      "chunk_id": 970,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def response(self, request, exception):\n        \"\"\"Fetch and executes an exception handler and returns a response object.\n\n        Args:\n            request (sanic.request.Request): Instance of the request.\n            exception (sanic.exceptions.SanicException or Exception): Exception to handle.\n\n        Returns:\n            Wrap the return value obtained from the `default` function or the registered handler for that type of exception.\n\n        \"\"\"  # noqa: E501\n        route_name = request.name if request else None\n        handler = self._lookup(exception, route_name)\n        response = None\n        try:\n            if handler:\n                response = handler(request, exception)\n            if response is None:\n                response = self.default(request, exception)\n        except Exception:\n            try:\n                url = repr(request.url)\n            except AttributeError:  # no cov\n                url = \"unknown\"\n            response_message = (\n                \"Exception raised in exception handler \" '\"%s\" for uri: %s'\n            )\n            error_logger.exception(response_message, handler.__name__, url)\n\n            if self.debug:\n                return text(response_message % (handler.__name__, url), 500)\n            else:\n                return text(\"An error occurred while handling an error\", 500)\n        return response"
    },
    {
      "chunk_id": 971,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "def default(self, request: Request, exception: Exception) -> HTTPResponse:\n        \"\"\"Provide a default behavior for the objects of ErrorHandler.\n\n        If a developer chooses to extend the ErrorHandler, they can\n        provide a custom implementation for this method to behave in a way\n        they see fit.\n\n        Args:\n            request (sanic.request.Request): Incoming request.\n            exception (sanic.exceptions.SanicException or Exception): Exception object.\n\n        Returns:\n            HTTPResponse: The response object.\n\n        Examples:\n            ```python\n            class CustomErrorHandler(ErrorHandler):\n                def default(self, request: Request, exception: Exception) -> HTTPResponse:\n                    # Custom logic for handling the exception and creating a response\n                    custom_response = my_custom_logic(request, exception)\n                    return custom_response\n\n            app = Sanic(\"MyApp\", error_handler=CustomErrorHandler())\n            ```\n        \"\"\"  # noqa: E501\n        self.log(request, exception)\n        fallback = request.app.config.FALLBACK_ERROR_FORMAT\n        return exception_response(\n            request,\n            exception,\n            debug=self.debug,\n            base=self.base,\n            fallback=fallback,\n        )"
    },
    {
      "chunk_id": 972,
      "source": "__internal__/data_repo/sanic/sanic/handlers/error.py",
      "content": "@staticmethod\n    def log(request: Request, exception: Exception) -> None:\n        \"\"\"Logs information about an incoming request and the associated exception.\n\n        Args:\n            request (Request): The incoming request to be logged.\n            exception (Exception): The exception that occurred during the handling of the request.\n\n        Returns:\n            None\n        \"\"\"  # noqa: E501\n        quiet = getattr(exception, \"quiet\", False)\n        noisy = getattr(request.app.config, \"NOISY_EXCEPTIONS\", False)\n        if quiet is False or noisy is True:\n            try:\n                url = repr(request.url)\n            except AttributeError:  # no cov\n                url = \"unknown\"\n\n            error_logger.exception(\n                \"Exception occurred while handling uri: %s\", url\n            )"
    },
    {
      "chunk_id": 973,
      "source": "__internal__/data_repo/sanic/sanic/handlers/content_range.py",
      "content": "from __future__ import annotations\n\nimport os\n\nfrom typing import TYPE_CHECKING\n\nfrom sanic.exceptions import (\n    HeaderNotFound,\n    InvalidRangeType,\n    RangeNotSatisfiable,\n)\nfrom sanic.models.protocol_types import Range\n\n\nif TYPE_CHECKING:\n    from sanic import Request"
    },
    {
      "chunk_id": 974,
      "source": "__internal__/data_repo/sanic/sanic/handlers/content_range.py",
      "content": "class ContentRangeHandler(Range):\n    \"\"\"Parse and process the incoming request headers to extract the content range information.\n\n    Args:\n        request (Request): The incoming request object.\n        stats (os.stat_result): The stats of the file being served.\n    \"\"\"  # noqa: E501\n\n    __slots__ = (\"start\", \"end\", \"size\", \"total\", \"headers\")\n\n    def __init__(self, request: Request, stats: os.stat_result) -> None:\n        self.total = stats.st_size\n        _range = request.headers.getone(\"range\", None)\n        if _range is None:\n            raise HeaderNotFound(\"Range Header Not Found\")\n        unit, _, value = tuple(map(str.strip, _range.partition(\"=\")))\n        if unit != \"bytes\":\n            raise InvalidRangeType(\n                \"{} is not a valid Range Type\".format(unit), self\n            )\n        start_b, _, end_b = tuple(map(str.strip, value.partition(\"-\")))\n        try:\n            self.start = int(start_b) if start_b else None\n        except ValueError:\n            raise RangeNotSatisfiable(\n                \"'{}' is invalid for Content Range\".format(start_b), self\n            )\n        try:\n            self.end = int(end_b) if end_b else None\n        except ValueError:\n            raise RangeNotSatisfiable(\n                \"'{}' is invalid for Content Range\".format(end_b), self\n            )\n        if self.end is None:\n            if self.start is None:\n                raise RangeNotSatisfiable(\n                    \"Invalid for Content Range parameters\", self\n                )\n            else:\n                # this case represents `Content-Range: bytes 5-`\n                self.end = self.total - 1\n        else:\n            if self.start is None:\n                # this case represents `Content-Range: bytes -5`\n                self.start = self.total - self.end\n                self.end = self.total - 1\n        if self.start > self.end:\n            raise RangeNotSatisfiable(\n                \"Invalid for Content Range parameters\", self\n            )\n        self.size = self.end - self.start + 1\n        self.headers = {\n            \"Content-Range\": \"bytes %s-%s/%s\"\n            % (self.start, self.end, self.total)\n        }"
    },
    {
      "chunk_id": 975,
      "source": "__internal__/data_repo/sanic/sanic/handlers/content_range.py",
      "content": "def __bool__(self):\n        return hasattr(self, \"size\") and self.size > 0"
    },
    {
      "chunk_id": 976,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Iterable, Sequence\nfrom datetime import datetime\nfrom operator import itemgetter\nfrom pathlib import Path\nfrom stat import S_ISDIR\nfrom typing import Optional, Union, cast\n\nfrom sanic.exceptions import NotFound\nfrom sanic.pages.directory_page import DirectoryPage, FileInfo\nfrom sanic.request import Request\nfrom sanic.response import file, html, redirect"
    },
    {
      "chunk_id": 977,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "class DirectoryHandler:\n    \"\"\"Serve files from a directory.\n\n    Args:\n        uri (str): The URI to serve the files at.\n        directory (Path): The directory to serve files from.\n        directory_view (bool): Whether to show a directory listing or not.\n        index (Optional[Union[str, Sequence[str]]]): The index file(s) to\n            serve if the directory is requested. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        uri: str,\n        directory: Path,\n        directory_view: bool = False,\n        index: Optional[Union[str, Sequence[str]]] = None,\n    ) -> None:\n        if isinstance(index, str):\n            index = [index]\n        elif index is None:\n            index = []\n        self.base = uri.strip(\"/\")\n        self.directory = directory\n        self.directory_view = directory_view\n        self.index = tuple(index)"
    },
    {
      "chunk_id": 978,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "async def handle(self, request: Request, path: str):\n        \"\"\"Handle the request.\n\n        Args:\n            request (Request): The incoming request object.\n            path (str): The path to the file to serve.\n\n        Raises:\n            NotFound: If the file is not found.\n            IsADirectoryError: If the path is a directory and directory_view is False.\n\n        Returns:\n            Response: The response object.\n        \"\"\"  # noqa: E501\n        current = path.strip(\"/\")[len(self.base) :].strip(\"/\")  # noqa: E203\n        for file_name in self.index:\n            index_file = self.directory / current / file_name\n            if index_file.is_file():\n                return await file(index_file)\n\n        if self.directory_view:\n            return self._index(\n                self.directory / current, path, request.app.debug\n            )\n\n        if self.index:\n            raise NotFound(\"File not found\")\n\n        raise IsADirectoryError(f\"{self.directory.as_posix()} is a directory\")"
    },
    {
      "chunk_id": 979,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "def _index(self, location: Path, path: str, debug: bool):\n        # Remove empty path elements, append slash\n        if \"//\" in path or not path.endswith(\"/\"):\n            return redirect(\n                \"/\" + \"\".join([f\"{p}/\" for p in path.split(\"/\") if p])\n            )\n\n        # Render file browser\n        page = DirectoryPage(self._iter_files(location), path, debug)\n        return html(page.render())"
    },
    {
      "chunk_id": 980,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "def _prepare_file(self, path: Path) -> dict[str, Union[int, str]]:\n        stat = path.stat()\n        modified = (\n            datetime.fromtimestamp(stat.st_mtime)\n            .isoformat()[:19]\n            .replace(\"T\", \" \")\n        )\n        is_dir = S_ISDIR(stat.st_mode)\n        icon = \"\ud83d\udcc1\" if is_dir else \"\ud83d\udcc4\"\n        file_name = path.name\n        if is_dir:\n            file_name += \"/\"\n        return {\n            \"priority\": is_dir * -1,\n            \"file_name\": file_name,\n            \"icon\": icon,\n            \"file_access\": modified,\n            \"file_size\": stat.st_size,\n        }"
    },
    {
      "chunk_id": 981,
      "source": "__internal__/data_repo/sanic/sanic/handlers/directory.py",
      "content": "def _iter_files(self, location: Path) -> Iterable[FileInfo]:\n        prepared = [self._prepare_file(f) for f in location.iterdir()]\n        for item in sorted(prepared, key=itemgetter(\"priority\", \"file_name\")):\n            del item[\"priority\"]\n            yield cast(FileInfo, item)"
    },
    {
      "chunk_id": 982,
      "source": "__internal__/data_repo/sanic/sanic/server/__init__.py",
      "content": "from sanic.models.server_types import ConnInfo, Signal\nfrom sanic.server.async_server import AsyncioServer\nfrom sanic.server.loop import try_use_uvloop\nfrom sanic.server.protocols.http_protocol import HttpProtocol\nfrom sanic.server.runners import serve"
    },
    {
      "chunk_id": 983,
      "source": "__internal__/data_repo/sanic/sanic/server/__init__.py",
      "content": "__all__ = (\n    \"AsyncioServer\",\n    \"ConnInfo\",\n    \"HttpProtocol\",\n    \"Signal\",\n    \"serve\",\n    \"try_use_uvloop\",\n)"
    },
    {
      "chunk_id": 984,
      "source": "__internal__/data_repo/sanic/sanic/server/events.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Iterable\nfrom inspect import isawaitable\nfrom typing import TYPE_CHECKING, Any, Callable, Optional"
    },
    {
      "chunk_id": 985,
      "source": "__internal__/data_repo/sanic/sanic/server/events.py",
      "content": "def trigger_events(\n    events: Optional[Iterable[Callable[..., Any]]],\n    loop,\n    app: Optional[Sanic] = None,\n    **kwargs,\n):\n    \"\"\"Trigger event callbacks (functions or async)\n\n    Args:\n        events (Optional[Iterable[Callable[..., Any]]]): [description]\n        loop ([type]): [description]\n        app (Optional[Sanic], optional): [description]. Defaults to None.\n    \"\"\"\n    if events:\n        for event in events:\n            try:\n                result = event(**kwargs) if not app else event(app, **kwargs)\n            except TypeError:\n                result = (\n                    event(loop, **kwargs)\n                    if not app\n                    else event(app, loop, **kwargs)\n                )\n            if isawaitable(result):\n                loop.run_until_complete(result)"
    },
    {
      "chunk_id": 986,
      "source": "__internal__/data_repo/sanic/sanic/server/goodbye.py",
      "content": "import random\nimport sys"
    },
    {
      "chunk_id": 987,
      "source": "__internal__/data_repo/sanic/sanic/server/goodbye.py",
      "content": "ascii_phrases = {\n    'Farewell', 'Bye', 'See you later', 'Take care', 'So long', 'Adieu', 'Cheerio',\n    'Goodbye', 'Adios', 'Au revoir', 'Arrivederci', 'Sayonara', 'Auf Wiedersehen',\n    'Do svidaniya', 'Annyeong', 'Tot ziens', 'Ha det', 'Selamat tinggal',\n    'Hasta luego', 'Nos vemos', 'Salut', 'Ciao', 'A presto',\n    'Dag', 'Tot later', 'Vi ses', 'Sampai jumpa',\n}\n\nnon_ascii_phrases = {\n    'Tsch\u00fcss', 'Z\u00e0i ji\u00e0n', 'B\u0101i b\u0101i', 'M\u00edngti\u0101n ji\u00e0n', 'Adeus', 'Tchau', 'At\u00e9 logo',\n    'Hejd\u00e5', '\u00c0 bient\u00f4t', 'Bis sp\u00e4ter', 'Adj\u00f8',\n    '\u3058\u3083\u306d', '\u307e\u305f\u306d', '\uc548\ub155\ud788 \uacc4\uc138\uc694', '\uc798 \uac00', '\u05e9\u05dc\u05d5\u05dd',\n    '\u05dc\u05d4\u05ea\u05e8\u05d0\u05d5\u05ea', '\u0645\u0639 \u0627\u0644\u0633\u0644\u0627\u0645\u0629', '\u0625\u0644\u0649 \u0627\u0644\u0644\u0642\u0627\u0621', '\u0648\u062f\u0627\u0639\u0627\u064b', '\u0905\u0932\u0935\u093f\u0926\u093e',\n    '\u092b\u093f\u0930 \u092e\u093f\u0932\u0947\u0902\u0917\u0947',\n}\n\nall_phrases = ascii_phrases | non_ascii_phrases"
    },
    {
      "chunk_id": 988,
      "source": "__internal__/data_repo/sanic/sanic/server/goodbye.py",
      "content": "def get_goodbye() -> str:  # pragma: no cover\n    is_utf8 = sys.stdout.encoding.lower() == \"utf-8\"\n    phrases = all_phrases if is_utf8 else ascii_phrases\n    return random.choice(list(phrases))  # nosec: B311"
    },
    {
      "chunk_id": 989,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "from __future__ import annotations\n\nfrom ssl import SSLContext\nfrom typing import TYPE_CHECKING, Optional, Union\n\nfrom sanic.config import Config\nfrom sanic.exceptions import ServerError\nfrom sanic.http.constants import HTTP\nfrom sanic.http.tls import get_ssl_context\n\n\nif TYPE_CHECKING:\n    from sanic.app import Sanic\n\nimport asyncio\nimport os\nimport socket\n\nfrom functools import partial\nfrom signal import SIG_IGN, SIGINT, SIGTERM\nfrom signal import signal as signal_func\n\nfrom sanic.application.ext import setup_ext\nfrom sanic.compat import OS_IS_WINDOWS, ctrlc_workaround_for_windows\nfrom sanic.http.http3 import SessionTicketStore, get_config\nfrom sanic.log import error_logger, server_logger\nfrom sanic.logging.setup import setup_logging\nfrom sanic.models.server_types import Signal\nfrom sanic.server.async_server import AsyncioServer\nfrom sanic.server.protocols.http_protocol import Http3Protocol, HttpProtocol\nfrom sanic.server.socket import bind_unix_socket, remove_unix_socket\n\n\ntry:\n    from aioquic.asyncio import serve as quic_serve\n\n    HTTP3_AVAILABLE = True\nexcept ModuleNotFoundError:  # no cov\n    HTTP3_AVAILABLE = False"
    },
    {
      "chunk_id": 990,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def serve(\n    host,\n    port,\n    app: Sanic,\n    ssl: Optional[SSLContext] = None,\n    sock: Optional[socket.socket] = None,\n    unix: Optional[str] = None,\n    reuse_port: bool = False,\n    loop=None,\n    protocol: type[asyncio.Protocol] = HttpProtocol,\n    backlog: int = 100,\n    register_sys_signals: bool = True,\n    run_multiple: bool = False,\n    run_async: bool = False,\n    connections=None,\n    signal=Signal(),\n    state=None,\n    asyncio_server_kwargs=None,\n    version=HTTP.VERSION_1,\n):\n    \"\"\"Start asynchronous HTTP Server on an individual process.\n\n    :param host: Address to host on\n    :param port: Port to host on\n    :param before_start: function to be executed before the server starts\n                         listening. Takes arguments `app` instance and `loop`\n    :param after_start: function to be executed after the server starts\n                        listening. Takes  arguments `app` instance and `loop`\n    :param before_stop: function to be executed when a stop signal is\n                        received before it is respected. Takes arguments\n                        `app` instance and `loop`\n    :param after_stop: function to be executed when a stop signal is\n                       received after it is respected. Takes arguments\n                       `app` instance and `loop`\n    :param ssl: SSLContext\n    :param sock: Socket for the server to accept connections from\n    :param unix: Unix socket to listen on instead of TCP port\n    :param reuse_port: `True` for multiple workers\n    :param loop: asyncio compatible event loop\n    :param run_async: bool: Do not create a new event loop for the server,\n                      and return an AsyncServer object rather than running it\n    :param asyncio_server_kwargs: key-value args for asyncio/uvloop\n                                  create_server method\n    :return: Nothing\n\n    Args:\n        host (str): Address to host on\n        port (int): Port to host on\n        app (Sanic): Sanic app instance\n        ssl (Optional[SSLContext], optional): SSLContext. Defaults to `None`.\n        sock (Optional[socket.socket], optional): Socket for the server to\n            accept connections from. Defaults to `None`.\n        unix (Optional[str], optional): Unix socket to listen on instead of\n            TCP port. Defaults to `None`.\n        reuse_port (bool, optional): `True` for multiple workers. Defaults\n            to `False`.\n        loop: asyncio compatible event loop. Defaults\n            to `None`.\n        protocol (Type[asyncio.Protocol], optional): Protocol to use. Defaults\n            to `HttpProtocol`.\n        backlog (int, optional): The maximum number of queued connections\n            passed to socket.listen(). Defaults to `100`.\n        register_sys_signals (bool, optional): Register SIGINT and SIGTERM.\n            Defaults to `True`.\n        run_multiple (bool, optional): Run multiple workers. Defaults\n            to `False`.\n        run_async (bool, optional): Return an AsyncServer object.\n            Defaults to `False`.\n        connections: Connections. Defaults to `None`.\n        signal (Signal, optional): Signal. Defaults to `Signal()`.\n        state: State. Defaults to `None`.\n        asyncio_server_kwargs (Optional[Dict[str, Union[int, float]]], optional):\n            key-value args for asyncio/uvloop create_server method. Defaults\n            to `None`.\n        version (str, optional): HTTP version. Defaults to `HTTP.VERSION_1`.\n\n    Raises:\n        ServerError: Cannot run HTTP/3 server without aioquic installed.\n\n    Returns:\n        AsyncioServer: AsyncioServer object if `run_async` is `True`.\n    \"\"\"  # noqa: E501\n    if not run_async and not loop:\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n    setup_logging(app.debug, app.config.NO_COLOR)\n\n    if app.debug:\n        loop.set_debug(app.debug)\n\n    app.asgi = False\n\n    if version is HTTP.VERSION_3:\n        return _serve_http_3(host, port, app, loop, ssl)\n    return _serve_http_1(\n        host,\n        port,\n        app,\n        ssl,\n        sock,\n        unix,\n        reuse_port,\n        loop,\n        protocol,\n        backlog,\n        register_sys_signals,\n        run_multiple,\n        run_async,\n        connections,\n        signal,\n        state,\n        asyncio_server_kwargs,\n    )"
    },
    {
      "chunk_id": 991,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def _setup_system_signals(\n    app: Sanic,\n    run_multiple: bool,\n    register_sys_signals: bool,\n    loop: asyncio.AbstractEventLoop,\n) -> None:  # no cov\n    signal_func(SIGINT, SIG_IGN)\n    signal_func(SIGTERM, SIG_IGN)\n    os.environ[\"SANIC_WORKER_PROCESS\"] = \"true\"\n    # Register signals for graceful termination\n    if register_sys_signals:\n        if OS_IS_WINDOWS:\n            ctrlc_workaround_for_windows(app)\n        else:\n            for _signal in [SIGINT, SIGTERM]:\n                loop.add_signal_handler(\n                    _signal, partial(app.stop, terminate=False)\n                )"
    },
    {
      "chunk_id": 992,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def _run_server_forever(loop, before_stop, after_stop, cleanup, unix):\n    pid = os.getpid()\n    try:\n        server_logger.info(\"Starting worker [%s]\", pid)\n        loop.run_forever()\n    finally:\n        server_logger.info(\"Stopping worker [%s]\", pid)\n\n        loop.run_until_complete(before_stop())\n\n        if cleanup:\n            cleanup()\n\n        loop.run_until_complete(after_stop())\n        remove_unix_socket(unix)\n        loop.close()\n        server_logger.info(\"Worker complete [%s]\", pid)"
    },
    {
      "chunk_id": 993,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def _serve_http_1(\n    host,\n    port,\n    app,\n    ssl,\n    sock,\n    unix,\n    reuse_port,\n    loop,\n    protocol,\n    backlog,\n    register_sys_signals,\n    run_multiple,\n    run_async,\n    connections,\n    signal,\n    state,\n    asyncio_server_kwargs,\n):\n    connections = connections if connections is not None else set()\n    protocol_kwargs = _build_protocol_kwargs(protocol, app.config)\n    server = partial(\n        protocol,\n        loop=loop,\n        connections=connections,\n        signal=signal,\n        app=app,\n        state=state,\n        unix=unix,\n        **protocol_kwargs,\n    )\n    asyncio_server_kwargs = (\n        asyncio_server_kwargs if asyncio_server_kwargs else {}\n    )\n    if OS_IS_WINDOWS and sock:\n        pid = os.getpid()\n        sock = sock.share(pid)\n        sock = socket.fromshare(sock)\n    # UNIX sockets are always bound by us (to preserve semantics between modes)\n    elif unix:\n        sock = bind_unix_socket(unix, backlog=backlog)\n    server_coroutine = loop.create_server(\n        server,\n        None if sock else host,\n        None if sock else port,\n        ssl=ssl,\n        reuse_port=reuse_port,\n        sock=sock,\n        backlog=backlog,\n        **asyncio_server_kwargs,\n    )\n\n    setup_ext(app)\n    if run_async:\n        return AsyncioServer(\n            app=app,\n            loop=loop,\n            serve_coro=server_coroutine,\n            connections=connections,\n        )\n\n    loop.run_until_complete(app._startup())\n    loop.run_until_complete(app._server_event(\"init\", \"before\"))\n    app.ack()\n\n    try:\n        http_server = loop.run_until_complete(server_coroutine)\n    except BaseException:\n        error_logger.exception(\"Unable to start server\", exc_info=True)\n        return\n\n    def _cleanup():\n        # Wait for event loop to finish and all connections to drain\n        http_server.close()\n        loop.run_until_complete(http_server.wait_closed())\n\n        # Complete all tasks on the loop\n        signal.stopped = True\n        for connection in connections:\n            connection.close_if_idle()\n\n        # Gracefully shutdown timeout.\n        # We should provide graceful_shutdown_timeout,\n        # instead of letting connection hangs forever.\n        # Let's roughly calcucate time.\n        graceful = app.config.GRACEFUL_SHUTDOWN_TIMEOUT\n        start_shutdown: float = 0\n        while connections and (start_shutdown < graceful):\n            loop.run_until_complete(asyncio.sleep(0.1))\n            start_shutdown = start_shutdown + 0.1\n\n        app.shutdown_tasks(graceful - start_shutdown)\n\n        # Force close non-idle connection after waiting for\n        # graceful_shutdown_timeout\n        for conn in connections:\n            if hasattr(conn, \"websocket\") and conn.websocket:\n                conn.websocket.fail_connection(code=1001)\n            else:\n                conn.abort()\n\n        app.set_serving(False)\n\n    _setup_system_signals(app, run_multiple, register_sys_signals, loop)\n    loop.run_until_complete(app._server_event(\"init\", \"after\"))\n    app.set_serving(True)\n    _run_server_forever(\n        loop,\n        partial(app._server_event, \"shutdown\", \"before\"),\n        partial(app._server_event, \"shutdown\", \"after\"),\n        _cleanup,\n        unix,\n    )"
    },
    {
      "chunk_id": 994,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def _serve_http_3(\n    host,\n    port,\n    app,\n    loop,\n    ssl,\n    register_sys_signals: bool = True,\n    run_multiple: bool = False,\n):\n    if not HTTP3_AVAILABLE:\n        raise ServerError(\n            \"Cannot run HTTP/3 server without aioquic installed. \"\n        )\n    protocol = partial(Http3Protocol, app=app)\n    ticket_store = SessionTicketStore()\n    ssl_context = get_ssl_context(app, ssl)\n    config = get_config(app, ssl_context)\n    coro = quic_serve(\n        host,\n        port,\n        configuration=config,\n        create_protocol=protocol,\n        session_ticket_fetcher=ticket_store.pop,\n        session_ticket_handler=ticket_store.add,\n    )\n    server = AsyncioServer(app, loop, coro, [])\n    loop.run_until_complete(server.startup())\n    loop.run_until_complete(server.before_start())\n    app.ack()\n    loop.run_until_complete(server)\n    _setup_system_signals(app, run_multiple, register_sys_signals, loop)\n    loop.run_until_complete(server.after_start())\n\n    # TODO: Create connection cleanup and graceful shutdown\n    cleanup = None\n    _run_server_forever(\n        loop, server.before_stop, server.after_stop, cleanup, None\n    )"
    },
    {
      "chunk_id": 995,
      "source": "__internal__/data_repo/sanic/sanic/server/runners.py",
      "content": "def _build_protocol_kwargs(\n    protocol: type[asyncio.Protocol], config: Config\n) -> dict[str, Union[int, float]]:\n    if hasattr(protocol, \"websocket_handshake\"):\n        return {\n            \"websocket_max_size\": config.WEBSOCKET_MAX_SIZE,\n            \"websocket_ping_timeout\": config.WEBSOCKET_PING_TIMEOUT,\n            \"websocket_ping_interval\": config.WEBSOCKET_PING_INTERVAL,\n        }\n    return {}"
    },
    {
      "chunk_id": 996,
      "source": "__internal__/data_repo/sanic/sanic/server/socket.py",
      "content": "from __future__ import annotations\n\nimport secrets\nimport socket\nimport stat\n\nfrom ipaddress import ip_address\nfrom pathlib import Path\nfrom typing import Any, Optional, Union\n\nfrom sanic.exceptions import ServerError\nfrom sanic.http.constants import HTTP"
    },
    {
      "chunk_id": 997,
      "source": "__internal__/data_repo/sanic/sanic/server/socket.py",
      "content": "def bind_socket(host: str, port: int, *, backlog=100) -> socket.socket:\n    \"\"\"Create TCP server socket.\n    :param host: IPv4, IPv6 or hostname may be specified\n    :param port: TCP port number\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n    location = (host, port)\n    # socket.share, socket.fromshare\n    try:  # IP address: family must be specified for IPv6 at least\n        ip = ip_address(host)\n        host = str(ip)\n        sock = socket.socket(\n            socket.AF_INET6 if ip.version == 6 else socket.AF_INET\n        )\n    except ValueError:  # Hostname, may become AF_INET or AF_INET6\n        sock = socket.socket()\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind(location)\n    sock.listen(backlog)\n    sock.set_inheritable(True)\n    return sock"
    },
    {
      "chunk_id": 998,
      "source": "__internal__/data_repo/sanic/sanic/server/socket.py",
      "content": "def bind_unix_socket(\n    path: Union[Path, str], *, mode=0o666, backlog=100\n) -> socket.socket:\n    \"\"\"Create unix socket.\n    :param path: filesystem path\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n\n    # Sanitise and pre-verify socket path\n    path = Path(path)\n    folder = path.parent\n    if not folder.is_dir():\n        raise FileNotFoundError(f\"Socket folder does not exist: {folder}\")\n    try:\n        if not stat.S_ISSOCK(path.lstat().st_mode):\n            raise FileExistsError(f\"Existing file is not a socket: {path}\")\n    except FileNotFoundError:\n        pass\n    # Create new socket with a random temporary name\n    tmp_path = path.with_name(f\"{path.name}.{secrets.token_urlsafe()}\")\n    sock = socket.socket(socket.AF_UNIX)\n    try:\n        # Critical section begins (filename races)\n        sock.bind(tmp_path.as_posix())\n        try:\n            tmp_path.chmod(mode)\n            # Start listening before rename to avoid connection failures\n            sock.listen(backlog)\n            tmp_path.rename(path)\n        except:  # noqa: E722\n            try:\n                tmp_path.unlink()\n            finally:\n                raise\n    except:  # noqa: E722\n        try:\n            sock.close()\n        finally:\n            raise\n    return sock"
    },
    {
      "chunk_id": 999,
      "source": "__internal__/data_repo/sanic/sanic/server/socket.py",
      "content": "def remove_unix_socket(path: Optional[Union[Path, str]]) -> None:\n    \"\"\"Remove dead unix socket during server exit.\"\"\"\n    if not path:\n        return\n    try:\n        path = Path(path)\n        if stat.S_ISSOCK(path.lstat().st_mode):\n            # Is it actually dead (doesn't belong to a new server instance)?\n            with socket.socket(socket.AF_UNIX) as testsock:\n                try:\n                    testsock.connect(path.as_posix())\n                except ConnectionRefusedError:\n                    path.unlink()\n    except FileNotFoundError:\n        pass"
    },
    {
      "chunk_id": 1000,
      "source": "__internal__/data_repo/sanic/sanic/server/socket.py",
      "content": "def configure_socket(\n    server_settings: dict[str, Any],\n) -> Optional[socket.SocketType]:\n    # Create a listening socket or use the one in settings\n    if server_settings.get(\"version\") is HTTP.VERSION_3:\n        return None\n    sock = server_settings.get(\"sock\")\n    unix = server_settings[\"unix\"]\n    backlog = server_settings[\"backlog\"]\n    if unix:\n        unix = Path(unix).absolute()\n        sock = bind_unix_socket(unix, backlog=backlog)\n        server_settings[\"unix\"] = unix\n    if sock is None:\n        try:\n            sock = bind_socket(\n                server_settings[\"host\"],\n                server_settings[\"port\"],\n                backlog=backlog,\n            )\n        except OSError as e:  # no cov\n            error = ServerError(\n                f\"Sanic server could not start: {e}.\\n\\n\"\n                \"This may have happened if you are running Sanic in the \"\n                \"global scope and not inside of a \"\n                '`if __name__ == \"__main__\"` block.\\n\\nSee more information: '\n                \"https://sanic.dev/en/guide/deployment/manager.html#\"\n                \"how-sanic-server-starts-processes\\n\"\n            )\n            error.quiet = True\n            raise error\n        sock.set_inheritable(True)\n        server_settings[\"sock\"] = sock\n        server_settings[\"host\"] = None\n        server_settings[\"port\"] = None\n    return sock"
    },
    {
      "chunk_id": 1001,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "from __future__ import annotations\n\nimport asyncio\n\nfrom typing import TYPE_CHECKING\n\nfrom sanic.exceptions import SanicException\n\n\nif TYPE_CHECKING:\n    from sanic import Sanic"
    },
    {
      "chunk_id": 1002,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "class AsyncioServer:\n    \"\"\"Wraps an asyncio server with functionality that might be useful to a user who needs to manage the server lifecycle manually.\"\"\"  # noqa: E501\n\n    __slots__ = (\"app\", \"connections\", \"loop\", \"serve_coro\", \"server\")\n\n    def __init__(\n        self,\n        app: Sanic,\n        loop,\n        serve_coro,\n        connections,\n    ):\n        # Note, Sanic already called \"before_server_start\" events\n        # before this helper was even created. So we don't need it here.\n        self.app = app\n        self.connections = connections\n        self.loop = loop\n        self.serve_coro = serve_coro\n        self.server = None"
    },
    {
      "chunk_id": 1003,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def startup(self):\n        \"\"\"Trigger \"startup\" operations on the app\"\"\"\n        return self.app._startup()"
    },
    {
      "chunk_id": 1004,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def before_start(self):\n        \"\"\"Trigger \"before_server_start\" events\"\"\"\n        return self._server_event(\"init\", \"before\")"
    },
    {
      "chunk_id": 1005,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def after_start(self):\n        \"\"\"Trigger \"after_server_start\" events\"\"\"\n        return self._server_event(\"init\", \"after\")"
    },
    {
      "chunk_id": 1006,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def before_stop(self):\n        \"\"\"Trigger \"before_server_stop\" events\"\"\"\n        return self._server_event(\"shutdown\", \"before\")"
    },
    {
      "chunk_id": 1007,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def after_stop(self):\n        \"\"\"Trigger \"after_server_stop\" events\"\"\"\n        return self._server_event(\"shutdown\", \"after\")"
    },
    {
      "chunk_id": 1008,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def is_serving(self) -> bool:\n        \"\"\"Returns True if the server is running, False otherwise\"\"\"\n        if self.server:\n            return self.server.is_serving()\n        return False"
    },
    {
      "chunk_id": 1009,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def wait_closed(self):\n        \"\"\"Wait until the server is closed\"\"\"\n        if self.server:\n            return self.server.wait_closed()"
    },
    {
      "chunk_id": 1010,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def close(self):\n        \"\"\"Close the server\"\"\"\n        if self.server:\n            self.server.close()\n            coro = self.wait_closed()\n            task = asyncio.ensure_future(coro, loop=self.loop)\n            return task"
    },
    {
      "chunk_id": 1011,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def start_serving(self):\n        \"\"\"Start serving requests\"\"\"\n        return self._serve(self.server.start_serving)"
    },
    {
      "chunk_id": 1012,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def serve_forever(self):\n        \"\"\"Serve requests until the server is stopped\"\"\"\n        return self._serve(self.server.serve_forever)"
    },
    {
      "chunk_id": 1013,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def _serve(self, serve_func):\n        if self.server:\n            if not self.app.state.is_started:\n                raise SanicException(\n                    \"Cannot run Sanic server without first running \"\n                    \"await server.startup()\"\n                )\n\n            try:\n                return serve_func()\n            except AttributeError:\n                name = serve_func.__name__\n                raise NotImplementedError(\n                    f\"server.{name} not available in this version \"\n                    \"of asyncio or uvloop.\"\n                )"
    },
    {
      "chunk_id": 1014,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def _server_event(self, concern: str, action: str):\n        if not self.app.state.is_started:\n            raise SanicException(\n                \"Cannot dispatch server event without \"\n                \"first running await server.startup()\"\n            )\n        return self.app._server_event(concern, action, loop=self.loop)"
    },
    {
      "chunk_id": 1015,
      "source": "__internal__/data_repo/sanic/sanic/server/async_server.py",
      "content": "def __await__(self):\n        \"\"\"\n        Starts the asyncio server, returns AsyncServerCoro\n        \"\"\"\n        task = asyncio.ensure_future(self.serve_coro)\n        while not task.done():\n            yield\n        self.server = task.result()\n        return self"
    },
    {
      "chunk_id": 1016,
      "source": "__internal__/data_repo/sanic/sanic/server/loop.py",
      "content": "import asyncio\n\nfrom os import getenv\n\nfrom sanic.compat import OS_IS_WINDOWS\nfrom sanic.log import error_logger\nfrom sanic.utils import str_to_bool"
    },
    {
      "chunk_id": 1017,
      "source": "__internal__/data_repo/sanic/sanic/server/loop.py",
      "content": "def try_use_uvloop() -> None:\n    \"\"\"Use uvloop instead of the default asyncio loop.\"\"\"\n    if OS_IS_WINDOWS:\n        error_logger.warning(\n            \"You are trying to use uvloop, but uvloop is not compatible \"\n            \"with your system. You can disable uvloop completely by setting \"\n            \"the 'USE_UVLOOP' configuration value to false, or simply not \"\n            \"defining it and letting Sanic handle it for you. Sanic will now \"\n            \"continue to run using the default event loop.\"\n        )\n        return\n\n    try:\n        import uvloop  # type: ignore\n    except ImportError:\n        error_logger.warning(\n            \"You are trying to use uvloop, but uvloop is not \"\n            \"installed in your system. In order to use uvloop \"\n            \"you must first install it. Otherwise, you can disable \"\n            \"uvloop completely by setting the 'USE_UVLOOP' \"\n            \"configuration value to false. Sanic will now continue \"\n            \"to run with the default event loop.\"\n        )\n        return\n\n    uvloop_install_removed = str_to_bool(getenv(\"SANIC_NO_UVLOOP\", \"no\"))\n    if uvloop_install_removed:\n        error_logger.info(\n            \"You are requesting to run Sanic using uvloop, but the \"\n            \"install-time 'SANIC_NO_UVLOOP' environment variable (used to \"\n            \"opt-out of installing uvloop with Sanic) is set to true. If \"\n            \"you want to prevent Sanic from overriding the event loop policy \"\n            \"during runtime, set the 'USE_UVLOOP' configuration value to \"\n            \"false.\"\n        )\n\n    if not isinstance(asyncio.get_event_loop_policy(), uvloop.EventLoopPolicy):\n        asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())"
    },
    {
      "chunk_id": 1018,
      "source": "__internal__/data_repo/sanic/sanic/server/loop.py",
      "content": "def try_windows_loop():\n    \"\"\"Try to use the WindowsSelectorEventLoopPolicy instead of the default\"\"\"\n    if not OS_IS_WINDOWS:\n        error_logger.warning(\n            \"You are trying to use an event loop policy that is not \"\n            \"compatible with your system. You can simply let Sanic handle \"\n            \"selecting the best loop for you. Sanic will now continue to run \"\n            \"using the default event loop.\"\n        )\n        return\n\n    if not isinstance(\n        asyncio.get_event_loop_policy(), asyncio.WindowsSelectorEventLoopPolicy\n    ):\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())"
    },
    {
      "chunk_id": 1019,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1020,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "from collections.abc import Awaitable, MutableMapping\nfrom typing import (\n    Any,\n    Callable,\n    Optional,\n    Union,\n)\n\nfrom sanic.exceptions import InvalidUsage\n\n\nASGIMessage = MutableMapping[str, Any]"
    },
    {
      "chunk_id": 1021,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "class WebSocketConnection:\n    \"\"\"\n    This is for ASGI Connections.\n    It provides an interface similar to WebsocketProtocol, but\n    sends/receives over an ASGI connection.\n    \"\"\"\n\n    # TODO\n    # - Implement ping/pong\n\n    def __init__(\n        self,\n        send: Callable[[ASGIMessage], Awaitable[None]],\n        receive: Callable[[], Awaitable[ASGIMessage]],\n        subprotocols: Optional[list[str]] = None,\n    ) -> None:\n        self._send = send\n        self._receive = receive\n        self._subprotocols = subprotocols or []"
    },
    {
      "chunk_id": 1022,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "async def send(self, data: Union[str, bytes], *args, **kwargs) -> None:\n        message: dict[str, Union[str, bytes]] = {\"type\": \"websocket.send\"}\n\n        if isinstance(data, bytes):\n            message.update({\"bytes\": data})\n        else:\n            message.update({\"text\": str(data)})\n\n        await self._send(message)"
    },
    {
      "chunk_id": 1023,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "async def recv(self, *args, **kwargs) -> Optional[Union[str, bytes]]:\n        message = await self._receive()\n\n        if message[\"type\"] == \"websocket.receive\":\n            try:\n                return message[\"text\"]\n            except KeyError:\n                try:\n                    return message[\"bytes\"]\n                except KeyError:\n                    raise InvalidUsage(\"Bad ASGI message received\")\n        elif message[\"type\"] == \"websocket.disconnect\":\n            pass\n\n        return None"
    },
    {
      "chunk_id": 1024,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "receive = recv"
    },
    {
      "chunk_id": 1025,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "async def accept(self, subprotocols: Optional[list[str]] = None) -> None:\n        subprotocol = None\n        if subprotocols:\n            for subp in subprotocols:\n                if subp in self.subprotocols:\n                    subprotocol = subp\n                    break\n\n        await self._send(\n            {\n                \"type\": \"websocket.accept\",\n                \"subprotocol\": subprotocol,\n            }\n        )"
    },
    {
      "chunk_id": 1026,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "async def close(self, code: int = 1000, reason: str = \"\") -> None:\n        pass"
    },
    {
      "chunk_id": 1027,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "@property\n    def subprotocols(self):\n        return self._subprotocols"
    },
    {
      "chunk_id": 1028,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/connection.py",
      "content": "@subprotocols.setter\n    def subprotocols(self, subprotocols: Optional[list[str]] = None):\n        self._subprotocols = subprotocols or []"
    },
    {
      "chunk_id": 1029,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/frame.py",
      "content": "import asyncio\nimport codecs\n\nfrom collections.abc import AsyncIterator\nfrom typing import TYPE_CHECKING, Optional\n\nfrom websockets.frames import Frame, Opcode\nfrom websockets.typing import Data\n\nfrom sanic.exceptions import ServerError"
    },
    {
      "chunk_id": 1030,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/frame.py",
      "content": "class WebsocketFrameAssembler:\n    \"\"\"\n    Assemble a message from frames.\n    Code borrowed from aaugustin/websockets project:\n    https://github.com/aaugustin/websockets/blob/6eb98dd8fa5b2c896b9f6be7e8d117708da82a39/src/websockets/sync/messages.py\n    \"\"\"\n\n    __slots__ = (\n        \"protocol\",\n        \"read_mutex\",\n        \"write_mutex\",\n        \"message_complete\",\n        \"message_fetched\",\n        \"get_in_progress\",\n        \"decoder\",\n        \"completed_queue\",\n        \"chunks\",\n        \"chunks_queue\",\n        \"paused\",\n        \"get_id\",\n        \"put_id\",\n    )\n    if TYPE_CHECKING:\n        protocol: \"WebsocketImplProtocol\"\n        read_mutex: asyncio.Lock\n        write_mutex: asyncio.Lock\n        message_complete: asyncio.Event\n        message_fetched: asyncio.Event\n        completed_queue: asyncio.Queue\n        get_in_progress: bool\n        decoder: Optional[codecs.IncrementalDecoder]\n        # For streaming chunks rather than messages:\n        chunks: list[Data]\n        chunks_queue: Optional[asyncio.Queue[Optional[Data]]]\n        paused: bool\n\n    def __init__(self, protocol) -> None:\n        self.protocol = protocol\n\n        self.read_mutex = asyncio.Lock()\n        self.write_mutex = asyncio.Lock()\n\n        self.completed_queue = asyncio.Queue(maxsize=1)  # type: asyncio.Queue[Data]\n\n        # put() sets this event to tell get() that a message can be fetched.\n        self.message_complete = asyncio.Event()\n        # get() sets this event to let put()\n        self.message_fetched = asyncio.Event()\n\n        # This flag prevents concurrent calls to get() by user code.\n        self.get_in_progress = False\n\n        # Decoder for text frames, None for binary frames.\n        self.decoder = None\n\n        # Buffer data from frames belonging to the same message.\n        self.chunks = []\n\n        # When switching from \"buffering\" to \"streaming\", we use a thread-safe\n        # queue for transferring frames from the writing thread (library code)\n        # to the reading thread (user code). We're buffering when chunks_queue\n        # is None and streaming when it's a Queue. None is a sentinel\n        # value marking the end of the stream, superseding message_complete.\n\n        # Stream data from frames belonging to the same message.\n        self.chunks_queue = None\n\n        # Flag to indicate we've paused the protocol\n        self.paused = False"
    },
    {
      "chunk_id": 1031,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/frame.py",
      "content": "async def get(self, timeout: Optional[float] = None) -> Optional[Data]:\n        \"\"\"\n        Read the next message.\n        :meth:`get` returns a single :class:`str` or :class:`bytes`.\n        If the :message was fragmented, :meth:`get` waits until the last frame\n        is received, then it reassembles the message.\n        If ``timeout`` is set and elapses before a complete message is\n        received, :meth:`get` returns ``None``.\n        \"\"\"\n        completed: bool\n        async with self.read_mutex:\n            if timeout is not None and timeout <= 0:\n                if not self.message_complete.is_set():\n                    return None\n            if self.get_in_progress:\n                # This should be guarded against with the read_mutex,\n                # exception is only here as a failsafe\n                raise ServerError(\n                    \"Called get() on Websocket frame assembler \"\n                    \"while asynchronous get is already in progress.\"\n                )\n            self.get_in_progress = True\n\n            # If the message_complete event isn't set yet, release the lock to\n            # allow put() to run and eventually set it.\n            # Locking with get_in_progress ensures only one task can get here.\n            if timeout is None:\n                completed = await self.message_complete.wait()\n            elif timeout <= 0:\n                completed = self.message_complete.is_set()\n            else:\n                try:\n                    await asyncio.wait_for(\n                        self.message_complete.wait(), timeout=timeout\n                    )\n                except asyncio.TimeoutError:\n                    ...\n                finally:\n                    completed = self.message_complete.is_set()\n\n            # Unpause the transport, if its paused\n            if self.paused:\n                self.protocol.resume_frames()\n                self.paused = False\n            if not self.get_in_progress:  # no cov\n                # This should be guarded against with the read_mutex,\n                # exception is here as a failsafe\n                raise ServerError(\n                    \"State of Websocket frame assembler was modified while an \"\n                    \"asynchronous get was in progress.\"\n                )\n            self.get_in_progress = False\n\n            # Waiting for a complete message timed out.\n            if not completed:\n                return None\n            if not self.message_complete.is_set():\n                return None\n\n            self.message_complete.clear()\n\n            joiner: Data = b\"\" if self.decoder is None else \"\"\n            # mypy cannot figure out that chunks have the proper type.\n            message: Data = joiner.join(self.chunks)  # type: ignore\n            if self.message_fetched.is_set():\n                # This should be guarded against with the read_mutex,\n                # and get_in_progress check, this exception is here\n                # as a failsafe\n                raise ServerError(\n                    \"Websocket get() found a message when \"\n                    \"state was already fetched.\"\n                )\n            self.message_fetched.set()\n            self.chunks = []\n            # this should already be None, but set it here for safety\n            self.chunks_queue = None\n            return message"
    },
    {
      "chunk_id": 1032,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/frame.py",
      "content": "async def get_iter(self) -> AsyncIterator[Data]:\n        \"\"\"\n        Stream the next message.\n        Iterating the return value of :meth:`get_iter` yields a :class:`str`\n        or :class:`bytes` for each frame in the message.\n        \"\"\"\n        async with self.read_mutex:\n            if self.get_in_progress:\n                # This should be guarded against with the read_mutex,\n                # exception is only here as a failsafe\n                raise ServerError(\n                    \"Called get_iter on Websocket frame assembler \"\n                    \"while asynchronous get is already in progress.\"\n                )\n            self.get_in_progress = True\n\n            chunks = self.chunks\n            self.chunks = []\n            self.chunks_queue = asyncio.Queue()\n\n            # Sending None in chunk_queue supersedes setting message_complete\n            # when switching to \"streaming\". If message is already complete\n            # when the switch happens, put() didn't send None, so we have to.\n            if self.message_complete.is_set():\n                await self.chunks_queue.put(None)\n\n            # Locking with get_in_progress ensures only one task can get here\n            for c in chunks:\n                yield c\n            while True:\n                chunk = await self.chunks_queue.get()\n                if chunk is None:\n                    break\n                yield chunk\n\n            # Unpause the transport, if its paused\n            if self.paused:\n                self.protocol.resume_frames()\n                self.paused = False\n            if not self.get_in_progress:  # no cov\n                # This should be guarded against with the read_mutex,\n                # exception is here as a failsafe\n                raise ServerError(\n                    \"State of Websocket frame assembler was modified while an \"\n                    \"asynchronous get was in progress.\"\n                )\n            self.get_in_progress = False\n            if not self.message_complete.is_set():  # no cov\n                # This should be guarded against with the read_mutex,\n                # exception is here as a failsafe\n                raise ServerError(\n                    \"Websocket frame assembler chunks queue ended before \"\n                    \"message was complete.\"\n                )\n            self.message_complete.clear()\n            if self.message_fetched.is_set():  # no cov\n                # This should be guarded against with the read_mutex,\n                # and get_in_progress check, this exception is\n                # here as a failsafe\n                raise ServerError(\n                    \"Websocket get_iter() found a message when state was \"\n                    \"already fetched.\"\n                )\n\n            self.message_fetched.set()\n            # this should already be empty, but set it here for safety\n            self.chunks = []\n            self.chunks_queue = None"
    },
    {
      "chunk_id": 1033,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/frame.py",
      "content": "async def put(self, frame: Frame) -> None:\n        \"\"\"\n        Add ``frame`` to the next message.\n        When ``frame`` is the final frame in a message, :meth:`put` waits\n        until the message is fetched, either by calling :meth:`get` or by\n        iterating the return value of :meth:`get_iter`.\n        :meth:`put` assumes that the stream of frames respects the protocol.\n        If it doesn't, the behavior is undefined.\n        \"\"\"\n\n        async with self.write_mutex:\n            if frame.opcode is Opcode.TEXT:\n                self.decoder = UTF8Decoder(errors=\"strict\")\n            elif frame.opcode is Opcode.BINARY:\n                self.decoder = None\n            elif frame.opcode is Opcode.CONT:\n                pass\n            else:\n                # Ignore control frames.\n                return\n            data: Data\n            if self.decoder is not None:\n                data = self.decoder.decode(frame.data, frame.fin)\n            else:\n                data = frame.data\n            if self.chunks_queue is None:\n                self.chunks.append(data)\n            else:\n                await self.chunks_queue.put(data)\n\n            if not frame.fin:\n                return\n            if not self.get_in_progress:\n                # nobody is waiting for this frame, so try to pause subsequent\n                # frames at the protocol level\n                self.paused = self.protocol.pause_frames()\n            # Message is complete. Wait until it's fetched to return.\n\n            if self.chunks_queue is not None:\n                await self.chunks_queue.put(None)\n            if self.message_complete.is_set():\n                # This should be guarded against with the write_mutex\n                raise ServerError(\n                    \"Websocket put() got a new message when a message was \"\n                    \"already in its chamber.\"\n                )\n            self.message_complete.set()  # Signal to get() it can serve the\n            if self.message_fetched.is_set():\n                # This should be guarded against with the write_mutex\n                raise ServerError(\n                    \"Websocket put() got a new message when the previous \"\n                    \"message was not yet fetched.\"\n                )\n\n            # Allow get() to run and eventually set the event.\n            await self.message_fetched.wait()\n            self.message_fetched.clear()\n            self.decoder = None"
    },
    {
      "chunk_id": 1034,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "import asyncio\nimport random\nimport struct\n\nfrom collections.abc import AsyncIterator, Iterable, Mapping, Sequence\nfrom typing import (\n    Optional,\n    Union,\n)\n\nfrom websockets.exceptions import (\n    ConnectionClosed,\n    ConnectionClosedError,\n    ConnectionClosedOK,\n)\nfrom websockets.frames import Frame, Opcode\n\n\ntry:  # websockets < 11.0\n    from websockets.connection import Event, State  # type: ignore\n    from websockets.server import ServerConnection as ServerProtocol\nexcept ImportError:  # websockets >= 11.0\n    from websockets.protocol import Event, State  # type: ignore\n    from websockets.server import ServerProtocol  # type: ignore\n\nfrom websockets.typing import Data\n\nfrom sanic.log import websockets_logger\nfrom sanic.server.protocols.base_protocol import SanicProtocol\n\nfrom ...exceptions import ServerError, WebsocketClosed\nfrom .frame import WebsocketFrameAssembler"
    },
    {
      "chunk_id": 1035,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "class WebsocketImplProtocol:\n    ws_proto: ServerProtocol\n    io_proto: Optional[SanicProtocol]\n    loop: Optional[asyncio.AbstractEventLoop]\n    max_queue: int\n    close_timeout: float\n    ping_interval: Optional[float]\n    ping_timeout: Optional[float]\n    assembler: WebsocketFrameAssembler\n    # Dict[bytes, asyncio.Future[None]]\n    pings: dict[bytes, asyncio.Future]\n    conn_mutex: asyncio.Lock\n    recv_lock: asyncio.Lock\n    recv_cancel: Optional[asyncio.Future]\n    process_event_mutex: asyncio.Lock\n    can_pause: bool\n    # Optional[asyncio.Future[None]]\n    data_finished_fut: Optional[asyncio.Future]\n    # Optional[asyncio.Future[None]]\n    pause_frame_fut: Optional[asyncio.Future]\n    # Optional[asyncio.Future[None]]\n    connection_lost_waiter: Optional[asyncio.Future]\n    keepalive_ping_task: Optional[asyncio.Task]\n    auto_closer_task: Optional[asyncio.Task]\n\n    def __init__(\n        self,\n        ws_proto,\n        max_queue=None,\n        ping_interval: Optional[float] = 20,\n        ping_timeout: Optional[float] = 20,\n        close_timeout: float = 10,\n        loop=None,\n    ):\n        self.ws_proto = ws_proto\n        self.io_proto = None\n        self.loop = None\n        self.max_queue = max_queue\n        self.close_timeout = close_timeout\n        self.ping_interval = ping_interval\n        self.ping_timeout = ping_timeout\n        self.assembler = WebsocketFrameAssembler(self)\n        self.pings = {}\n        self.conn_mutex = asyncio.Lock()\n        self.recv_lock = asyncio.Lock()\n        self.recv_cancel = None\n        self.process_event_mutex = asyncio.Lock()\n        self.data_finished_fut = None\n        self.can_pause = True\n        self.pause_frame_fut = None\n        self.keepalive_ping_task = None\n        self.auto_closer_task = None\n        self.connection_lost_waiter = None"
    },
    {
      "chunk_id": 1036,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "@property\n    def subprotocol(self):\n        return self.ws_proto.subprotocol"
    },
    {
      "chunk_id": 1037,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def pause_frames(self):\n        if not self.can_pause:\n            return False\n        if self.pause_frame_fut:\n            websockets_logger.debug(\"Websocket connection already paused.\")\n            return False\n        if (not self.loop) or (not self.io_proto):\n            return False\n        if self.io_proto.transport:\n            self.io_proto.transport.pause_reading()\n        self.pause_frame_fut = self.loop.create_future()\n        websockets_logger.debug(\"Websocket connection paused.\")\n        return True"
    },
    {
      "chunk_id": 1038,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def resume_frames(self):\n        if not self.pause_frame_fut:\n            websockets_logger.debug(\"Websocket connection not paused.\")\n            return False\n        if (not self.loop) or (not self.io_proto):\n            websockets_logger.debug(\n                \"Websocket attempting to resume reading frames, \"\n                \"but connection is gone.\"\n            )\n            return False\n        if self.io_proto.transport:\n            self.io_proto.transport.resume_reading()\n        self.pause_frame_fut.set_result(None)\n        self.pause_frame_fut = None\n        websockets_logger.debug(\"Websocket connection unpaused.\")\n        return True"
    },
    {
      "chunk_id": 1039,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def connection_made(\n        self,\n        io_proto: SanicProtocol,\n        loop: Optional[asyncio.AbstractEventLoop] = None,\n    ):\n        if not loop:\n            try:\n                loop = getattr(io_proto, \"loop\")\n            except AttributeError:\n                loop = asyncio.get_event_loop()\n        if not loop:\n            raise ServerError(\"Connection received with no asyncio loop.\")\n        if self.auto_closer_task:\n            raise ServerError(\n                \"Cannot call connection_made more than once \"\n                \"on a websocket connection.\"\n            )\n        self.loop = loop\n        self.io_proto = io_proto\n        self.connection_lost_waiter = self.loop.create_future()\n        self.data_finished_fut = asyncio.shield(self.loop.create_future())\n\n        if self.ping_interval:\n            self.keepalive_ping_task = asyncio.create_task(\n                self.keepalive_ping()\n            )\n        self.auto_closer_task = asyncio.create_task(\n            self.auto_close_connection()\n        )"
    },
    {
      "chunk_id": 1040,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def wait_for_connection_lost(self, timeout=None) -> bool:\n        \"\"\"\n        Wait until the TCP connection is closed or ``timeout`` elapses.\n        If timeout is None, wait forever.\n        Recommend you should pass in self.close_timeout as timeout\n\n        Return ``True`` if the connection is closed and ``False`` otherwise.\n\n        \"\"\"\n        if not self.connection_lost_waiter:\n            return False\n        if self.connection_lost_waiter.done():\n            return True\n        else:\n            try:\n                await asyncio.wait_for(\n                    asyncio.shield(self.connection_lost_waiter), timeout\n                )\n                return True\n            except asyncio.TimeoutError:\n                return self.connection_lost_waiter.done()"
    },
    {
      "chunk_id": 1041,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def process_events(self, events: Sequence[Event]) -> None:\n        \"\"\"\n        Process a list of incoming events.\n        \"\"\"\n        async with self.process_event_mutex:\n            for event in events:\n                if not isinstance(event, Frame):\n                    continue\n                if event.opcode == Opcode.PONG:\n                    await self.process_pong(event)\n                elif event.opcode == Opcode.CLOSE:\n                    if self.recv_cancel:\n                        self.recv_cancel.cancel()\n                else:\n                    await self.assembler.put(event)"
    },
    {
      "chunk_id": 1042,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def process_pong(self, frame: Frame) -> None:\n        if frame.data in self.pings:\n            ping_ids = []\n            for ping_id, ping in self.pings.items():\n                ping_ids.append(ping_id)\n                if not ping.done():\n                    ping.set_result(None)\n                if ping_id == frame.data:\n                    break\n            else:  # noqa\n                raise ServerError(\"ping_id is not in self.pings\")\n            for ping_id in ping_ids:\n                del self.pings[ping_id]"
    },
    {
      "chunk_id": 1043,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def keepalive_ping(self) -> None:\n        \"\"\"\n        Send a Ping frame and wait for a Pong frame at regular intervals.\n        This coroutine exits when the connection terminates and one of the\n        following happens:\n        - :meth:`ping` raises :exc:`ConnectionClosed`, or\n        - :meth:`auto_close_connection` cancels :attr:`keepalive_ping_task`.\n        \"\"\"\n        if self.ping_interval is None:\n            return\n\n        try:\n            while True:\n                await asyncio.sleep(self.ping_interval)\n\n                ping_waiter = await self.ping()\n\n                if self.ping_timeout is not None:\n                    try:\n                        await asyncio.wait_for(ping_waiter, self.ping_timeout)\n                    except asyncio.TimeoutError:\n                        websockets_logger.warning(\n                            \"Websocket timed out waiting for pong\"\n                        )\n                        self.fail_connection(1011)\n                        break\n        except asyncio.CancelledError:\n            websockets_logger.debug(\n                \"Websocket keepalive ping task was cancelled.\"\n            )\n        except (ConnectionClosed, WebsocketClosed):\n            websockets_logger.debug(\n                \"Websocket closed. Keepalive ping task exiting.\"\n            )\n        except Exception as e:\n            websockets_logger.warning(\n                \"Unexpected exception in websocket keepalive ping task.\"\n            )\n            websockets_logger.debug(str(e))"
    },
    {
      "chunk_id": 1044,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def _force_disconnect(self) -> bool:\n        \"\"\"\n        Internal method used by end_connection and fail_connection\n        only when the graceful auto-closer cannot be used\n        \"\"\"\n        if self.auto_closer_task and not self.auto_closer_task.done():\n            self.auto_closer_task.cancel()\n        if self.data_finished_fut and not self.data_finished_fut.done():\n            self.data_finished_fut.cancel()\n            self.data_finished_fut = None\n        if self.keepalive_ping_task and not self.keepalive_ping_task.done():\n            self.keepalive_ping_task.cancel()\n            self.keepalive_ping_task = None\n        if self.loop and self.io_proto and self.io_proto.transport:\n            self.io_proto.transport.close()\n            self.loop.call_later(\n                self.close_timeout, self.io_proto.transport.abort\n            )\n        return True"
    },
    {
      "chunk_id": 1045,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def fail_connection(self, code: int = 1006, reason: str = \"\") -> bool:\n        \"\"\"\n        Fail the WebSocket Connection\n        This requires:\n        1. Stopping all processing of incoming data, which means cancelling\n           pausing the underlying io protocol. The close code will be 1006\n           unless a close frame was received earlier.\n        2. Sending a close frame with an appropriate code if the opening\n           handshake succeeded and the other side is likely to process it.\n        3. Closing the connection. :meth:`auto_close_connection` takes care\n           of this.\n        (The specification describes these steps in the opposite order.)\n        \"\"\"\n        if self.io_proto and self.io_proto.transport:\n            self.io_proto.transport.pause_reading()\n\n            _ = self.ws_proto.data_to_send()\n            if self.ws_proto.state is OPEN:\n                if code in (1000, 1001):\n                    self.ws_proto.send_close(code, reason)\n                else:\n                    self.ws_proto.fail(code, reason)\n                try:\n                    data_to_send = self.ws_proto.data_to_send()\n                    while (\n                        len(data_to_send)\n                        and self.io_proto\n                        and self.io_proto.transport\n                    ):\n                        frame_data = data_to_send.pop(0)\n                        self.io_proto.transport.write(frame_data)\n                except Exception:\n                    ...\n        if code == 1006:\n            self.ws_proto.state = CLOSED\n        if self.data_finished_fut and not self.data_finished_fut.done():\n            self.data_finished_fut.cancel()\n            self.data_finished_fut = None\n        if (not self.auto_closer_task) or self.auto_closer_task.done():\n            return self._force_disconnect()\n        return False"
    },
    {
      "chunk_id": 1046,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def end_connection(self, code=1000, reason=\"\"):\n        if code == 1006 or not self.io_proto or not self.io_proto.transport:\n            return self.fail_connection(code, reason)\n\n        self.io_proto.transport.pause_reading()\n        if self.ws_proto.state == OPEN:\n            data_to_send = self.ws_proto.data_to_send()\n            self.ws_proto.send_close(code, reason)\n            data_to_send.extend(self.ws_proto.data_to_send())\n            try:\n                while (\n                    len(data_to_send)\n                    and self.io_proto\n                    and self.io_proto.transport\n                ):\n                    frame_data = data_to_send.pop(0)\n                    self.io_proto.transport.write(frame_data)\n            except Exception:\n                ...\n        if self.data_finished_fut and not self.data_finished_fut.done():\n            self.data_finished_fut.cancel()\n            self.data_finished_fut = None\n        if (not self.auto_closer_task) or self.auto_closer_task.done():\n            return self._force_disconnect()\n        return False"
    },
    {
      "chunk_id": 1047,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def auto_close_connection(self) -> None:\n        \"\"\"\n        Close the WebSocket Connection\n        When the opening handshake succeeds, :meth:`connection_open` starts\n        this coroutine in a task. It waits for the data transfer phase to\n        complete then it closes the TCP connection cleanly.\n        When the opening handshake fails, :meth:`fail_connection` does the\n        same. There's no data transfer phase in that case.\n        \"\"\"\n        try:\n            if self.data_finished_fut:\n                try:\n                    await self.data_finished_fut\n                    websockets_logger.debug(\n                        \"Websocket task finished. Closing the connection.\"\n                    )\n                except asyncio.CancelledError:\n                    websockets_logger.debug(\n                        \"Websocket handler cancelled. Closing the connection.\"\n                    )\n\n            if self.keepalive_ping_task:\n                self.keepalive_ping_task.cancel()\n                self.keepalive_ping_task = None\n\n            if (\n                self.io_proto\n                and self.io_proto.transport\n                and self.io_proto.transport.can_write_eof()\n            ):\n                websockets_logger.debug(\n                    \"Websocket half-closing TCP connection\"\n                )\n                self.io_proto.transport.write_eof()\n                if self.connection_lost_waiter:\n                    if await self.wait_for_connection_lost(timeout=0):\n                        return\n        except asyncio.CancelledError:\n            ...\n        finally:\n            if (not self.io_proto) or (not self.io_proto.transport):\n                return\n            elif (\n                self.connection_lost_waiter\n                and self.connection_lost_waiter.done()\n            ):\n                ...\n            elif self.io_proto.transport.is_closing():\n                ...\n            else:\n                self.io_proto.transport.close()\n            if not self.connection_lost_waiter:\n                try:\n                    await asyncio.sleep(self.close_timeout)\n                except asyncio.CancelledError:\n                    ...\n                if self.io_proto and self.io_proto.transport:\n                    self.io_proto.transport.abort()\n            else:\n                if await self.wait_for_connection_lost(\n                    timeout=self.close_timeout\n                ):\n                    return\n                websockets_logger.warning(\n                    \"Timeout waiting for TCP connection to close. Aborting\"\n                )\n                if self.io_proto and self.io_proto.transport:\n                    self.io_proto.transport.abort()"
    },
    {
      "chunk_id": 1048,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def abort_pings(self) -> None:\n        \"\"\"\n        Raise ConnectionClosed in pending keepalive pings.\n        They'll never receive a pong once the connection is closed.\n        \"\"\"\n        if self.ws_proto.state is not CLOSED:\n            raise ServerError(\n                \"Webscoket about_pings should only be called \"\n                \"after connection state is changed to CLOSED\"\n            )\n\n        for ping in self.pings.values():\n            ping.set_exception(ConnectionClosedError(None, None))\n            ping.cancel()"
    },
    {
      "chunk_id": 1049,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def close(self, code: int = 1000, reason: str = \"\") -> None:\n        \"\"\"\n        Perform the closing handshake.\n        This is a websocket-protocol level close.\n        :meth:`close` waits for the other end to complete the handshake and\n        for the TCP connection to terminate.\n        :meth:`close` is idempotent: it doesn't do anything once the\n        connection is closed.\n        :param code: WebSocket close code\n        :param reason: WebSocket close reason\n        \"\"\"\n        if code == 1006:\n            self.fail_connection(code, reason)\n            return\n        async with self.conn_mutex:\n            if self.ws_proto.state is OPEN:\n                self.ws_proto.send_close(code, reason)\n                data_to_send = self.ws_proto.data_to_send()\n                await self.send_data(data_to_send)"
    },
    {
      "chunk_id": 1050,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def recv(self, timeout: Optional[float] = None) -> Optional[Data]:\n        \"\"\"\n        Receive the next message.\n        Return a :class:`str` for a text frame and :class:`bytes` for a binary\n        frame.\n        When the end of the message stream is reached, :meth:`recv` raises\n        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it\n        raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal\n        connection closure and\n        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol\n        error or a network failure.\n        If ``timeout`` is ``None``, block until a message is received. Else,\n        if no message is received within ``timeout`` seconds, return ``None``.\n        Set ``timeout`` to ``0`` to check if a message was already received.\n        :raises ~websockets.exceptions.ConnectionClosed: when the\n            connection is closed\n        :raises asyncio.CancelledError: if the websocket closes while waiting\n        :raises ServerError: if two tasks call :meth:`recv` or\n            :meth:`recv_streaming` concurrently\n        \"\"\"\n\n        if self.recv_lock.locked():\n            raise ServerError(\n                \"cannot call recv while another task is \"\n                \"already waiting for the next message\"\n            )\n        await self.recv_lock.acquire()\n        if self.ws_proto.state is CLOSED:\n            self.recv_lock.release()\n            raise WebsocketClosed(\n                \"Cannot receive from websocket interface after it is closed.\"\n            )\n        assembler_get: Optional[asyncio.Task] = None\n        try:\n            self.recv_cancel = asyncio.Future()\n            assembler_get = asyncio.create_task(self.assembler.get(timeout))\n            tasks = (self.recv_cancel, assembler_get)\n            done, pending = await asyncio.wait(\n                tasks,\n                return_when=asyncio.FIRST_COMPLETED,\n            )\n            done_task = next(iter(done))\n            if done_task is self.recv_cancel:\n                for p in pending:\n                    p.cancel()\n                raise asyncio.CancelledError()\n            else:\n                self.recv_cancel.cancel()\n                return done_task.result()\n        except asyncio.CancelledError:\n            if assembler_get:\n                assembler_get.cancel()\n            raise\n        finally:\n            self.recv_cancel = None\n            self.recv_lock.release()"
    },
    {
      "chunk_id": 1051,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def recv_burst(self, max_recv=256) -> Sequence[Data]:\n        \"\"\"\n        Receive the messages which have arrived since last checking.\n        Return a :class:`list` containing :class:`str` for a text frame\n        and :class:`bytes` for a binary frame.\n        When the end of the message stream is reached, :meth:`recv_burst`\n        raises :exc:`~websockets.exceptions.ConnectionClosed`. Specifically,\n        it raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a\n        normal connection closure and\n        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol\n        error or a network failure.\n        :raises ~websockets.exceptions.ConnectionClosed: when the\n            connection is closed\n        :raises ServerError: if two tasks call :meth:`recv_burst` or\n            :meth:`recv_streaming` concurrently\n        \"\"\"\n\n        if self.recv_lock.locked():\n            raise ServerError(\n                \"cannot call recv_burst while another task is already waiting \"\n                \"for the next message\"\n            )\n        await self.recv_lock.acquire()\n        if self.ws_proto.state is CLOSED:\n            self.recv_lock.release()\n            raise WebsocketClosed(\n                \"Cannot receive from websocket interface after it is closed.\"\n            )\n        messages = []\n        assembler_get: Optional[asyncio.Task] = None\n        try:\n            self.can_pause = False\n            self.recv_cancel = asyncio.Future()\n            while True:\n                assembler_get = asyncio.create_task(self.assembler.get(0))\n                tasks = (self.recv_cancel, assembler_get)\n                done, pending = await asyncio.wait(\n                    tasks,\n                    return_when=asyncio.FIRST_COMPLETED,\n                )\n                done_task = next(iter(done))\n                if done_task is self.recv_cancel:\n                    for p in pending:\n                        p.cancel()\n                    raise asyncio.CancelledError()\n                m = done_task.result()\n                if m is None:\n                    break\n                messages.append(m)\n                if len(messages) >= max_recv:\n                    break\n                await asyncio.sleep(0)\n            self.recv_cancel.cancel()\n        except asyncio.CancelledError:\n            if assembler_get:\n                assembler_get.cancel()\n            raise\n        finally:\n            self.recv_cancel = None\n            self.can_pause = True\n            self.recv_lock.release()\n        return messages"
    },
    {
      "chunk_id": 1052,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def recv_streaming(self) -> AsyncIterator[Data]:\n        \"\"\"\n        Receive the next message frame by frame.\n        Return an iterator of :class:`str` for a text frame and :class:`bytes`\n        for a binary frame. The iterator should be exhausted, or else the\n        connection will become unusable.\n        With the exception of the return value, :meth:`recv_streaming` behaves\n        like :meth:`recv`.\n        \"\"\"\n        if self.recv_lock.locked():\n            raise ServerError(\n                \"Cannot call recv_streaming while another task \"\n                \"is already waiting for the next message\"\n            )\n        await self.recv_lock.acquire()\n        if self.ws_proto.state is CLOSED:\n            self.recv_lock.release()\n            raise WebsocketClosed(\n                \"Cannot receive from websocket interface after it is closed.\"\n            )\n        try:\n            cancelled = False\n            self.recv_cancel = asyncio.Future()\n            self.can_pause = False\n            async for m in self.assembler.get_iter():\n                if self.recv_cancel.done():\n                    cancelled = True\n                    break\n                yield m\n            if cancelled:\n                raise asyncio.CancelledError()\n        finally:\n            self.can_pause = True\n            self.recv_cancel = None\n            self.recv_lock.release()"
    },
    {
      "chunk_id": 1053,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def send(self, message: Union[Data, Iterable[Data]]) -> None:\n        \"\"\"\n        Send a message.\n        A string (:class:`str`) is sent as a `Text frame`_. A bytestring or\n        bytes-like object (:class:`bytes`, :class:`bytearray`, or\n        :class:`memoryview`) is sent as a `Binary frame`_.\n        .. _Text frame: https://tools.ietf.org/html/rfc6455#section-5.6\n        .. _Binary frame: https://tools.ietf.org/html/rfc6455#section-5.6\n        :meth:`send` also accepts an iterable of strings, bytestrings, or\n        bytes-like objects. In that case the message is fragmented. Each item\n        is treated as a message fragment and sent in its own frame. All items\n        must be of the same type, or else :meth:`send` will raise a\n        :exc:`TypeError` and the connection will be closed.\n        :meth:`send` rejects dict-like objects because this is often an error.\n        If you wish to send the keys of a dict-like object as fragments, call\n        its :meth:`~dict.keys` method and pass the result to :meth:`send`.\n        :raises TypeError: for unsupported inputs\n        \"\"\"\n        async with self.conn_mutex:\n            if self.ws_proto.state in (CLOSED, CLOSING):\n                raise WebsocketClosed(\n                    \"Cannot write to websocket interface after it is closed.\"\n                )\n            if (not self.data_finished_fut) or self.data_finished_fut.done():\n                raise ServerError(\n                    \"Cannot write to websocket interface after it is finished.\"\n                )\n\n            if isinstance(message, str):\n                self.ws_proto.send_text(message.encode(\"utf-8\"))\n                await self.send_data(self.ws_proto.data_to_send())\n\n            elif isinstance(message, (bytes, bytearray, memoryview)):\n                self.ws_proto.send_binary(message)\n                await self.send_data(self.ws_proto.data_to_send())\n\n            elif isinstance(message, Mapping):\n                raise TypeError(\"data is a dict-like object\")\n\n            elif isinstance(message, Iterable):\n                raise NotImplementedError(\n                    \"Fragmented websocket messages are not supported.\"\n                )\n            else:\n                raise TypeError(\"Websocket data must be bytes, str.\")"
    },
    {
      "chunk_id": 1054,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def ping(self, data: Optional[Data] = None) -> asyncio.Future:\n        \"\"\"\n        Send a ping.\n        Return an :class:`~asyncio.Future` that will be resolved when the\n        corresponding pong is received. You can ignore it if you don't intend\n        to wait.\n        A ping may serve as a keepalive or as a check that the remote endpoint\n        received all messages up to this point::\n            await pong_event = ws.ping()\n            await pong_event # only if you want to wait for the pong\n        By default, the ping contains four random bytes. This payload may be\n        overridden with the optional ``data`` argument which must be a string\n        (which will be encoded to UTF-8) or a bytes-like object.\n        \"\"\"\n        async with self.conn_mutex:\n            if self.ws_proto.state in (CLOSED, CLOSING):\n                raise WebsocketClosed(\n                    \"Cannot send a ping when the websocket interface \"\n                    \"is closed.\"\n                )\n            if (not self.io_proto) or (not self.io_proto.loop):\n                raise ServerError(\n                    \"Cannot send a ping when the websocket has no I/O \"\n                    \"protocol attached.\"\n                )\n            if data is not None:\n                if isinstance(data, str):\n                    data = data.encode(\"utf-8\")\n                elif isinstance(data, (bytearray, memoryview)):\n                    data = bytes(data)\n\n            if data in self.pings:\n                raise ValueError(\n                    \"already waiting for a pong with the same data\"\n                )\n\n            while data is None or data in self.pings:\n                data = struct.pack(\"!I\", random.getrandbits(32))\n\n            self.pings[data] = self.io_proto.loop.create_future()\n\n            self.ws_proto.send_ping(data)\n            await self.send_data(self.ws_proto.data_to_send())\n\n            return asyncio.shield(self.pings[data])"
    },
    {
      "chunk_id": 1055,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def pong(self, data: Data = b\"\") -> None:\n        \"\"\"\n        Send a pong.\n        An unsolicited pong may serve as a unidirectional heartbeat.\n        The payload may be set with the optional ``data`` argument which must\n        be a string (which will be encoded to UTF-8) or a bytes-like object.\n        \"\"\"\n        async with self.conn_mutex:\n            if self.ws_proto.state in (CLOSED, CLOSING):\n                return\n            if isinstance(data, str):\n                data = data.encode(\"utf-8\")\n            elif isinstance(data, (bytearray, memoryview)):\n                data = bytes(data)\n            self.ws_proto.send_pong(data)\n            await self.send_data(self.ws_proto.data_to_send())"
    },
    {
      "chunk_id": 1056,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def send_data(self, data_to_send):\n        for data in data_to_send:\n            if data:\n                await self.io_proto.send(data)\n            else:\n                if (\n                    self.auto_closer_task\n                    and not self.auto_closer_task.done()\n                    and self.data_finished_fut\n                    and not self.data_finished_fut.done()\n                ):\n                    self.data_finished_fut.set_result(None)\n                else:\n                    SanicProtocol.close(self.io_proto, timeout=1.0)"
    },
    {
      "chunk_id": 1057,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def async_data_received(self, data_to_send, events_to_process):\n        if self.ws_proto.state in (OPEN, CLOSING) and len(data_to_send) > 0:\n            await self.send_data(data_to_send)\n        if len(events_to_process) > 0:\n            await self.process_events(events_to_process)"
    },
    {
      "chunk_id": 1058,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def data_received(self, data):\n        self.ws_proto.receive_data(data)\n        data_to_send = self.ws_proto.data_to_send()\n        events_to_process = self.ws_proto.events_received()\n        if len(data_to_send) > 0 or len(events_to_process) > 0:\n            asyncio.create_task(\n                self.async_data_received(data_to_send, events_to_process)\n            )"
    },
    {
      "chunk_id": 1059,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def async_eof_received(self, data_to_send, events_to_process):\n        if self.ws_proto.state in (OPEN, CLOSING) and len(data_to_send) > 0:\n            await self.send_data(data_to_send)\n        if len(events_to_process) > 0:\n            await self.process_events(events_to_process)\n        if self.recv_cancel:\n            self.recv_cancel.cancel()\n        if (\n            self.auto_closer_task\n            and not self.auto_closer_task.done()\n            and self.data_finished_fut\n            and not self.data_finished_fut.done()\n        ):\n            self.data_finished_fut.set_result(None)\n        else:\n            SanicProtocol.close(self.io_proto, timeout=1.0)"
    },
    {
      "chunk_id": 1060,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def eof_received(self) -> Optional[bool]:\n        self.ws_proto.receive_eof()\n        data_to_send = self.ws_proto.data_to_send()\n        events_to_process = self.ws_proto.events_received()\n        asyncio.create_task(\n            self.async_eof_received(data_to_send, events_to_process)\n        )\n        return False"
    },
    {
      "chunk_id": 1061,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "def connection_lost(self, exc):\n        \"\"\"\n        The WebSocket Connection is Closed.\n        \"\"\"\n        if not self.ws_proto.state == CLOSED:\n            self.ws_proto.fail(code=1006)\n            self.ws_proto.state = CLOSED\n\n        self.abort_pings()\n        if self.connection_lost_waiter:\n            self.connection_lost_waiter.set_result(None)"
    },
    {
      "chunk_id": 1062,
      "source": "__internal__/data_repo/sanic/sanic/server/websockets/impl.py",
      "content": "async def __aiter__(self):\n        try:\n            while True:\n                yield await self.recv()\n        except ConnectionClosedOK:\n            return"
    },
    {
      "chunk_id": 1063,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1064,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1065,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1066,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One:\", self.value)"
    },
    {
      "chunk_id": 1067,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two:\", self.value)"
    },
    {
      "chunk_id": 1068,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "def standalone_function(param):\n    return param * 2"
    },
    {
      "chunk_id": 1069,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/__init__.py",
      "content": "if __name__ == \"__main__\":\n    instance = MyClass(10)\n    instance.method_one()\n    instance.method_two()\n    result = standalone_function(5)\n    print(\"Standalone Function Result:\", result)\n```"
    },
    {
      "chunk_id": 1070,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Optional\n\nfrom sanic.http.constants import HTTP\nfrom sanic.http.http3 import Http3\nfrom sanic.touchup.meta import TouchUpMeta\n\n\nif TYPE_CHECKING:\n    from sanic.app import Sanic\n\n\nfrom asyncio import CancelledError\nfrom time import monotonic as current_time\n\nfrom sanic.exceptions import (\n    RequestCancelled,\n    RequestTimeout,\n    ServiceUnavailable,\n)\nfrom sanic.http import Http, Stage\nfrom sanic.log import (\n    Colors,\n    access_logger,\n    error_logger,\n    logger,\n    websockets_logger,\n)\nfrom sanic.models.server_types import ConnInfo\nfrom sanic.request import Request\nfrom sanic.server.protocols.base_protocol import SanicProtocol"
    },
    {
      "chunk_id": 1071,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "ConnectionProtocol = type(\"ConnectionProtocol\", (), {})\ntry:\n    from aioquic.asyncio import QuicConnectionProtocol\n    from aioquic.h3.connection import H3_ALPN, H3Connection\n    from aioquic.quic.events import (\n        DatagramFrameReceived,\n        ProtocolNegotiated,\n        QuicEvent,\n    )\n\n    ConnectionProtocol = QuicConnectionProtocol\nexcept ModuleNotFoundError:  # no cov\n    ..."
    },
    {
      "chunk_id": 1072,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "class HttpProtocolMixin:\n    __slots__ = ()\n    __version__: HTTP\n\n    def _setup_connection(self, *args, **kwargs):\n        self._http = self.HTTP_CLASS(self, *args, **kwargs)\n        self._time = current_time()\n        try:\n            self.check_timeouts()\n        except AttributeError:\n            ...\n\n    def _setup(self):\n        self.request: Optional[Request] = None\n        self.access_log = self.app.config.ACCESS_LOG\n        self.request_handler = self.app.handle_request\n        self.error_handler = self.app.error_handler\n        self.request_timeout = self.app.config.REQUEST_TIMEOUT\n        self.response_timeout = self.app.config.RESPONSE_TIMEOUT\n        self.keep_alive_timeout = self.app.config.KEEP_ALIVE_TIMEOUT\n        self.request_max_size = self.app.config.REQUEST_MAX_SIZE\n        self.request_class = self.app.request_class or Request\n\n    @property\n    def http(self):\n        if not hasattr(self, \"_http\"):\n            return None\n        return self._http\n\n    @property\n    def version(self):\n        return self.__class__.__version__"
    },
    {
      "chunk_id": 1073,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "class HttpProtocol(HttpProtocolMixin, SanicProtocol, metaclass=TouchUpMeta):\n    \"\"\"\n    This class provides implements the HTTP 1.1 protocol on top of our\n    Sanic Server transport\n    \"\"\"\n\n    HTTP_CLASS = Http\n\n    __touchup__ = (\n        \"send\",\n        \"connection_task\",\n    )\n    __version__ = HTTP.VERSION_1\n    __slots__ = (\n        # request params\n        \"request\",\n        # request config\n        \"request_handler\",\n        \"request_timeout\",\n        \"response_timeout\",\n        \"keep_alive_timeout\",\n        \"request_max_size\",\n        \"request_class\",\n        \"error_handler\",\n        # enable or disable access log purpose\n        \"access_log\",\n        # connection management\n        \"state\",\n        \"url\",\n        \"_handler_task\",\n        \"_http\",\n        \"_exception\",\n        \"recv_buffer\",\n        \"_callback_check_timeouts\",\n    )\n\n    def __init__(\n        self,\n        *,\n        loop,\n        app: Sanic,\n        signal=None,\n        connections=None,\n        state=None,\n        unix=None,\n        **kwargs,\n    ):\n        super().__init__(\n            loop=loop,\n            app=app,\n            signal=signal,\n            connections=connections,\n            unix=unix,\n        )\n        self.url = None\n        self.state = state if state else {}\n        self._setup()\n        if \"requests_count\" not in self.state:\n            self.state[\"requests_count\"] = 0\n        self._exception = None\n        self._callback_check_timeouts = None"
    },
    {
      "chunk_id": 1074,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "async def connection_task(self):  # no cov\n        \"\"\"\n        Run a HTTP connection.\n\n        Timeouts and some additional error handling occur here, while most of\n        everything else happens in class Http or in code called from there.\n        \"\"\"\n        try:\n            self._setup_connection()\n            await self.app.dispatch(\n                \"http.lifecycle.begin\",\n                inline=True,\n                context={\"conn_info\": self.conn_info},\n            )\n            await self._http.http1()\n        except CancelledError:\n            pass\n        except Exception:\n            error_logger.exception(\"protocol.connection_task uncaught\")\n        finally:\n            if (\n                self.access_log\n                and self._http\n                and self.transport\n                and not self._http.upgrade_websocket\n            ):\n                self.log_disconnect()\n            self._http = None\n            self._task = None\n            try:\n                self.close()\n            except BaseException:\n                error_logger.exception(\"Closing failed\")\n            finally:\n                await self.app.dispatch(\n                    \"http.lifecycle.complete\",\n                    inline=True,\n                    context={\"conn_info\": self.conn_info},\n                )\n                # Important to keep this Ellipsis here for the TouchUp module\n                ..."
    },
    {
      "chunk_id": 1075,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def log_disconnect(self):\n        ip = self.transport.get_extra_info(\"peername\")\n\n        req = self._http.request\n        res = self._http.response\n        extra = {\n            \"status\": res.status if res else str(self._http.stage),\n            \"byte\": \"DISCONNECTED\",\n            \"host\": f\"{id(self):X}\"[-5:-1] + \"unx\",\n            \"request\": \"nil\",\n            \"duration\": \"\",\n        }\n        if req is not None:\n            if ip := req.client_ip:\n                extra[\"host\"] = f\"{ip}:{req.port}\"\n            extra[\"request\"] = f\"{req.method} {req.url}\"\n        access_logger.info(\"\", extra=extra)"
    },
    {
      "chunk_id": 1076,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def check_timeouts(self):\n        \"\"\"\n        Runs itself periodically to enforce any expired timeouts.\n        \"\"\"\n        try:\n            if not self._task:\n                return\n            duration = current_time() - self._time\n            stage = self._http.stage\n            if stage is Stage.IDLE and duration > self.keep_alive_timeout:\n                logger.debug(\"KeepAlive Timeout. Closing connection.\")\n            elif stage is Stage.REQUEST and duration > self.request_timeout:\n                logger.debug(\"Request Timeout. Closing connection.\")\n                self._http.exception = RequestTimeout(\"Request Timeout\")\n            elif stage is Stage.HANDLER and self._http.upgrade_websocket:\n                websockets_logger.debug(\n                    \"Handling websocket. Timeouts disabled.\"\n                )\n                return\n            elif (\n                stage in (Stage.HANDLER, Stage.RESPONSE, Stage.FAILED)\n                and duration > self.response_timeout\n            ):\n                logger.debug(\"Response Timeout. Closing connection.\")\n                self._http.exception = ServiceUnavailable(\"Response Timeout\")\n            else:\n                interval = (\n                    min(\n                        self.keep_alive_timeout,\n                        self.request_timeout,\n                        self.response_timeout,\n                    )\n                    / 2\n                )\n                _interval = max(0.1, interval)\n                self._callback_check_timeouts = self.loop.call_later(\n                    _interval, self.check_timeouts\n                )\n                return\n            cancel_msg_args = ()\n            cancel_msg_args = (\"Cancel connection task with a timeout\",)\n            self._task.cancel(*cancel_msg_args)\n        except Exception:\n            error_logger.exception(\"protocol.check_timeouts\")"
    },
    {
      "chunk_id": 1077,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def close(self, timeout: Optional[float] = None):\n        \"\"\"\n        Requires to prevent checking timeouts for closed connections\n        \"\"\"\n\n        if self._callback_check_timeouts:\n            self._callback_check_timeouts.cancel()\n        return super().close(timeout=timeout)"
    },
    {
      "chunk_id": 1078,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "async def send(self, data):  # no cov\n        \"\"\"\n        Writes HTTP data with backpressure control.\n        \"\"\"\n        await self._can_write.wait()\n        if self.transport.is_closing():\n            raise RequestCancelled\n        await self.app.dispatch(\n            \"http.lifecycle.send\",\n            inline=True,\n            context={\"data\": data},\n        )\n        self.transport.write(data)\n        self._time = current_time()"
    },
    {
      "chunk_id": 1079,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def close_if_idle(self) -> bool:\n        \"\"\"\n        Close the connection if a request is not being sent or received\n\n        :return: boolean - True if closed, false if staying open\n        \"\"\"\n        if self._http is None or self._http.stage is Stage.IDLE:\n            self.close()\n            return True\n        return False"
    },
    {
      "chunk_id": 1080,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "# -------------------------------------------- #\n    # Only asyncio.Protocol callbacks below this\n    # -------------------------------------------- #\n\n    def connection_made(self, transport):\n        \"\"\"\n        HTTP-protocol-specific new connection handler\n        \"\"\"\n        try:\n            # TODO: Benchmark to find suitable write buffer limits\n            transport.set_write_buffer_limits(low=16384, high=65536)\n            self.connections.add(self)\n            self.transport = transport\n            self._task = self.loop.create_task(self.connection_task())\n            self.recv_buffer = bytearray()\n            self.conn_info = ConnInfo(self.transport, unix=self._unix)\n        except Exception:\n            error_logger.exception(\"protocol.connect_made\")"
    },
    {
      "chunk_id": 1081,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def data_received(self, data: bytes):\n        try:\n            self._time = current_time()\n            if not data:\n                return self.close()\n            self.recv_buffer += data\n\n            if (\n                len(self.recv_buffer) >= self.app.config.REQUEST_BUFFER_SIZE\n                and self.transport\n            ):\n                self.transport.pause_reading()\n\n            if self._data_received:\n                self._data_received.set()\n        except Exception:\n            error_logger.exception(\"protocol.data_received\")"
    },
    {
      "chunk_id": 1082,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "class Http3Protocol(HttpProtocolMixin, ConnectionProtocol):  # type: ignore\n    HTTP_CLASS = Http3\n    __version__ = HTTP.VERSION_3\n\n    def __init__(self, *args, app: Sanic, **kwargs) -> None:\n        self.app = app\n        super().__init__(*args, **kwargs)\n        self._setup()\n        self._connection: Optional[H3Connection] = None"
    },
    {
      "chunk_id": 1083,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "def quic_event_received(self, event: QuicEvent) -> None:\n        logger.debug(\n            f\"{Colors.BLUE}[quic_event_received]: \"\n            f\"{Colors.PURPLE}{event}{Colors.END}\",\n            extra={\"verbosity\": 2},\n        )\n        if isinstance(event, ProtocolNegotiated):\n            self._setup_connection(transmit=self.transmit)\n            if event.alpn_protocol in H3_ALPN:\n                self._connection = H3Connection(\n                    self._quic, enable_webtransport=True\n                )\n        elif isinstance(event, DatagramFrameReceived):\n            if event.data == b\"quack\":\n                self._quic.send_datagram_frame(b\"quack-ack\")\n\n        #  pass event to the HTTP layer\n        if self._connection is not None:\n            for http_event in self._connection.handle_event(event):\n                self._http.http_event_received(http_event)"
    },
    {
      "chunk_id": 1084,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/http_protocol.py",
      "content": "@property\n    def connection(self) -> Optional[H3Connection]:\n        return self._connection"
    },
    {
      "chunk_id": 1085,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Optional\n\nfrom sanic.exceptions import RequestCancelled\n\n\nif TYPE_CHECKING:\n    from sanic.app import Sanic\n\nimport asyncio\n\nfrom asyncio.transports import Transport\nfrom time import monotonic as current_time\n\nfrom sanic.log import error_logger\nfrom sanic.models.server_types import ConnInfo, Signal"
    },
    {
      "chunk_id": 1086,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "class SanicProtocol(asyncio.Protocol):\n    __slots__ = (\n        \"app\",\n        # event loop, connection\n        \"loop\",\n        \"transport\",\n        \"connections\",\n        \"conn_info\",\n        \"signal\",\n        \"_can_write\",\n        \"_time\",\n        \"_task\",\n        \"_unix\",\n        \"_data_received\",\n    )\n\n    def __init__(\n        self,\n        *,\n        loop,\n        app: Sanic,\n        signal=None,\n        connections=None,\n        unix=None,\n        **kwargs,\n    ):\n        asyncio.set_event_loop(loop)\n        self.loop = loop\n        self.app: Sanic = app\n        self.signal = signal or Signal()\n        self.transport: Optional[Transport] = None\n        self.connections = connections if connections is not None else set()\n        self.conn_info: Optional[ConnInfo] = None\n        self._can_write = asyncio.Event()\n        self._can_write.set()\n        self._unix = unix\n        self._time = 0.0  # type: float\n        self._task = None  # type: Optional[asyncio.Task]\n        self._data_received = asyncio.Event()"
    },
    {
      "chunk_id": 1087,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "@property\n    def ctx(self):\n        if self.conn_info is not None:\n            return self.conn_info.ctx\n        else:\n            return None"
    },
    {
      "chunk_id": 1088,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "async def send(self, data):\n        \"\"\"\n        Generic data write implementation with backpressure control.\n        \"\"\"\n        await self._can_write.wait()\n        if self.transport.is_closing():\n            raise RequestCancelled\n        self.transport.write(data)\n        self._time = current_time()"
    },
    {
      "chunk_id": 1089,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "async def receive_more(self):\n        \"\"\"\n        Wait until more data is received into the Server protocol's buffer\n        \"\"\"\n        self.transport.resume_reading()\n        self._data_received.clear()\n        await self._data_received.wait()"
    },
    {
      "chunk_id": 1090,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def close(self, timeout: Optional[float] = None):\n        \"\"\"\n        Attempt close the connection.\n        \"\"\"\n        if self.transport is None or self.transport.is_closing():\n            # do not attempt to close again, already aborted or closing\n            return\n\n        # Check if write is already paused _before_ close() is called.\n        write_was_paused = not self._can_write.is_set()\n        # Trigger the UVLoop Stream Transport Close routine\n        # Causes a call to connection_lost where further cleanup occurs\n        # Close may fully close the connection now, but if there is still\n        # data in the libuv buffer, then close becomes an async operation\n        self.transport.close()\n        try:\n            # Check write-buffer data left _after_ close is called.\n            # in UVLoop, get the data in the libuv transport write-buffer\n            data_left = self.transport.get_write_buffer_size()\n        # Some asyncio implementations don't support get_write_buffer_size\n        except (AttributeError, NotImplementedError):\n            data_left = 0\n        if write_was_paused or data_left > 0:\n            # don't call resume_writing here, it gets called by the transport\n            # to unpause the protocol when it is ready for more data\n\n            # Schedule the async close checker, to close the connection\n            # after the transport is done, and clean everything up.\n            if timeout is None:\n                # This close timeout needs to be less than the graceful\n                # shutdown timeout. The graceful shutdown _could_ be waiting\n                # for this transport to close before shutting down the app.\n                timeout = self.app.config.GRACEFUL_TCP_CLOSE_TIMEOUT\n                # This is 5s by default.\n        else:\n            # Schedule the async close checker but with no timeout,\n            # this will ensure abort() is called if required.\n            if timeout is None:\n                timeout = 0\n        self.loop.call_soon(\n            _async_protocol_transport_close,\n            self,\n            self.loop,\n            timeout,\n        )"
    },
    {
      "chunk_id": 1091,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def abort(self):\n        \"\"\"\n        Force close the connection.\n        \"\"\"\n        # Cause a call to connection_lost where further cleanup occurs\n        if self.transport:\n            self.transport.abort()\n            self.transport = None"
    },
    {
      "chunk_id": 1092,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "# asyncio.Protocol API Callbacks #\n    # ------------------------------ #\n    def connection_made(self, transport):\n        \"\"\"\n        Generic connection-made, with no connection_task, and no recv_buffer.\n        Override this for protocol-specific connection implementations.\n        \"\"\"\n        try:\n            transport.set_write_buffer_limits(low=16384, high=65536)\n            self.connections.add(self)\n            self.transport = transport\n            self.conn_info = ConnInfo(self.transport, unix=self._unix)\n        except Exception:\n            error_logger.exception(\"protocol.connect_made\")"
    },
    {
      "chunk_id": 1093,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def connection_lost(self, exc):\n        \"\"\"\n        This is a callback handler that is called from the asyncio\n        transport layer implementation (eg, UVLoop's UVStreamTransport).\n        It is scheduled to be called async after the transport has closed.\n        When data is still in the send buffer, this call to connection_lost\n        will be delayed until _after_ the buffer is finished being sent.\n\n        So we can use this callback as a confirmation callback\n        that the async write-buffer transfer is finished.\n        \"\"\"\n        try:\n            self.connections.discard(self)\n            # unblock the send queue if it is paused,\n            # this allows the route handler to see\n            # the CancelledError exception\n            self.resume_writing()\n            self.conn_info.lost = True\n            if self._task:\n                self._task.cancel()\n        except BaseException:\n            error_logger.exception(\"protocol.connection_lost\")"
    },
    {
      "chunk_id": 1094,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def pause_writing(self):\n        self._can_write.clear()"
    },
    {
      "chunk_id": 1095,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def resume_writing(self):\n        self._can_write.set()"
    },
    {
      "chunk_id": 1096,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def data_received(self, data: bytes):\n        try:\n            self._time = current_time()\n            if not data:\n                return self.close()\n\n            if self._data_received:\n                self._data_received.set()\n        except BaseException:\n            error_logger.exception(\"protocol.data_received\")"
    },
    {
      "chunk_id": 1097,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/base_protocol.py",
      "content": "def _async_protocol_transport_close(\n    protocol: SanicProtocol,\n    loop: asyncio.AbstractEventLoop,\n    timeout: float,\n):\n    \"\"\"\n    This function is scheduled to be called after close() is called.\n    It checks that the transport has shut down properly, or waits\n    for any remaining data to be sent, and aborts after a timeout.\n    This is required if the transport is closed while there is an async\n    large async transport write operation in progress.\n    This is observed when NGINX reverse-proxy is the client.\n    \"\"\"\n    if protocol.transport is None:\n        # abort() is the only method that can make\n        # protocol.transport be None, so abort was already called\n        return\n    # protocol.connection_lost does not set protocol.transport to None\n    # so to detect it a different way with conninfo.lost\n    elif protocol.conn_info is not None and protocol.conn_info.lost:\n        # Terminus. Most connections finish the protocol here!\n        # Connection_lost callback was executed already,\n        # so transport did complete and close itself properly.\n        # No need to call abort().\n\n        # This is the last part of cleanup to do\n        # that is not done by connection_lost handler.\n        # Ensure transport is cleaned up by GC.\n        protocol.transport = None\n        return\n    elif not protocol.transport.is_closing():\n        raise RuntimeError(\n            \"You must call transport.close() before \"\n            \"protocol._async_transport_close() runs.\"\n        )\n\n    write_is_paused = not protocol._can_write.is_set()\n    try:\n        # in UVLoop, get the data in the libuv write-buffer\n        data_left = protocol.transport.get_write_buffer_size()\n    # Some asyncio implementations don't support get_write_buffer_size\n    except (AttributeError, NotImplementedError):\n        data_left = 0\n    if write_is_paused or data_left > 0:\n        # don't need to call resume_writing here to unpause\n        if timeout <= 0:\n            # timeout is 0 or less, so we can simply abort now\n            loop.call_soon(SanicProtocol.abort, protocol)\n        else:\n            next_check_interval = min(timeout, 0.1)\n            next_check_timeout = timeout - next_check_interval\n            loop.call_later(\n                # Recurse back in after the timeout, to check again\n                next_check_interval,\n                # this next time with reduced timeout.\n                _async_protocol_transport_close,\n                protocol,\n                loop,\n                next_check_timeout,\n            )\n    else:\n        # Not paused, and no data left in the buffer, but transport\n        # is still open, connection_lost has not been called yet.\n        # We can call abort() to fix that.\n        loop.call_soon(SanicProtocol.abort, protocol)"
    },
    {
      "chunk_id": 1098,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "from collections.abc import Sequence\nfrom typing import Optional, cast\n\ntry:  # websockets >= 11.0\n    from websockets.protocol import State  # type: ignore\n    from websockets.server import ServerProtocol  # type: ignore\nexcept ImportError:  # websockets < 11.0\n    from websockets.connection import State\n    from websockets.server import ServerConnection as ServerProtocol\n\nfrom websockets import http11\nfrom websockets.datastructures import Headers as WSHeaders\nfrom websockets.typing import Subprotocol\n\nfrom sanic.exceptions import SanicException\nfrom sanic.log import access_logger, websockets_logger\nfrom sanic.request import Request\nfrom sanic.server import HttpProtocol\n\nfrom ..websockets.impl import WebsocketImplProtocol\n\nOPEN = State.OPEN\nCLOSING = State.CLOSING\nCLOSED = State.CLOSED"
    },
    {
      "chunk_id": 1099,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "class WebSocketProtocol(HttpProtocol):\n    __slots__ = (\n        \"websocket\",\n        \"websocket_timeout\",\n        \"websocket_max_size\",\n        \"websocket_ping_interval\",\n        \"websocket_ping_timeout\",\n        \"websocket_url\",\n        \"websocket_peer\",\n    )\n\n    def __init__(\n        self,\n        *args,\n        websocket_timeout: float = 10.0,\n        websocket_max_size: Optional[int] = None,\n        websocket_ping_interval: Optional[float] = 20.0,\n        websocket_ping_timeout: Optional[float] = 20.0,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.websocket: Optional[WebsocketImplProtocol] = None\n        self.websocket_timeout = websocket_timeout\n        self.websocket_max_size = websocket_max_size\n        self.websocket_ping_interval = websocket_ping_interval\n        self.websocket_ping_timeout = websocket_ping_timeout\n        self.websocket_url: Optional[str] = None\n        self.websocket_peer: Optional[str] = None"
    },
    {
      "chunk_id": 1100,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def connection_lost(self, exc):\n        if self.websocket is not None:\n            self.websocket.connection_lost(exc)\n        super().connection_lost(exc)\n        self.log_websocket(\"CLOSE\")\n        self.websocket_url = None\n        self.websocket_peer = None"
    },
    {
      "chunk_id": 1101,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def data_received(self, data):\n        if self.websocket is not None:\n            self.websocket.data_received(data)\n        else:\n            # Pass it to HttpProtocol handler first\n            # That will (hopefully) upgrade it to a websocket.\n            super().data_received(data)"
    },
    {
      "chunk_id": 1102,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def eof_received(self) -> Optional[bool]:\n        if self.websocket is not None:\n            return self.websocket.eof_received()\n        else:\n            return False"
    },
    {
      "chunk_id": 1103,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def close(self, timeout: Optional[float] = None):\n        # Called by HttpProtocol at the end of connection_task\n        # If we've upgraded to websocket, we do our own closing\n        if self.websocket is not None:\n            # Note, we don't want to use websocket.close()\n            # That is used for user's application code to send a\n            # websocket close packet. This is different.\n            self.websocket.end_connection(1001)\n        else:\n            super().close()"
    },
    {
      "chunk_id": 1104,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def close_if_idle(self):\n        # Called by Sanic Server when shutting down\n        # If we've upgraded to websocket, shut it down\n        if self.websocket is not None:\n            if self.websocket.ws_proto.state in (CLOSING, CLOSED):\n                return True\n            elif self.websocket.loop is not None:\n                self.websocket.loop.create_task(self.websocket.close(1001))\n            else:\n                self.websocket.end_connection(1001)\n        else:\n            return super().close_if_idle()"
    },
    {
      "chunk_id": 1105,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "@staticmethod\n    def sanic_request_to_ws_request(request: Request):\n        return http11.Request(\n            path=request.path,\n            headers=WSHeaders(request.headers),\n        )"
    },
    {
      "chunk_id": 1106,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "async def websocket_handshake(\n        self, request, subprotocols: Optional[Sequence[str]] = None\n    ):\n        # let the websockets package do the handshake with the client\n        try:\n            if subprotocols is not None:\n                # subprotocols can be a set or frozenset,\n                # but ServerProtocol needs a list\n                subprotocols = cast(\n                    Optional[Sequence[Subprotocol]],\n                    list(\n                        [\n                            Subprotocol(subprotocol)\n                            for subprotocol in subprotocols\n                        ]\n                    ),\n                )\n            ws_proto = ServerProtocol(\n                max_size=self.websocket_max_size,\n                subprotocols=subprotocols,\n                state=OPEN,\n                logger=websockets_logger,\n            )\n            resp = ws_proto.accept(self.sanic_request_to_ws_request(request))\n        except Exception:\n            msg = (\n                \"Failed to open a WebSocket connection.\\n\"\n                \"See server log for more information.\\n\"\n            )\n            raise SanicException(msg, status_code=500)\n        if 100 <= resp.status_code <= 299:\n            first_line = (\n                f\"HTTP/1.1 {resp.status_code} {resp.reason_phrase}\\r\\n\"\n            ).encode()\n            rbody = bytearray(first_line)\n            rbody += (\n                \"\".join([f\"{k}: {v}\\r\\n\" for k, v in resp.headers.items()])\n            ).encode()\n            rbody += b\"\\r\\n\"\n            if resp.body is not None:\n                rbody += resp.body\n                rbody += b\"\\r\\n\\r\\n\"\n            await super().send(rbody)\n        else:\n            raise SanicException(resp.body, resp.status_code)\n        self.websocket = WebsocketImplProtocol(\n            ws_proto,\n            ping_interval=self.websocket_ping_interval,\n            ping_timeout=self.websocket_ping_timeout,\n            close_timeout=self.websocket_timeout,\n        )\n        loop = (\n            request.transport.loop\n            if hasattr(request, \"transport\")\n            and hasattr(request.transport, \"loop\")\n            else None\n        )\n        await self.websocket.connection_made(self, loop=loop)\n        self.websocket_url = self._http.request.url\n        self.websocket_peer = f\"{id(self):X}\"[-5:-1] + \"unx\"\n        if ip := self._http.request.client_ip:\n            self.websocket_peer = f\"{ip}:{self._http.request.port}\"\n        self.log_websocket(\"OPEN\")\n        return self.websocket"
    },
    {
      "chunk_id": 1107,
      "source": "__internal__/data_repo/sanic/sanic/server/protocols/websocket_protocol.py",
      "content": "def log_websocket(self, message):\n        if not self.access_log or not self.websocket_url:\n            return\n        status = \"\"\n        close = \"\"\n        try:\n            # Can we get some useful statistics?\n            p = self.websocket.ws_proto\n            state = p.state\n            if state == CLOSED:\n                codes = {\n                    1000: \"NORMAL\",\n                    1001: \"GOING AWAY\",\n                    1005: \"NO STATUS\",\n                    1006: \"ABNORMAL\",\n                    1011: \"SERVER ERR\",\n                }\n                if p.close_code == 1006:\n                    message = \"CLOSE_ABN\"\n                scode = rcode = 1006  # Abnormal closure (disconnection)\n                sdesc = rdesc = \"\"\n                if p.close_sent:\n                    scode = p.close_sent.code\n                    sdesc = p.close_sent.reason\n                if p.close_rcvd:\n                    rcode = p.close_rcvd.code\n                    rdesc = p.close_rcvd.reason\n                # Use repr() to escape any control characters\n                sdesc = repr(sdesc[:256]) if sdesc else codes.get(scode, \"\")\n                rdesc = repr(rdesc[:256]) if rdesc else codes.get(rcode, \"\")\n                if p.close_rcvd_then_sent or scode == 1006:\n                    status = rcode\n                    close = (\n                        f\"{rdesc} from client\"\n                        if scode in (rcode, 1006)\n                        else f\"{rdesc} \u25bc\u25b2 {scode} {sdesc}\"\n                    )\n                else:\n                    status = scode\n                    close = (\n                        f\"{sdesc} from server\"\n                        if rcode in (scode, 1006)\n                        else f\"{sdesc} \u25b2\u25bc {rcode} {rdesc}\"\n                    )\n\n        except AttributeError:\n            ...\n        extra = {\n            \"status\": status,\n            \"byte\": close,\n            \"host\": self.websocket_peer,\n            \"request\": f\" \ud83d\udd0c {self.websocket_url}\",\n            \"duration\": \"\",\n        }\n        access_logger.info(message, extra=extra)"
    },
    {
      "chunk_id": 1108,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1109,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1110,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1111,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "def method_one(self):\n        return self.value + 1"
    },
    {
      "chunk_id": 1112,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "def method_two(self):\n        return self.value * 2"
    },
    {
      "chunk_id": 1113,
      "source": "__internal__/data_repo/sanic/sanic/application/__init__.py",
      "content": "def standalone_function(param):\n    return param ** 2\n```"
    },
    {
      "chunk_id": 1114,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "from abc import ABC, abstractmethod\nfrom shutil import get_terminal_size\nfrom textwrap import indent, wrap\nfrom typing import Optional\n\nfrom sanic import __version__\nfrom sanic.helpers import is_atty\nfrom sanic.log import logger"
    },
    {
      "chunk_id": 1115,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "class MOTD(ABC):\n    \"\"\"Base class for the Message of the Day (MOTD) display.\"\"\"\n\n    def __init__(\n        self,\n        logo: Optional[str],\n        serve_location: str,\n        data: dict[str, str],\n        extra: dict[str, str],\n    ) -> None:\n        self.logo = logo\n        self.serve_location = serve_location\n        self.data = data\n        self.extra = extra\n        self.key_width = 0\n        self.value_width = 0\n\n    @abstractmethod\n    def display(self):\n        \"\"\"Display the MOTD.\"\"\"\n\n    @classmethod\n    def output(\n        cls,\n        logo: Optional[str],\n        serve_location: str,\n        data: dict[str, str],\n        extra: dict[str, str],\n    ) -> None:\n        \"\"\"Output the MOTD.\n\n        Args:\n            logo (Optional[str]): Logo to display.\n            serve_location (str): Location to serve.\n            data (Dict[str, str]): Data to display.\n            extra (Dict[str, str]): Extra data to display.\n        \"\"\"\n        motd_class = MOTDTTY if is_atty() else MOTDBasic\n        motd_class(logo, serve_location, data, extra).display()"
    },
    {
      "chunk_id": 1116,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "class MOTDBasic(MOTD):\n    \"\"\"A basic MOTD display.\n\n    This is used when the terminal does not support ANSI escape codes.\n    \"\"\"\n\n    def display(self):\n        if self.logo:\n            logger.debug(self.logo)\n        lines = [f\"Sanic v{__version__}\"]\n        if self.serve_location:\n            lines.append(f\"Goin' Fast @ {self.serve_location}\")\n        lines += [\n            *(f\"{key}: {value}\" for key, value in self.data.items()),\n            *(f\"{key}: {value}\" for key, value in self.extra.items()),\n        ]\n        for line in lines:\n            logger.info(line)"
    },
    {
      "chunk_id": 1117,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "class MOTDTTY(MOTD):\n    \"\"\"A MOTD display for terminals that support ANSI escape codes.\"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.set_variables()\n\n    def set_variables(self):  # no  cov\n        \"\"\"Set the variables used for display.\"\"\"\n        fallback = (108, 24)\n        terminal_width = max(\n            get_terminal_size(fallback=fallback).columns, fallback[0]\n        )\n        self.max_value_width = terminal_width - fallback[0] + 36\n\n        self.key_width = 4\n        self.value_width = self.max_value_width\n        if self.data:\n            self.key_width = max(map(len, self.data.keys()))\n            self.value_width = min(\n                max(map(len, self.data.values())), self.max_value_width\n            )\n        if self.extra:\n            self.key_width = max(\n                self.key_width, max(map(len, self.extra.keys()))\n            )\n            self.value_width = min(\n                max((*map(len, self.extra.values()), self.value_width)),\n                self.max_value_width,\n            )\n        self.logo_lines = self.logo.split(\"\\n\") if self.logo else []\n        self.logo_line_length = 24\n        self.centering_length = (\n            self.key_width + self.value_width + 2 + self.logo_line_length\n        )\n        self.display_length = self.key_width + self.value_width + 2"
    },
    {
      "chunk_id": 1118,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "def display(self, version=True, action=\"Goin' Fast\", out=None):\n        \"\"\"Display the MOTD.\n\n        Args:\n            version (bool, optional): Display the version. Defaults to `True`.\n            action (str, optional): Action to display. Defaults to\n                `\"Goin' Fast\"`.\n            out (Optional[Callable], optional): Output function. Defaults to\n                `None`.\n        \"\"\"\n        if not out:\n            out = logger.info\n        header = \"Sanic\"\n        if version:\n            header += f\" v{__version__}\"\n        header = header.center(self.centering_length)\n        running = (\n            f\"{action} @ {self.serve_location}\" if self.serve_location else \"\"\n        ).center(self.centering_length)\n        length = len(header) + 2 - self.logo_line_length\n        first_filler = \"\u2500\" * (self.logo_line_length - 1)\n        second_filler = \"\u2500\" * length\n        display_filler = \"\u2500\" * (self.display_length + 2)\n        lines = [\n            f\"\\n\u250c{first_filler}\u2500{second_filler}\u2510\",\n            f\"\u2502 {header} \u2502\",\n            f\"\u2502 {running} \u2502\",\n            f\"\u251c{first_filler}\u252c{second_filler}\u2524\",\n        ]\n\n        self._render_data(lines, self.data, 0)\n        if self.extra:\n            logo_part = self._get_logo_part(len(lines) - 4)\n            lines.append(f\"\u2502 {logo_part} \u251c{display_filler}\u2524\")\n            self._render_data(lines, self.extra, len(lines) - 4)\n\n        self._render_fill(lines)\n\n        lines.append(f\"\u2514{first_filler}\u2534{second_filler}\u2518\\n\")\n        out(indent(\"\\n\".join(lines), \"  \"))"
    },
    {
      "chunk_id": 1119,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "def _render_data(self, lines, data, start):\n        offset = 0\n        for idx, (key, value) in enumerate(data.items(), start=start):\n            key = key.rjust(self.key_width)\n\n            wrapped = wrap(value, self.max_value_width, break_on_hyphens=False)\n            for wrap_index, part in enumerate(wrapped):\n                part = part.ljust(self.value_width)\n                logo_part = self._get_logo_part(idx + offset + wrap_index)\n                display = (\n                    f\"{key}: {part}\"\n                    if wrap_index == 0\n                    else (\" \" * len(key) + f\"  {part}\")\n                )\n                lines.append(f\"\u2502 {logo_part} \u2502 {display} \u2502\")\n                if wrap_index:\n                    offset += 1"
    },
    {
      "chunk_id": 1120,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "def _render_fill(self, lines):\n        filler = \" \" * self.display_length\n        idx = len(lines) - 5\n        for i in range(1, len(self.logo_lines) - idx):\n            logo_part = self.logo_lines[idx + i]\n            lines.append(f\"\u2502 {logo_part} \u2502 {filler} \u2502\")"
    },
    {
      "chunk_id": 1121,
      "source": "__internal__/data_repo/sanic/sanic/application/motd.py",
      "content": "def _get_logo_part(self, idx):\n        try:\n            logo_part = self.logo_lines[idx]\n        except IndexError:\n            logo_part = \" \" * (self.logo_line_length - 3)\n        return logo_part"
    },
    {
      "chunk_id": 1122,
      "source": "__internal__/data_repo/sanic/sanic/application/constants.py",
      "content": "from enum import Enum, IntEnum, auto"
    },
    {
      "chunk_id": 1123,
      "source": "__internal__/data_repo/sanic/sanic/application/constants.py",
      "content": "class StrEnum(str, Enum):  # no cov\n    def _generate_next_value_(name: str, *args) -> str:  # type: ignore\n        return name.lower()\n\n    def __eq__(self, value: object) -> bool:\n        value = str(value).upper()\n        return super().__eq__(value)\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def __str__(self) -> str:\n        return self.value"
    },
    {
      "chunk_id": 1124,
      "source": "__internal__/data_repo/sanic/sanic/application/constants.py",
      "content": "class Server(StrEnum):\n    \"\"\"Server types.\"\"\"\n\n    SANIC = auto()\n    ASGI = auto()"
    },
    {
      "chunk_id": 1125,
      "source": "__internal__/data_repo/sanic/sanic/application/constants.py",
      "content": "class Mode(StrEnum):\n    \"\"\"Server modes.\"\"\"\n\n    PRODUCTION = auto()\n    DEBUG = auto()"
    },
    {
      "chunk_id": 1126,
      "source": "__internal__/data_repo/sanic/sanic/application/constants.py",
      "content": "class ServerStage(IntEnum):\n    \"\"\"Server stages.\"\"\"\n\n    STOPPED = auto()\n    PARTIAL = auto()\n    SERVING = auto()"
    },
    {
      "chunk_id": 1127,
      "source": "__internal__/data_repo/sanic/sanic/application/ext.py",
      "content": "from __future__ import annotations\n\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom typing import TYPE_CHECKING\n\n\nif TYPE_CHECKING:\n    from sanic import Sanic"
    },
    {
      "chunk_id": 1128,
      "source": "__internal__/data_repo/sanic/sanic/application/ext.py",
      "content": "def setup_ext(app: Sanic, *, fail: bool = False, **kwargs):\n    \"\"\"Setup Sanic Extensions.\n\n    Requires Sanic Extensions to be installed.\n\n    Args:\n        app (Sanic): Sanic application.\n        fail (bool, optional): Raise an error if Sanic Extensions is not\n            installed. Defaults to `False`.\n        **kwargs: Keyword arguments to pass to `sanic_ext.Extend`.\n\n    Returns:\n        sanic_ext.Extend: Sanic Extensions instance.\n    \"\"\"\n\n    if not app.config.AUTO_EXTEND:\n        return\n\n    sanic_ext = None\n    with suppress(ModuleNotFoundError):\n        sanic_ext = import_module(\"sanic_ext\")\n\n    if not sanic_ext:  # no cov\n        if fail:\n            raise RuntimeError(\n                \"Sanic Extensions is not installed. You can add it to your \"\n                \"environment using:\\n$ pip install sanic[ext]\\nor\\n$ pip \"\n                \"install sanic-ext\"\n            )\n\n        return\n\n    if not getattr(app, \"_ext\", None):\n        Ext = getattr(sanic_ext, \"Extend\")\n        app._ext = Ext(app, **kwargs)\n\n        return app.ext"
    },
    {
      "chunk_id": 1129,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "import os\nimport sys\nimport time\n\nfrom contextlib import contextmanager\nfrom queue import Queue\nfrom threading import Thread\n\n\nif os.name == \"nt\":  # noqa\n    import ctypes  # noqa\n\n    class _CursorInfo(ctypes.Structure):\n        _fields_ = [(\"size\", ctypes.c_int), (\"visible\", ctypes.c_byte)]"
    },
    {
      "chunk_id": 1130,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "class Spinner:  # noqa\n    \"\"\"Spinner class to show a loading spinner in the terminal.\n\n    Used internally by the `loading` context manager.\n    \"\"\"\n\n    def __init__(self, message: str) -> None:\n        self.message = message\n        self.queue: Queue[int] = Queue()\n        self.spinner = self.cursor()\n        self.thread = Thread(target=self.run)"
    },
    {
      "chunk_id": 1131,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "def start(self):\n        self.queue.put(1)\n        self.thread.start()\n        self.hide()"
    },
    {
      "chunk_id": 1132,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "def run(self):\n        while self.queue.get():\n            output = f\"\\r{self.message} [{next(self.spinner)}]\"\n            sys.stdout.write(output)\n            sys.stdout.flush()\n            time.sleep(0.1)\n            self.queue.put(1)"
    },
    {
      "chunk_id": 1133,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "def stop(self):\n        self.queue.put(0)\n        self.thread.join()\n        self.show()"
    },
    {
      "chunk_id": 1134,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "@staticmethod\n    def cursor():\n        while True:\n            yield from \"|/-\\\\\""
    },
    {
      "chunk_id": 1135,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "@staticmethod\n    def hide():\n        if os.name == \"nt\":\n            ci = _CursorInfo()\n            handle = ctypes.windll.kernel32.GetStdHandle(-11)\n            ctypes.windll.kernel32.GetConsoleCursorInfo(\n                handle, ctypes.byref(ci)\n            )\n            ci.visible = False\n            ctypes.windll.kernel32.SetConsoleCursorInfo(\n                handle, ctypes.byref(ci)\n            )\n        elif os.name == \"posix\":\n            sys.stdout.write(\"\\033[?25l\")\n            sys.stdout.flush()"
    },
    {
      "chunk_id": 1136,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "@staticmethod\n    def show():\n        if os.name == \"nt\":\n            ci = _CursorInfo()\n            handle = ctypes.windll.kernel32.GetStdHandle(-11)\n            ctypes.windll.kernel32.GetConsoleCursorInfo(\n                handle, ctypes.byref(ci)\n            )\n            ci.visible = True\n            ctypes.windll.kernel32.SetConsoleCursorInfo(\n                handle, ctypes.byref(ci)\n            )\n        elif os.name == \"posix\":\n            sys.stdout.write(\"\\033[?25h\")\n            sys.stdout.flush()"
    },
    {
      "chunk_id": 1137,
      "source": "__internal__/data_repo/sanic/sanic/application/spinner.py",
      "content": "@contextmanager\ndef loading(message: str = \"Loading\"):  # noqa\n    spinner = Spinner(message)\n    spinner.start()\n    yield\n    spinner.stop()"
    },
    {
      "chunk_id": 1138,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "from __future__ import annotations\n\nimport logging\n\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom socket import socket\nfrom ssl import SSLContext\nfrom typing import TYPE_CHECKING, Any, Optional, Union\n\nfrom sanic.application.constants import Mode, Server, ServerStage\nfrom sanic.log import VerbosityFilter, logger\nfrom sanic.server.async_server import AsyncioServer"
    },
    {
      "chunk_id": 1139,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "@dataclass\nclass ApplicationServerInfo:\n    \"\"\"Information about a server instance.\"\"\"\n\n    settings: dict[str, Any]\n    stage: ServerStage = field(default=ServerStage.STOPPED)\n    server: Optional[AsyncioServer] = field(default=None)"
    },
    {
      "chunk_id": 1140,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "@dataclass\nclass ApplicationState:\n    \"\"\"Application state.\n\n    This class is used to store the state of the application. It is\n    instantiated by the application and is available as `app.state`.\n    \"\"\"\n\n    app: Sanic\n    asgi: bool = field(default=False)\n    coffee: bool = field(default=False)\n    fast: bool = field(default=False)\n    host: str = field(default=\"\")\n    port: int = field(default=0)\n    ssl: Optional[SSLContext] = field(default=None)\n    sock: Optional[socket] = field(default=None)\n    unix: Optional[str] = field(default=None)\n    mode: Mode = field(default=Mode.PRODUCTION)\n    reload_dirs: set[Path] = field(default_factory=set)\n    auto_reload: bool = field(default=False)\n    server: Server = field(default=Server.SANIC)\n    is_running: bool = field(default=False)\n    is_started: bool = field(default=False)\n    is_stopping: bool = field(default=False)\n    verbosity: int = field(default=0)\n    workers: int = field(default=0)\n    primary: bool = field(default=True)\n    server_info: list[ApplicationServerInfo] = field(default_factory=list)\n\n    # This property relates to the ApplicationState instance and should\n    # not be changed except in the __post_init__ method\n    _init: bool = field(default=False)\n\n    def __post_init__(self) -> None:\n        self._init = True\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        if self._init and name == \"_init\":\n            raise RuntimeError(\n                \"Cannot change the value of _init after instantiation\"\n            )\n        super().__setattr__(name, value)\n        if self._init and hasattr(self, f\"set_{name}\"):\n            getattr(self, f\"set_{name}\")(value)"
    },
    {
      "chunk_id": 1141,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "def set_mode(self, value: Union[str, Mode]):\n    if hasattr(self.app, \"error_handler\"):\n        self.app.error_handler.debug = self.app.debug\n    if getattr(self.app, \"configure_logging\", False) and self.app.debug:\n        logger.setLevel(logging.DEBUG)"
    },
    {
      "chunk_id": 1142,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "def set_verbosity(self, value: int) -> None:\n    \"\"\"Set the verbosity level.\n\n    Args:\n        value (int): Verbosity level.\n    \"\"\"\n    VerbosityFilter.verbosity = value"
    },
    {
      "chunk_id": 1143,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "@property\ndef is_debug(self) -> bool:\n    \"\"\"Check if the application is in debug mode.\n\n    Returns:\n        bool: `True` if the application is in debug mode, `False`\n            otherwise.\n    \"\"\"\n    return self.mode is Mode.DEBUG"
    },
    {
      "chunk_id": 1144,
      "source": "__internal__/data_repo/sanic/sanic/application/state.py",
      "content": "@property\ndef stage(self) -> ServerStage:\n    \"\"\"Get the server stage.\n\n    Returns:\n        ServerStage: Server stage.\n    \"\"\"\n    if not self.server_info:\n        return ServerStage.STOPPED\n\n    if all(info.stage is ServerStage.SERVING for info in self.server_info):\n        return ServerStage.SERVING\n    elif any(\n        info.stage is ServerStage.SERVING for info in self.server_info\n    ):\n        return ServerStage.PARTIAL\n\n    return ServerStage.STOPPED"
    },
    {
      "chunk_id": 1145,
      "source": "__internal__/data_repo/sanic/sanic/application/logo.py",
      "content": "import re\nimport sys\n\nfrom os import environ\n\nfrom sanic.helpers import is_atty"
    },
    {
      "chunk_id": 1146,
      "source": "__internal__/data_repo/sanic/sanic/application/logo.py",
      "content": "BASE_LOGO = \"\"\"\n\n                 Sanic\n         Build Fast. Run Fast.\n\n\"\"\"\nCOFFEE_LOGO = \"\"\"\\033[48;2;255;13;104m                     \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m     \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584      \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m    \u2588\u2588       \u2588\u2588\u2580\u2580\u2584   \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588   \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2584\u2580   \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m     \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580       \\033[0m\n\\033[48;2;255;13;104m                     \\033[0m\nDark roast. No sugar.\"\"\"\n\nCOLOR_LOGO = \"\"\"\\033[48;2;255;13;104m                     \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m    \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m   \u2588\u2588                \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m    \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2584    \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m                \u2588\u2588   \\033[0m\n\\033[38;2;255;255;255;48;2;255;13;104m   \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580    \\033[0m\n\\033[48;2;255;13;104m                     \\033[0m\nBuild Fast. Run Fast.\"\"\"\n\nFULL_COLOR_LOGO = \"\"\"\n\n\\033[38;2;255;13;104m  \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \\033[0m     \u2584\u2588\u2584      \u2588\u2588       \u2588   \u2588   \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\\033[38;2;255;13;104m \u2588\u2588             \\033[0m    \u2588   \u2588     \u2588 \u2588\u2588     \u2588   \u2588  \u2588\u2588\n\\033[38;2;255;13;104m  \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2584 \\033[0m   \u2580     \u2588    \u2588   \u2588\u2588   \u2584   \u2588  \u2588\u2588\n\\033[38;2;255;13;104m              \u2588\u2588\\033[0m  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588     \u2588\u2588 \u2588   \u2588  \u2584\u2584\n\\033[38;2;255;13;104m \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \\033[0m \u2588         \u2588  \u2588       \u2588\u2588   \u2588   \u2580\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\n\"\"\"  # noqa\n\nSVG_LOGO_SIMPLE = \"\"\"<svg id=logo-simple viewBox=\"0 0 964 279\"><desc>Sanic</desc><path d=\"M107 222c9-2 10-20 1-22s-20-2-30-2-17 7-16 14 6 10 15 10h30zm115-1c16-2 30-11 35-23s6-24 2-33-6-14-15-20-24-11-38-10c-7 3-10 13-5 19s17-1 24 4 15 14 13 24-5 15-14 18-50 0-74 0h-17c-6 4-10 15-4 20s16 2 23 3zM251 83q9-1 9-7 0-15-10-16h-13c-10 6-10 20 0 22zM147 60c-4 0-10 3-11 11s5 13 10 12 42 0 67 0c5-3 7-10 6-15s-4-8-9-8zm-33 1c-8 0-16 0-24 3s-20 10-25 20-6 24-4 36 15 22 26 27 78 8 94 3c4-4 4-12 0-18s-69 8-93-10c-8-7-9-23 0-30s12-10 20-10 12 2 16-3 1-15-5-18z\" fill=\"#ff0d68\"/><path d=\"M676 74c0-14-18-9-20 0s0 30 0 39 20 9 20 2zm-297-10c-12 2-15 12-23 23l-41 58H340l22-30c8-12 23-13 30-4s20 24 24 38-10 10-17 10l-68 2q-17 1-48 30c-7 6-10 20 0 24s15-8 20-13 20 -20 58-21h50 c20 2 33 9 52 30 8 10 24-4 16-13L384 65q-3-2-5-1zm131 0c-10 1-12 12-11 20v96c1 10-3 23 5 32s20-5 17-15c0-23-3-46 2-67 5-12 22-14 32-5l103 87c7 5 19 1 18-9v-64c-3-10-20-9-21 2s-20 22-30 13l-97-80c-5-4-10-10-18-10zM701 76v128c2 10 15 12 20 4s0-102 0-124s-20-18-20-7z M850 63c-35 0-69-2-86 15s-20 60-13 66 13 8 16 0 1-10 1-27 12-26 20-32 66-5 85-5 31 4 31-10-18-7-54-7M764 159c-6-2-15-2-16 12s19 37 33 43 23 8 25-4-4-11-11-14q-9-3-22-18c-4-7-3-16-10-19zM828 196c-4 0-8 1-10 5s-4 12 0 15 8 2 12 2h60c5 0 10-2 12-6 3-7-1-16-8-16z\" fill=\"#1f1f1f\"/></svg>\"\"\"  # noqa"
    },
    {
      "chunk_id": 1147,
      "source": "__internal__/data_repo/sanic/sanic/application/logo.py",
      "content": "def get_logo(full: bool = False, coffee: bool = False) -> str:\n    \"\"\"Get the Sanic logo.\n\n    Will return the full color logo if the terminal supports it.\n\n    Args:\n        full (bool, optional): Use the full color logo. Defaults to `False`.\n        coffee (bool, optional): Use the coffee logo. Defaults to `False`.\n\n    Returns:\n        str: Sanic logo.\n    \"\"\"\n    logo = (\n        (FULL_COLOR_LOGO if full else (COFFEE_LOGO if coffee else COLOR_LOGO))\n        if is_atty()\n        else BASE_LOGO\n    )\n\n    if (\n        sys.platform == \"darwin\"\n        and environ.get(\"TERM_PROGRAM\") == \"Apple_Terminal\"\n    ):\n        logo = ansi_pattern.sub(\"\", logo)\n\n    return logo"
    },
    {
      "chunk_id": 1148,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "import asyncio\n\nimport httpx\n\nfrom sanic import Sanic\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1149,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "app = Sanic(\"Example\")\n\nsem = None"
    },
    {
      "chunk_id": 1150,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "@app.before_server_start\ndef init(sanic, _):\n    global sem\n    concurrency_per_worker = 4\n    sem = asyncio.Semaphore(concurrency_per_worker)"
    },
    {
      "chunk_id": 1151,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "async def bounded_fetch(session, url):\n    \"\"\"\n    Use session object to perform 'get' request on url\n    \"\"\"\n    async with sem:\n        response = await session.get(url)\n        return response.json()"
    },
    {
      "chunk_id": 1152,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    \"\"\"\n    Download and serve example JSON\n    \"\"\"\n    url = \"https://api.github.com/repos/sanic-org/sanic\"\n\n    async with httpx.AsyncClient() as session:\n        response = await bounded_fetch(session, url)\n        return json(response)"
    },
    {
      "chunk_id": 1153,
      "source": "__internal__/data_repo/sanic/examples/limit_concurrency.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, workers=2)"
    },
    {
      "chunk_id": 1154,
      "source": "__internal__/data_repo/sanic/examples/redirect_example.py",
      "content": "from sanic import Sanic, response"
    },
    {
      "chunk_id": 1155,
      "source": "__internal__/data_repo/sanic/examples/redirect_example.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1156,
      "source": "__internal__/data_repo/sanic/examples/redirect_example.py",
      "content": "@app.route(\"/\")\ndef handle_request(request):\n    return response.redirect(\"/redirect\")"
    },
    {
      "chunk_id": 1157,
      "source": "__internal__/data_repo/sanic/examples/redirect_example.py",
      "content": "@app.route(\"/redirect\")\nasync def test(request):\n    return response.json({\"Redirected\": True})"
    },
    {
      "chunk_id": 1158,
      "source": "__internal__/data_repo/sanic/examples/redirect_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1159,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "\"\"\"pytest-xdist example for sanic server\n\nInstall testing tools:\n\n    $ pip install pytest pytest-xdist\n\nRun with xdist params:\n\n    $ pytest examples/pytest_xdist.py -n 8  # 8 workers\n\"\"\""
    },
    {
      "chunk_id": 1160,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "import re\n\nimport pytest\n\nfrom sanic_testing import SanicTestClient\nfrom sanic_testing.testing import PORT as PORT_BASE\n\nfrom sanic import Sanic\nfrom sanic.response import text"
    },
    {
      "chunk_id": 1161,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "@pytest.fixture(scope=\"session\")\ndef test_port(worker_id):\n    m = re.search(r\"[0-9]+\", worker_id)\n    if m:\n        num_id = m.group(0)\n    else:\n        num_id = 0\n    port = PORT_BASE + int(num_id)\n    return port"
    },
    {
      "chunk_id": 1162,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "@pytest.fixture(scope=\"session\")\ndef app():\n    app = Sanic(\"Example\")\n\n    @app.route(\"/\")\n    async def index(request):\n        return text(\"OK\")\n\n    return app"
    },
    {
      "chunk_id": 1163,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "@pytest.fixture(scope=\"session\")\ndef client(app, test_port):\n    return SanicTestClient(app, test_port)"
    },
    {
      "chunk_id": 1164,
      "source": "__internal__/data_repo/sanic/examples/pytest_xdist.py",
      "content": "@pytest.mark.parametrize(\"run_id\", range(100))\ndef test_index(client, run_id):\n    request, response = client._sanic_endpoint_test(\"get\", \"/\")\n    assert response.status == 200\n    assert response.text == \"OK\""
    },
    {
      "chunk_id": 1165,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "import logging\nimport socket\n\nfrom os import getenv\nfrom platform import node\nfrom uuid import getnode as get_mac\n\nfrom logdna import LogDNAHandler\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1166,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "log = logging.getLogger(\"logdna\")\nlog.setLevel(logging.INFO)"
    },
    {
      "chunk_id": 1167,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "def get_my_ip_address(remote_server=\"google.com\"):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n        s.connect((remote_server, 80))\n        return s.getsockname()[0]"
    },
    {
      "chunk_id": 1168,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "def get_mac_address():\n    h = iter(hex(get_mac())[2:].zfill(12))\n    return \":\".join(i + next(h) for i in h)"
    },
    {
      "chunk_id": 1169,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "logdna_options = {\n    \"app\": __name__,\n    \"index_meta\": True,\n    \"hostname\": node(),\n    \"ip\": get_my_ip_address(),\n    \"mac\": get_mac_address(),\n}"
    },
    {
      "chunk_id": 1170,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "logdna_handler = LogDNAHandler(\n    getenv(\"LOGDNA_API_KEY\"), options=logdna_options\n)\n\nlogdna = logging.getLogger(__name__)\nlogdna.setLevel(logging.INFO)\nlogdna.addHandler(logdna_handler)"
    },
    {
      "chunk_id": 1171,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1172,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "@app.middleware\ndef log_request(request: Request):\n    logdna.info(\"I was Here with a new Request to URL: {}\".format(request.url))"
    },
    {
      "chunk_id": 1173,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "@app.route(\"/\")\ndef default(request):\n    return json({\"response\": \"I was here\"})"
    },
    {
      "chunk_id": 1174,
      "source": "__internal__/data_repo/sanic/examples/logdna_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=getenv(\"PORT\", 8080))"
    },
    {
      "chunk_id": 1175,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "from sanic import Sanic\nfrom sanic.response import text\nfrom sanic.views import HTTPMethodView"
    },
    {
      "chunk_id": 1176,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "app = Sanic(\"some_name\")"
    },
    {
      "chunk_id": 1177,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "class SimpleView(HTTPMethodView):\n    \"\"\"Simple HTTP methods view.\"\"\"\n    \n    def get(self, request):\n        return text(\"I am get method\")\n\n    def post(self, request):\n        return text(\"I am post method\")\n\n    def put(self, request):\n        return text(\"I am put method\")\n\n    def patch(self, request):\n        return text(\"I am patch method\")\n\n    def delete(self, request):\n        return text(\"I am delete method\")"
    },
    {
      "chunk_id": 1178,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "class SimpleAsyncView(HTTPMethodView):\n    \"\"\"Simple asynchronous HTTP methods view.\"\"\"\n    \n    async def get(self, request):\n        return text(\"I am async get method\")\n\n    async def post(self, request):\n        return text(\"I am async post method\")\n\n    async def put(self, request):\n        return text(\"I am async put method\")"
    },
    {
      "chunk_id": 1179,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "app.add_route(SimpleView.as_view(), \"/\")\napp.add_route(SimpleAsyncView.as_view(), \"/async\")"
    },
    {
      "chunk_id": 1180,
      "source": "__internal__/data_repo/sanic/examples/simple_async_view.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1181,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "import asyncio"
    },
    {
      "chunk_id": 1182,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "from sanic import Sanic, response\nfrom sanic.config import Config\nfrom sanic.exceptions import RequestTimeout"
    },
    {
      "chunk_id": 1183,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "Config.REQUEST_TIMEOUT = 1\napp = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1184,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    await asyncio.sleep(3)\n    return response.text(\"Hello, world!\")"
    },
    {
      "chunk_id": 1185,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "@app.exception(RequestTimeout)\ndef timeout(request, exception):\n    return response.text(\"RequestTimeout from error_handler.\", 408)"
    },
    {
      "chunk_id": 1186,
      "source": "__internal__/data_repo/sanic/examples/request_timeout.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1187,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "from pathlib import Path\n\nfrom sanic import Sanic, response"
    },
    {
      "chunk_id": 1188,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1189,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.route(\"/text\")\ndef handler_text(request):\n    return response.text(\"Hello\")"
    },
    {
      "chunk_id": 1190,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.route(\"/json\")\ndef handler_json(request):\n    return response.json({\"foo\": \"bar\"})"
    },
    {
      "chunk_id": 1191,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.websocket(\"/ws\")\nasync def handler_ws(request, ws):\n    name = \"<someone>\"\n    while True:\n        data = f\"Hello {name}\"\n        await ws.send(data)\n        name = await ws.recv()\n\n        if not name:\n            break"
    },
    {
      "chunk_id": 1192,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.route(\"/file\")\nasync def handler_file(request):\n    return await response.file(Path(\"../\") / \"setup.py\")"
    },
    {
      "chunk_id": 1193,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.route(\"/file_stream\")\nasync def handler_file_stream(request):\n    return await response.file_stream(\n        Path(\"../\") / \"setup.py\", chunk_size=1024\n    )"
    },
    {
      "chunk_id": 1194,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.post(\"/stream\", stream=True)\nasync def handler_stream(request):\n    while True:\n        body = await request.stream.read()\n        if body is None:\n            break\n        body = body.decode(\"utf-8\").replace(\"1\", \"A\")\n        await response.write(body)\n    return response.stream(body)"
    },
    {
      "chunk_id": 1195,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.before_server_start\nasync def listener_before_server_start(*args, **kwargs):\n    print(\"before_server_start\")"
    },
    {
      "chunk_id": 1196,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.after_server_start\nasync def listener_after_server_start(*args, **kwargs):\n    print(\"after_server_start\")"
    },
    {
      "chunk_id": 1197,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.before_server_stop\nasync def listener_before_server_stop(*args, **kwargs):\n    print(\"before_server_stop\")"
    },
    {
      "chunk_id": 1198,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.after_server_stop\nasync def listener_after_server_stop(*args, **kwargs):\n    print(\"after_server_stop\")"
    },
    {
      "chunk_id": 1199,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.on_request\nasync def print_on_request(request):\n    print(\"print_on_request\")"
    },
    {
      "chunk_id": 1200,
      "source": "__internal__/data_repo/sanic/examples/run_asgi.py",
      "content": "@app.on_response\nasync def print_on_response(request, response):\n    print(\"print_on_response\")"
    },
    {
      "chunk_id": 1201,
      "source": "__internal__/data_repo/sanic/examples/static_assets.py",
      "content": "from sanic import Sanic"
    },
    {
      "chunk_id": 1202,
      "source": "__internal__/data_repo/sanic/examples/static_assets.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1203,
      "source": "__internal__/data_repo/sanic/examples/static_assets.py",
      "content": "app.static(\"/\", \"./static\")"
    },
    {
      "chunk_id": 1204,
      "source": "__internal__/data_repo/sanic/examples/teapot.py",
      "content": "from sanic import Sanic\nfrom sanic import response as res"
    },
    {
      "chunk_id": 1205,
      "source": "__internal__/data_repo/sanic/examples/teapot.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1206,
      "source": "__internal__/data_repo/sanic/examples/teapot.py",
      "content": "@app.route(\"/\")\nasync def test(req):\n    return res.text(\"I'm a teapot\", status=418)"
    },
    {
      "chunk_id": 1207,
      "source": "__internal__/data_repo/sanic/examples/teapot.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1208,
      "source": "__internal__/data_repo/sanic/examples/url_for_example.py",
      "content": "from sanic import Sanic, response"
    },
    {
      "chunk_id": 1209,
      "source": "__internal__/data_repo/sanic/examples/url_for_example.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1210,
      "source": "__internal__/data_repo/sanic/examples/url_for_example.py",
      "content": "@app.route(\"/\")\nasync def index(request):\n    # generate a URL for the endpoint `post_handler`\n    url = app.url_for(\"post_handler\", post_id=5)\n    # the URL is `/posts/5`, redirect to it\n    return response.redirect(url)"
    },
    {
      "chunk_id": 1211,
      "source": "__internal__/data_repo/sanic/examples/url_for_example.py",
      "content": "@app.route(\"/posts/<post_id>\")\nasync def post_handler(request, post_id):\n    return response.text(\"Post - {}\".format(post_id))"
    },
    {
      "chunk_id": 1212,
      "source": "__internal__/data_repo/sanic/examples/url_for_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1213,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "from sanic import Sanic, response\nfrom sanic.blueprints import Blueprint"
    },
    {
      "chunk_id": 1214,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "app = Sanic(\"Example\")\nbp = Blueprint(\"bp\", host=\"bp.example.com\")"
    },
    {
      "chunk_id": 1215,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "@app.route(\n    \"/\", host=[\"example.com\", \"somethingelse.com\", \"therestofyourdomains.com\"]\n)\nasync def hello_0(request):\n    return response.text(\"Some defaults\")"
    },
    {
      "chunk_id": 1216,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "@app.route(\"/\", host=\"sub.example.com\")\nasync def hello_1(request):\n    return response.text(\"42\")"
    },
    {
      "chunk_id": 1217,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "@bp.route(\"/question\")\nasync def hello_2(request):\n    return response.text(\"What is the meaning of life?\")"
    },
    {
      "chunk_id": 1218,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "@bp.route(\"/answer\")\nasync def hello_3(request):\n    return response.text(\"42\")"
    },
    {
      "chunk_id": 1219,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "@app.get(\"/name\")\ndef name(request):\n    return response.text(request.app.url_for(\"name\", _external=True))"
    },
    {
      "chunk_id": 1220,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "app.blueprint(bp)"
    },
    {
      "chunk_id": 1221,
      "source": "__internal__/data_repo/sanic/examples/vhosts.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1222,
      "source": "__internal__/data_repo/sanic/examples/run_async.py",
      "content": "import asyncio\n\nimport uvloop\n\nfrom sanic import Sanic, response"
    },
    {
      "chunk_id": 1223,
      "source": "__internal__/data_repo/sanic/examples/run_async.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1224,
      "source": "__internal__/data_repo/sanic/examples/run_async.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    return response.json({\"answer\": \"42\"})"
    },
    {
      "chunk_id": 1225,
      "source": "__internal__/data_repo/sanic/examples/run_async.py",
      "content": "async def main():\n    server = await app.create_server(\n        port=8000, host=\"0.0.0.0\", return_asyncio_server=True\n    )\n\n    if server is None:\n        return\n\n    await server.startup()\n    await server.serve_forever()"
    },
    {
      "chunk_id": 1226,
      "source": "__internal__/data_repo/sanic/examples/run_async.py",
      "content": "if __name__ == \"__main__\":\n    asyncio.set_event_loop(uvloop.new_event_loop())\n    asyncio.run(main())"
    },
    {
      "chunk_id": 1227,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "# -*- coding: utf-8 -*-"
    },
    {
      "chunk_id": 1228,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "from functools import wraps\n\nfrom sanic import Sanic\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1229,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1230,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "def check_request_for_authorization_status(request):\n    # Note: Define your check, for instance cookie, session.\n    flag = True\n    return flag"
    },
    {
      "chunk_id": 1231,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "def authorized(f):\n    @wraps(f)\n    async def decorated_function(request, *args, **kwargs):\n        # run some method that checks the request\n        # for the client's authorization status\n        is_authorized = check_request_for_authorization_status(request)\n\n        if is_authorized:\n            # the user is authorized.\n            # run the handler method and return the response\n            response = await f(request, *args, **kwargs)\n            return response\n        else:\n            # the user is not authorized.\n            return json({\"status\": \"not_authorized\"}, 403)\n\n    return decorated_function"
    },
    {
      "chunk_id": 1232,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "@app.route(\"/\")\n@authorized\nasync def test(request):\n    return json({\"status\": \"authorized\"})"
    },
    {
      "chunk_id": 1233,
      "source": "__internal__/data_repo/sanic/examples/authorized_sanic.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1234,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "from sanic import Sanic\nfrom sanic.response import redirect"
    },
    {
      "chunk_id": 1235,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1236,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "app.static(\"index.html\", \"websocket.html\")"
    },
    {
      "chunk_id": 1237,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "@app.route(\"/\")\ndef index(request):\n    return redirect(\"index.html\")"
    },
    {
      "chunk_id": 1238,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "@app.websocket(\"/feed\")\nasync def feed(request, ws):\n    while True:\n        data = \"hello!\"\n        print(\"Sending: \" + data)\n        await ws.send(data)\n        data = await ws.recv()\n        print(\"Received: \" + data)"
    },
    {
      "chunk_id": 1239,
      "source": "__internal__/data_repo/sanic/examples/websocket.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1240,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "from os import getenv\n\nimport rollbar\n\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.handlers import ErrorHandler\n\n\nrollbar.init(getenv(\"ROLLBAR_API_KEY\"))"
    },
    {
      "chunk_id": 1241,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "class RollbarExceptionHandler(ErrorHandler):\n    \"\"\"Handles exceptions and reports them to Rollbar.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1242,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "def default(self, request, exception):\n        rollbar.report_message(str(exception))\n        return super().default(request, exception)"
    },
    {
      "chunk_id": 1243,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "app = Sanic(\"Example\", error_handler=RollbarExceptionHandler())"
    },
    {
      "chunk_id": 1244,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "@app.route(\"/raise\")\ndef create_error(request):\n    raise SanicException(\"I was here and I don't like where I am\")"
    },
    {
      "chunk_id": 1245,
      "source": "__internal__/data_repo/sanic/examples/rollbar_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=getenv(\"PORT\", 8080))"
    },
    {
      "chunk_id": 1246,
      "source": "__internal__/data_repo/sanic/examples/exception_monitoring.py",
      "content": "```python\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.handlers import ErrorHandler\n```"
    },
    {
      "chunk_id": 1247,
      "source": "__internal__/data_repo/sanic/examples/exception_monitoring.py",
      "content": "```python\nclass CustomHandler(ErrorHandler):\n    def default(self, request, exception):\n        # Here, we have access to the exception object\n        # and can do anything with it (log, send to external service, etc)\n\n        # Some exceptions are trivial and built into Sanic (404s, etc)\n        if not isinstance(exception, SanicException):\n            print(exception)\n\n        # Then, we must finish handling the exception by returning\n        # our response to the client\n        # For this we can just call the super class' default handler\n        return super().default(request, exception)\n```"
    },
    {
      "chunk_id": 1248,
      "source": "__internal__/data_repo/sanic/examples/exception_monitoring.py",
      "content": "```python\nhandler = CustomHandler()\napp = Sanic(\"Example\", error_handler=handler)\n```"
    },
    {
      "chunk_id": 1249,
      "source": "__internal__/data_repo/sanic/examples/exception_monitoring.py",
      "content": "```python\n@app.route(\"/\")\nasync def test(request):\n    # Here, something occurs which causes an unexpected exception\n    # This exception will flow to our custom handler.\n    raise SanicException(\"You Broke It!\")\n```"
    },
    {
      "chunk_id": 1250,
      "source": "__internal__/data_repo/sanic/examples/exception_monitoring.py",
      "content": "```python\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)\n```"
    },
    {
      "chunk_id": 1251,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "from os import getenv\n\nfrom sentry_sdk import init as sentry_init\nfrom sentry_sdk.integrations.sanic import SanicIntegration\n\nfrom sanic import Sanic\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1252,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "sentry_init(\n    dsn=getenv(\"SENTRY_DSN\"),\n    integrations=[SanicIntegration()],\n)"
    },
    {
      "chunk_id": 1253,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1254,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "@app.route(\"/working\")\nasync def working_path(request):\n    return json({\"response\": \"Working API Response\"})"
    },
    {
      "chunk_id": 1255,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "@app.route(\"/raise-error\")\nasync def raise_error(request):\n    raise Exception(\"Testing Sentry Integration\")"
    },
    {
      "chunk_id": 1256,
      "source": "__internal__/data_repo/sanic/examples/sentry_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=getenv(\"PORT\", 8080))"
    },
    {
      "chunk_id": 1257,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "\"\"\"\nModify header or status in response\n\"\"\""
    },
    {
      "chunk_id": 1258,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "from sanic import Sanic, response"
    },
    {
      "chunk_id": 1259,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1260,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "@app.route(\"/\")\ndef handle_request(request):\n    return response.json(\n        {\"message\": \"Hello world!\"},\n        headers={\"X-Served-By\": \"sanic\"},\n        status=200,\n    )"
    },
    {
      "chunk_id": 1261,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "@app.route(\"/unauthorized\")\ndef handle_unauthorized_request(request):\n    return response.json(\n        {\"message\": \"You are not authorized\"},\n        headers={\"X-Served-By\": \"sanic\"},\n        status=404,\n    )"
    },
    {
      "chunk_id": 1262,
      "source": "__internal__/data_repo/sanic/examples/modify_header_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1263,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "# -*- coding: utf-8 -*-"
    },
    {
      "chunk_id": 1264,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "import asyncio"
    },
    {
      "chunk_id": 1265,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "from sanic import Sanic"
    },
    {
      "chunk_id": 1266,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1267,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "async def notify_server_started_after_five_seconds():\n    await asyncio.sleep(5)\n    print(\"Server successfully started!\")"
    },
    {
      "chunk_id": 1268,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "app.add_task(notify_server_started_after_five_seconds())"
    },
    {
      "chunk_id": 1269,
      "source": "__internal__/data_repo/sanic/examples/add_task_sanic.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1270,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "import os"
    },
    {
      "chunk_id": 1271,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "from sanic import Sanic, response\nfrom sanic.exceptions import ServerError\nfrom sanic.log import logger as log"
    },
    {
      "chunk_id": 1272,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1273,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/\")\nasync def test_async(request):\n    return response.json({\"test\": True})"
    },
    {
      "chunk_id": 1274,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/sync\", methods=[\"GET\", \"POST\"])\ndef test_sync(request):\n    return response.json({\"test\": True})"
    },
    {
      "chunk_id": 1275,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/dynamic/<name>/<i:int>\")\ndef test_params(request, name, i):\n    return response.text(\"yeehaww {} {}\".format(name, i))"
    },
    {
      "chunk_id": 1276,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/exception\")\ndef exception(request):\n    raise ServerError(\"It's dead jim\")"
    },
    {
      "chunk_id": 1277,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/await\")\nasync def test_await(request):\n    import asyncio\n\n    await asyncio.sleep(5)\n    return response.text(\"I'm feeling sleepy\")"
    },
    {
      "chunk_id": 1278,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/file\")\nasync def test_file(request):\n    return await response.file(os.path.abspath(\"setup.py\"))"
    },
    {
      "chunk_id": 1279,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/file_stream\")\nasync def test_file_stream(request):\n    return await response.file_stream(\n        os.path.abspath(\"setup.py\"), chunk_size=1024\n    )"
    },
    {
      "chunk_id": 1280,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.exception(ServerError)\nasync def test(request, exception):\n    return response.json(\n        {\"exception\": str(exception), \"status\": exception.status_code},\n        status=exception.status_code,\n    )"
    },
    {
      "chunk_id": 1281,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/json\")\ndef post_json(request):\n    return response.json({\"received\": True, \"message\": request.json})"
    },
    {
      "chunk_id": 1282,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/form\")\ndef post_form_json(request):\n    return response.json(\n        {\n            \"received\": True,\n            \"form_data\": request.form,\n            \"test\": request.form.get(\"test\"),\n        }\n    )"
    },
    {
      "chunk_id": 1283,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.route(\"/query_string\")\ndef query_string(request):\n    return response.json(\n        {\n            \"parsed\": True,\n            \"args\": request.args,\n            \"url\": request.url,\n            \"query_string\": request.query_string,\n        }\n    )"
    },
    {
      "chunk_id": 1284,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.before_server_start\ndef before_start(app, loop):\n    log.info(\"SERVER STARTING\")"
    },
    {
      "chunk_id": 1285,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.after_server_start\ndef after_start(app, loop):\n    log.info(\"OH OH OH OH OHHHHHHHH\")"
    },
    {
      "chunk_id": 1286,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.before_server_stop\ndef before_stop(app, loop):\n    log.info(\"SERVER STOPPING\")"
    },
    {
      "chunk_id": 1287,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "@app.after_server_stop\ndef after_stop(app, loop):\n    log.info(\"TRIED EVERYTHING\")"
    },
    {
      "chunk_id": 1288,
      "source": "__internal__/data_repo/sanic/examples/try_everything.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1289,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "from random import randint\n\nfrom sanic import Sanic\nfrom sanic.response import text"
    },
    {
      "chunk_id": 1290,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1291,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "@app.middleware(\"request\")\ndef append_request(request):\n    request.ctx.num = randint(0, 100)"
    },
    {
      "chunk_id": 1292,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "@app.get(\"/pop\")\ndef pop_handler(request):\n    return text(request.ctx.num)"
    },
    {
      "chunk_id": 1293,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "@app.get(\"/key_exist\")\ndef key_exist_handler(request):\n    # Check the key is exist or not\n    if hasattr(request.ctx, \"num\"):\n        return text(\"num exist in request\")\n\n    return text(\"num does not exist in request\")"
    },
    {
      "chunk_id": 1294,
      "source": "__internal__/data_repo/sanic/examples/amending_request_object.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)"
    },
    {
      "chunk_id": 1295,
      "source": "__internal__/data_repo/sanic/examples/unix_socket.py",
      "content": "from sanic import Sanic, response"
    },
    {
      "chunk_id": 1296,
      "source": "__internal__/data_repo/sanic/examples/unix_socket.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1297,
      "source": "__internal__/data_repo/sanic/examples/unix_socket.py",
      "content": "@app.route(\"/test\")\nasync def test(request):\n    return response.text(\"OK\")"
    },
    {
      "chunk_id": 1298,
      "source": "__internal__/data_repo/sanic/examples/unix_socket.py",
      "content": "if __name__ == \"__main__\":\n    app.run(unix=\"./uds_socket\")"
    },
    {
      "chunk_id": 1299,
      "source": "__internal__/data_repo/sanic/examples/override_logging.py",
      "content": "import logging\n\nfrom sanic import Sanic, text"
    },
    {
      "chunk_id": 1300,
      "source": "__internal__/data_repo/sanic/examples/override_logging.py",
      "content": "logging_format = \"[%(asctime)s] %(process)d-%(levelname)s \"\nlogging_format += \"%(module)s::%(funcName)s():l%(lineno)d: \"\nlogging_format += \"%(message)s\"\n\nlogging.basicConfig(format=logging_format, level=logging.DEBUG)\nlog = logging.getLogger()"
    },
    {
      "chunk_id": 1301,
      "source": "__internal__/data_repo/sanic/examples/override_logging.py",
      "content": "app = Sanic(\"app\")"
    },
    {
      "chunk_id": 1302,
      "source": "__internal__/data_repo/sanic/examples/override_logging.py",
      "content": "@app.route(\"/\")\ndef test(request):\n    log.info(\"received request; responding with 'hey'\")\n    return text(\"hey\")"
    },
    {
      "chunk_id": 1303,
      "source": "__internal__/data_repo/sanic/examples/override_logging.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1304,
      "source": "__internal__/data_repo/sanic/examples/hello_world.py",
      "content": "from sanic import Sanic, response"
    },
    {
      "chunk_id": 1305,
      "source": "__internal__/data_repo/sanic/examples/hello_world.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1306,
      "source": "__internal__/data_repo/sanic/examples/hello_world.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    return response.json({\"test\": True})"
    },
    {
      "chunk_id": 1307,
      "source": "__internal__/data_repo/sanic/examples/hello_world.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1308,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "from sanic import Sanic, response, text\nfrom sanic.handlers import ErrorHandler\nfrom sanic.server.async_server import AsyncioServer"
    },
    {
      "chunk_id": 1309,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "HTTP_PORT = 9999\nHTTPS_PORT = 8888\n\nhttp = Sanic(\"http\")\nhttp.config.SERVER_NAME = f\"localhost:{HTTP_PORT}\"\nhttps = Sanic(\"https\")\nhttps.config.SERVER_NAME = f\"localhost:{HTTPS_PORT}\""
    },
    {
      "chunk_id": 1310,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "@https.get(\"/foo\")\ndef foo(request):\n    return text(\"foo\")"
    },
    {
      "chunk_id": 1311,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "@https.get(\"/bar\")\ndef bar(request):\n    return text(\"bar\")"
    },
    {
      "chunk_id": 1312,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "@http.get(\"/<path:path>\")\ndef proxy(request, path):\n    url = request.app.url_for(\n        \"proxy\",\n        path=path,\n        _server=https.config.SERVER_NAME,\n        _external=True,\n        _scheme=\"https\",\n    )\n    return response.redirect(url)"
    },
    {
      "chunk_id": 1313,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "@https.main_process_start\nasync def start(app, _):\n    http_server = await http.create_server(\n        port=HTTP_PORT, return_asyncio_server=True\n    )\n    app.add_task(runner(http, http_server))\n    app.ctx.http_server = http_server\n    app.ctx.http = http"
    },
    {
      "chunk_id": 1314,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "@https.main_process_stop\nasync def stop(app, _):\n    await app.ctx.http_server.before_stop()\n    await app.ctx.http_server.close()\n    for connection in app.ctx.http_server.connections:\n        connection.close_if_idle()\n    await app.ctx.http_server.after_stop()\n    app.ctx.http = False"
    },
    {
      "chunk_id": 1315,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "async def runner(app: Sanic, app_server: AsyncioServer):\n    app.is_running = True\n    try:\n        app.signalize()\n        app.finalize()\n        ErrorHandler.finalize(app.error_handler)\n        app_server.init = True\n\n        await app_server.before_start()\n        await app_server.after_start()\n        await app_server.serve_forever()\n    finally:\n        app.is_running = False\n        app.is_stopping = True"
    },
    {
      "chunk_id": 1316,
      "source": "__internal__/data_repo/sanic/examples/http_redirect.py",
      "content": "if __name__ == \"__main__\":\n    https.run(port=HTTPS_PORT, debug=True)"
    },
    {
      "chunk_id": 1317,
      "source": "__internal__/data_repo/sanic/examples/delayed_response.py",
      "content": "from asyncio import sleep\n\nfrom sanic import Sanic, response"
    },
    {
      "chunk_id": 1318,
      "source": "__internal__/data_repo/sanic/examples/delayed_response.py",
      "content": "app = Sanic(\"DelayedResponseApp\", strict_slashes=True)\napp.config.AUTO_EXTEND = False"
    },
    {
      "chunk_id": 1319,
      "source": "__internal__/data_repo/sanic/examples/delayed_response.py",
      "content": "@app.get(\"/\")\nasync def handler(request):\n    return response.redirect(\"/sleep/3\")"
    },
    {
      "chunk_id": 1320,
      "source": "__internal__/data_repo/sanic/examples/delayed_response.py",
      "content": "@app.get(\"/sleep/<t:float>\")\nasync def handler2(request, t=0.3):\n    await sleep(t)\n    return response.text(f\"Slept {t:.1f} seconds.\\n\")"
    },
    {
      "chunk_id": 1321,
      "source": "__internal__/data_repo/sanic/examples/delayed_response.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1322,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "import asyncio\n\nfrom signal import SIGINT, signal\n\nimport uvloop\n\nfrom sanic import Sanic, response\nfrom sanic.server import AsyncioServer"
    },
    {
      "chunk_id": 1323,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "app = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1324,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "@app.before_server_start\nasync def before_server_start(app, loop):\n    print(\"Async Server starting\")"
    },
    {
      "chunk_id": 1325,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "@app.after_server_start\nasync def after_server_start(app, loop):\n    print(\"Async Server started\")"
    },
    {
      "chunk_id": 1326,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "@app.before_server_stop\nasync def before_server_stop(app, loop):\n    print(\"Async Server stopping\")"
    },
    {
      "chunk_id": 1327,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "@app.after_server_stop\nasync def after_server_stop(app, loop):\n    print(\"Async Server stopped\")"
    },
    {
      "chunk_id": 1328,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    return response.json({\"answer\": \"42\"})"
    },
    {
      "chunk_id": 1329,
      "source": "__internal__/data_repo/sanic/examples/run_async_advanced.py",
      "content": "if __name__ == \"__main__\":\n    asyncio.set_event_loop(uvloop.new_event_loop())\n    serv_coro = app.create_server(\n        host=\"0.0.0.0\", port=8000, return_asyncio_server=True\n    )\n    loop = asyncio.get_event_loop()\n    serv_task = asyncio.ensure_future(serv_coro, loop=loop)\n    signal(SIGINT, lambda s, f: loop.stop())\n    server: AsyncioServer = loop.run_until_complete(serv_task)\n    loop.run_until_complete(server.startup())\n\n    # When using app.run(), this actually triggers before the serv_coro.\n    # But, in this example, we are using the convenience method, even if it is\n    # out of order.\n    loop.run_until_complete(server.before_start())\n    loop.run_until_complete(server.after_start())\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        loop.stop()\n    finally:\n        loop.run_until_complete(server.before_stop())\n\n        # Wait for server to close\n        close_task = server.close()\n        loop.run_until_complete(close_task)\n\n        # Complete all tasks on the loop\n        for connection in server.connections:\n            connection.close_if_idle()\n        loop.run_until_complete(server.after_stop())"
    },
    {
      "chunk_id": 1330,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "from sanic import Blueprint, Sanic\nfrom sanic.response import text\n\n\n\"\"\"\nDemonstrates that blueprint request middleware are executed in the order they\nare added. And blueprint response middleware are executed in _reverse_ order.\nOn a valid request, it should print \"1 2 3 6 5 4\" to terminal\n\"\"\""
    },
    {
      "chunk_id": 1331,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "app = Sanic(\"Example\")\n\nbp = Blueprint(\"bp_example\")"
    },
    {
      "chunk_id": 1332,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_request\ndef request_middleware_1(request):\n    print(\"1\")"
    },
    {
      "chunk_id": 1333,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_request\ndef request_middleware_2(request):\n    print(\"2\")"
    },
    {
      "chunk_id": 1334,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_request\ndef request_middleware_3(request):\n    print(\"3\")"
    },
    {
      "chunk_id": 1335,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_response\ndef resp_middleware_4(request, response):\n    print(\"4\")"
    },
    {
      "chunk_id": 1336,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_response\ndef resp_middleware_5(request, response):\n    print(\"5\")"
    },
    {
      "chunk_id": 1337,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.on_response\ndef resp_middleware_6(request, response):\n    print(\"6\")"
    },
    {
      "chunk_id": 1338,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "@bp.route(\"/\")\ndef pop_handler(request):\n    return text(\"hello world\")"
    },
    {
      "chunk_id": 1339,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "app.blueprint(bp, url_prefix=\"/bp\")"
    },
    {
      "chunk_id": 1340,
      "source": "__internal__/data_repo/sanic/examples/blueprint_middlware_execution_order.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True, auto_reload=False)"
    },
    {
      "chunk_id": 1341,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "import logging\n\nfrom contextvars import ContextVar\n\nfrom sanic import Sanic, response"
    },
    {
      "chunk_id": 1342,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "class RequestIdFilter(logging.Filter):\n    \"\"\"Filter to add request ID to log records.\"\"\"\n    \n    def filter(self, record):\n        try:\n            record.request_id = app.ctx.request_id.get(None) or \"n/a\"\n        except AttributeError:\n            record.request_id = \"n/a\"\n        return True"
    },
    {
      "chunk_id": 1343,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "LOG_SETTINGS = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"level\": \"DEBUG\",\n            \"formatter\": \"default\",\n            \"filters\": [\"requestid\"],\n        },\n    },\n    \"filters\": {\n        \"requestid\": {\n            \"()\": RequestIdFilter,\n        },\n    },\n    \"formatters\": {\n        \"default\": {\n            \"format\": (\n                \"%(asctime)s %(levelname)s %(name)s:%(lineno)d\"\n                \" %(request_id)s | %(message)s\"\n            ),\n        },\n    },\n    \"loggers\": {\n        \"\": {\"level\": \"DEBUG\", \"handlers\": [\"console\"], \"propagate\": True},\n    },\n}"
    },
    {
      "chunk_id": 1344,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "app = Sanic(\"Example\", log_config=LOG_SETTINGS)"
    },
    {
      "chunk_id": 1345,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "@app.on_request\nasync def set_request_id(request):\n    request.app.ctx.request_id.set(request.id)\n    log.info(f\"Setting {request.id=}\")"
    },
    {
      "chunk_id": 1346,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "@app.on_response\nasync def set_request_header(request, response):\n    response.headers[\"X-Request-ID\"] = request.id"
    },
    {
      "chunk_id": 1347,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    log.debug(\"X-Request-ID: %s\", request.id)\n    log.info(\"Hello from test!\")\n    return response.json({\"test\": True})"
    },
    {
      "chunk_id": 1348,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "@app.before_server_start\ndef setup(app, loop):\n    app.ctx.request_id = ContextVar(\"request_id\")"
    },
    {
      "chunk_id": 1349,
      "source": "__internal__/data_repo/sanic/examples/log_request_id.py",
      "content": "if __name__ == \"__main__\":\n    app.run(port=9999, debug=True)"
    },
    {
      "chunk_id": 1350,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "from sanic import Sanic\nfrom sanic.blueprints import Blueprint\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1351,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "app = Sanic(name=\"blue-print-group-version-example\")"
    },
    {
      "chunk_id": 1352,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "bp1 = Blueprint(name=\"ultron\", url_prefix=\"/ultron\")\nbp2 = Blueprint(name=\"vision\", url_prefix=\"/vision\", strict_slashes=None)"
    },
    {
      "chunk_id": 1353,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "bpg = Blueprint.group(\n    bp1, bp2, url_prefix=\"/sentient/robot\", version=1, strict_slashes=True\n)"
    },
    {
      "chunk_id": 1354,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "@bp1.get(\"/name\")\nasync def bp1_name(request):\n    \"\"\"This will expose an Endpoint GET /v1/sentient/robot/ultron/name\"\"\"\n    return json({\"name\": \"Ultron\"})"
    },
    {
      "chunk_id": 1355,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "@bp2.get(\"/name\")\nasync def bp2_name(request):\n    \"\"\"This will expose an Endpoint GET /v1/sentient/robot/vision/name\"\"\"\n    return json({\"name\": \"vision\"})"
    },
    {
      "chunk_id": 1356,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "@bp2.get(\"/name\", version=2)\nasync def bp2_revised_name(request):\n    \"\"\"This will expose an Endpoint GET /v2/sentient/robot/vision/name\"\"\"\n    return json({\"name\": \"new vision\"})"
    },
    {
      "chunk_id": 1357,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "app.blueprint(bpg)"
    },
    {
      "chunk_id": 1358,
      "source": "__internal__/data_repo/sanic/examples/versioned_blueprint_group.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1359,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "from os import getenv\n\nfrom raygun4py.raygunprovider import RaygunSender\n\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.handlers import ErrorHandler"
    },
    {
      "chunk_id": 1360,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "class RaygunExceptionReporter(ErrorHandler):\n    def __init__(self, raygun_api_key=None):\n        super().__init__()\n        if raygun_api_key is None:\n            raygun_api_key = getenv(\"RAYGUN_API_KEY\")\n\n        self.sender = RaygunSender(raygun_api_key)"
    },
    {
      "chunk_id": 1361,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "def default(self, request, exception):\n        self.sender.send_exception(exception=exception)\n        return super().default(request, exception)"
    },
    {
      "chunk_id": 1362,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "raygun_error_reporter = RaygunExceptionReporter()\napp = Sanic(\"Example\", error_handler=raygun_error_reporter)"
    },
    {
      "chunk_id": 1363,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "@app.route(\"/raise\")\nasync def test(request):\n    raise SanicException(\"You Broke It!\")"
    },
    {
      "chunk_id": 1364,
      "source": "__internal__/data_repo/sanic/examples/raygun_example.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=getenv(\"PORT\", 8080))"
    },
    {
      "chunk_id": 1365,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "from sanic import Blueprint, Sanic\nfrom sanic.response import file, json"
    },
    {
      "chunk_id": 1366,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "app = Sanic(\"Example\")\nblueprint = Blueprint(\"bp_example\", url_prefix=\"/my_blueprint\")\nblueprint2 = Blueprint(\"bp_example2\", url_prefix=\"/my_blueprint2\")\nblueprint3 = Blueprint(\"bp_example3\", url_prefix=\"/my_blueprint3\")"
    },
    {
      "chunk_id": 1367,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "@blueprint.route(\"/foo\")\nasync def foo(request):\n    return json({\"msg\": \"hi from blueprint\"})"
    },
    {
      "chunk_id": 1368,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "@blueprint2.route(\"/foo\")\nasync def foo2(request):\n    return json({\"msg\": \"hi from blueprint2\"})"
    },
    {
      "chunk_id": 1369,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "@blueprint3.route(\"/foo\")\nasync def index(request):\n    return await file(\"websocket.html\")"
    },
    {
      "chunk_id": 1370,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "@app.websocket(\"/feed\")\nasync def foo3(request, ws):\n    while True:\n        data = \"hello!\"\n        print(\"Sending: \" + data)\n        await ws.send(data)\n        data = await ws.recv()\n        print(\"Received: \" + data)"
    },
    {
      "chunk_id": 1371,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "app.blueprint(blueprint)\napp.blueprint(blueprint2)\napp.blueprint(blueprint3)"
    },
    {
      "chunk_id": 1372,
      "source": "__internal__/data_repo/sanic/examples/blueprints.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=9999, debug=True)"
    },
    {
      "chunk_id": 1373,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "from sanic import Sanic\nfrom sanic.blueprints import Blueprint\nfrom sanic.response import stream, text\nfrom sanic.views import HTTPMethodView\nfrom sanic.views import stream as stream_decorator"
    },
    {
      "chunk_id": 1374,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "bp = Blueprint(\"bp_example\")\napp = Sanic(\"Example\")"
    },
    {
      "chunk_id": 1375,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "class SimpleView(HTTPMethodView):\n    async def post(self, request):\n        result = \"\"\n        while True:\n            body = await request.stream.get()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)"
    },
    {
      "chunk_id": 1376,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "@app.post(\"/stream\", stream=True)\nasync def handler(request):\n    async def streaming(response):\n        while True:\n            body = await request.stream.get()\n            if body is None:\n                break\n            body = body.decode(\"utf-8\").replace(\"1\", \"A\")\n            await response.write(body)\n\n    return stream(streaming)"
    },
    {
      "chunk_id": 1377,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "@bp.put(\"/bp_stream\", stream=True)\nasync def bp_handler(request):\n    result = \"\"\n    while True:\n        body = await request.stream.get()\n        if body is None:\n            break\n        result += body.decode(\"utf-8\").replace(\"1\", \"A\")\n    return text(result)"
    },
    {
      "chunk_id": 1378,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "async def post_handler(request):\n    result = \"\"\n    while True:\n        body = await request.stream.get()\n        if body is None:\n            break\n        result += body.decode(\"utf-8\")\n    return text(result)"
    },
    {
      "chunk_id": 1379,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "app.blueprint(bp)\napp.add_route(SimpleView.as_view(), \"/method_view\")"
    },
    {
      "chunk_id": 1380,
      "source": "__internal__/data_repo/sanic/examples/request_stream/server.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)"
    },
    {
      "chunk_id": 1381,
      "source": "__internal__/data_repo/sanic/examples/request_stream/client.py",
      "content": "import requests"
    },
    {
      "chunk_id": 1382,
      "source": "__internal__/data_repo/sanic/examples/request_stream/client.py",
      "content": "data = \"\"\nfor i in range(1, 250000):\n    data += str(i)"
    },
    {
      "chunk_id": 1383,
      "source": "__internal__/data_repo/sanic/examples/request_stream/client.py",
      "content": "r = requests.post(\"http://0.0.0.0:8000/stream\", data=data)\nprint(r.text)"
    },
    {
      "chunk_id": 1384,
      "source": "__internal__/data_repo/sanic/guide/server.py",
      "content": "\"\"\"Sanic  User Guide\n\nhttps://sanic.dev\n\nBuilt using the SHH stack:\n- Sanic\n- html5tagger\n- HTMX\"\"\""
    },
    {
      "chunk_id": 1385,
      "source": "__internal__/data_repo/sanic/guide/server.py",
      "content": "from pathlib import Path"
    },
    {
      "chunk_id": 1386,
      "source": "__internal__/data_repo/sanic/guide/server.py",
      "content": "from webapp.worker.factory import create_app"
    },
    {
      "chunk_id": 1387,
      "source": "__internal__/data_repo/sanic/guide/server.py",
      "content": "app = create_app(Path(__file__).parent)"
    },
    {
      "chunk_id": 1388,
      "source": "__internal__/data_repo/sanic/guide/webapp/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1389,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1390,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/view.py",
      "content": "from sanic import Blueprint"
    },
    {
      "chunk_id": 1391,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/view.py",
      "content": "from .search import bp as search_bp"
    },
    {
      "chunk_id": 1392,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/view.py",
      "content": "bp = Blueprint.group(search_bp)"
    },
    {
      "chunk_id": 1393,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/sitemap.py",
      "content": "from sanic import Request, Sanic, raw"
    },
    {
      "chunk_id": 1394,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/sitemap.py",
      "content": "def setup_sitemap(app: Sanic) -> None:\n    app.get(\"/sitemap.xml\")(_sitemap)\n    app.before_server_start(_compile_sitemap, priority=0)"
    },
    {
      "chunk_id": 1395,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/sitemap.py",
      "content": "async def _compile_sitemap(app: Sanic):\n    pages: list[str] = [\n        app.url_for(\n            \"page\",\n            language=\"en\",\n            path=page.relative_path.with_suffix(\".html\"),\n            _external=True,\n            _server=\"sanic.dev\",\n            _scheme=\"https\",\n        )\n        for page in app.ctx.pages\n        if page.relative_path\n    ]\n    sitemap_parts: list[str] = [\n        '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n        '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">',\n        *[f\"<url><loc>{page}</loc></url>\" for page in pages],\n        \"</urlset>\",\n    ]\n    app.ctx.sitemap = \"\\n\".join(sitemap_parts)"
    },
    {
      "chunk_id": 1396,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/sitemap.py",
      "content": "async def _sitemap(request: Request):\n    return raw(request.app.ctx.sitemap, content_type=\"application/xml\")"
    },
    {
      "chunk_id": 1397,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/search.py",
      "content": "# from urllib.parse import unquote"
    },
    {
      "chunk_id": 1398,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/search.py",
      "content": "from sanic import Blueprint, Request, Sanic, html\nfrom webapp.display.page import Page\nfrom webapp.display.search.renderer import SearchRenderer\nfrom webapp.display.search.search import Document, Searcher, Stemmer"
    },
    {
      "chunk_id": 1399,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/search.py",
      "content": "bp = Blueprint(\"search\", url_prefix=\"/<language>/search\")"
    },
    {
      "chunk_id": 1400,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/search.py",
      "content": "@bp.get(\"\")\nasync def _search(request: Request, language: str, searcher: Searcher):\n    full = not bool(request.headers.get(\"HX-Request\"))\n    renderer = SearchRenderer(\"Sanic Documentation Search\")\n    builder = renderer.render(request, language, searcher, full)\n\n    return html(str(builder))"
    },
    {
      "chunk_id": 1401,
      "source": "__internal__/data_repo/sanic/guide/webapp/endpoint/search.py",
      "content": "@bp.before_server_start\nasync def setup_search(app: Sanic):\n    stemmer = Stemmer()\n    pages: list[Page] = app.ctx.pages\n    documents = [\n        Document(page=page, language=page.meta.language).process(stemmer)\n        for page in pages\n    ]\n    app.ext.dependency(Searcher(stemmer, documents))"
    },
    {
      "chunk_id": 1402,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1403,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/text.py",
      "content": "import re"
    },
    {
      "chunk_id": 1404,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/text.py",
      "content": "SLUGIFY_PATTERN = re.compile(r\"[^a-zA-Z0-9-]\")"
    },
    {
      "chunk_id": 1405,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/text.py",
      "content": "def slugify(text: str) -> str:\n    return SLUGIFY_PATTERN.sub(\"\", text.lower().replace(\" \", \"-\"))"
    },
    {
      "chunk_id": 1406,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/base.py",
      "content": "from __future__ import annotations\n\nfrom os import environ\n\nfrom html5tagger import Builder, Document, E  # type: ignore"
    },
    {
      "chunk_id": 1407,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/base.py",
      "content": "class BaseRenderer:\n    def __init__(self, base_title: str):\n        self.base_title = base_title"
    },
    {
      "chunk_id": 1408,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/base.py",
      "content": "def get_builder(self, full: bool, language: str) -> Builder:\n        if full:\n            urls = [\n                \"/assets/code.css\",\n                \"/assets/style.css\",\n                \"/assets/docs.js\",\n                \"https://unpkg.com/htmx.org@1.9.2/dist/htmx.min.js\",\n                \"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\",\n            ]\n            builder = Document(\n                self.title(), lang=language, _urls=urls, _viewport=True\n            )\n            builder(*self._head())\n            builder.full = True\n        else:\n            builder = Builder(name=\"Partial\")\n            builder.full = False\n        return builder"
    },
    {
      "chunk_id": 1409,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/base.py",
      "content": "def title(self) -> str:\n        return self.base_title"
    },
    {
      "chunk_id": 1410,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/base.py",
      "content": "def _head(self) -> list[Builder]:\n        head = [\n            E.meta(name=\"theme-color\", content=\"#ff0d68\"),\n            E.meta(name=\"title\", content=self.title()),\n            E.meta(\n                name=\"description\",\n                content=(\n                    \"Sanic is a Python 3.9+ web server and \"\n                    \"web framework that's written to go fast.\"\n                ),\n            ),\n            E.link(rel=\"icon\", href=\"/favicon.ico\", sizes=\"any\"),\n            E.link(rel=\"icon\", href=\"/favicon-32x32.png\", type=\"image/png\"),\n            E.link(rel=\"icon\", href=\"/favicon-16x16.png\", type=\"image/png\"),\n            E.link(\n                rel=\"apple-touch-icon\",\n                sizes=\"180x180\",\n                href=\"/apple-touch-icon.png\",\n            ),\n            E.link(rel=\"manifest\", href=\"/site.webmanifest\"),\n            E.link(\n                rel=\"android-chrome\",\n                sizes=\"192x192\",\n                href=\"/android-chrome-192x192.png\",\n            ),\n            E.link(\n                rel=\"android-chrome\",\n                sizes=\"512x512\",\n                href=\"/android-chrome-512x512.png\",\n            ),\n            E.meta(name=\"msapplication-config\", content=\"/browserconfig.xml\"),\n            E.meta(name=\"msapplication-TileColor\", content=\"#ffffff\"),\n            E.meta(\n                name=\"msapplication-TileImage\", content=\"/mstile-144x144.png\"\n            ),\n            E.meta(name=\"theme-color\", content=\"#ff0d68\"),\n            E.link(\n                rel=\"mask-icon\", href=\"/safari-pinned-tab.svg\", color=\"#ff0d68\"\n            ),\n        ]\n        umami = E.script(\n            None,\n            async_=True,\n            defer=True,\n            data_website_id=\"0131e426-4d6d-476b-a84b-34a45e0be6de\",\n            src=\"https://analytics.sanicframework.org/umami.js\",\n        )\n        if environ.get(\"UMAMI\"):\n            head.append(umami)\n        return head"
    },
    {
      "chunk_id": 1411,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/code_style.py",
      "content": "from pygments.style import Style\nfrom pygments.token import (  # Error,; Generic,; Number,; Operator,\n    Comment,\n    Keyword,\n    Name,\n    String,\n    Token,\n)"
    },
    {
      "chunk_id": 1412,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/code_style.py",
      "content": "class SanicCodeStyle(Style):\n    \"\"\"\n    Custom style for Sanic code highlighting.\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1413,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/code_style.py",
      "content": "styles = {\n        Token: \"#777\",\n        Comment: \"italic #a2a2a2\",\n        Keyword: \"#ff0d68\",\n        Name: \"#333\",\n        Name.Class: \"bold #37ae6f\",\n        Name.Function: \"#0092FF\",\n        String: \"bg:#eee #833FE3\",\n    }"
    },
    {
      "chunk_id": 1414,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "import re\n\nfrom textwrap import dedent\n\nfrom html5tagger import HTML, Builder, E  # type: ignore\nfrom mistune import HTMLRenderer, create_markdown, escape\nfrom mistune.directives import RSTDirective, TableOfContents\nfrom mistune.util import safe_entity\nfrom pygments import highlight\nfrom pygments.formatters import html\nfrom pygments.lexers import get_lexer_by_name\n\nfrom .code_style import SanicCodeStyle\nfrom .plugins.attrs import Attributes\nfrom .plugins.columns import Column\nfrom .plugins.hook import Hook\nfrom .plugins.inline_directive import inline_directive\nfrom .plugins.mermaid import Mermaid\nfrom .plugins.notification import Notification\nfrom .plugins.span import span\nfrom .plugins.tabs import Tabs\nfrom .text import slugify"
    },
    {
      "chunk_id": 1415,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "class DocsRenderer(HTMLRenderer):\n    def __init__(self):\n        super().__init__()\n\n    def block_code(self, code: str, info: str | None = None):\n        builder = Builder(\"Block\")\n        with builder.div(class_=\"code-block\"):\n            if info:\n                lexer = get_lexer_by_name(info, stripall=False)\n                formatter = html.HtmlFormatter(\n                    style=SanicCodeStyle,\n                    wrapcode=True,\n                    cssclass=f\"highlight language-{info}\",\n                )\n                builder(HTML(highlight(code, lexer, formatter)))\n                with builder.div(\n                    class_=\"code-block__copy\",\n                    onclick=\"copyCode(this)\",\n                ):\n                    builder.div(\n                        class_=\"code-block__rectangle code-block__filled\"\n                    ).div(class_=\"code-block__rectangle code-block__outlined\")\n            else:\n                builder.pre(E.code(escape(code)))\n        return str(builder)\n\n    def heading(self, text: str, level: int, **attrs) -> str:\n        ident = slugify(text)\n        if level > 1:\n            text += self._make_tag(\n                \"a\", {\"href\": f\"#{ident}\", \"class\": \"anchor\"}, \"#\"\n            )\n        return self._make_tag(\n            f\"h{level}\",\n            {\n                \"id\": ident,\n                \"class\": (\n                    f\"is-size-{level}-desktop \" f\"is-size-{level+2}-touch\"\n                ),\n            },\n            text,\n        )\n\n    def link(self, text: str, url: str, title: str | None = None) -> str:\n        url = self.safe_url(url).replace(\".md\", \".html\")\n        url, anchor = url.split(\"#\", 1) if \"#\" in url else (url, None)\n        if (\n            not url.endswith(\"/\")\n            and not url.endswith(\".html\")\n            and not url.startswith(\"http\")\n        ):\n            url += \".html\"\n        if anchor:\n            url += f\"#{anchor}\"\n        attributes: dict[str, str] = {\"href\": url}\n        if title:\n            attributes[\"title\"] = safe_entity(title)\n        if url.startswith(\"http\"):\n            attributes[\"target\"] = \"_blank\"\n            attributes[\"rel\"] = \"nofollow noreferrer\"\n        else:\n            attributes[\"hx-get\"] = url\n            attributes[\"hx-target\"] = \"#content\"\n            attributes[\"hx-swap\"] = \"innerHTML\"\n            attributes[\"hx-push-url\"] = \"true\"\n        return self._make_tag(\"a\", attributes, text)\n\n    def span(self, text, classes, **attrs) -> str:\n        if classes:\n            attrs[\"class\"] = classes\n        return self._make_tag(\"span\", attrs, text)\n\n    def list(self, text: str, ordered: bool, **attrs) -> str:\n        tag = \"ol\" if ordered else \"ul\"\n        attrs[\"class\"] = tag\n        return self._make_tag(tag, attrs, text)\n\n    def list_item(self, text: str, **attrs) -> str:\n        attrs[\"class\"] = \"li\"\n        return self._make_tag(\"li\", attrs, text)\n\n    def table(self, text: str, **attrs) -> str:\n        attrs[\"class\"] = \"table is-fullwidth is-bordered\"\n        return self._make_tag(\"table\", attrs, text)\n\n    def inline_directive(self, text: str, **attrs) -> str:\n        num_dots = text.count(\".\")\n        display = self.codespan(text)\n\n        if num_dots <= 1:\n            return display\n\n        module, *_ = text.rsplit(\".\", num_dots - 1)\n        href = f\"/api/{module}.html\"\n        return self._make_tag(\n            \"a\",\n            {\"href\": href, \"class\": \"inline-directive\"},\n            display,\n        )\n\n    def _make_tag(\n        self, tag: str, attributes: dict[str, str], text: str | None = None\n    ) -> str:\n        attrs = \" \".join(\n            f'{key}=\"{value}\"' for key, value in attributes.items()\n        )\n        if text is None:\n            return f\"<{tag} {attrs} />\"\n        return f\"<{tag} {attrs}>{text}</{tag}>\""
    },
    {
      "chunk_id": 1416,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "class SanicTableOfContents(TableOfContents):\n    def generate_heading_id(self, token, index):\n        return slugify(token[\"text\"])"
    },
    {
      "chunk_id": 1417,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "RST_CODE_BLOCK_PATTERN = re.compile(\n    r\"\\.\\.\\scode-block::\\s(\\w+)\\n\\n((?:\\n|(?:\\s\\s\\s\\s[^\\n]*))+)\"\n)"
    },
    {
      "chunk_id": 1418,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "_render_markdown = create_markdown(\n    renderer=DocsRenderer(),\n    plugins=[\n        RSTDirective(\n            [\n                # Admonition(),\n                Attributes(),\n                Notification(),\n                SanicTableOfContents(),\n                Column(),\n                Mermaid(),\n                Tabs(),\n                Hook(),\n            ]\n        ),\n        \"abbr\",\n        \"def_list\",\n        \"footnotes\",\n        \"mark\",\n        \"table\",\n        span,\n        inline_directive,\n    ],\n)"
    },
    {
      "chunk_id": 1419,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/markdown.py",
      "content": "def render_markdown(text: str) -> str:\n    def replacer(match):\n        language = match.group(1)\n        code_block = dedent(match.group(2)).strip()\n        return f\"```{language}\\n{code_block}\\n```\\n\\n\"\n\n    text = RST_CODE_BLOCK_PATTERN.sub(replacer, text)\n    return _render_markdown(text)"
    },
    {
      "chunk_id": 1420,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/__init__.py",
      "content": "from .page import Page\nfrom .renderer import PageRenderer"
    },
    {
      "chunk_id": 1421,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/__init__.py",
      "content": "__all__ = [\"Page\", \"PageRenderer\"]"
    },
    {
      "chunk_id": 1422,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "from __future__ import annotations\n\nimport importlib\nimport inspect\nimport pkgutil\n\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom html import escape\n\nfrom docstring_parser import Docstring, DocstringParam, DocstringRaises\nfrom docstring_parser import parse as parse_docstring\nfrom docstring_parser.common import DocstringExample\nfrom html5tagger import HTML, Builder, E  # type: ignore\n\nfrom ..markdown import render_markdown, slugify"
    },
    {
      "chunk_id": 1423,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "@dataclass\nclass DocObject:\n    name: str\n    module_name: str\n    full_name: str\n    signature: inspect.Signature | None\n    docstring: Docstring\n    object_type: str = \"\"\n    methods: list[DocObject] = field(default_factory=list)\n    decorators: list[str] = field(default_factory=list)"
    },
    {
      "chunk_id": 1424,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _extract_classes_methods(obj, full_name, docstrings):\n    methods = []\n    for method_name, method in inspect.getmembers(obj, _is_public_member):\n        try:\n            signature = _get_method_signature(method)\n            docstring = inspect.getdoc(method)\n            decorators = _detect_decorators(obj, method)\n            methods.append(\n                DocObject(\n                    name=method_name,\n                    module_name=\"\",\n                    full_name=f\"{full_name}.{method_name}\",\n                    signature=signature,\n                    docstring=parse_docstring(docstring or \"\"),\n                    decorators=decorators,\n                    object_type=_get_object_type(method),\n                )\n            )\n        except ValueError:\n            pass\n\n    docstrings[full_name].methods = methods"
    },
    {
      "chunk_id": 1425,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _get_method_signature(method):\n    try:\n        return inspect.signature(method)\n    except TypeError:\n        signature = None\n        if func := getattr(method, \"fget\", None):\n            signature = inspect.signature(func)\n    return signature"
    },
    {
      "chunk_id": 1426,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _is_public_member(obj: object) -> bool:\n    obj_name = getattr(obj, \"__name__\", \"\")\n    if func := getattr(obj, \"fget\", None):\n        obj_name = getattr(func, \"__name__\", \"\")\n    return (\n        not obj_name.startswith(\"_\")\n        and not obj_name.isupper()\n        and (\n            inspect.ismethod(obj)\n            or inspect.isfunction(obj)\n            or isinstance(obj, property)\n            or isinstance(obj, property)\n        )\n    )"
    },
    {
      "chunk_id": 1427,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _detect_decorators(cls, method):\n    decorators = []\n    method_name = getattr(method, \"__name__\", None)\n    if isinstance(cls.__dict__.get(method_name), classmethod):\n        decorators.append(\"classmethod\")\n    if isinstance(cls.__dict__.get(method_name), staticmethod):\n        decorators.append(\"staticmethod\")\n    if isinstance(method, property):\n        decorators.append(\"property\")\n    return decorators"
    },
    {
      "chunk_id": 1428,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _get_object_type(obj) -> str:\n    if inspect.isclass(obj):\n        return \"class\"\n\n    # If the object is a method, get the underlying function\n    if inspect.ismethod(obj):\n        obj = obj.__func__\n\n    # If the object is a coroutine or a coroutine function\n    if inspect.iscoroutine(obj) or inspect.iscoroutinefunction(obj):\n        return \"async def\"\n\n    return \"def\""
    },
    {
      "chunk_id": 1429,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def organize_docobjects(package_name: str) -> dict[str, str]:\n    page_content: defaultdict[str, str] = defaultdict(str)\n    docobjects = _extract_docobjects(package_name)\n    page_registry: defaultdict[str, list[str]] = defaultdict(list)\n    for module, docobject in docobjects.items():\n        builder = Builder(name=\"Partial\")\n        _docobject_to_html(docobject, builder)\n        ref = module.rsplit(\".\", module.count(\".\") - 1)[0]\n        page_registry[ref].append(module)\n        page_content[f\"/api/{ref}.md\"] += str(builder)\n    for ref, objects in page_registry.items():\n        page_content[f\"/api/{ref}.md\"] = (\n            _table_of_contents(objects) + page_content[f\"/api/{ref}.md\"]\n        )\n    return page_content"
    },
    {
      "chunk_id": 1430,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _table_of_contents(objects: list[str]) -> str:\n    builder = Builder(name=\"Partial\")\n    with builder.div(class_=\"table-of-contents\"):\n        builder.h3(\"Table of Contents\", class_=\"is-size-4\")\n        for obj in objects:\n            module, name = obj.rsplit(\".\", 1)\n            builder.a(\n                E.strong(name),\n                E.small(module),\n                href=f\"#{slugify(obj.replace('.', '-'))}\",\n                class_=\"table-of-contents-item\",\n            )\n    return str(builder)"
    },
    {
      "chunk_id": 1431,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _extract_docobjects(package_name: str) -> dict[str, DocObject]:\n    docstrings = {}\n    package = importlib.import_module(package_name)\n\n    for _, name, _ in pkgutil.walk_packages(\n        package.__path__, package_name + \".\"\n    ):\n        module = importlib.import_module(name)\n        for obj_name, obj in inspect.getmembers(module):\n            if (\n                obj_name.startswith(\"_\")\n                or inspect.getmodule(obj) != module\n                or not callable(obj)\n            ):\n                continue\n            try:\n                signature = inspect.signature(obj)\n            except ValueError:\n                signature = None\n            docstring = inspect.getdoc(obj)\n            full_name = f\"{name}.{obj_name}\"\n            docstrings[full_name] = DocObject(\n                name=obj_name,\n                full_name=full_name,\n                module_name=name,\n                signature=signature,\n                docstring=parse_docstring(docstring or \"\"),\n                object_type=_get_object_type(obj),\n            )\n            if inspect.isclass(obj):\n                _extract_classes_methods(obj, full_name, docstrings)\n\n    return docstrings"
    },
    {
      "chunk_id": 1432,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _docobject_to_html(\n    docobject: DocObject, builder: Builder, as_method: bool = False\n) -> None:\n    anchor_id = slugify(docobject.full_name.replace(\".\", \"-\"))\n    anchor = E.a(\"#\", class_=\"anchor\", href=f\"#{anchor_id}\")\n    class_name, heading = _define_heading_and_class(\n        docobject, anchor, as_method\n    )\n\n    with builder.div(class_=class_name):\n        builder(heading)\n\n        if docobject.docstring.short_description:\n            builder.div(\n                HTML(render_markdown(docobject.docstring.short_description)),\n                class_=\"short-description mt-3 is-size-5\",\n            )\n\n        if docobject.object_type == \"class\":\n            mro = [\n                item\n                for idx, item in enumerate(\n                    inspect.getmro(\n                        getattr(\n                            importlib.import_module(docobject.module_name),\n                            docobject.name,\n                        )\n                    )\n                )\n                if idx > 0 and item not in (object, type)\n            ]\n            if mro:\n                builder.div(\n                    E.span(\"Inherits from: \", class_=\"is-italic\"),\n                    E.span(\n                        \", \".join([cls.__name__ for cls in mro]),\n                        class_=\"has-text-weight-bold\",\n                    ),\n                    class_=\"short-description mt-3 is-size-5\",\n                )\n\n        builder.p(\n            HTML(\n                _signature_to_html(\n                    docobject.name,\n                    docobject.object_type,\n                    docobject.signature,\n                    docobject.decorators,\n                )\n            ),\n            class_=\"signature notification is-family-monospace\",\n        )\n\n        if docobject.docstring.long_description:\n            builder.div(\n                HTML(render_markdown(docobject.docstring.long_description)),\n                class_=\"long-description mt-3\",\n            )\n\n        if docobject.docstring.params:\n            with builder.div(class_=\"box mt-5\"):\n                builder.h5(\n                    \"Parameters\", class_=\"is-size-5 has-text-weight-bold\"\n                )\n                _render_params(builder, docobject.docstring.params)\n\n        if docobject.docstring.returns:\n            _render_returns(builder, docobject)\n\n        if docobject.docstring.raises:\n            _render_raises(builder, docobject.docstring.raises)\n\n        if docobject.docstring.examples:\n            _render_examples(builder, docobject.docstring.examples)\n\n        for method in docobject.methods:\n            _docobject_to_html(method, builder, as_method=True)"
    },
    {
      "chunk_id": 1433,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _signature_to_html(\n    name: str,\n    object_type: str,\n    signature: inspect.Signature | None,\n    decorators: list[str],\n) -> str:\n    parts = []\n    parts.append(\"<span class='function-signature'>\")\n    for decorator in decorators:\n        parts.append(\n            f\"<span class='function-decorator'>@{decorator}</span><br>\"\n        )\n    parts.append(\n        f\"<span class='is-italic'>{object_type}</span> \"\n        f\"<span class='has-text-weight-bold'>{name}</span>(\"\n    )\n    if not signature:\n        parts.append(\"<span class='param-name'>self</span>)\")\n        parts.append(\"</span>\")\n        return \"\".join(parts)\n    for i, param in enumerate(signature.parameters.values()):\n        parts.append(f\"<span class='param-name'>{escape(param.name)}</span>\")\n        annotation = \"\"\n        if param.annotation != inspect.Parameter.empty:\n            annotation = escape(str(param.annotation))\n            parts.append(\n                f\": <span class='param-annotation'>{annotation}</span>\"\n            )\n        if param.default != inspect.Parameter.empty:\n            default = escape(str(param.default))\n            if annotation == \"str\":\n                default = f'\"{default}\"'\n            parts.append(f\" = <span class='param-default'>{default}</span>\")\n        if i < len(signature.parameters) - 1:\n            parts.append(\", \")\n    parts.append(\")\")\n    if signature.return_annotation != inspect.Signature.empty:\n        return_annotation = escape(str(signature.return_annotation))\n        parts.append(\n            f\": -> <span class='return-annotation'>{return_annotation}</span>\"\n        )\n    parts.append(\"</span>\")\n    return \"\".join(parts)"
    },
    {
      "chunk_id": 1434,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _define_heading_and_class(\n    docobject: DocObject, anchor: Builder, as_method: bool\n) -> tuple[str, Builder]:\n    anchor_id = slugify(docobject.full_name.replace(\".\", \"-\"))\n    anchor = E.a(\"#\", class_=\"anchor\", href=f\"#{anchor_id}\")\n    if as_method:\n        class_name = \"method\"\n        heading = E.h3(\n            docobject.name,\n            anchor,\n            class_=\"is-size-4 has-text-weight-bold mt-6\",\n            id_=anchor_id,\n        )\n    else:\n        class_name = \"docobject\"\n        heading = E.h2(\n            E.span(docobject.module_name, class_=\"has-text-weight-light\"),\n            \".\",\n            E.span(docobject.name, class_=\"has-text-weight-bold is-size-1\"),\n            anchor,\n            class_=\"is-size-2\",\n            id_=anchor_id,\n        )\n    return class_name, heading"
    },
    {
      "chunk_id": 1435,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _render_params(builder: Builder, params: list[DocstringParam]) -> None:\n    for param in params:\n        with builder.dl(class_=\"mt-2\"):\n            dt_args = [param.arg_name]\n            if param.type_name:\n                parts = [\n                    E.br(),\n                    E.span(\n                        param.type_name,\n                        class_=(\n                            \"has-text-weight-normal has-text-purple \"\n                            \"is-size-7 ml-2\"\n                        ),\n                    ),\n                ]\n                dt_args.extend(parts)\n            builder.dt(*dt_args, class_=\"is-family-monospace\")\n            builder.dd(\n                HTML(\n                    render_markdown(\n                        param.description\n                        or param.arg_name\n                        or param.type_name\n                        or \"\"\n                    )\n                )\n            )"
    },
    {
      "chunk_id": 1436,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _render_raises(builder: Builder, raises: list[DocstringRaises]) -> None:\n    with builder.div(class_=\"box mt-5\"):\n        builder.h5(\"Raises\", class_=\"is-size-5 has-text-weight-bold\")\n        for raise_ in raises:\n            with builder.dl(class_=\"mt-2\"):\n                builder.dt(raise_.type_name, class_=\"is-family-monospace\")\n                builder.dd(\n                    HTML(\n                        render_markdown(\n                            raise_.description or raise_.type_name or \"\"\n                        )\n                    )\n                )"
    },
    {
      "chunk_id": 1437,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _render_returns(builder: Builder, docobject: DocObject) -> None:\n    assert docobject.docstring.returns\n    return_type = docobject.docstring.returns.type_name\n    if not return_type or return_type == \"None\":\n        return\n    with builder.div(class_=\"box mt-5\"):\n        if not return_type and docobject.signature:\n            return_type = docobject.signature.return_annotation\n\n        if not return_type or return_type == inspect.Signature.empty:\n            return_type = \"N/A\"\n\n        term = (\n            \"Return\"\n            if not docobject.docstring.returns.is_generator\n            else \"Yields\"\n        )\n        builder.h5(term, class_=\"is-size-5 has-text-weight-bold\")\n        with builder.dl(class_=\"mt-2\"):\n            builder.dt(return_type, class_=\"is-family-monospace\")\n            builder.dd(\n                HTML(\n                    render_markdown(\n                        docobject.docstring.returns.description\n                        or docobject.docstring.returns.type_name\n                        or \"\"\n                    )\n                )\n            )"
    },
    {
      "chunk_id": 1438,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/docobject.py",
      "content": "def _render_examples(\n    builder: Builder, examples: list[DocstringExample]\n) -> None:\n    with builder.div(class_=\"box mt-5\"):\n        builder.h5(\"Examples\", class_=\"is-size-5 has-text-weight-bold\")\n        for example in examples:\n            with builder.div(class_=\"mt-2\"):\n                builder(\n                    HTML(\n                        render_markdown(\n                            example.description or example.snippet or \"\"\n                        )\n                    )\n                )"
    },
    {
      "chunk_id": 1439,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "from __future__ import annotations\n\nfrom contextlib import contextmanager\n\nfrom html5tagger import HTML, Builder  # type: ignore\n\nfrom sanic import Request\nfrom webapp.display.base import BaseRenderer\n\nfrom ..layouts.base import BaseLayout\nfrom .page import Page"
    },
    {
      "chunk_id": 1440,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "class PageRenderer(BaseRenderer):\n    def __init__(self):\n        super().__init__()\n\n    def render(self, request: Request, language: str, path: str) -> Builder:\n        self._setup_request(request, language, path)\n        builder = self.get_builder(\n            full=request.headers.get(\"HX-Request\") is None,\n            language=language,\n        )\n        self._body(request, builder, language, path)\n        return builder"
    },
    {
      "chunk_id": 1441,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "def title(self) -> str:\n        request = Request.get_current()\n        title: str | None = None\n        if request and (\n            current_page := getattr(request.ctx, \"current_page\", None)\n        ):\n            title = f\"{self.base_title} - {current_page.meta.title}\"\n        return title or self.base_title"
    },
    {
      "chunk_id": 1442,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "def _setup_request(self, request: Request, language: str, path: str):\n        prev_page, current_page, next_page = Page.get(language, path)\n        request.ctx.language = (\n            Page.DEFAULT_LANGUAGE if language == \"api\" else language\n        )\n        request.ctx.current_page = current_page\n        request.ctx.previous_page = prev_page\n        request.ctx.next_page = next_page"
    },
    {
      "chunk_id": 1443,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "def _body(\n        self, request: Request, builder: Builder, language: str, path: str\n    ):\n        current_page = request.ctx.current_page\n        with self._base(request, builder, current_page):\n            if current_page is None:\n                builder.h1(\"Not found\")\n                return\n            builder(HTML(current_page.content))"
    },
    {
      "chunk_id": 1444,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/renderer.py",
      "content": "@contextmanager\n    def _base(self, request: Request, builder: Builder, page: Page | None):\n        layout_type: type[BaseLayout] = (\n            page.get_layout() if page else BaseLayout\n        )\n        layout = layout_type(builder)\n        with layout(request, builder.full):\n            yield"
    },
    {
      "chunk_id": 1445,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\nfrom frontmatter import parse\n\nfrom ..layouts.base import BaseLayout\nfrom ..layouts.home import HomeLayout\nfrom ..layouts.main import MainLayout\nfrom ..markdown import render_markdown\nfrom .docobject import organize_docobjects\n\n\n_PAGE_CACHE: dict[\n    str, dict[str, tuple[Page | None, Page | None, Page | None]]\n] = {}\n_LAYOUTS_CACHE: dict[str, type[BaseLayout]] = {\n    \"home\": HomeLayout,\n    \"main\": MainLayout,\n}\n_DEFAULT = \"en\""
    },
    {
      "chunk_id": 1446,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@dataclass\nclass PageMeta:\n    language: str = _DEFAULT\n    title: str = \"\"\n    description: str = \"\"\n    layout: str = \"main\"\n    features: list[dict[str, str]] = field(default_factory=list)\n    content_class: str = \"\""
    },
    {
      "chunk_id": 1447,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@dataclass\nclass Page:\n    path: Path\n    content: str\n    meta: PageMeta = field(default_factory=PageMeta)\n    _relative_path: Path | None = None\n    next_page: Page | None = None\n    previous_page: Page | None = None\n    anchors: list[str] = field(default_factory=list)\n\n    DEFAULT_LANGUAGE = _DEFAULT\n\n    def get_layout(self) -> type[BaseLayout]:\n        return _LAYOUTS_CACHE[self.meta.layout]\n\n    @property\n    def relative_path(self) -> Path:\n        if self._relative_path is None:\n            raise RuntimeError(\"Page not initialized\")\n        return self._relative_path"
    },
    {
      "chunk_id": 1448,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@classmethod\n    def get(\n        cls, language: str, path: str\n    ) -> tuple[Page | None, Page | None, Page | None]:\n        if path.endswith(\"/\") or not path:\n            path += \"index.html\"\n        if not path.endswith(\".md\"):\n            path = path.removesuffix(\".html\") + \".md\"\n        if language == \"api\":\n            path = f\"/api/{path}\"\n        return _PAGE_CACHE.get(language, {}).get(path, (None, None, None))"
    },
    {
      "chunk_id": 1449,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@classmethod\n    def load_pages(cls, base_path: Path, page_order: list[str]) -> list[Page]:\n        output: list[Page] = []\n        for path in base_path.glob(\"**/*.md\"):\n            relative = path.relative_to(base_path)\n            language = relative.parts[0]\n            name = \"/\".join(relative.parts[1:])\n            page = cls._load_page(path)\n            output.append(page)\n            page._relative_path = relative\n            _PAGE_CACHE.setdefault(language, {})[name] = (\n                None,\n                page,\n                None,\n            )\n            _PAGE_CACHE[\"api\"] = {}\n        for language, pages in _PAGE_CACHE.items():\n            for name, (_, current, _) in pages.items():\n                previous_page = None\n                next_page = None\n                try:\n                    index = page_order.index(name)\n                except ValueError:\n                    continue\n                try:\n                    if index > 0:\n                        previous_page = pages[page_order[index - 1]][1]\n                except KeyError:\n                    pass\n                try:\n                    if index < len(page_order) - 1:\n                        next_page = pages[page_order[index + 1]][1]\n                except KeyError:\n                    pass\n                pages[name] = (previous_page, current, next_page)\n            previous_page = None\n            next_page = None\n\n        api_pages = cls._load_api_pages()\n        filtered_order = [ref for ref in page_order if ref in api_pages]\n        for idx, ref in enumerate(filtered_order):\n            current_page = api_pages[ref]\n            previous_page = None\n            next_page = None\n            try:\n                if idx > 0:\n                    previous_page = api_pages[filtered_order[idx - 1]]\n            except KeyError:\n                pass\n            try:\n                if idx < len(filtered_order) - 1:\n                    next_page = api_pages[filtered_order[idx + 1]]\n            except KeyError:\n                pass\n            _PAGE_CACHE[\"api\"][ref] = (previous_page, current_page, next_page)\n\n        return output"
    },
    {
      "chunk_id": 1450,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@staticmethod\n    def _load_page(path: Path) -> Page:\n        raw = path.read_text()\n        metadata, raw_content = parse(raw)\n        content = render_markdown(raw_content)\n        page = Page(\n            path=path,\n            content=content,\n            meta=PageMeta(**metadata),\n        )\n        if not page.meta.title:\n            page.meta.title = page.path.stem.replace(\"-\", \" \").title()\n\n        for line in raw.splitlines():\n            if line.startswith(\"##\") and not line.startswith(\"###\"):\n                line = line.lstrip(\"#\").strip()\n                page.anchors.append(line)\n\n        return page"
    },
    {
      "chunk_id": 1451,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/page/page.py",
      "content": "@staticmethod\n    def _load_api_pages() -> dict[str, Page]:\n        docstring_content = organize_docobjects(\"sanic\")\n        output: dict[str, Page] = {}\n\n        for module, content in docstring_content.items():\n            path = Path(module)\n            page = Page(\n                path=path,\n                content=content,\n                meta=PageMeta(\n                    title=path.stem,\n                    description=\"\",\n                    layout=\"main\",\n                ),\n            )\n            page._relative_path = Path(f\"./{module}\")\n            output[module] = page\n\n        return output"
    },
    {
      "chunk_id": 1452,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1453,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/mermaid.py",
      "content": "from html import unescape\nfrom re import Match\nfrom textwrap import dedent\nfrom typing import Any\n\nfrom html5tagger import HTML, E\nfrom mistune import HTMLRenderer\nfrom mistune.block_parser import BlockParser\nfrom mistune.core import BlockState\nfrom mistune.directives import DirectivePlugin, RSTDirective\nfrom mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1454,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/mermaid.py",
      "content": "class Mermaid(DirectivePlugin):\n    \"\"\"A directive plugin for rendering Mermaid diagrams.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1455,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/mermaid.py",
      "content": "def parse(\n        self, block: BlockParser, m: Match, state: BlockState\n    ) -> dict[str, Any]:\n        info = m.groupdict()\n\n        new_state = block.state_cls()\n        new_state.process(dedent(info[\"text\"]))\n        block.parse(new_state)\n\n        text = HTML(info[\"text\"].strip())\n\n        return {\n            \"type\": \"mermaid\",\n            \"text\": text,\n            \"children\": [{\"type\": \"text\", \"text\": text}],\n            \"attrs\": {},\n        }"
    },
    {
      "chunk_id": 1456,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/mermaid.py",
      "content": "def __call__(self, directive: RSTDirective, md: Markdown) -> None:  # type: ignore\n        directive.register(\"mermaid\", self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"mermaid\", self._render_mermaid)"
    },
    {
      "chunk_id": 1457,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/mermaid.py",
      "content": "def _render_mermaid(self, renderer: HTMLRenderer, text: str, **attrs):\n        return str(E.div(class_=\"mermaid\")(HTML(unescape(text))))"
    },
    {
      "chunk_id": 1458,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/tabs.py",
      "content": "from re import Match\nfrom textwrap import dedent\nfrom typing import Any\n\nfrom mistune import HTMLRenderer\nfrom mistune.block_parser import BlockParser\nfrom mistune.core import BlockState\nfrom mistune.directives import DirectivePlugin, RSTDirective\nfrom mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1459,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/tabs.py",
      "content": "class Tabs(DirectivePlugin):\n    \"\"\"A class to handle tab directives in markdown.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1460,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/tabs.py",
      "content": "def parse(\n        self, block: BlockParser, m: Match, state: BlockState\n    ) -> dict[str, Any]:\n        info = m.groupdict()\n\n        new_state = block.state_cls()\n        new_state.process(dedent(info[\"text\"]))\n        block.parse(new_state)\n\n        return {\n            \"type\": \"tab\",\n            \"text\": info[\"text\"],\n            \"children\": new_state.tokens,\n            \"attrs\": {\n                \"title\": info[\"title\"],\n            },\n        }"
    },
    {
      "chunk_id": 1461,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/tabs.py",
      "content": "def __call__(  # type: ignore\n        self,\n        directive: RSTDirective,\n        md: Markdown,\n    ) -> None:\n        directive.register(\"tab\", self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"tab\", self._render_tab)"
    },
    {
      "chunk_id": 1462,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/tabs.py",
      "content": "def _render_tab(self, renderer: HTMLRenderer, text: str, **attrs):\n        start = (\n            '<div class=\"tab-container mt-6\"><div class=\"tabs\"><ul>\\n'\n            if attrs.get(\"first\")\n            else \"\"\n        )\n        end = (\n            '</ul></div><div class=\"tab-display\"></div></div>\\n'\n            if attrs.get(\"last\")\n            else \"\"\n        )\n        content = f'<div class=\"tab-content\">{text}</div>\\n'\n        tab = f'<li><a>{attrs[\"title\"]}</a>{content}</li>\\n'\n        return start + tab + end"
    },
    {
      "chunk_id": 1463,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/columns.py",
      "content": "from re import Match\nfrom textwrap import dedent\nfrom typing import Any\n\nfrom mistune import HTMLRenderer\nfrom mistune.block_parser import BlockParser\nfrom mistune.core import BlockState\nfrom mistune.directives import DirectivePlugin, RSTDirective\nfrom mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1464,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/columns.py",
      "content": "class Column(DirectivePlugin):\n    \"\"\"Column directive for mistune.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1465,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/columns.py",
      "content": "def parse(\n        self, block: BlockParser, m: Match, state: BlockState\n    ) -> dict[str, Any]:\n        info = m.groupdict()\n\n        new_state = block.state_cls()\n        new_state.process(dedent(info[\"text\"]))\n        block.parse(new_state)\n\n        return {\n            \"type\": \"column\",\n            \"text\": info[\"text\"],\n            \"children\": new_state.tokens,\n            \"attrs\": {},\n        }"
    },
    {
      "chunk_id": 1466,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/columns.py",
      "content": "def __call__(  # type: ignore\n        self, directive: RSTDirective, md: Markdown\n    ) -> None:\n        directive.register(\"column\", self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"column\", self._render_column)"
    },
    {
      "chunk_id": 1467,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/columns.py",
      "content": "def _render_column(self, renderer: HTMLRenderer, text: str, **attrs):\n        start = (\n            '<div class=\"columns mt-3 is-multiline\">\\n'\n            if attrs.get(\"first\")\n            else \"\"\n        )\n        end = \"</div>\\n\" if attrs.get(\"last\") else \"\"\n        col = f'<div class=\"column is-half\">{text}</div>\\n'\n        return start + (col) + end"
    },
    {
      "chunk_id": 1468,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/hook.py",
      "content": "from mistune.core import BlockState\nfrom mistune.directives import DirectivePlugin, RSTDirective\nfrom mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1469,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/hook.py",
      "content": "class Hook(DirectivePlugin):\n    def __call__(  # type: ignore\n        self, directive: RSTDirective, md: Markdown\n    ) -> None:\n        if md.renderer.NAME == \"html\":\n            md.before_render_hooks.append(self._hook)"
    },
    {
      "chunk_id": 1470,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/hook.py",
      "content": "def _hook(self, md: Markdown, state: BlockState) -> None:\n        prev = None\n        for idx, token in enumerate(state.tokens):\n            for type_ in (\"column\", \"tab\"):\n                if token[\"type\"] == type_:\n                    maybe_next = (\n                        state.tokens[idx + 1]\n                        if idx + 1 < len(state.tokens)\n                        else None\n                    )\n                    token.setdefault(\"attrs\", {})\n                    if prev and prev[\"type\"] != type_:\n                        token[\"attrs\"][\"first\"] = True\n                    if (\n                        maybe_next and maybe_next[\"type\"] != type_\n                    ) or not maybe_next:\n                        token[\"attrs\"][\"last\"] = True\n\n            prev = token"
    },
    {
      "chunk_id": 1471,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/span.py",
      "content": "import re"
    },
    {
      "chunk_id": 1472,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/span.py",
      "content": "from mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1473,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/span.py",
      "content": "def parse_inline_span(inline, m: re.Match, state):\n    state.append_token(\n        {\n            \"type\": \"span\",\n            \"attrs\": {\"classes\": m.group(\"classes\")},\n            \"raw\": m.group(\"content\"),\n        }\n    )\n    return m.end()"
    },
    {
      "chunk_id": 1474,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/span.py",
      "content": "SPAN_PATTERN = r\"{span:(?:(?P<classes>[^\\:]+?):)?(?P<content>.*?)}\""
    },
    {
      "chunk_id": 1475,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/span.py",
      "content": "def span(md: Markdown) -> None:\n    md.inline.register(\n        \"span\",\n        SPAN_PATTERN,\n        parse_inline_span,\n        before=\"link\",\n    )"
    },
    {
      "chunk_id": 1476,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/notification.py",
      "content": "from html5tagger import HTML, E\nfrom mistune.directives import Admonition"
    },
    {
      "chunk_id": 1477,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/notification.py",
      "content": "class Notification(Admonition):\n    SUPPORTED_NAMES = {\n        \"success\",\n        \"info\",\n        \"warning\",\n        \"danger\",\n        \"tip\",\n        \"new\",\n        \"note\",\n    }\n\n    def __call__(self, directive, md):\n        for name in self.SUPPORTED_NAMES:\n            directive.register(name, self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"admonition\", self._render_admonition)\n            md.renderer.register(\n                \"admonition_title\", self._render_admonition_title\n            )\n            md.renderer.register(\n                \"admonition_content\", self._render_admonition_content\n            )"
    },
    {
      "chunk_id": 1478,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/notification.py",
      "content": "def _render_admonition(self, _, text, name, **attrs) -> str:\n        return str(\n            E.div(\n                HTML(text),\n                class_=f\"notification is-{name}\",\n            )\n        )"
    },
    {
      "chunk_id": 1479,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/notification.py",
      "content": "def _render_admonition_title(self, _, text) -> str:\n        return str(\n            E.p(\n                text,\n                class_=\"notification-title\",\n            )\n        )"
    },
    {
      "chunk_id": 1480,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/notification.py",
      "content": "def _render_admonition_content(self, _, text) -> str:\n        return text"
    },
    {
      "chunk_id": 1481,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/attrs.py",
      "content": "from re import Match\nfrom textwrap import dedent\nfrom typing import Any\n\nfrom html5tagger import HTML, E\nfrom mistune.block_parser import BlockParser\nfrom mistune.core import BlockState\nfrom mistune.directives import DirectivePlugin"
    },
    {
      "chunk_id": 1482,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/attrs.py",
      "content": "class Attributes(DirectivePlugin):\n    \"\"\"A class to handle attributes for directives.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1483,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/attrs.py",
      "content": "def __call__(self, directive, md):\n        directive.register(\"attrs\", self.parse)\n\n        if md.renderer.NAME == \"html\":\n            md.renderer.register(\"attrs\", self._render)"
    },
    {
      "chunk_id": 1484,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/attrs.py",
      "content": "def parse(\n        self, block: BlockParser, m: Match, state: BlockState\n    ) -> dict[str, Any]:\n        info = m.groupdict()\n        options = dict(self.parse_options(m))\n        new_state = block.state_cls()\n        new_state.process(dedent(info[\"text\"]))\n        block.parse(new_state)\n        options.setdefault(\"class_\", \"additional-attributes\")\n        classes = options.pop(\"class\", \"\")\n        if classes:\n            options[\"class_\"] += f\" {classes}\"\n\n        return {\n            \"type\": \"attrs\",\n            \"text\": info[\"text\"],\n            \"children\": new_state.tokens,\n            \"attrs\": options,\n        }"
    },
    {
      "chunk_id": 1485,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/attrs.py",
      "content": "def _render(self, _, text: str, **attrs) -> str:\n        return str(E.div(HTML(text), **attrs))"
    },
    {
      "chunk_id": 1486,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/inline_directive.py",
      "content": "import re"
    },
    {
      "chunk_id": 1487,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/inline_directive.py",
      "content": "from mistune.markdown import Markdown"
    },
    {
      "chunk_id": 1488,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/inline_directive.py",
      "content": "DIRECTIVE_PATTERN = r\":(?:class|func|meth|attr|exc|mod|data|const|obj|keyword|option|cmdoption|envvar):`(?P<ref>sanic\\.[^`]+)`\"  # noqa: E501"
    },
    {
      "chunk_id": 1489,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/inline_directive.py",
      "content": "def _parse_inline_directive(inline, m: re.Match, state):\n    state.append_token(\n        {\n            \"type\": \"inline_directive\",\n            \"attrs\": {},\n            \"raw\": m.group(\"ref\"),\n        }\n    )\n    return m.end()"
    },
    {
      "chunk_id": 1490,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/plugins/inline_directive.py",
      "content": "def inline_directive(md: Markdown):\n    md.inline.register(\n        \"inline_directive\",\n        DIRECTIVE_PATTERN,\n        _parse_inline_directive,\n        before=\"escape\",\n    )"
    },
    {
      "chunk_id": 1491,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "```python"
    },
    {
      "chunk_id": 1492,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1493,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "class MyClass:\n    \"\"\"This is a sample class.\"\"\"\n    \n    def __init__(self, value):\n        self.value = value"
    },
    {
      "chunk_id": 1494,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "def method_one(self):\n        print(\"Method One\")"
    },
    {
      "chunk_id": 1495,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "def method_two(self):\n        print(\"Method Two\")"
    },
    {
      "chunk_id": 1496,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/__init__.py",
      "content": "def standalone_function():\n    print(\"This is a standalone function.\")\n```"
    },
    {
      "chunk_id": 1497,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "from collections.abc import Generator\nfrom contextlib import contextmanager\n\nfrom sanic import Request\nfrom webapp.display.layouts.elements.footer import do_footer\nfrom webapp.display.layouts.elements.navbar import do_navbar\nfrom webapp.display.layouts.elements.sidebar import do_sidebar\n\nfrom .base import BaseLayout"
    },
    {
      "chunk_id": 1498,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "class MainLayout(BaseLayout):\n    \"\"\"Main layout for the web application.\"\"\"\n\n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1499,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "@contextmanager\n    def layout(\n        self, request: Request, full: bool = True\n    ) -> Generator[None, None, None]:\n        if full:\n            self.builder.div(class_=\"loading-bar\")\n            with self.builder.div(class_=\"is-flex\"):\n                self._sidebar(request)\n                with self.builder.main(class_=\"is-flex-grow-1\"):\n                    self._navbar(request)\n                    with self.builder.div(class_=\"container\", id=\"content\"):\n                        with self._content_wrapper(request):\n                            yield\n                        self._footer(request)\n        else:\n            with self._content_wrapper(request):\n                yield\n            self._footer(request)"
    },
    {
      "chunk_id": 1500,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "@contextmanager\n    def _content_wrapper(\n        self, request: Request\n    ) -> Generator[None, None, None]:\n        current_page = (\n            request.ctx.current_page\n            if hasattr(request.ctx, \"current_page\")\n            else None\n        )\n        section_class = \"section\"\n        if current_page and current_page.meta.content_class:\n            section_class += f\" {current_page.meta.content_class}\"\n        with self.builder.section(class_=section_class):\n            with self.builder.article():\n                yield"
    },
    {
      "chunk_id": 1501,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "def _navbar(self, request: Request) -> None:\n        do_navbar(self.builder, request)"
    },
    {
      "chunk_id": 1502,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "def _sidebar(self, request: Request) -> None:\n        do_sidebar(self.builder, request)"
    },
    {
      "chunk_id": 1503,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/main.py",
      "content": "def _footer(self, request: Request) -> None:\n        do_footer(self.builder, request)"
    },
    {
      "chunk_id": 1504,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/base.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\n\nfrom html5tagger import Builder\n\nfrom sanic import Request"
    },
    {
      "chunk_id": 1505,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/base.py",
      "content": "class BaseLayout:\n    def __init__(self, builder: Builder):\n        self.builder = builder"
    },
    {
      "chunk_id": 1506,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/base.py",
      "content": "@contextmanager\n    def __call__(\n        self, request: Request, full: bool = True\n    ) -> Generator[BaseLayout, None, None]:\n        with self.layout(request, full=full):\n            yield self"
    },
    {
      "chunk_id": 1507,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/base.py",
      "content": "@contextmanager\n    def layout(\n        self, request: Request, full: bool = True\n    ) -> Generator[None, None, None]:\n        yield"
    },
    {
      "chunk_id": 1508,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/models.py",
      "content": "from __future__ import annotations\n\nfrom msgspec import Struct, field"
    },
    {
      "chunk_id": 1509,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/models.py",
      "content": "class MenuItem(Struct, kw_only=False, omit_defaults=True):\n    \"\"\"\n    Represents a menu item with a label, path, href, and sub-items.\n    \"\"\"\n    label: str\n    path: str | None = None\n    href: str | None = None\n    items: list[MenuItem] = field(default_factory=list)"
    },
    {
      "chunk_id": 1510,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/models.py",
      "content": "class GeneralConfig(Struct, kw_only=False):\n    \"\"\"\n    Represents the general configuration with a current version.\n    \"\"\"\n    current_version: str"
    },
    {
      "chunk_id": 1511,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "from __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\n\nfrom html5tagger import Builder, E\n\nfrom sanic import Request\nfrom webapp.display.layouts.elements.footer import do_footer\n\nfrom .base import BaseLayout"
    },
    {
      "chunk_id": 1512,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "class HomeLayout(BaseLayout):\n    \"\"\"Home layout for the Sanic web application.\"\"\"\n    \n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1513,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "@contextmanager\n    def layout(\n        self, request: Request, full: bool = True\n    ) -> Generator[None, None, None]:\n        self._sponsors()\n        self._hero(request.ctx.language)\n        with self.builder.div(class_=\"home container\"):\n            yield\n        self._footer(request)"
    },
    {
      "chunk_id": 1514,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "def _hero(self, language: str) -> None:\n        with self.builder.section(class_=\"hero is-large has-text-centered\"):\n            self.builder.div(\n                E.h1(E.span(\"Sanic\"), class_=\"title\"),\n                E.h2(class_=\"subtitle\")(\"Build fast. Run fast.\"),\n                E.h3(class_=\"tagline\")(\"Accelerate your web app development\"),\n                self._do_buttons(language),\n                class_=\"hero-body\",\n            )"
    },
    {
      "chunk_id": 1515,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "def _do_buttons(self, language: str) -> Builder:\n        builder = E.div(class_=\"buttons is-centered\")\n        with builder:\n            builder.a(\n                \"Get Started\",\n                class_=\"button is-primary\",\n                href=f\"/{language}/guide/getting-started.html\",\n            )\n            builder.a(\n                \"Help\",\n                class_=\"button is-outlined\",\n                href=f\"/{language}/help.html\",\n            )\n            builder.a(\n                \"GitHub\",\n                class_=\"button is-outlined\",\n                href=\"https://github.com/sanic-org/sanic\",\n                target=\"_blank\",\n            )\n        return builder"
    },
    {
      "chunk_id": 1516,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "def _sponsors(self) -> None:\n        with self.builder.section(class_=\"sponsors\"):\n            self.builder(\n                \"Secure, auto-document, and monetize \"\n                \"your Sanic API with Zuplo\",\n                E.a(\n                    \"Start free\",\n                    href=\"https://zuplo.com\",\n                    target=\"_blank\",\n                    class_=\"button is-primary is-small\",\n                ),\n            )"
    },
    {
      "chunk_id": 1517,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/home.py",
      "content": "def _footer(self, request: Request) -> None:\n        do_footer(\n            self.builder,\n            request,\n            extra_classes=\"mb-0 mt-6\",\n            with_pagination=False,\n        )"
    },
    {
      "chunk_id": 1518,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1519,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "from collections import deque\nfrom datetime import datetime\n\nfrom html5tagger import Builder, E  # type: ignore\n\nfrom sanic import Request"
    },
    {
      "chunk_id": 1520,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "def do_footer(\n    builder: Builder,\n    request: Request,\n    extra_classes: str = \"\",\n    with_pagination: bool = True,\n) -> None:\n    content = deque([_content()])\n    if with_pagination:\n        content.appendleft(_pagination(request))\n    css_classes = \"footer\"\n    if extra_classes:\n        css_classes += f\" {extra_classes}\"\n    builder.footer(\n        *content,\n        class_=css_classes,\n    )"
    },
    {
      "chunk_id": 1521,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "def _pagination(request: Request) -> Builder:\n    return E.div(\n        _pagination_left(request), _pagination_right(request), class_=\"level\"\n    )"
    },
    {
      "chunk_id": 1522,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "def _pagination_left(request: Request) -> Builder:\n    item = E.div(class_=\"level-item\")\n    if not hasattr(request.ctx, \"previous_page\"):\n        return E.div(item, class_=\"level-left\")\n    with item:\n        if p := request.ctx.previous_page:\n            path = p.relative_path.with_suffix(\".html\")\n            item.a(\n                f\"\u2190 {p.meta.title}\",\n                href=f\"/{path}\",\n                hx_get=f\"/{path}\",\n                hx_target=\"#content\",\n                hx_swap=\"innerHTML\",\n                hx_push_url=\"true\",\n                class_=\"button pagination\",\n            )\n    return E.div(item, class_=\"level-left\")"
    },
    {
      "chunk_id": 1523,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "def _pagination_right(request: Request) -> Builder:\n    item = E.div(class_=\"level-item\")\n    if not hasattr(request.ctx, \"next_page\"):\n        return E.div(item, class_=\"level-right\")\n    with item:\n        if p := request.ctx.next_page:\n            path = p.relative_path.with_suffix(\".html\")\n            item.a(\n                f\"{p.meta.title} \u2192\",\n                href=f\"/{path}\",\n                hx_get=f\"/{path}\",\n                hx_target=\"#content\",\n                hx_swap=\"innerHTML\",\n                hx_push_url=\"true\",\n                class_=\"button pagination\",\n            )\n    return E.div(item, class_=\"level-right\")"
    },
    {
      "chunk_id": 1524,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/footer.py",
      "content": "def _content() -> Builder:\n    year = datetime.now().year\n    legal = E.p(\n        E.a(\n            \"MIT Licensed\",\n            href=\"https://github.com/sanic-org/sanic/blob/master/LICENSE\",\n            target=\"_blank\",\n            rel=\"nofollow noopener noreferrer\",\n        ).br()(\n            E.small(f\"Copyright \u00a9 2018-{year} Sanic Community Organization\")\n        ),\n    )\n    powered = E.p(\n        E.a(\"This site is powered\", href=\"/en/built-with-sanic.html\"),\n        E.img(\n            src=\"/assets/images/sanic-framework-logo-circle-32x32.png\",\n            alt=\"Sanic Logo\",\n            style=\"vertical-align: middle;\",\n            class_=\"ml-1\",\n        ),\n    )\n    with_love = E.p(\"~ Made with \u2764\ufe0f and \u2615\ufe0f ~\")\n    return E.div(\n        legal,\n        powered,\n        with_love,\n        class_=\"content has-text-centered\",\n    )"
    },
    {
      "chunk_id": 1525,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "from html5tagger import Builder, E  # type: ignore\n\nfrom sanic import Request\nfrom webapp.display.layouts.models import MenuItem\nfrom webapp.display.text import slugify"
    },
    {
      "chunk_id": 1526,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def do_sidebar(builder: Builder, request: Request) -> None:\n    builder.a(class_=\"burger\")(E.span().span().span().span())\n    builder.aside(*_menu_items(request), class_=\"menu\")"
    },
    {
      "chunk_id": 1527,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _menu_items(request: Request) -> list[Builder]:\n    return [\n        _sanic_logo(request),\n        *_sidebar_items(request),\n        E.hr(),\n        E.p(\"Current with version \").strong(\n            request.app.config.GENERAL.current_version\n        ),\n        E.hr(),\n        E.ul.li(\"Need \").a(\"help\", href=f\"/{request.ctx.language}/help.html\")(\n            \"?\"\n        ),\n        E.li(\"How we \").a(\n            \"built this site w/ Sanic\",\n            href=\"/{request.ctx.language}/built-with-sanic.html\",\n        ),\n        E.li(\"The \").a(\n            \"Awesome Sanic\",\n            href=\"https://github.com/mekicha/awesome-sanic\",\n            target=\"_blank\",\n        )(\" list\"),\n        E.hr(),\n        E.p(\"Want more? \")\n        .a(\"sanicbook.com\", href=\"https://sanicbook.com\", target=\"_blank\")\n        .br.img(src=\"https://sanicbook.com/images/SanicCoverFinal.png\"),\n        E.br.small(\"Book proceeds fund our journey\"),\n        E.hr(),\n        E.p(\"Secure, auto-document, and monetize your Sanic API with:\").a(\n            E.img(\n                src=\"/assets/images/zuplo.svg\",\n                alt=(\n                    \"Zuplo - Secure, auto-document, \"\n                    \"and monetize your Sanic API\"\n                ),\n                style=\"width: 90%;\",\n            ),\n            href=\"https://zuplo.com\",\n            target=\"_blank\",\n            rel=\"nofollow noopener noreferrer\",\n        ),\n    ]"
    },
    {
      "chunk_id": 1528,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _sanic_logo(request: Request) -> Builder:\n    return E.a(\n        class_=\"navbar-item sanic-simple-logo my-3\",\n        href=f\"https://sanic.dev/{request.ctx.language}/\",\n    )(\n        E.img(\n            src=\"/assets/images/sanic-framework-logo-simple-400x97.png\",  # noqa: E501\n            alt=\"Sanic Framework\",\n        )\n    )"
    },
    {
      "chunk_id": 1529,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _sidebar_items(request: Request) -> list[Builder]:\n    return [\n        builder\n        for item in request.app.config.SIDEBAR\n        for builder in _render_sidebar_item(item, request, True)\n    ]"
    },
    {
      "chunk_id": 1530,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _render_sidebar_item(\n    item: MenuItem, request: Request, root: bool = False\n) -> list[Builder]:\n    builders: list[Builder] = []\n    if root:\n        builders.append(E.p(class_=\"menu-label\")(item.label))\n    else:\n        builders.append(_single_sidebar_item(item, request))\n\n    if item.items:\n        ul = E.ul(class_=\"menu-list\")\n        with ul:\n            for subitem in item.items:\n                sub_builders = _render_sidebar_item(subitem, request)\n                ul(*sub_builders)\n        builders.append(ul)\n\n    return builders"
    },
    {
      "chunk_id": 1531,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _single_sidebar_item(item: MenuItem, request: Request) -> Builder:\n    if item.path and item.path.startswith(\"/\"):\n        path = item.path\n    else:\n        path = f\"/{request.ctx.language}/{item.path}\" if item.path else \"\"\n    kwargs = {}\n    classes: list[str] = []\n    li_classes = \"menu-item\"\n    _, page, _ = request.app.ctx.get_page(\n        request.ctx.language, item.path or \"\"\n    )\n    if request.path == path:\n        classes.append(\"is-active\")\n    if item.href:\n        kwargs[\"href\"] = item.href\n        kwargs[\"target\"] = \"_blank\"\n        kwargs[\"rel\"] = \"nofollow noopener noreferrer\"\n    elif not path:\n        li_classes += \" is-group\"\n        if _is_open_item(item, request.ctx.language, request.path):\n            classes.append(\"is-open\")\n    else:\n        kwargs.update(\n            {\n                \"href\": path,\n                \"hx-get\": path,\n                \"hx-target\": \"#content\",\n                \"hx-swap\": \"innerHTML\",\n                \"hx-push-url\": \"true\",\n            }\n        )\n    kwargs[\"class_\"] = \" \".join(classes)\n    inner = E().a(item.label, **kwargs)\n    if page and page.anchors:\n        with inner.ul(class_=\"anchor-list\"):\n            for anchor in page.anchors:\n                inner.li(\n                    E.a(anchor.strip(\"`\"), href=f\"{path}#{slugify(anchor)}\"),\n                    class_=\"is-anchor\",\n                )\n    return E.li(inner, class_=li_classes)"
    },
    {
      "chunk_id": 1532,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/sidebar.py",
      "content": "def _is_open_item(item: MenuItem, language: str, current_path: str) -> bool:\n    path = f\"/{language}/{item.path}\" if item.path else \"\"\n    if current_path == path:\n        return True\n    for subitem in item.items:\n        if _is_open_item(subitem, language, current_path):\n            return True\n    return False"
    },
    {
      "chunk_id": 1533,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/navbar.py",
      "content": "from html5tagger import Builder, E  # type: ignore\n\nfrom sanic import Request\nfrom webapp.display.layouts.models import MenuItem"
    },
    {
      "chunk_id": 1534,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/navbar.py",
      "content": "def do_navbar(builder: Builder, request: Request) -> None:\n    navbar_items = [\n        _render_navbar_item(item, request)\n        for item in request.app.config.NAVBAR\n    ]\n    container = E.div(\n        _search_form(request), *navbar_items, class_=\"navbar-end\"\n    )\n\n    builder.nav(\n        E.div(container, class_=\"navbar-menu\"),\n        class_=\"navbar is-hidden-touch\",\n    )"
    },
    {
      "chunk_id": 1535,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/navbar.py",
      "content": "def _search_form(request: Request) -> Builder:\n    return E.div(\n        E.div(\n            E.input(\n                id_=\"search\",\n                type_=\"text\",\n                placeholder=\"Search\",\n                class_=\"input\",\n                value=request.args.get(\"q\", \"\"),\n                hx_target=\"#content\",\n                hx_swap=\"innerHTML\",\n                hx_push_url=\"true\",\n                hx_trigger=\"keyup changed delay:500ms\",\n                hx_get=f\"/{request.ctx.language}/search\",\n                hx_params=\"*\",\n            ),\n            class_=\"control\",\n        ),\n        class_=\"navbar-item\",\n    )"
    },
    {
      "chunk_id": 1536,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/layouts/elements/navbar.py",
      "content": "def _render_navbar_item(item: MenuItem, request: Request) -> Builder:\n    if item.items:\n        return E.div(\n            E.a(item.label, class_=\"navbar-link\"),\n            E.div(\n                *(\n                    _render_navbar_item(subitem, request)\n                    for subitem in item.items\n                ),\n                class_=\"navbar-dropdown\",\n            ),\n            class_=\"navbar-item has-dropdown is-hoverable\",\n        )\n\n    kwargs = {\n        \"class_\": \"navbar-item\",\n    }\n    if item.href:\n        kwargs[\"href\"] = item.href\n        kwargs[\"target\"] = \"_blank\"\n        kwargs[\"rel\"] = \"nofollow noopener noreferrer\"\n    elif item.path:\n        kwargs[\"href\"] = f\"/{request.ctx.language}/{item.path}\"\n    internal = [item.label]\n    return E.a(*internal, **kwargs)"
    },
    {
      "chunk_id": 1537,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1538,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "from contextlib import contextmanager\nfrom urllib.parse import unquote\n\nfrom html5tagger import Builder, E  # type: ignore\n\nfrom sanic import Request\nfrom webapp.display.search.search import Searcher\n\nfrom ..base import BaseRenderer\nfrom ..layouts.main import MainLayout"
    },
    {
      "chunk_id": 1539,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "class SearchRenderer(BaseRenderer):\n    \"\"\"SearchRenderer class for rendering search results.\"\"\"\n\n    def __init__(self):\n        super().__init__()"
    },
    {
      "chunk_id": 1540,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "def render(\n        self, request: Request, language: str, searcher: Searcher, full: bool\n    ) -> Builder:\n        builder = self.get_builder(\n            full=request.headers.get(\"HX-Request\") is None,\n            language=language,\n        )\n        self._body(request, builder, language, searcher, full)\n        return builder"
    },
    {
      "chunk_id": 1541,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "def _body(\n        self,\n        request: Request,\n        builder: Builder,\n        language: str,\n        searcher: Searcher,\n        full: bool,\n    ):\n        with self._base(request, builder, full):\n            builder.h1(\"Search\")\n            self._results(request, builder, searcher, language)"
    },
    {
      "chunk_id": 1542,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "@contextmanager\n    def _base(self, request: Request, builder: Builder, full: bool):\n        layout = MainLayout(builder)\n        with layout(request, full):\n            yield"
    },
    {
      "chunk_id": 1543,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/renderer.py",
      "content": "def _results(\n        self,\n        request: Request,\n        builder: Builder,\n        searcher: Searcher,\n        language: str,\n    ):\n        query = unquote(request.args.get(\"q\", \"\"))\n        results = searcher.search(query, language)\n        if not query or not results:\n            builder.p(\"No results found\")\n            return\n\n        with builder.div(class_=\"container\"):\n            with builder.ul():\n                for _, doc in results:\n                    builder.li(\n                        E.a(\n                            doc.title,\n                            href=f\"/{doc.page.relative_path}\",\n                            hx_get=f\"/{doc.page.relative_path}\",\n                            hx_target=\"#content\",\n                            hx_swap=\"innerHTML\",\n                            hx_push_url=\"true\",\n                        ),\n                        f\" - {doc.page.relative_path}\",\n                    )"
    },
    {
      "chunk_id": 1544,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "from __future__ import annotations\n\nfrom collections import Counter\nfrom pathlib import Path\nfrom typing import ClassVar\n\nfrom msgspec import Struct\n\nfrom webapp.display.page import Page"
    },
    {
      "chunk_id": 1545,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "class Stemmer:\n    STOP_WORDS: ClassVar[set[str]] = set(\n        \"a about above after again against all am an and any are aren't as at be because been before being below between both but by can't cannot could couldn't did didn't do does doesn't doing don't down during each few for from further had hadn't has hasn't have haven't having he he'd he'll he's her here here's hers herself him himself his how how's i i'd i'll i'm i've if in into is isn't it it's its itself let's me more most mustn't my myself no nor not of off on once only or other ought our ours ourselves out over own same shan't she she'd she'll she's should shouldn't so some such than that that's the their theirs them themselves then there there's these they they'd they'll they're they've this those through to too under until up very was wasn't we we'd we'll we're we've were weren't what what's when when's where where's which while who who's whom why why's with won't would wouldn't you you'd you'll you're you've your yours yourself yourselves\".split()  # noqa: E501\n    )\n    PREFIXES = set(\"auto be fore over re un under\".split())\n    SUFFIXES = set(\n        \"able al ance ant ate ed en er ful hood ing ion ish ity ive ize less ly ment ness ous ship sion tion y\".split()  # noqa: E501\n    )\n    VOWELS = set(\"aeiou\")\n    PLURALIZATION = set(\"s es ies\".split())\n\n    def stem(self, word: str) -> str:\n        if word in self.STOP_WORDS:\n            return word\n        if word in self.PREFIXES:\n            return word\n        for suffix in self.SUFFIXES | self.PLURALIZATION:\n            if word.endswith(suffix):\n                return self._stem(word[: -len(suffix)])\n        return word\n\n    def _stem(self, word: str) -> str:\n        if word.endswith(\"e\"):\n            return word[:-1]\n        if word.endswith(\"y\") and word[-2] not in self.VOWELS:\n            return word[:-1]\n        return word\n\n    def __call__(self, word: str) -> str:\n        return self.stem(word)"
    },
    {
      "chunk_id": 1546,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "class Document(Struct, kw_only=True):\n    TITLE_WEIGHT: ClassVar[int] = 3\n    BODY_WEIGHT: ClassVar[int] = 1\n\n    page: Page\n    language: str\n    term_frequency: dict[str, float] = {}\n\n    @property\n    def title(self) -> str:\n        return self.page.meta.title\n\n    @property\n    def text(self) -> str:\n        return self.page.content\n\n    @property\n    def weighted_text(self) -> str:\n        \"\"\"Return the text with the title repeated.\"\"\"\n        return \" \".join(\n            [self.title] * self.TITLE_WEIGHT + [self.text] * self.BODY_WEIGHT\n        )\n\n    def _term_frequency(self, stemmer: Stemmer) -> None:\n        \"\"\"Count the number of times each word appears in the document.\"\"\"\n        words = [\n            stemmer(word)\n            for word in self.weighted_text.lower().split()\n            if word not in Stemmer.STOP_WORDS\n        ]\n        num_words = len(words)\n        word_count = Counter(words)\n        self.term_frequency = {\n            word: count / num_words for word, count in word_count.items()\n        }\n\n    def process(self, stemmer: Stemmer) -> Document:\n        \"\"\"Process the document.\"\"\"\n        self._term_frequency(stemmer)\n        return self"
    },
    {
      "chunk_id": 1547,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "def _inverse_document_frequency(docs: list[Document]) -> dict[str, float]:\n    \"\"\"Count the number of documents each word appears in.\"\"\"\n    num_docs = len(docs)\n    word_count: Counter[str] = Counter()\n    for doc in docs:\n        word_count.update(doc.term_frequency.keys())\n    return {word: num_docs / count for word, count in word_count.items()}"
    },
    {
      "chunk_id": 1548,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "def _tf_idf_vector(\n    document: Document, idf: dict[str, float]\n) -> dict[str, float]:\n    \"\"\"Calculate the TF-IDF vector for a document.\"\"\"\n    return {\n        word: tf * idf[word]\n        for word, tf in document.term_frequency.items()\n        if word in idf\n    }"
    },
    {
      "chunk_id": 1549,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "def _cosine_similarity(\n    vec1: dict[str, float], vec2: dict[str, float]\n) -> float:\n    \"\"\"Calculate the cosine similarity between two vectors.\"\"\"\n    if not vec1 or not vec2:\n        return 0.0\n    dot_product = sum(vec1.get(word, 0) * vec2.get(word, 0) for word in vec1)\n    magnitude1 = sum(value**2 for value in vec1.values()) ** 0.5\n    magnitude2 = sum(value**2 for value in vec2.values()) ** 0.5\n    return dot_product / (magnitude1 * magnitude2)"
    },
    {
      "chunk_id": 1550,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "def _search(\n    query: str,\n    language: str,\n    vectors: list[dict[str, float]],\n    idf: dict[str, float],\n    documents: list[Document],\n    stemmer: Stemmer,\n) -> list[tuple[float, Document]]:\n    dummy_page = Page(Path(), query)\n    tf_idf_query = _tf_idf_vector(\n        Document(page=dummy_page, language=language).process(stemmer), idf\n    )\n    similarities = [\n        _cosine_similarity(tf_idf_query, vector) for vector in vectors\n    ]\n    return [\n        (similarity, document)\n        for similarity, document in sorted(\n            zip(similarities, documents),\n            reverse=True,\n            key=lambda pair: pair[0],\n        )[:10]\n        if similarity > 0\n    ]"
    },
    {
      "chunk_id": 1551,
      "source": "__internal__/data_repo/sanic/guide/webapp/display/search/search.py",
      "content": "class Searcher:\n    def __init__(\n        self,\n        stemmer: Stemmer,\n        documents: list[Document],\n    ):\n        self._documents: dict[str, list[Document]] = {}\n        for document in documents:\n            self._documents.setdefault(document.language, []).append(document)\n        self._idf = {\n            language: _inverse_document_frequency(documents)\n            for language, documents in self._documents.items()\n        }\n        self._vectors = {\n            language: [\n                _tf_idf_vector(document, self._idf[language])\n                for document in documents\n            ]\n            for language, documents in self._documents.items()\n        }\n        self._stemmer = stemmer\n\n    def search(\n        self, query: str, language: str\n    ) -> list[tuple[float, Document]]:\n        return _search(\n            query,\n            language,\n            self._vectors[language],\n            self._idf[language],\n            self._documents[language],\n            self._stemmer,\n        )"
    },
    {
      "chunk_id": 1552,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1553,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "from asyncio import sleep\nfrom multiprocessing import Manager\nfrom pathlib import Path\nfrom queue import Empty, Queue\nfrom typing import Any\n\nimport ujson\n\nfrom sanic import Request, Sanic, Websocket"
    },
    {
      "chunk_id": 1554,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "def setup_livereload(app: Sanic) -> None:\n    @app.main_process_start\n    async def main_process_start(app: Sanic):\n        app.ctx.manager = Manager()\n        app.shared_ctx.reload_queue = app.ctx.manager.Queue()\n\n    @app.main_process_ready\n    async def main_process_ready(app: Sanic):\n        app.manager.manage(\n            \"Livereload\",\n            _run_reload_server,\n            {\n                \"reload_queue\": app.shared_ctx.reload_queue,\n                \"debug\": app.state.is_debug,\n                \"state\": app.manager.worker_state,\n            },\n        )\n\n    @app.main_process_stop\n    async def main_process_stop(app: Sanic):\n        app.ctx.manager.shutdown()\n\n    @app.before_server_start\n    async def before_server_start(app: Sanic):\n        app.shared_ctx.reload_queue.put(\"reload\")\n\n    @app.after_server_start\n    async def after_server_start(app: Sanic):\n        app.m.state[\"ready\"] = True\n\n    @app.before_server_stop\n    async def before_server_stop(app: Sanic):\n        app.m.state[\"ready\"] = False"
    },
    {
      "chunk_id": 1555,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "class Livereload:\n    SERVER_NAME = \"Reloader\"\n    HELLO = {\n        \"command\": \"hello\",\n        \"protocols\": [\n            \"http://livereload.com/protocols/official-7\",\n        ],\n        \"serverName\": SERVER_NAME,\n    }\n\n    def __init__(\n        self, reload_queue: Queue, debug: bool, state: dict[str, Any]\n    ):\n        self.reload_queue = reload_queue\n        self.app = Sanic(self.SERVER_NAME)\n        self.debug = debug\n        self.state = state\n        self.app.static(\n            \"/livereload.js\", Path(__file__).parent / \"livereload.js\"\n        )\n        self.app.add_websocket_route(\n            self.livereload_handler, \"/livereload\", name=\"livereload\"\n        )\n        self.app.add_task(self._listen_to_queue())\n        self.app.config.EVENT_AUTOREGISTER = True"
    },
    {
      "chunk_id": 1556,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "def run(self):\n        kwargs = {\n            \"debug\": self.debug,\n            \"access_log\": False,\n            \"single_process\": True,\n            \"port\": 35729,\n        }\n        self.app.run(**kwargs)"
    },
    {
      "chunk_id": 1557,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "async def _listen_to_queue(self):\n        while True:\n            try:\n                self.reload_queue.get_nowait()\n            except Empty:\n                await sleep(0.5)\n                continue\n            await self.app.dispatch(\"livereload.file.reload\")"
    },
    {
      "chunk_id": 1558,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "async def livereload_handler(self, request: Request, ws: Websocket):\n        await ws.recv()\n        await ws.send(ujson.dumps(self.HELLO))\n\n        while True:\n            await request.app.event(\"livereload.file.reload\")\n            await self._wait_for_state()\n            await ws.send(ujson.dumps({\"command\": \"reload\", \"path\": \"...\"}))"
    },
    {
      "chunk_id": 1559,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "async def _wait_for_state(self):\n        while True:\n            states = [\n                state.get(\"ready\")\n                for state in self.state.values()\n                if state.get(\"server\")\n            ]\n            if all(states):\n                await sleep(0.5)\n                break"
    },
    {
      "chunk_id": 1560,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/reload.py",
      "content": "def _run_reload_server(\n    reload_queue: Queue, debug: bool, state: dict[str, Any]\n):\n    Livereload(reload_queue, debug, state).run()"
    },
    {
      "chunk_id": 1561,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/style.py",
      "content": "# from scss.compiler import compile_string\n\nfrom pygments.formatters import html\nfrom sass import compile as compile_scss\n\nfrom sanic import Sanic\nfrom webapp.display.code_style import SanicCodeStyle"
    },
    {
      "chunk_id": 1562,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/style.py",
      "content": "def setup_style(app: Sanic) -> None:\n    index = app.config.STYLE_DIR / \"index.scss\"\n    style_output = app.config.PUBLIC_DIR / \"assets\" / \"style.css\"\n    code_output = app.config.PUBLIC_DIR / \"assets\" / \"code.css\"\n\n    @app.before_server_start\n    async def setup(app: Sanic):\n        scss = compile_scss(\n            string=index.read_text(),\n            include_paths=[\n                str(app.config.NODE_MODULES_DIR),\n                str(app.config.STYLE_DIR),\n            ],\n        )\n        style_output.write_text(scss)\n        formatter = html.HtmlFormatter(\n            style=SanicCodeStyle, full=True, cssfile=code_output\n        )\n        code_output.write_text(formatter.get_style_defs())"
    },
    {
      "chunk_id": 1563,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/factory.py",
      "content": "from pathlib import Path\n\nfrom sanic import Request, Sanic, html, redirect\nfrom webapp.display.layouts.models import MenuItem\nfrom webapp.display.page import Page, PageRenderer\nfrom webapp.endpoint.sitemap import setup_sitemap\nfrom webapp.endpoint.view import bp\nfrom webapp.worker.config import load_config, load_menu\nfrom webapp.worker.reload import setup_livereload\nfrom webapp.worker.style import setup_style"
    },
    {
      "chunk_id": 1564,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/factory.py",
      "content": "KNOWN_REDIRECTS = {\n    \"guide/deployment/configuration.html\": \"guide/running/configuration.html\",\n    \"guide/deployment/development.html\": \"guide/running/development.html\",\n    \"guide/deployment/running.html\": \"guide/running/running.html\",\n    \"guide/deployment/manager.html\": \"guide/running/manager.html\",\n    \"guide/deployment/app-loader.html\": \"guide/running/app-loader.html\",\n    \"guide/deployment/inspector.html\": \"guide/running/inspector.html\",\n    \"org/policies.html\": \"organization/policies.html\",\n    \"org/scope.html\": \"organization/scope.html\",\n    \"org/feature_requests.html\": \"\",\n}"
    },
    {
      "chunk_id": 1565,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/factory.py",
      "content": "def _compile_sidebar_order(items: list[MenuItem]) -> list[str]:\n    order = []\n    for item in items:\n        if item.path:\n            order.append(item.path.removesuffix(\".html\") + \".md\")\n        if item.items:\n            order.extend(_compile_sidebar_order(item.items))\n    return order"
    },
    {
      "chunk_id": 1566,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/factory.py",
      "content": "def create_app(root: Path) -> Sanic:\n    app = Sanic(\"Documentation\")\n    app.config.PUBLIC_DIR = root / \"public\"\n    app.config.CONTENT_DIR = root / \"content\"\n    app.config.CONFIG_DIR = root / \"config\"\n    app.config.STYLE_DIR = root / \"style\"\n    app.config.NODE_MODULES_DIR = root / \"node_modules\"\n    app.config.LANGUAGES = [\"en\"]\n    app.config.SIDEBAR = load_menu(\n        app.config.CONFIG_DIR / \"en\" / \"sidebar.yaml\"\n    )\n    app.config.NAVBAR = load_menu(app.config.CONFIG_DIR / \"en\" / \"navbar.yaml\")\n    app.config.GENERAL = load_config(\n        app.config.CONFIG_DIR / \"en\" / \"general.yaml\"\n    )\n\n    setup_livereload(app)\n    setup_style(app)\n    setup_sitemap(app)\n    app.blueprint(bp)\n\n    app.static(\"/assets/\", app.config.PUBLIC_DIR / \"assets\", name=\"assets\")\n\n    for path in (app.config.PUBLIC_DIR / \"web\").glob(\"*\"):\n        app.static(f\"/{path.name}\", path, name=path.name)\n\n    @app.before_server_start(priority=1)\n    async def setup(app: Sanic):\n        app.ext.dependency(PageRenderer(base_title=\"Sanic User Guide\"))\n        page_order = _compile_sidebar_order(app.config.SIDEBAR)\n        app.ctx.pages = Page.load_pages(app.config.CONTENT_DIR, page_order)\n        app.ctx.get_page = Page.get\n\n    @app.get(\"/\", name=\"root\")\n    @app.get(\"/index.html\", name=\"index\")\n    async def index(request: Request):\n        return redirect(request.app.url_for(\"page\", language=\"en\", path=\"\"))\n\n    @app.get(\"/<language:str>\", name=\"page-without-path\")\n    @app.get(\"/<language:str>/<path:path>\")\n    async def page(\n        request: Request,\n        page_renderer: PageRenderer,\n        language: str,\n        path: str = \"\",\n    ):\n        # TODO: Add more language support\n        if language != \"api\" and language not in app.config.LANGUAGES:\n            return redirect(\n                request.app.url_for(\"page\", language=\"en\", path=path)\n            )\n        if path in KNOWN_REDIRECTS:\n            return redirect(\n                request.app.url_for(\n                    \"page\", language=language, path=KNOWN_REDIRECTS[path]\n                ),\n                status=301,\n            )\n        builder = page_renderer.render(request, language, path)\n        title_text = page_renderer.title()\n        return html(\n            str(builder),\n            headers={\n                \"vary\": \"hx-request\",\n                \"x-title\": title_text,\n            },\n        )\n\n    @app.on_request\n    async def set_language(request: Request):\n        request.ctx.language = request.match_info.get(\n            \"language\", Page.DEFAULT_LANGUAGE\n        )\n\n    return app"
    },
    {
      "chunk_id": 1567,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/config.py",
      "content": "from pathlib import Path\n\nfrom msgspec import yaml\n\nfrom webapp.display.layouts.models import GeneralConfig, MenuItem"
    },
    {
      "chunk_id": 1568,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/config.py",
      "content": "def load_menu(path: Path) -> list[MenuItem]:\n    loaded = yaml.decode(path.read_bytes(), type=dict[str, list[MenuItem]])\n    return loaded[\"root\"]"
    },
    {
      "chunk_id": 1569,
      "source": "__internal__/data_repo/sanic/guide/webapp/worker/config.py",
      "content": "def load_config(path: Path) -> GeneralConfig:\n    loaded = yaml.decode(path.read_bytes(), type=GeneralConfig)\n    return loaded"
    },
    {
      "chunk_id": 1570,
      "source": "__internal__/data_repo/sanic/guide/content/en/emoji.py",
      "content": "EMOJI = {\n    \"1st_place_medal\": \"\ud83e\udd47\",\n    \"2nd_place_medal\": \"\ud83e\udd48\",\n    \"3rd_place_medal\": \"\ud83e\udd49\",\n    \"AB_button_(blood_type)\": \"\ud83c\udd8e\",\n    \"ATM_sign\": \"\ud83c\udfe7\",\n    \"A_button_(blood_type)\": \"\ud83c\udd70\",\n    \"Afghanistan\": \"\ud83c\udde6\ud83c\uddeb\",\n    \"Albania\": \"\ud83c\udde6\ud83c\uddf1\",\n    \"Algeria\": \"\ud83c\udde9\ud83c\uddff\",\n    \"American_Samoa\": \"\ud83c\udde6\ud83c\uddf8\",\n    \"Andorra\": \"\ud83c\udde6\ud83c\udde9\",\n    \"Angola\": \"\ud83c\udde6\ud83c\uddf4\",\n    \"Anguilla\": \"\ud83c\udde6\ud83c\uddee\",\n    \"Antarctica\": \"\ud83c\udde6\ud83c\uddf6\",\n    \"Antigua_&_Barbuda\": \"\ud83c\udde6\ud83c\uddec\",\n    \"Aquarius\": \"\u2652\",\n    \"Argentina\": \"\ud83c\udde6\ud83c\uddf7\",\n    \"Aries\": \"\u2648\",\n    \"Armenia\": \"\ud83c\udde6\ud83c\uddf2\",\n    \"Aruba\": \"\ud83c\udde6\ud83c\uddfc\",\n    \"Ascension_Island\": \"\ud83c\udde6\ud83c\udde8\",\n    \"Australia\": \"\ud83c\udde6\ud83c\uddfa\",\n    \"Austria\": \"\ud83c\udde6\ud83c\uddf9\",\n    \"Azerbaijan\": \"\ud83c\udde6\ud83c\uddff\",\n    \"BACK_arrow\": \"\ud83d\udd19\",\n    \"B_button_(blood_type)\": \"\ud83c\udd71\",\n    \"Bahamas\": \"\ud83c\udde7\ud83c\uddf8\",\n    \"Bahrain\": \"\ud83c\udde7\ud83c\udded\",\n    \"Bangladesh\": \"\ud83c\udde7\ud83c\udde9\",\n    \"Barbados\": \"\ud83c\udde7\ud83c\udde7\",\n    \"Belarus\": \"\ud83c\udde7\ud83c\uddfe\",\n    \"Belgium\": \"\ud83c\udde7\ud83c\uddea\",\n    \"Belize\": \"\ud83c\udde7\ud83c\uddff\",\n    \"Benin\": \"\ud83c\udde7\ud83c\uddef\",\n    \"Bermuda\": \"\ud83c\udde7\ud83c\uddf2\",\n    \"Bhutan\": \"\ud83c\udde7\ud83c\uddf9\",\n    \"Bolivia\": \"\ud83c\udde7\ud83c\uddf4\",\n    \"Bosnia_&_Herzegovina\": \"\ud83c\udde7\ud83c\udde6\",\n    \"Botswana\": \"\ud83c\udde7\ud83c\uddfc\",\n    \"Bouvet_Island\": \"\ud83c\udde7\ud83c\uddfb\",\n    \"Brazil\": \"\ud83c\udde7\ud83c\uddf7\",\n    \"British_Indian_Ocean_Territory\": \"\ud83c\uddee\ud83c\uddf4\",\n    \"British_Virgin_Islands\": \"\ud83c\uddfb\ud83c\uddec\",\n    \"Brunei\": \"\ud83c\udde7\ud83c\uddf3\",\n    \"Bulgaria\": \"\ud83c\udde7\ud83c\uddec\",\n    \"Burkina_Faso\": \"\ud83c\udde7\ud83c\uddeb\",\n    \"Burundi\": \"\ud83c\udde7\ud83c\uddee\",\n    \"CL_button\": \"\ud83c\udd91\",\n    \"COOL_button\": \"\ud83c\udd92\",\n    \"Cambodia\": \"\ud83c\uddf0\ud83c\udded\",\n    \"Cameroon\": \"\ud83c\udde8\ud83c\uddf2\",\n    \"Canada\": \"\ud83c\udde8\ud83c\udde6\",\n    \"Canary_Islands\": \"\ud83c\uddee\ud83c\udde8\",\n    \"Cancer\": \"\u264b\",\n    \"Cape_Verde\": \"\ud83c\udde8\ud83c\uddfb\",\n    \"Capricorn\": \"\u2651\",\n    \"Caribbean_Netherlands\": \"\ud83c\udde7\ud83c\uddf6\",\n    \"Cayman_Islands\": \"\ud83c\uddf0\ud83c\uddfe\",\n    \"Central_African_Republic\": \"\ud83c\udde8\ud83c\uddeb\",\n    \"Ceuta_&_Melilla\": \"\ud83c\uddea\ud83c\udde6\",\n    \"Chad\": \"\ud83c\uddf9\ud83c\udde9\",\n    \"Chile\": \"\ud83c\udde8\ud83c\uddf1\",\n    \"China\": \"\ud83c\udde8\ud83c\uddf3\",\n    \"Christmas_Island\": \"\ud83c\udde8\ud83c\uddfd\",\n    \"Christmas_tree\": \"\ud83c\udf84\",\n    \"Clipperton_Island\": \"\ud83c\udde8\ud83c\uddf5\",\n    \"Cocos_(Keeling)_Islands\": \"\ud83c\udde8\ud83c\udde8\",\n    \"Colombia\": \"\ud83c\udde8\ud83c\uddf4\",\n    \"Comoros\": \"\ud83c\uddf0\ud83c\uddf2\",\n    \"Congo-Brazzaville\": \"\ud83c\udde8\ud83c\uddec\",\n    \"Congo-Kinshasa\": \"\ud83c\udde8\ud83c\udde9\",\n    \"Cook_Islands\": \"\ud83c\udde8\ud83c\uddf0\",\n    \"Costa_Rica\": \"\ud83c\udde8\ud83c\uddf7\",\n    \"Croatia\": \"\ud83c\udded\ud83c\uddf7\",\n    \"Cuba\": \"\ud83c\udde8\ud83c\uddfa\",\n    \"Cura\u00e7ao\": \"\ud83c\udde8\ud83c\uddfc\",\n    \"Cyprus\": \"\ud83c\udde8\ud83c\uddfe\",\n    \"Czechia\": \"\ud83c\udde8\ud83c\uddff\",\n    \"C\u00f4te_d\u2019Ivoire\": \"\ud83c\udde8\ud83c\uddee\",\n    \"Denmark\": \"\ud83c\udde9\ud83c\uddf0\",\n    \"Diego_Garcia\": \"\ud83c\udde9\ud83c\uddec\",\n    \"Djibouti\": \"\ud83c\udde9\ud83c\uddef\",\n    \"Dominica\": \"\ud83c\udde9\ud83c\uddf2\",\n    \"Dominican_Republic\": \"\ud83c\udde9\ud83c\uddf4\",\n    \"END_arrow\": \"\ud83d\udd1a\",\n    \"Ecuador\": \"\ud83c\uddea\ud83c\udde8\",\n    \"Egypt\": \"\ud83c\uddea\ud83c\uddec\",\n    \"El_Salvador\": \"\ud83c\uddf8\ud83c\uddfb\",\n    \"England\": \"\ud83c\udff4\",\n    \"Equatorial_Guinea\": \"\ud83c\uddec\ud83c\uddf6\",\n    \"Eritrea\": \"\ud83c\uddea\ud83c\uddf7\",\n    \"Estonia\": \"\ud83c\uddea\ud83c\uddea\",\n    \"Eswatini\": \"\ud83c\uddf8\ud83c\uddff\",\n    \"Ethiopia\": \"\ud83c\uddea\ud83c\uddf9\",\n    \"European_Union\": \"\ud83c\uddea\ud83c\uddfa\",\n    \"FREE_button\": \"\ud83c\udd93\",\n    \"Falkland_Islands\": \"\ud83c\uddeb\ud83c\uddf0\",\n    \"Faroe_Islands\": \"\ud83c\uddeb\ud83c\uddf4\",\n    \"Fiji\": \"\ud83c\uddeb\ud83c\uddef\",\n    \"Finland\": \"\ud83c\uddeb\ud83c\uddee\",\n    \"France\": \"\ud83c\uddeb\ud83c\uddf7\",\n    \"French_Guiana\": \"\ud83c\uddec\ud83c\uddeb\",\n    \"French_Polynesia\": \"\ud83c\uddf5\ud83c\uddeb\",\n    \"French_Southern_Territories\": \"\ud83c\uddf9\ud83c\uddeb\",\n    \"Gabon\": \"\ud83c\uddec\ud83c\udde6\",\n    \"Gambia\": \"\ud83c\uddec\ud83c\uddf2\",\n    \"Gemini\": \"\u264a\",\n    \"Georgia\": \"\ud83c\uddec\ud83c\uddea\",\n    \"Germany\": \"\ud83c\udde9\ud83c\uddea\",\n    \"Ghana\": \"\ud83c\uddec\ud83c\udded\",\n    \"Gibraltar\": \"\ud83c\uddec\ud83c\uddee\",\n    \"Greece\": \"\ud83c\uddec\ud83c\uddf7\",\n    \"Greenland\": \"\ud83c\uddec\ud83c\uddf1\",\n    \"Grenada\": \"\ud83c\uddec\ud83c\udde9\",\n    \"Guadeloupe\": \"\ud83c\uddec\ud83c\uddf5\",\n    \"Guam\": \"\ud83c\uddec\ud83c\uddfa\",\n    \"Guatemala\": \"\ud83c\uddec\ud83c\uddf9\",\n    \"Guernsey\": \"\ud83c\uddec\ud83c\uddec\",\n    \"Guinea\": \"\ud83c\uddec\ud83c\uddf3\",\n    \"Guinea-Bissau\": \"\ud83c\uddec\ud83c\uddfc\",\n    \"Guyana\": \"\ud83c\uddec\ud83c\uddfe\",\n    \"Haiti\": \"\ud83c\udded\ud83c\uddf9\",\n    \"Heard_&_McDonald_Islands\": \"\ud83c\udded\ud83c\uddf2\",\n    \"Honduras\": \"\ud83c\udded\ud83c\uddf3\",\n    \"Hong_Kong_SAR_China\": \"\ud83c\udded\ud83c\uddf0\",\n    \"Hungary\": \"\ud83c\udded\ud83c\uddfa\",\n    \"ID_button\": \"\ud83c\udd94\",\n    \"Iceland\": \"\ud83c\uddee\ud83c\uddf8\",\n    \"India\": \"\ud83c\uddee\ud83c\uddf3\",\n    \"Indonesia\": \"\ud83c\uddee\ud83c\udde9\",\n    \"Iran\": \"\ud83c\uddee\ud83c\uddf7\",\n    \"Iraq\": \"\ud83c\uddee\ud83c\uddf6\",\n    \"Ireland\": \"\ud83c\uddee\ud83c\uddea\",\n    \"Isle_of_Man\": \"\ud83c\uddee\ud83c\uddf2\",\n    \"Israel\": \"\ud83c\uddee\ud83c\uddf1\",\n    \"Italy\": \"\ud83c\uddee\ud83c\uddf9\",\n    \"Jamaica\": \"\ud83c\uddef\ud83c\uddf2\",\n    \"Japan\": \"\ud83c\uddef\ud83c\uddf5\",\n    \"Japanese_acceptable_button\": \"\ud83c\ude51\",\n    \"Japanese_application_button\": \"\ud83c\ude38\",\n    \"Japanese_bargain_button\": \"\ud83c\ude50\",\n    \"Japanese_castle\": \"\ud83c\udfef\",\n    \"Japanese_congratulations_button\": \"\u3297\",\n    \"Japanese_discount_button\": \"\ud83c\ude39\",\n    \"Japanese_dolls\": \"\ud83c\udf8e\",\n    \"Japanese_free_of_charge_button\": \"\ud83c\ude1a\",\n    \"Japanese_here_button\": \"\ud83c\ude01\",\n    \"Japanese_monthly_amount_button\": \"\ud83c\ude37\",\n    \"Japanese_no_vacancy_button\": \"\ud83c\ude35\",\n    \"Japanese_not_free_of_charge_button\": \"\ud83c\ude36\",\n    \"Japanese_open_for_business_button\": \"\ud83c\ude3a\",\n    \"Japanese_passing_grade_button\": \"\ud83c\ude34\",\n    \"Japanese_post_office\": \"\ud83c\udfe3\",\n    \"Japanese_prohibited_button\": \"\ud83c\ude32\",\n    \"Japanese_reserved_button\": \"\ud83c\ude2f\",\n    \"Japanese_secret_button\": \"\u3299\",\n    \"Japanese_service_charge_button\": \"\ud83c\ude02\",\n    \"Japanese_symbol_for_beginner\": \"\ud83d\udd30\",\n    \"Japanese_vacancy_button\": \"\ud83c\ude33\",\n    \"Jersey\": \"\ud83c\uddef\ud83c\uddea\",\n    \"Jordan\": \"\ud83c\uddef\ud83c\uddf4\",\n    \"Kazakhstan\": \"\ud83c\uddf0\ud83c\uddff\",\n    \"Kenya\": \"\ud83c\uddf0\ud83c\uddea\",\n    \"Kiribati\": \"\ud83c\uddf0\ud83c\uddee\",\n    \"Kosovo\": \"\ud83c\uddfd\ud83c\uddf0\",\n    \"Kuwait\": \"\ud83c\uddf0\ud83c\uddfc\",\n    \"Kyrgyzstan\": \"\ud83c\uddf0\ud83c\uddec\",\n    \"Laos\": \"\ud83c\uddf1\ud83c\udde6\",\n    \"Latvia\": \"\ud83c\uddf1\ud83c\uddfb\",\n    \"Lebanon\": \"\ud83c\uddf1\ud83c\udde7\",\n    \"Leo\": \"\u264c\",\n    \"Lesotho\": \"\ud83c\uddf1\ud83c\uddf8\",\n    \"Liberia\": \"\ud83c\uddf1\ud83c\uddf7\",\n    \"Libra\": \"\u264e\",\n    \"Libya\": \"\ud83c\uddf1\ud83c\uddfe\",\n    \"Liechtenstein\": \"\ud83c\uddf1\ud83c\uddee\",\n    \"Lithuania\": \"\ud83c\uddf1\ud83c\uddf9\",\n    \"Luxembourg\": \"\ud83c\uddf1\ud83c\uddfa\",\n    \"Macao_SAR_China\": \"\ud83c\uddf2\ud83c\uddf4\",\n    \"Madagascar\": \"\ud83c\uddf2\ud83c\uddec\",\n    \"Malawi\": \"\ud83c\uddf2\ud83c\uddfc\",\n    \"Malaysia\": \"\ud83c\uddf2\ud83c\uddfe\",\n    \"Maldives\": \"\ud83c\uddf2\ud83c\uddfb\",\n    \"Mali\": \"\ud83c\uddf2\ud83c\uddf1\",\n    \"Malta\": \"\ud83c\uddf2\ud83c\uddf9\",\n    \"Marshall_Islands\": \"\ud83c\uddf2\ud83c\udded\",\n    \"Martinique\": \"\ud83c\uddf2\ud83c\uddf6\",\n    \"Mauritania\": \"\ud83c\uddf2\ud83c\uddf7\",\n    \"Mauritius\": \"\ud83c\uddf2\ud83c\uddfa\",\n    \"Mayotte\": \"\ud83c\uddfe\ud83c\uddf9\",\n    \"Mexico\": \"\ud83c\uddf2\ud83c\uddfd\",\n    \"Micronesia\": \"\ud83c\uddeb\ud83c\uddf2\",\n    \"Moldova\": \"\ud83c\uddf2\ud83c\udde9\",\n    \"Monaco\": \"\ud83c\uddf2\ud83c\udde8\",\n    \"Mongolia\": \"\ud83c\uddf2\ud83c\uddf3\",\n    \"Montenegro\": \"\ud83c\uddf2\ud83c\uddea\",\n    \"Montserrat\": \"\ud83c\uddf2\ud83c\uddf8\",\n    \"Morocco\": \"\ud83c\uddf2\ud83c\udde6\",\n    \"Mozambique\": \"\ud83c\uddf2\ud83c\uddff\",\n    \"Mrs._Claus\": \"\ud83e\udd36\",\n    \"Mrs._Claus_dark_skin_tone\": \"\ud83e\udd36\ud83c\udfff\",\n    \"Mrs._Claus_light_skin_tone\": \"\ud83e\udd36\ud83c\udffb\",\n    \"Mrs._Claus_medium-dark_skin_tone\": \"\ud83e\udd36\ud83c\udffe\",\n    \"Mrs._Claus_medium-light_skin_tone\": \"\ud83e\udd36\ud83c\udffc\",\n    \"Mrs._Claus_medium_skin_tone\": \"\ud83e\udd36\ud83c\udffd\",\n    \"Myanmar_(Burma)\": \"\ud83c\uddf2\ud83c\uddf2\",\n    \"NEW_button\": \"\ud83c\udd95\",\n    \"NG_button\": \"\ud83c\udd96\",\n    \"Namibia\": \"\ud83c\uddf3\ud83c\udde6\",\n    \"Nauru\": \"\ud83c\uddf3\ud83c\uddf7\",\n    \"Nepal\": \"\ud83c\uddf3\ud83c\uddf5\",\n    \"Netherlands\": \"\ud83c\uddf3\ud83c\uddf1\",\n    \"New_Caledonia\": \"\ud83c\uddf3\ud83c\udde8\",\n    \"New_Zealand\": \"\ud83c\uddf3\ud83c\uddff\",\n    \"Nicaragua\": \"\ud83c\uddf3\ud83c\uddee\",\n    \"Niger\": \"\ud83c\uddf3\ud83c\uddea\",\n    \"Nigeria\": \"\ud83c\uddf3\ud83c\uddec\",\n    \"Niue\": \"\ud83c\uddf3\ud83c\uddfa\",\n    \"Norfolk_Island\": \"\ud83c\uddf3\ud83c\uddeb\",\n    \"North_Korea\": \"\ud83c\uddf0\ud83c\uddf5\",\n    \"North_Macedonia\": \"\ud83c\uddf2\ud83c\uddf0\",\n    \"Northern_Mariana_Islands\": \"\ud83c\uddf2\ud83c\uddf5\",\n    \"Norway\": \"\ud83c\uddf3\ud83c\uddf4\",\n    \"OK_button\": \"\ud83c\udd97\",\n    \"OK_hand\": \"\ud83d\udc4c\",\n    \"OK_hand_dark_skin_tone\": \"\ud83d\udc4c\ud83c\udfff\",\n    \"OK_hand_light_skin_tone\": \"\ud83d\udc4c\ud83c\udffb\",\n    \"OK_hand_medium-dark_skin_tone\": \"\ud83d\udc4c\ud83c\udffe\",\n    \"OK_hand_medium-light_skin_tone\": \"\ud83d\udc4c\ud83c\udffc\",\n    \"OK_hand_medium_skin_tone\": \"\ud83d\udc4c\ud83c\udffd\",\n    \"ON!_arrow\": \"\ud83d\udd1b\",\n    \"O_button_(blood_type)\": \"\ud83c\udd7e\",\n    \"Oman\": \"\ud83c\uddf4\ud83c\uddf2\",\n    \"Ophiuchus\": \"\u26ce\",\n    \"P_button\": \"\ud83c\udd7f\",\n    \"Pakistan\": \"\ud83c\uddf5\ud83c\uddf0\",\n    \"Palau\": \"\ud83c\uddf5\ud83c\uddfc\",\n    \"Palestinian_Territories\": \"\ud83c\uddf5\ud83c\uddf8\",\n    \"Panama\": \"\ud83c\uddf5\ud83c\udde6\",\n    \"Papua_New_Guinea\": \"\ud83c\uddf5\ud83c\uddec\",\n    \"Paraguay\": \"\ud83c\uddf5\ud83c\uddfe\",\n    \"Peru\": \"\ud83c\uddf5\ud83c\uddea\",\n    \"Philippines\": \"\ud83c\uddf5\ud83c\udded\",\n    \"Pisces\": \"\u2653\",\n    \"Pitcairn_Islands\": \"\ud83c\uddf5\ud83c\uddf3\",\n    \"Poland\": \"\ud83c\uddf5\ud83c\uddf1\",\n    \"Portugal\": \"\ud83c\uddf5\ud83c\uddf9\",\n    \"Puerto_Rico\": \"\ud83c\uddf5\ud83c\uddf7\",\n    \"Qatar\": \"\ud83c\uddf6\ud83c\udde6\",\n    \"Romania\": \"\ud83c\uddf7\ud83c\uddf4\",\n    \"Russia\": \"\ud83c\uddf7\ud83c\uddfa\",\n    \"Rwanda\": \"\ud83c\uddf7\ud83c\uddfc\",\n    \"R\u00e9union\": \"\ud83c\uddf7\ud83c\uddea\",\n    \"SOON_arrow\": \"\ud83d\udd1c\",\n    \"SOS_button\": \"\ud83c\udd98\",\n    \"Sagittarius\": \"\u2650\",\n    \"Samoa\": \"\ud83c\uddfc\ud83c\uddf8\",\n    \"San_Marino\": \"\ud83c\uddf8\ud83c\uddf2\",\n    \"Santa_Claus\": \"\ud83c\udf85\",\n    \"Santa_Claus_dark_skin_tone\": \"\ud83c\udf85\ud83c\udfff\",\n    \"Santa_Claus_light_skin_tone\": \"\ud83c\udf85\ud83c\udffb\",\n    \"Santa_Claus_medium-dark_skin_tone\": \"\ud83c\udf85\ud83c\udffe\",\n    \"Santa_Claus_medium-light_skin_tone\": \"\ud83c\udf85\ud83c\udffc\",\n    \"Santa_Claus_medium_skin_tone\": \"\ud83c\udf85\ud83c\udffd\",\n    \"Saudi_Arabia\": \"\ud83c\uddf8\ud83c\udde6\",\n    \"Scorpio\": \"\u264f\",\n    \"Scotland\": \"\ud83c\udff4\",\n    \"Senegal\": \"\ud83c\uddf8\ud83c\uddf3\",\n    \"Serbia\": \"\ud83c\uddf7\ud83c\uddf8\",\n    \"Seychelles\": \"\ud83c\uddf8\ud83c\udde8\",\n    \"Sierra_Leone\": \"\ud83c\uddf8\ud83c\uddf1\",\n    \"Singapore\": \"\ud83c\uddf8\ud83c\uddec\",\n    \"Sint_Maarten\": \"\ud83c\uddf8\ud83c\uddfd\",\n    \"Slovakia\": \"\ud83c\uddf8\ud83c\uddf0\",\n    \"Slovenia\": \"\ud83c\uddf8\ud83c\uddee\",\n    \"Solomon_Islands\": \"\ud83c\uddf8\ud83c\udde7\",\n    \"Somalia\": \"\ud83c\uddf8\ud83c\uddf4\",\n    \"South_Africa\": \"\ud83c\uddff\ud83c\udde6\",\n    \"South_Georgia_&_South_Sandwich_Islands\": \"\ud83c\uddec\ud83c\uddf8\",\n    \"South_Korea\": \"\ud83c\uddf0\ud83c\uddf7\",\n    \"South_Sudan\": \"\ud83c\uddf8\ud83c\uddf8\",\n    \"Spain\": \"\ud83c\uddea\ud83c\uddf8\",\n    \"Sri_Lanka\": \"\ud83c\uddf1\ud83c\uddf0\",\n    \"St._Barth\u00e9lemy\": \"\ud83c\udde7\ud83c\uddf1\",\n    \"St._Helena\": \"\ud83c\uddf8\ud83c\udded\",\n    \"St._Kitts_&_Nevis\": \"\ud83c\uddf0\ud83c\uddf3\",\n    \"St._Lucia\": \"\ud83c\uddf1\ud83c\udde8\",\n    \"St._Martin\": \"\ud83c\uddf2\ud83c\uddeb\",\n    \"St._Pierre_&_Miquelon\": \"\ud83c\uddf5\ud83c\uddf2\",\n    \"St._Vincent_&_Grenadines\": \"\ud83c\uddfb\ud83c\udde8\",\n    \"Statue_of_Liberty\": \"\ud83d\uddfd\",\n    \"Sudan\": \"\ud83c\uddf8\ud83c\udde9\",\n    \"Suriname\": \"\ud83c\uddf8\ud83c\uddf7\",\n    \"Svalbard_&_Jan_Mayen\": \"\ud83c\uddf8\ud83c\uddef\",\n    \"Sweden\": \"\ud83c\uddf8\ud83c\uddea\",\n    \"Switzerland\": \"\ud83c\udde8\ud83c\udded\",\n    \"Syria\": \"\ud83c\uddf8\ud83c\uddfe\",\n    \"S\u00e3o_Tom\u00e9_&_Pr\u00edncipe\": \"\ud83c\uddf8\ud83c\uddf9\",\n    \"T-Rex\": \"\ud83e\udd96\",\n    \"TOP_arrow\": \"\ud83d\udd1d\",\n    \"Taiwan\": \"\ud83c\uddf9\ud83c\uddfc\",\n    \"Tajikistan\": \"\ud83c\uddf9\ud83c\uddef\",\n    \"Tanzania\": \"\ud83c\uddf9\ud83c\uddff\",\n    \"Taurus\": \"\u2649\",\n    \"Thailand\": \"\ud83c\uddf9\ud83c\udded\",\n    \"Timor-Leste\": \"\ud83c\uddf9\ud83c\uddf1\",\n    \"Togo\": \"\ud83c\uddf9\ud83c\uddec\",\n    \"Tokelau\": \"\ud83c\uddf9\ud83c\uddf0\",\n    \"Tokyo_tower\": \"\ud83d\uddfc\",\n    \"Tonga\": \"\ud83c\uddf9\ud83c\uddf4\",\n    \"Trinidad_&_Tobago\": \"\ud83c\uddf9\ud83c\uddf9\",\n    \"Tristan_da_Cunha\": \"\ud83c\uddf9\ud83c\udde6\",\n    \"Tunisia\": \"\ud83c\uddf9\ud83c\uddf3\",\n    \"Turkey\": \"\ud83c\uddf9\ud83c\uddf7\",\n    \"Turkmenistan\": \"\ud83c\uddf9\ud83c\uddf2\",\n    \"Turks_&_Caicos_Islands\": \"\ud83c\uddf9\ud83c\udde8\",\n    \"Tuvalu\": \"\ud83c\uddf9\ud83c\uddfb\",\n    \"U.S._Outlying_Islands\": \"\ud83c\uddfa\ud83c\uddf2\",\n    \"U.S._Virgin_Islands\": \"\ud83c\uddfb\ud83c\uddee\",\n    \"UP!_button\": \"\ud83c\udd99\",\n    \"Uganda\": \"\ud83c\uddfa\ud83c\uddec\",\n    \"Ukraine\": \"\ud83c\uddfa\ud83c\udde6\",\n    \"United_Arab_Emirates\": \"\ud83c\udde6\ud83c\uddea\",\n    \"United_Kingdom\": \"\ud83c\uddec\ud83c\udde7\",\n    \"United_Nations\": \"\ud83c\uddfa\ud83c\uddf3\",\n    \"United_States\": \"\ud83c\uddfa\ud83c\uddf8\",\n    \"Uruguay\": \"\ud83c\uddfa\ud83c\uddfe\",\n    \"Uzbekistan\": \"\ud83c\uddfa\ud83c\uddff\",\n    \"VS_button\": \"\ud83c\udd9a\",\n    \"Vanuatu\": \"\ud83c\uddfb\ud83c\uddfa\",\n    \"Vatican_City\": \"\ud83c\uddfb\ud83c\udde6\",\n    \"Venezuela\": \"\ud83c\uddfb\ud83c\uddea\",\n    \"Vietnam\": \"\ud83c\uddfb\ud83c\uddf3\",\n    \"Virgo\": \"\u264d\",\n    \"Wales\": \"\ud83c\udff4\",\n    \"Wallis_&_Futuna\": \"\ud83c\uddfc\ud83c\uddeb\",\n    \"Western_Sahara\": \"\ud83c\uddea\ud83c\udded\",\n    \"Yemen\": \"\ud83c\uddfe\ud83c\uddea\",\n    \"ZZZ\": \"\ud83d\udca4\",\n    \"Zambia\": \"\ud83c\uddff\ud83c\uddf2\",\n    \"Zimbabwe\": \"\ud83c\uddff\ud83c\uddfc\",\n    \"abacus\": \"\ud83e\uddee\",\n    \"accordion\": \"\ud83e\ude97\",\n    \"adhesive_bandage\": \"\ud83e\ude79\",\n    \"admission_tickets\": \"\ud83c\udf9f\",\n    \"aerial_tramway\": \"\ud83d\udea1\",\n    \"airplane\": \"\u2708\",\n    \"airplane_arrival\": \"\ud83d\udeec\",\n    \"airplane_departure\": \"\ud83d\udeeb\",\n    \"alarm_clock\": \"\u23f0\",\n    \"alembic\": \"\u2697\",\n    \"alien\": \"\ud83d\udc7d\",\n    \"alien_monster\": \"\ud83d\udc7e\",\n    \"ambulance\": \"\ud83d\ude91\",\n    \"american_football\": \"\ud83c\udfc8\",\n    \"amphora\": \"\ud83c\udffa\",\n    \"anatomical_heart\": \"\ud83e\udec0\",\n    \"anchor\": \"\u2693\",\n    \"anger_symbol\": \"\ud83d\udca2\",\n    \"angry_face\": \"\ud83d\ude20\",\n    \"angry_face_with_horns\": \"\ud83d\udc7f\",\n    \"anguished_face\": \"\ud83d\ude27\",\n    \"ant\": \"\ud83d\udc1c\",\n    \"antenna_bars\": \"\ud83d\udcf6\",\n    \"anxious_face_with_sweat\": \"\ud83d\ude30\",\n    \"articulated_lorry\": \"\ud83d\ude9b\",\n    \"artist\": \"\ud83e\uddd1\u200d\ud83c\udfa8\",\n    \"artist_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83c\udfa8\",\n    \"artist_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83c\udfa8\",\n    \"artist_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83c\udfa8\",\n    \"artist_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83c\udfa8\",\n    \"artist_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83c\udfa8\",\n    \"artist_palette\": \"\ud83c\udfa8\",\n    \"astonished_face\": \"\ud83d\ude32\",\n    \"astronaut\": \"\ud83e\uddd1\u200d\ud83d\ude80\",\n    \"astronaut_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83d\ude80\",\n    \"astronaut_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83d\ude80\",\n    \"astronaut_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83d\ude80\",\n    \"astronaut_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83d\ude80\",\n    \"astronaut_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83d\ude80\",\n    \"atom_symbol\": \"\u269b\",\n    \"auto_rickshaw\": \"\ud83d\udefa\",\n    \"automobile\": \"\ud83d\ude97\",\n    \"avocado\": \"\ud83e\udd51\",\n    \"axe\": \"\ud83e\ude93\",\n    \"baby\": \"\ud83d\udc76\",\n    \"baby_angel\": \"\ud83d\udc7c\",\n    \"baby_angel_dark_skin_tone\": \"\ud83d\udc7c\ud83c\udfff\",\n    \"baby_angel_light_skin_tone\": \"\ud83d\udc7c\ud83c\udffb\",\n    \"baby_angel_medium-dark_skin_tone\": \"\ud83d\udc7c\ud83c\udffe\",\n    \"baby_angel_medium-light_skin_tone\": \"\ud83d\udc7c\ud83c\udffc\",\n    \"baby_angel_medium_skin_tone\": \"\ud83d\udc7c\ud83c\udffd\",\n    \"baby_bottle\": \"\ud83c\udf7c\",\n    \"baby_chick\": \"\ud83d\udc24\",\n    \"baby_dark_skin_tone\": \"\ud83d\udc76\ud83c\udfff\",\n    \"baby_light_skin_tone\": \"\ud83d\udc76\ud83c\udffb\",\n    \"baby_medium-dark_skin_tone\": \"\ud83d\udc76\ud83c\udffe\",\n    \"baby_medium-light_skin_tone\": \"\ud83d\udc76\ud83c\udffc\",\n    \"baby_medium_skin_tone\": \"\ud83d\udc76\ud83c\udffd\",\n    \"baby_symbol\": \"\ud83d\udebc\",\n    \"backhand_index_pointing_down\": \"\ud83d\udc47\",\n    \"backhand_index_pointing_down_dark_skin_tone\": \"\ud83d\udc47\ud83c\udfff\",\n    \"backhand_index_pointing_down_light_skin_tone\": \"\ud83d\udc47\ud83c\udffb\",\n    \"backhand_index_pointing_down_medium-dark_skin_tone\": \"\ud83d\udc47\ud83c\udffe\",\n    \"backhand_index_pointing_down_medium-light_skin_tone\": \"\ud83d\udc47\ud83c\udffc\",\n    \"backhand_index_pointing_down_medium_skin_tone\": \"\ud83d\udc47\ud83c\udffd\",\n    \"backhand_index_pointing_left\": \"\ud83d\udc48\",\n    \"backhand_index_pointing_left_dark_skin_tone\": \"\ud83d\udc48\ud83c\udfff\",\n    \"backhand_index_pointing_left_light_skin_tone\": \"\ud83d\udc48\ud83c\udffb\",\n    \"backhand_index_pointing_left_medium-dark_skin_tone\": \"\ud83d\udc48\ud83c\udffe\",\n    \"backhand_index_pointing_left_medium-light_skin_tone\": \"\ud83d\udc48\ud83c\udffc\",\n    \"backhand_index_pointing_left_medium_skin_tone\": \"\ud83d\udc48\ud83c\udffd\",\n    \"backhand_index_pointing_right\": \"\ud83d\udc49\",\n    \"backhand_index_pointing_right_dark_skin_tone\": \"\ud83d\udc49\ud83c\udfff\",\n    \"backhand_index_pointing_right_light_skin_tone\": \"\ud83d\udc49\ud83c\udffb\",\n    \"backhand_index_pointing_right_medium-dark_skin_tone\": \"\ud83d\udc49\ud83c\udffe\",\n    \"backhand_index_pointing_right_medium-light_skin_tone\": \"\ud83d\udc49\ud83c\udffc\",\n    \"backhand_index_pointing_right_medium_skin_tone\": \"\ud83d\udc49\ud83c\udffd\",\n    \"backhand_index_pointing_up\": \"\ud83d\udc46\",\n    \"backhand_index_pointing_up_dark_skin_tone\": \"\ud83d\udc46\ud83c\udfff\",\n    \"backhand_index_pointing_up_light_skin_tone\": \"\ud83d\udc46\ud83c\udffb\",\n    \"backhand_index_pointing_up_medium-dark_skin_tone\": \"\ud83d\udc46\ud83c\udffe\",\n    \"backhand_index_pointing_up_medium-light_skin_tone\": \"\ud83d\udc46\ud83c\udffc\",\n    \"backhand_index_pointing_up_medium_skin_tone\": \"\ud83d\udc46\ud83c\udffd\",\n    \"backpack\": \"\ud83c\udf92\",\n    \"bacon\": \"\ud83e\udd53\",\n    \"badger\": \"\ud83e\udda1\",\n    \"badminton\": \"\ud83c\udff8\",\n    \"bagel\": \"\ud83e\udd6f\",\n    \"baggage_claim\": \"\ud83d\udec4\",\n    \"baguette_bread\": \"\ud83e\udd56\",\n    \"balance_scale\": \"\u2696\",\n    \"bald\": \"\ud83e\uddb2\",\n    \"ballet_shoes\": \"\ud83e\ude70\",\n    \"balloon\": \"\ud83c\udf88\",\n    \"ballot_box_with_ballot\": \"\ud83d\uddf3\",\n    \"banana\": \"\ud83c\udf4c\",\n    \"banjo\": \"\ud83e\ude95\",\n    \"bank\": \"\ud83c\udfe6\",\n    \"bar_chart\": \"\ud83d\udcca\",\n    \"barber_pole\": \"\ud83d\udc88\",\n    \"baseball\": \"\u26be\",\n    \"basket\": \"\ud83e\uddfa\",\n    \"basketball\": \"\ud83c\udfc0\",\n    \"bat\": \"\ud83e\udd87\",\n    \"bathtub\": \"\ud83d\udec1\",\n    \"battery\": \"\ud83d\udd0b\",\n    \"beach_with_umbrella\": \"\ud83c\udfd6\",\n    \"beaming_face_with_smiling_eyes\": \"\ud83d\ude01\",\n    \"beans\": \"\ud83e\uded8\",\n    \"bear\": \"\ud83d\udc3b\",\n    \"beating_heart\": \"\ud83d\udc93\",\n    \"beaver\": \"\ud83e\uddab\",\n    \"bed\": \"\ud83d\udecf\",\n    \"beer_mug\": \"\ud83c\udf7a\",\n    \"beetle\": \"\ud83e\udeb2\",\n    \"bell\": \"\ud83d\udd14\",\n    \"bell_pepper\": \"\ud83e\uded1\",\n    \"bell_with_slash\": \"\ud83d\udd15\",\n    \"bellhop_bell\": \"\ud83d\udece\",\n    \"bento_box\": \"\ud83c\udf71\",\n    \"beverage_box\": \"\ud83e\uddc3\",\n    \"bicycle\": \"\ud83d\udeb2\",\n    \"bikini\": \"\ud83d\udc59\",\n    \"billed_cap\": \"\ud83e\udde2\",\n    \"biohazard\": \"\u2623\",\n    \"bird\": \"\ud83d\udc26\",\n    \"birthday_cake\": \"\ud83c\udf82\",\n    \"bison\": \"\ud83e\uddac\",\n    \"biting_lip\": \"\ud83e\udee6\",\n    \"black_bird\": \"\ud83d\udc26\u200d\u2b1b\",\n    \"black_cat\": \"\ud83d\udc08\u200d\u2b1b\",\n    \"black_circle\": \"\u26ab\",\n    \"black_flag\": \"\ud83c\udff4\",\n    \"black_heart\": \"\ud83d\udda4\",\n    \"black_large_square\": \"\u2b1b\",\n    \"black_medium-small_square\": \"\u25fe\",\n    \"black_medium_square\": \"\u25fc\",\n    \"black_nib\": \"\u2712\",\n    \"black_small_square\": \"\u25aa\",\n    \"black_square_button\": \"\ud83d\udd32\",\n    \"blossom\": \"\ud83c\udf3c\",\n    \"blowfish\": \"\ud83d\udc21\",\n    \"blue_book\": \"\ud83d\udcd8\",\n    \"blue_circle\": \"\ud83d\udd35\",\n    \"blue_heart\": \"\ud83d\udc99\",\n    \"blue_square\": \"\ud83d\udfe6\",\n    \"blueberries\": \"\ud83e\uded0\",\n    \"boar\": \"\ud83d\udc17\",\n    \"bomb\": \"\ud83d\udca3\",\n    \"bone\": \"\ud83e\uddb4\",\n    \"bookmark\": \"\ud83d\udd16\",\n    \"bookmark_tabs\": \"\ud83d\udcd1\",\n    \"books\": \"\ud83d\udcda\",\n    \"boomerang\": \"\ud83e\ude83\",\n    \"bottle_with_popping_cork\": \"\ud83c\udf7e\",\n    \"bouquet\": \"\ud83d\udc90\",\n    \"bow_and_arrow\": \"\ud83c\udff9\",\n    \"bowl_with_spoon\": \"\ud83e\udd63\",\n    \"bowling\": \"\ud83c\udfb3\",\n    \"boxing_glove\": \"\ud83e\udd4a\",\n    \"boy\": \"\ud83d\udc66\",\n    \"boy_dark_skin_tone\": \"\ud83d\udc66\ud83c\udfff\",\n    \"boy_light_skin_tone\": \"\ud83d\udc66\ud83c\udffb\",\n    \"boy_medium-dark_skin_tone\": \"\ud83d\udc66\ud83c\udffe\",\n    \"boy_medium-light_skin_tone\": \"\ud83d\udc66\ud83c\udffc\",\n    \"boy_medium_skin_tone\": \"\ud83d\udc66\ud83c\udffd\",\n    \"brain\": \"\ud83e\udde0\",\n    \"bread\": \"\ud83c\udf5e\",\n    \"breast-feeding\": \"\ud83e\udd31\",\n    \"breast-feeding_dark_skin_tone\": \"\ud83e\udd31\ud83c\udfff\",\n    \"breast-feeding_light_skin_tone\": \"\ud83e\udd31\ud83c\udffb\",\n    \"breast-feeding_medium-dark_skin_tone\": \"\ud83e\udd31\ud83c\udffe\",\n    \"breast-feeding_medium-light_skin_tone\": \"\ud83e\udd31\ud83c\udffc\",\n    \"breast-feeding_medium_skin_tone\": \"\ud83e\udd31\ud83c\udffd\",\n    \"brick\": \"\ud83e\uddf1\",\n    \"bridge_at_night\": \"\ud83c\udf09\",\n    \"briefcase\": \"\ud83d\udcbc\",\n    \"briefs\": \"\ud83e\ude72\",\n    \"bright_button\": \"\ud83d\udd06\",\n    \"broccoli\": \"\ud83e\udd66\",\n    \"broken_heart\": \"\ud83d\udc94\",\n    \"broom\": \"\ud83e\uddf9\",\n    \"brown_circle\": \"\ud83d\udfe4\",\n    \"brown_heart\": \"\ud83e\udd0e\",\n    \"brown_square\": \"\ud83d\udfeb\",\n    \"bubble_tea\": \"\ud83e\uddcb\",\n    \"bubbles\": \"\ud83e\udee7\",\n    \"bucket\": \"\ud83e\udea3\",\n    \"bug\": \"\ud83d\udc1b\",\n    \"building_construction\": \"\ud83c\udfd7\",\n    \"bullet_train\": \"\ud83d\ude85\",\n    \"bullseye\": \"\ud83c\udfaf\",\n    \"burrito\": \"\ud83c\udf2f\",\n    \"bus\": \"\ud83d\ude8c\",\n    \"bus_stop\": \"\ud83d\ude8f\",\n    \"bust_in_silhouette\": \"\ud83d\udc64\",\n    \"busts_in_silhouette\": \"\ud83d\udc65\",\n    \"butter\": \"\ud83e\uddc8\",\n    \"butterfly\": \"\ud83e\udd8b\",\n    \"cactus\": \"\ud83c\udf35\",\n    \"calendar\": \"\ud83d\udcc5\",\n    \"call_me_hand\": \"\ud83e\udd19\",\n    \"call_me_hand_dark_skin_tone\": \"\ud83e\udd19\ud83c\udfff\",\n    \"call_me_hand_light_skin_tone\": \"\ud83e\udd19\ud83c\udffb\",\n    \"call_me_hand_medium-dark_skin_tone\": \"\ud83e\udd19\ud83c\udffe\",\n    \"call_me_hand_medium-light_skin_tone\": \"\ud83e\udd19\ud83c\udffc\",\n    \"call_me_hand_medium_skin_tone\": \"\ud83e\udd19\ud83c\udffd\",\n    \"camel\": \"\ud83d\udc2a\",\n    \"camera\": \"\ud83d\udcf7\",\n    \"camera_with_flash\": \"\ud83d\udcf8\",\n    \"camping\": \"\ud83c\udfd5\",\n    \"candle\": \"\ud83d\udd6f\",\n    \"candy\": \"\ud83c\udf6c\",\n    \"canned_food\": \"\ud83e\udd6b\",\n    \"canoe\": \"\ud83d\udef6\",\n    \"card_file_box\": \"\ud83d\uddc3\",\n    \"card_index\": \"\ud83d\udcc7\",\n    \"card_index_dividers\": \"\ud83d\uddc2\",\n    \"carousel_horse\": \"\ud83c\udfa0\",\n    \"carp_streamer\": \"\ud83c\udf8f\",\n    \"carpentry_saw\": \"\ud83e\ude9a\",\n    \"carrot\": \"\ud83e\udd55\",\n    \"castle\": \"\ud83c\udff0\",\n    \"cat\": \"\ud83d\udc08\",\n    \"cat_face\": \"\ud83d\udc31\",\n    \"cat_with_tears_of_joy\": \"\ud83d\ude39\",\n    \"cat_with_wry_smile\": \"\ud83d\ude3c\",\n    \"chains\": \"\u26d3\",\n    \"chair\": \"\ud83e\ude91\",\n    \"chart_decreasing\": \"\ud83d\udcc9\",\n    \"chart_increasing\": \"\ud83d\udcc8\",\n    \"chart_increasing_with_yen\": \"\ud83d\udcb9\",\n    \"check_box_with_check\": \"\u2611\",\n    \"check_mark\": \"\u2714\",\n    \"check_mark_button\": \"\u2705\",\n    \"cheese_wedge\": \"\ud83e\uddc0\",\n    \"chequered_flag\": \"\ud83c\udfc1\",\n    \"cherries\": \"\ud83c\udf52\",\n    \"cherry_blossom\": \"\ud83c\udf38\",\n    \"chess_pawn\": \"\u265f\",\n    \"chestnut\": \"\ud83c\udf30\",\n    \"chicken\": \"\ud83d\udc14\",\n    \"child\": \"\ud83e\uddd2\",\n    \"child_dark_skin_tone\": \"\ud83e\uddd2\ud83c\udfff\",\n    \"child_light_skin_tone\": \"\ud83e\uddd2\ud83c\udffb\",\n    \"child_medium-dark_skin_tone\": \"\ud83e\uddd2\ud83c\udffe\",\n    \"child_medium-light_skin_tone\": \"\ud83e\uddd2\ud83c\udffc\",\n    \"child_medium_skin_tone\": \"\ud83e\uddd2\ud83c\udffd\",\n    \"children_crossing\": \"\ud83d\udeb8\",\n    \"chipmunk\": \"\ud83d\udc3f\",\n    \"chocolate_bar\": \"\ud83c\udf6b\",\n    \"chopsticks\": \"\ud83e\udd62\",\n    \"church\": \"\u26ea\",\n    \"cigarette\": \"\ud83d\udeac\",\n    \"cinema\": \"\ud83c\udfa6\",\n    \"circled_M\": \"\u24c2\",\n    \"circus_tent\": \"\ud83c\udfaa\",\n    \"cityscape\": \"\ud83c\udfd9\",\n    \"cityscape_at_dusk\": \"\ud83c\udf06\",\n    \"clamp\": \"\ud83d\udddc\",\n    \"clapper_board\": \"\ud83c\udfac\",\n    \"clapping_hands\": \"\ud83d\udc4f\",\n    \"clapping_hands_dark_skin_tone\": \"\ud83d\udc4f\ud83c\udfff\",\n    \"clapping_hands_light_skin_tone\": \"\ud83d\udc4f\ud83c\udffb\",\n    \"clapping_hands_medium-dark_skin_tone\": \"\ud83d\udc4f\ud83c\udffe\",\n    \"clapping_hands_medium-light_skin_tone\": \"\ud83d\udc4f\ud83c\udffc\",\n    \"clapping_hands_medium_skin_tone\": \"\ud83d\udc4f\ud83c\udffd\",\n    \"classical_building\": \"\ud83c\udfdb\",\n    \"clinking_beer_mugs\": \"\ud83c\udf7b\",\n    \"clinking_glasses\": \"\ud83e\udd42\",\n    \"clipboard\": \"\ud83d\udccb\",\n    \"clockwise_vertical_arrows\": \"\ud83d\udd03\",\n    \"closed_book\": \"\ud83d\udcd5\",\n    \"closed_mailbox_with_lowered_flag\": \"\ud83d\udcea\",\n    \"closed_mailbox_with_raised_flag\": \"\ud83d\udceb\",\n    \"closed_umbrella\": \"\ud83c\udf02\",\n    \"cloud\": \"\u2601\",\n    \"cloud_with_lightning\": \"\ud83c\udf29\",\n    \"cloud_with_lightning_and_rain\": \"\u26c8\",\n    \"cloud_with_rain\": \"\ud83c\udf27\",\n    \"cloud_with_snow\": \"\ud83c\udf28\",\n    \"clown_face\": \"\ud83e\udd21\",\n    \"club_suit\": \"\u2663\",\n    \"clutch_bag\": \"\ud83d\udc5d\",\n    \"coat\": \"\ud83e\udde5\",\n    \"cockroach\": \"\ud83e\udeb3\",\n    \"cocktail_glass\": \"\ud83c\udf78\",\n    \"coconut\": \"\ud83e\udd65\",\n    \"coffin\": \"\u26b0\",\n    \"coin\": \"\ud83e\ude99\",\n    \"cold_face\": \"\ud83e\udd76\",\n    \"collision\": \"\ud83d\udca5\",\n    \"comet\": \"\u2604\",\n    \"compass\": \"\ud83e\udded\",\n    \"computer_disk\": \"\ud83d\udcbd\",\n    \"computer_mouse\": \"\ud83d\uddb1\",\n    \"confetti_ball\": \"\ud83c\udf8a\",\n    \"confounded_face\": \"\ud83d\ude16\",\n    \"confused_face\": \"\ud83d\ude15\",\n    \"construction\": \"\ud83d\udea7\",\n    \"construction_worker\": \"\ud83d\udc77\",\n    \"construction_worker_dark_skin_tone\": \"\ud83d\udc77\ud83c\udfff\",\n    \"construction_worker_light_skin_tone\": \"\ud83d\udc77\ud83c\udffb\",\n    \"construction_worker_medium-dark_skin_tone\": \"\ud83d\udc77\ud83c\udffe\",\n    \"construction_worker_medium-light_skin_tone\": \"\ud83d\udc77\ud83c\udffc\",\n    \"construction_worker_medium_skin_tone\": \"\ud83d\udc77\ud83c\udffd\",\n    \"control_knobs\": \"\ud83c\udf9b\",\n    \"convenience_store\": \"\ud83c\udfea\",\n    \"cook\": \"\ud83e\uddd1\u200d\ud83c\udf73\",\n    \"cook_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83c\udf73\",\n    \"cook_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83c\udf73\",\n    \"cook_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83c\udf73\",\n    \"cook_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83c\udf73\",\n    \"cook_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83c\udf73\",\n    \"cooked_rice\": \"\ud83c\udf5a\",\n    \"cookie\": \"\ud83c\udf6a\",\n    \"cooking\": \"\ud83c\udf73\",\n    \"copyright\": \"\u00a9\",\n    \"coral\": \"\ud83e\udeb8\",\n    \"couch_and_lamp\": \"\ud83d\udecb\",\n    \"counterclockwise_arrows_button\": \"\ud83d\udd04\",\n    \"couple_with_heart\": \"\ud83d\udc91\",\n    \"couple_with_heart_dark_skin_tone\": \"\ud83d\udc91\ud83c\udfff\",\n    \"couple_with_heart_light_skin_tone\": \"\ud83d\udc91\ud83c\udffb\",\n    \"couple_with_heart_man_man\": \"\ud83d\udc68\u200d\u2764\u200d\ud83d\udc68\",\n    \"couple_with_heart_man_man_dark_skin_tone\": \"\ud83d\udc68\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    \"couple_with_heart_man_man_dark_skin_tone_light_skin_tone\": \"\ud83d\udc68\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_man_man_dark_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_man_man_dark_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_man_man_dark_skin_tone_medium_skin_tone\": \"\ud83d\udc68\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_man_man_light_skin_tone\": \"\ud83d\udc68\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    \"couple_with_heart_man_man_light_skin_tone_dark_skin_tone\": \"\ud83d\udc68\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_man_man_light_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_man_man_light_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_man_man_light_skin_tone_medium_skin_tone\": \"\ud83d\udc68\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_man_man_medium-dark_skin_tone\": \"\ud83d\udc68\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-dark_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-dark_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_man_man_medium\"\n        \"-dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_man_man_medium-light_skin_tone\": \"\ud83d\udc68\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-light_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-light_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_man_man_medium\"\n        \"-light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_man_man_medium\" \"-light_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_man_man_medium_skin_tone\": \"\ud83d\udc68\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_man_man_medium_skin_tone_dark_skin_tone\": \"\ud83d\udc68\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    \"couple_with_heart_man_man_medium_skin_tone_light_skin_tone\": \"\ud83d\udc68\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_man_man_medium_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_man_man_medium_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc68\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_medium-dark_skin_tone\": \"\ud83d\udc91\ud83c\udffe\",\n    \"couple_with_heart_medium-light_skin_tone\": \"\ud83d\udc91\ud83c\udffc\",\n    \"couple_with_heart_medium_skin_tone\": \"\ud83d\udc91\ud83c\udffd\",\n    (\n        \"couple_with_heart_person_\" \"person_dark_skin_tone_light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udfff\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffb\",\n    (\n        \"couple_with_heart_person_\"\n        \"person_dark_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udfff\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffe\",\n    (\n        \"couple_with_heart_person_person_\"\n        \"dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udfff\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffc\",\n    (\n        \"couple_with_heart_person_person_\" \"dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udfff\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffd\",\n    (\n        \"couple_with_heart_person_\" \"person_light_skin_tone_dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffb\u200d\u2764\u200d\ud83e\uddd1\ud83c\udfff\",\n    (\n        \"couple_with_heart_person_person_\"\n        \"light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffb\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffe\",\n    (\n        \"couple_with_heart_person_person_\"\n        \"light_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffb\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffc\",\n    (\n        \"couple_with_heart_person_\" \"person_light_skin_tone_medium_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffb\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffd\",\n    (\n        \"couple_with_heart_person_\"\n        \"person_medium-dark_skin_tone_dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffe\u200d\u2764\u200d\ud83e\uddd1\ud83c\udfff\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium-dark_skin_tone_light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffe\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffb\",\n    (\n        \"couple_with_heart_person_person_medium\"\n        \"-dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffe\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffc\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium-dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffe\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffd\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium-light_skin_tone_dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffc\u200d\u2764\u200d\ud83e\uddd1\ud83c\udfff\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium-light_skin_tone_light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffc\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffb\",\n    (\n        \"couple_with_heart_person_person_medium\"\n        \"-light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffc\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffe\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium-light_skin_tone_medium_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffc\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffd\",\n    (\n        \"couple_with_heart_person_person_medium_skin_tone_dark_skin_tone\" \"\"\n    ): \"\ud83e\uddd1\ud83c\udffd\u200d\u2764\u200d\ud83e\uddd1\ud83c\udfff\",\n    (\n        \"couple_with_heart_person_person_medium_skin_tone_light_skin_tone\" \"\"\n    ): \"\ud83e\uddd1\ud83c\udffd\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffb\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffd\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffe\",\n    (\n        \"couple_with_heart_person_person\"\n        \"_medium_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83e\uddd1\ud83c\udffd\u200d\u2764\u200d\ud83e\uddd1\ud83c\udffc\",\n    \"couple_with_heart_woman_man\": \"\ud83d\udc69\u200d\u2764\u200d\ud83d\udc68\",\n    \"couple_with_heart_woman_man_dark_skin_tone\": \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    \"couple_with_heart_woman_man_dark_skin_tone_light_skin_tone\": \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_man_dark_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_man_dark_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_woman_man_dark_skin_tone_medium_skin_tone\": \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_woman_man_light_skin_tone\": \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    \"couple_with_heart_woman_man_light_skin_tone_dark_skin_tone\": \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_woman_man_light_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_man_light_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_woman_man_light_skin_tone_medium_skin_tone\": \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_woman_man_medium-dark_skin_tone\": \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-dark_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-dark_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_man_medium\"\n        \"-dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_woman_man_medium-light_skin_tone\": \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-light_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-light_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_man_medium\"\n        \"-light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_man_medium\" \"-light_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_woman_man_medium_skin_tone\": \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffd\",\n    \"couple_with_heart_woman_man_medium_skin_tone_dark_skin_tone\": \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udfff\",\n    \"couple_with_heart_woman_man_medium_skin_tone_light_skin_tone\": \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_man_medium_skin_tone_medium\" \"-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_man_medium_skin_tone_medium\" \"-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc68\ud83c\udffc\",\n    \"couple_with_heart_woman_woman\": \"\ud83d\udc69\u200d\u2764\u200d\ud83d\udc69\",\n    \"couple_with_heart_woman_woman_dark_skin_tone\": \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc69\ud83c\udfff\",\n    (\n        \"couple_with_heart_\" \"woman_woman_dark_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc69\ud83c\udffb\",\n    (\n        \"couple_with_heart_\" \"woman_woman_dark_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc69\ud83c\udffe\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc69\ud83c\udffc\",\n    (\n        \"couple_with_heart_\" \"woman_woman_dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udfff\u200d\u2764\u200d\ud83d\udc69\ud83c\udffd\",\n    \"couple_with_heart_woman_woman_light_skin_tone\": \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc69\ud83c\udffb\",\n    (\n        \"couple_with_heart_\" \"woman_woman_light_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc69\ud83c\udfff\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc69\ud83c\udffe\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_light_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc69\ud83c\udffc\",\n    (\n        \"couple_with_heart_\" \"woman_woman_light_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffb\u200d\u2764\u200d\ud83d\udc69\ud83c\udffd\",\n    \"couple_with_heart_woman_woman_medium-dark_skin_tone\": \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc69\ud83c\udffe\",\n    (\n        \"couple_with_heart_\" \"woman_woman_medium-dark_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc69\ud83c\udfff\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_medium-dark_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc69\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_woman_medium\"\n        \"-dark_skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc69\ud83c\udffc\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_medium-dark_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffe\u200d\u2764\u200d\ud83d\udc69\ud83c\udffd\",\n    \"couple_with_heart_woman_woman_medium-light_skin_tone\": \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc69\ud83c\udffc\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_medium-light_skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc69\ud83c\udfff\",\n    (\n        \"couple_with_heart_\"\n        \"woman_woman_medium-light_skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc69\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_woman_medium\"\n        \"-light_skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc69\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_woman_medium\"\n        \"-light_skin_tone_medium_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffc\u200d\u2764\u200d\ud83d\udc69\ud83c\udffd\",\n    \"couple_with_heart_woman_woman_medium_skin_tone\": \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc69\ud83c\udffd\",\n    (\n        \"couple_with_heart_woman_woman_medium_\" \"skin_tone_dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc69\ud83c\udfff\",\n    (\n        \"couple_with_heart_woman_woman_medium_\" \"skin_tone_light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc69\ud83c\udffb\",\n    (\n        \"couple_with_heart_woman_woman_medium_\"\n        \"skin_tone_medium-dark_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc69\ud83c\udffe\",\n    (\n        \"couple_with_heart_woman_woman_medium_\"\n        \"skin_tone_medium-light_skin_tone\"\n    ): \"\ud83d\udc69\ud83c\udffd\u200d\u2764\u200d\ud83d\udc69\ud83c\udffc\",\n    \"cow\": \"\ud83d\udc04\",\n    \"cow_face\": \"\ud83d\udc2e\",\n    \"cowboy_hat_face\": \"\ud83e\udd20\",\n    \"crab\": \"\ud83e\udd80\",\n    \"crayon\": \"\ud83d\udd8d\",\n    \"credit_card\": \"\ud83d\udcb3\",\n    \"crescent_moon\": \"\ud83c\udf19\",\n    \"cricket\": \"\ud83e\udd97\",\n    \"cricket_game\": \"\ud83c\udfcf\",\n    \"crocodile\": \"\ud83d\udc0a\",\n    \"croissant\": \"\ud83e\udd50\",\n    \"cross_mark\": \"\u274c\",\n    \"cross_mark_button\": \"\u274e\",\n    \"crossed_fingers\": \"\ud83e\udd1e\",\n    \"crossed_fingers_dark_skin_tone\": \"\ud83e\udd1e\ud83c\udfff\",\n    \"crossed_fingers_light_skin_tone\": \"\ud83e\udd1e\ud83c\udffb\",\n    \"crossed_fingers_medium-dark_skin_tone\": \"\ud83e\udd1e\ud83c\udffe\",\n    \"crossed_fingers_medium-light_skin_tone\": \"\ud83e\udd1e\ud83c\udffc\",\n    \"crossed_fingers_medium_skin_tone\": \"\ud83e\udd1e\ud83c\udffd\",\n    \"crossed_flags\": \"\ud83c\udf8c\",\n    \"crossed_swords\": \"\u2694\",\n    \"crown\": \"\ud83d\udc51\",\n    \"crutch\": \"\ud83e\ude7c\",\n    \"crying_cat\": \"\ud83d\ude3f\",\n    \"crying_face\": \"\ud83d\ude22\",\n    \"crystal_ball\": \"\ud83d\udd2e\",\n    \"cucumber\": \"\ud83e\udd52\",\n    \"cup_with_straw\": \"\ud83e\udd64\",\n    \"cupcake\": \"\ud83e\uddc1\",\n    \"curling_stone\": \"\ud83e\udd4c\",\n    \"curly_hair\": \"\ud83e\uddb1\",\n    \"curly_loop\": \"\u27b0\",\n    \"currency_exchange\": \"\ud83d\udcb1\",\n    \"curry_rice\": \"\ud83c\udf5b\",\n    \"custard\": \"\ud83c\udf6e\",\n    \"customs\": \"\ud83d\udec3\",\n    \"cut_of_meat\": \"\ud83e\udd69\",\n    \"cyclone\": \"\ud83c\udf00\",\n    \"dagger\": \"\ud83d\udde1\",\n    \"dango\": \"\ud83c\udf61\",\n    \"dark_skin_tone\": \"\ud83c\udfff\",\n    \"dashing_away\": \"\ud83d\udca8\",\n    \"deaf_man\": \"\ud83e\uddcf\u200d\u2642\",\n    \"deaf_man_dark_skin_tone\": \"\ud83e\uddcf\ud83c\udfff\u200d\u2642\",\n    \"deaf_man_light_skin_tone\": \"\ud83e\uddcf\ud83c\udffb\u200d\u2642\",\n    \"deaf_man_medium-dark_skin_tone\": \"\ud83e\uddcf\ud83c\udffe\u200d\u2642\",\n    \"deaf_man_medium-light_skin_tone\": \"\ud83e\uddcf\ud83c\udffc\u200d\u2642\",\n    \"deaf_man_medium_skin_tone\": \"\ud83e\uddcf\ud83c\udffd\u200d\u2642\",\n    \"deaf_person\": \"\ud83e\uddcf\",\n    \"deaf_person_dark_skin_tone\": \"\ud83e\uddcf\ud83c\udfff\",\n    \"deaf_person_light_skin_tone\": \"\ud83e\uddcf\ud83c\udffb\",\n    \"deaf_person_medium-dark_skin_tone\": \"\ud83e\uddcf\ud83c\udffe\",\n    \"deaf_person_medium-light_skin_tone\": \"\ud83e\uddcf\ud83c\udffc\",\n    \"deaf_person_medium_skin_tone\": \"\ud83e\uddcf\ud83c\udffd\",\n    \"deaf_woman\": \"\ud83e\uddcf\u200d\u2640\",\n    \"deaf_woman_dark_skin_tone\": \"\ud83e\uddcf\ud83c\udfff\u200d\u2640\",\n    \"deaf_woman_light_skin_tone\": \"\ud83e\uddcf\ud83c\udffb\u200d\u2640\",\n    \"deaf_woman_medium-dark_skin_tone\": \"\ud83e\uddcf\ud83c\udffe\u200d\u2640\",\n    \"deaf_woman_medium-light_skin_tone\": \"\ud83e\uddcf\ud83c\udffc\u200d\u2640\",\n    \"deaf_woman_medium_skin_tone\": \"\ud83e\uddcf\ud83c\udffd\u200d\u2640\",\n    \"deciduous_tree\": \"\ud83c\udf33\",\n    \"deer\": \"\ud83e\udd8c\",\n    \"delivery_truck\": \"\ud83d\ude9a\",\n    \"department_store\": \"\ud83c\udfec\",\n    \"derelict_house\": \"\ud83c\udfda\",\n    \"desert\": \"\ud83c\udfdc\",\n    \"desert_island\": \"\ud83c\udfdd\",\n    \"desktop_computer\": \"\ud83d\udda5\",\n    \"detective\": \"\ud83d\udd75\",\n    \"detective_dark_skin_tone\": \"\ud83d\udd75\ud83c\udfff\",\n    \"detective_light_skin_tone\": \"\ud83d\udd75\ud83c\udffb\",\n    \"detective_medium-dark_skin_tone\": \"\ud83d\udd75\ud83c\udffe\",\n    \"detective_medium-light_skin_tone\": \"\ud83d\udd75\ud83c\udffc\",\n    \"detective_medium_skin_tone\": \"\ud83d\udd75\ud83c\udffd\",\n    \"diamond_suit\": \"\u2666\",\n    \"diamond_with_a_dot\": \"\ud83d\udca0\",\n    \"dim_button\": \"\ud83d\udd05\",\n    \"disappointed_face\": \"\ud83d\ude1e\",\n    \"disguised_face\": \"\ud83e\udd78\",\n    \"divide\": \"\u2797\",\n    \"diving_mask\": \"\ud83e\udd3f\",\n    \"diya_lamp\": \"\ud83e\ude94\",\n    \"dizzy\": \"\ud83d\udcab\",\n    \"dna\": \"\ud83e\uddec\",\n    \"dodo\": \"\ud83e\udda4\",\n    \"dog\": \"\ud83d\udc15\",\n    \"dog_face\": \"\ud83d\udc36\",\n    \"dollar_banknote\": \"\ud83d\udcb5\",\n    \"dolphin\": \"\ud83d\udc2c\",\n    \"donkey\": \"\ud83e\udecf\",\n    \"door\": \"\ud83d\udeaa\",\n    \"dotted_line_face\": \"\ud83e\udee5\",\n    \"dotted_six-pointed_star\": \"\ud83d\udd2f\",\n    \"double_curly_loop\": \"\u27bf\",\n    \"double_exclamation_mark\": \"\u203c\",\n    \"doughnut\": \"\ud83c\udf69\",\n    \"dove\": \"\ud83d\udd4a\",\n    \"down-left_arrow\": \"\u2199\",\n    \"down-right_arrow\": \"\u2198\",\n    \"down_arrow\": \"\u2b07\",\n    \"downcast_face_with_sweat\": \"\ud83d\ude13\",\n    \"downwards_button\": \"\ud83d\udd3d\",\n    \"dragon\": \"\ud83d\udc09\",\n    \"dragon_face\": \"\ud83d\udc32\",\n    \"dress\": \"\ud83d\udc57\",\n    \"drooling_face\": \"\ud83e\udd24\",\n    \"drop_of_blood\": \"\ud83e\ude78\",\n    \"droplet\": \"\ud83d\udca7\",\n    \"drum\": \"\ud83e\udd41\",\n    \"duck\": \"\ud83e\udd86\",\n    \"dumpling\": \"\ud83e\udd5f\",\n    \"dvd\": \"\ud83d\udcc0\",\n    \"e-mail\": \"\ud83d\udce7\",\n    \"eagle\": \"\ud83e\udd85\",\n    \"ear\": \"\ud83d\udc42\",\n    \"ear_dark_skin_tone\": \"\ud83d\udc42\ud83c\udfff\",\n    \"ear_light_skin_tone\": \"\ud83d\udc42\ud83c\udffb\",\n    \"ear_medium-dark_skin_tone\": \"\ud83d\udc42\ud83c\udffe\",\n    \"ear_medium-light_skin_tone\": \"\ud83d\udc42\ud83c\udffc\",\n    \"ear_medium_skin_tone\": \"\ud83d\udc42\ud83c\udffd\",\n    \"ear_of_corn\": \"\ud83c\udf3d\",\n    \"ear_with_hearing_aid\": \"\ud83e\uddbb\",\n    \"ear_with_hearing_aid_dark_skin_tone\": \"\ud83e\uddbb\ud83c\udfff\",\n    \"ear_with_hearing_aid_light_skin_tone\": \"\ud83e\uddbb\ud83c\udffb\",\n    \"ear_with_hearing_aid_medium-dark_skin_tone\": \"\ud83e\uddbb\ud83c\udffe\",\n    \"ear_with_hearing_aid_medium-light_skin_tone\": \"\ud83e\uddbb\ud83c\udffc\",\n    \"ear_with_hearing_aid_medium_skin_tone\": \"\ud83e\uddbb\ud83c\udffd\",\n    \"egg\": \"\ud83e\udd5a\",\n    \"eggplant\": \"\ud83c\udf46\",\n    \"eight-pointed_star\": \"\u2734\",\n    \"eight-spoked_asterisk\": \"\u2733\",\n    \"eight-thirty\": \"\ud83d\udd63\",\n    \"eight_o\u2019clock\": \"\ud83d\udd57\",\n    \"eject_button\": \"\u23cf\",\n    \"electric_plug\": \"\ud83d\udd0c\",\n    \"elephant\": \"\ud83d\udc18\",\n    \"elevator\": \"\ud83d\uded7\",\n    \"eleven-thirty\": \"\ud83d\udd66\",\n    \"eleven_o\u2019clock\": \"\ud83d\udd5a\",\n    \"elf\": \"\ud83e\udddd\",\n    \"elf_dark_skin_tone\": \"\ud83e\udddd\ud83c\udfff\",\n    \"elf_light_skin_tone\": \"\ud83e\udddd\ud83c\udffb\",\n    \"elf_medium-dark_skin_tone\": \"\ud83e\udddd\ud83c\udffe\",\n    \"elf_medium-light_skin_tone\": \"\ud83e\udddd\ud83c\udffc\",\n    \"elf_medium_skin_tone\": \"\ud83e\udddd\ud83c\udffd\",\n    \"empty_nest\": \"\ud83e\udeb9\",\n    \"enraged_face\": \"\ud83d\ude21\",\n    \"envelope\": \"\u2709\",\n    \"envelope_with_arrow\": \"\ud83d\udce9\",\n    \"euro_banknote\": \"\ud83d\udcb6\",\n    \"evergreen_tree\": \"\ud83c\udf32\",\n    \"ewe\": \"\ud83d\udc11\",\n    \"exclamation_question_mark\": \"\u2049\",\n    \"exploding_head\": \"\ud83e\udd2f\",\n    \"expressionless_face\": \"\ud83d\ude11\",\n    \"eye\": \"\ud83d\udc41\",\n    \"eye_in_speech_bubble\": \"\ud83d\udc41\u200d\ud83d\udde8\",\n    \"eyes\": \"\ud83d\udc40\",\n    \"face_blowing_a_kiss\": \"\ud83d\ude18\",\n    \"face_exhaling\": \"\ud83d\ude2e\u200d\ud83d\udca8\",\n    \"face_holding_back_tears\": \"\ud83e\udd79\",\n    \"face_in_clouds\": \"\ud83d\ude36\u200d\ud83c\udf2b\",\n    \"face_savoring_food\": \"\ud83d\ude0b\",\n    \"face_screaming_in_fear\": \"\ud83d\ude31\",\n    \"face_vomiting\": \"\ud83e\udd2e\",\n    \"face_with_crossed-out_eyes\": \"\ud83d\ude35\",\n    \"face_with_diagonal_mouth\": \"\ud83e\udee4\",\n    \"face_with_hand_over_mouth\": \"\ud83e\udd2d\",\n    \"face_with_head-bandage\": \"\ud83e\udd15\",\n    \"face_with_medical_mask\": \"\ud83d\ude37\",\n    \"face_with_monocle\": \"\ud83e\uddd0\",\n    \"face_with_open_eyes_and_hand_over_mouth\": \"\ud83e\udee2\",\n    \"face_with_open_mouth\": \"\ud83d\ude2e\",\n    \"face_with_peeking_eye\": \"\ud83e\udee3\",\n    \"face_with_raised_eyebrow\": \"\ud83e\udd28\",\n    \"face_with_rolling_eyes\": \"\ud83d\ude44\",\n    \"face_with_spiral_eyes\": \"\ud83d\ude35\u200d\ud83d\udcab\",\n    \"face_with_steam_from_nose\": \"\ud83d\ude24\",\n    \"face_with_symbols_on_mouth\": \"\ud83e\udd2c\",\n    \"face_with_tears_of_joy\": \"\ud83d\ude02\",\n    \"face_with_thermometer\": \"\ud83e\udd12\",\n    \"face_with_tongue\": \"\ud83d\ude1b\",\n    \"face_without_mouth\": \"\ud83d\ude36\",\n    \"factory\": \"\ud83c\udfed\",\n    \"factory_worker\": \"\ud83e\uddd1\u200d\ud83c\udfed\",\n    \"factory_worker_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83c\udfed\",\n    \"factory_worker_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83c\udfed\",\n    \"factory_worker_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83c\udfed\",\n    \"factory_worker_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83c\udfed\",\n    \"factory_worker_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83c\udfed\",\n    \"fairy\": \"\ud83e\uddda\",\n    \"fairy_dark_skin_tone\": \"\ud83e\uddda\ud83c\udfff\",\n    \"fairy_light_skin_tone\": \"\ud83e\uddda\ud83c\udffb\",\n    \"fairy_medium-dark_skin_tone\": \"\ud83e\uddda\ud83c\udffe\",\n    \"fairy_medium-light_skin_tone\": \"\ud83e\uddda\ud83c\udffc\",\n    \"fairy_medium_skin_tone\": \"\ud83e\uddda\ud83c\udffd\",\n    \"falafel\": \"\ud83e\uddc6\",\n    \"fallen_leaf\": \"\ud83c\udf42\",\n    \"family\": \"\ud83d\udc6a\",\n    \"family_man_boy\": \"\ud83d\udc68\u200d\ud83d\udc66\",\n    \"family_man_boy_boy\": \"\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\",\n    \"family_man_girl\": \"\ud83d\udc68\u200d\ud83d\udc67\",\n    \"family_man_girl_boy\": \"\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66\",\n    \"family_man_girl_girl\": \"\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc67\",\n    \"family_man_man_boy\": \"\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\",\n    \"family_man_man_boy_boy\": \"\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\",\n    \"family_man_man_girl\": \"\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\",\n    \"family_man_man_girl_boy\": \"\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66\",\n    \"family_man_man_girl_girl\": \"\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc67\",\n    \"family_man_woman_boy\": \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\",\n    \"family_man_woman_boy_boy\": \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\",\n    \"family_man_woman_girl\": \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\",\n    \"family_man_woman_girl_boy\": \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66\",\n    \"family_man_woman_girl_girl\": \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67\",\n    \"family_woman_boy\": \"\ud83d\udc69\u200d\ud83d\udc66\",\n    \"family_woman_boy_boy\": \"\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\",\n    \"family_woman_girl\": \"\ud83d\udc69\u200d\ud83d\udc67\",\n    \"family_woman_girl_boy\": \"\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66\",\n    \"family_woman_girl_girl\": \"\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67\",\n    \"family_woman_woman_boy\": \"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\",\n    \"family_woman_woman_boy_boy\": \"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\",\n    \"family_woman_woman_girl\": \"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\",\n    \"family_woman_woman_girl_boy\": \"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66\",\n    \"family_woman_woman_girl_girl\": \"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67\",\n    \"farmer\": \"\ud83e\uddd1\u200d\ud83c\udf3e\",\n    \"farmer_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83c\udf3e\",\n    \"farmer_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83c\udf3e\",\n    \"farmer_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83c\udf3e\",\n    \"farmer_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83c\udf3e\",\n    \"farmer_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83c\udf3e\",\n    \"fast-forward_button\": \"\u23e9\",\n    \"fast_down_button\": \"\u23ec\",\n    \"fast_reverse_button\": \"\u23ea\",\n    \"fast_up_button\": \"\u23eb\",\n    \"fax_machine\": \"\ud83d\udce0\",\n    \"fearful_face\": \"\ud83d\ude28\",\n    \"feather\": \"\ud83e\udeb6\",\n    \"female_sign\": \"\u2640\",\n    \"ferris_wheel\": \"\ud83c\udfa1\",\n    \"ferry\": \"\u26f4\",\n    \"field_hockey\": \"\ud83c\udfd1\",\n    \"file_cabinet\": \"\ud83d\uddc4\",\n    \"file_folder\": \"\ud83d\udcc1\",\n    \"film_frames\": \"\ud83c\udf9e\",\n    \"film_projector\": \"\ud83d\udcfd\",\n    \"fire\": \"\ud83d\udd25\",\n    \"fire_engine\": \"\ud83d\ude92\",\n    \"fire_extinguisher\": \"\ud83e\uddef\",\n    \"firecracker\": \"\ud83e\udde8\",\n    \"firefighter\": \"\ud83e\uddd1\u200d\ud83d\ude92\",\n    \"firefighter_dark_skin_tone\": \"\ud83e\uddd1\ud83c\udfff\u200d\ud83d\ude92\",\n    \"firefighter_light_skin_tone\": \"\ud83e\uddd1\ud83c\udffb\u200d\ud83d\ude92\",\n    \"firefighter_medium-dark_skin_tone\": \"\ud83e\uddd1\ud83c\udffe\u200d\ud83d\ude92\",\n    \"firefighter_medium-light_skin_tone\": \"\ud83e\uddd1\ud83c\udffc\u200d\ud83d\ude92\",\n    \"firefighter_medium_skin_tone\": \"\ud83e\uddd1\ud83c\udffd\u200d\ud83d\ude92\",\n    \"fireworks\": \"\ud83c\udf86\",\n    \"first_quarter_moon\": \"\ud83c\udf13\",\n    \"first_quarter_moon_face\": \"\ud83c\udf1b\",\n    \"fish\": \"\ud83d\udc1f\",\n    \"fish_cake_with_swirl\": \"\ud83c\udf65\",\n    \"fishing_pole\": \"\ud83c\udfa3\",\n    \"five-thirty\": \"\ud83d\udd60\",\n    \"five_o\u2019clock\": \"\ud83d\udd54\",\n    \"flag_in_hole\": \"\u26f3\",\n    \"flamingo\": \"\ud83e\udda9\",\n    \"flashlight\": \"\ud83d\udd26\",\n    \"flat_shoe\": \"\ud83e\udd7f\",\n    \"flatbread\": \"\ud83e\uded3\",\n    \"fleur-de-lis\": \"\u269c\",\n    \"flexed_biceps\": \"\ud83d\udcaa\",\n    \"flexed_biceps_dark_skin_tone\": \"\ud83d\udcaa\ud83c\udfff\",\n    \"flexed_biceps_light_skin_tone\": \"\ud83d\udcaa\ud83c\udffb\",\n    \"flexed_biceps_medium-dark_skin_tone\": \"\ud83d\udcaa\ud83c\udffe\",\n    \"flexed_biceps_medium-light_skin_tone\": \"\ud83d\udcaa\ud83c\udffc\",\n    \"flexed_biceps_medium_skin_tone\": \"\ud83d\udcaa\ud83c\udffd\",\n    \"floppy_disk\": \"\ud83d\udcbe\",\n    \"flower_playing_cards\": \"\ud83c\udfb4\",\n    \"flushed_face\": \"\ud83d\ude33\",\n    \"flute\": \"\ud83e\ude88\",\n    \"fly\": \"\ud83e\udeb0\",\n    \"flying_disc\": \"\ud83e\udd4f\",\n    \"flying_saucer\": \"\ud83d\udef8\",\n    \"fog\": \"\ud83c\udf2b\",\n    \"foggy\": \"\ud83c\udf01\",\n    \"folded_hands\": \"\ud83d\ude4f\",\n    \"folded_hands_dark_skin_tone\": \"\ud83d\ude4f\ud83c\udfff\",\n    \"folded_hands_light_skin_tone\": \"\ud83d\ude4f\ud83c\udffb\",\n    \"folded_hands_medium-dark_skin_tone\": \"\ud83d\ude4f\ud83c\udffe\",\n    \"folded_hands_medium-light_skin_tone\": \"\ud83d\ude4f\ud83c\udffc\",\n    \"folded_hands_medium_skin_tone\": \"\ud83d\ude4f\ud83c\udffd\",\n    \"folding_hand_fan\": \"\ud83e\udead\",\n    \"fondue\": \"\ud83e\uded5\",\n    \"foot\": \"\ud83e\uddb6\",\n    \"foot_dark_skin_tone\": \"\ud83e\uddb6\ud83c\udfff\",\n    \"foot_light_skin_tone\": \"\ud83e\uddb6\ud83c\udffb\",\n    \"foot_medium-dark_skin_tone\": \"\ud83e\uddb6\ud83c\udffe\",\n    \"foot_medium-light_skin_tone\": \"\ud83e\uddb6\ud83c\udffc\",\n    \"foot_medium_skin_tone\": \"\ud83e\uddb6\ud83c\udffd\",\n    \"footprints\": \"\ud83d\udc63\",\n    \"fork_and_knife\": \"\ud83c\udf74\",\n    \"fork_and_knife_with_plate\": \"\ud83c\udf7d\",\n    \"fortune_cookie\": \"\ud83e\udd60\",\n    \"fountain\": \"\u26f2\",\n    \"fountain_pen\": \"\ud83d\udd8b\",\n    \"four-thirty\": \"\ud83d\udd5f\",\n    \"four_leaf_clover\": \"\ud83c\udf40\",\n    \"four_o\u2019clock\": \"\ud83d\udd53\",\n    \"fox\": \"\ud83e\udd8a\",\n    \"framed_picture\": \"\ud83d\uddbc\",\n    \"french_fries\": \"\ud83c\udf5f\",\n    \"fried_shrimp\": \"\ud83c\udf64\",\n    \"frog\": \"\ud83d\udc38\",\n    \"front-facing_baby_chick\": \"\ud83d\udc25\",\n    \"frowning_face\": \"\u2639\",\n    \"frowning_face_with_open_mouth\": \"\ud83d\ude26\",\n    \"fuel_pump\": \"\u26fd\",\n    \"full_moon\": \"\ud83c\udf15\",\n    \"full_moon_face\": \"\ud83c\udf1d\",\n    \"funeral_urn\": \"\u26b1\",\n    \"game_die\": \"\ud83c\udfb2\",\n    \"garlic\": \"\ud83e\uddc4\",\n    \"gear\": \"\u2699\",\n    \"gem_stone\": \"\ud83d\udc8e\",\n    \"genie\": \"\ud83e\uddde\",\n    \"ghost\": \"\ud83d\udc7b\",\n    \"ginger_root\": \"\ud83e\udeda\",\n    \"giraffe\": \"\ud83e\udd92\",\n    \"girl\": \"\ud83d\udc67\",\n    \"girl_dark_skin_tone\": \"\ud83d\udc67\ud83c\udfff\",\n    \"girl_light_skin_tone\": \"\ud83d\udc67\ud83c\udffb\",\n    \"girl_medium-dark_skin_tone\": \"\ud83d\udc67\ud83c\udffe\",\n    \"girl_medium-light_skin_tone\": \"\ud83d\udc67\ud83c\udffc\",\n    \"girl_medium_skin_tone\": \"\ud83d\udc67\ud83c\udffd\",\n    \"glass_of_milk\": \"\ud83e\udd5b\",\n    \"glasses\": \"\ud83d\udc53\",\n    \"globe_showing_Americas\": \"\ud83c\udf0e\",\n    \"globe_showing_Asia-Australia\": \"\ud83c\udf0f\",\n    \"globe_showing_Europe-Africa\": \"\ud83c\udf0d\",\n    \"globe_with_meridians\": \"\ud83c\udf10\",\n    \"gloves\": \"\ud83e\udde4\",\n    \"glowing_star\": \"\ud83c\udf1f\",\n    \"goal_net\": \"\ud83e\udd45\",\n    \"goat\": \"\ud83d\udc10\",\n    \"goblin\": \"\ud83d\udc7a\",\n    \"goggles\": \"\ud83e\udd7d\",\n    \"goose\": \"\ud83e\udebf\",\n    \"gorilla\": \"\ud83e\udd8d\",\n    \"graduation_cap\": \"\ud83c\udf93\",\n    \"grapes\": \"\ud83c\udf47\",\n    \"green_apple\": \"\ud83c\udf4f\",\n    \"green_book\": \"\ud83d\udcd7\",\n    \"green_circle\": \"\ud83d\udfe2\",\n    \"green_heart\": \"\ud83d\udc9a\",\n    \"green_salad\": \"\ud83e\udd57\",\n    \"green_square\": \"\ud83d\udfe9\",\n    \"grey_heart\": \"\ud83e\ude76\",\n    \"grimacing_face\": \"\ud83d\ude2c\",\n    \"grinning_cat\": \"\ud83d\ude3a\",\n    \"grinning_cat_with_smiling_eyes\": \"\ud83d\ude38\",\n    \"grinning_face\": \"\ud83d\ude00\",\n    \"grinning_face_with_big_eyes\": \"\ud83d\ude03\",\n    \"grinning_face_with_smiling_eyes\": \"\ud83d\ude04\",\n    \"grinning_face_with_sweat\": \"\ud83d\ude05\",\n    \"grinning_squinting_face\": \"\ud83d\ude06\",\n    \"growing_heart\": \"\ud83d\udc97\",\n    \"guard\": \"\ud83d\udc82\",\n    \"guard_dark_skin_tone\": \"\ud83d\udc82\ud83c\udfff\",\n    \"guard_light_skin_tone\": \"\ud83d\udc82\ud83c\udffb\",\n    \"guard_medium-dark_skin_tone\": \"\ud83d\udc82\ud83c\udffe\",\n    \"guard_medium-light_skin_tone\": \"\ud83d\udc82\ud83c\udffc\",\n    \"guard_medium_skin_tone\": \"\ud83d\udc82\ud83c\udffd\",\n    \"guide_dog\": \"\ud83e\uddae\",\n    \"guitar\": \"\ud83c\udfb8\",\n    \"hair_pick\": \"\ud83e\udeae\",\n    \"hamburger\": \"\ud83c\udf54\",\n    \"hammer\": \"\ud83d\udd28\",\n    \"hammer_and_pick\": \"\u2692\",\n    \"hammer_and_wrench\": \"\ud83d\udee0\",\n    \"hamsa\": \"\ud83e\udeac\",\n    \"hamster\": \"\ud83d\udc39\",\n    \"hand_with_fingers_splayed\": \"\ud83d\udd90\",\n    \"hand_with_fingers_splayed_dark_skin_tone\": \"\ud83d\udd90\ud83c\udfff\",\n    \"hand_with_fingers_splayed_light_skin_tone\": \"\ud83d\udd90\ud83c\udffb\",\n    \"hand_with_fingers_splayed_medium-dark_skin_tone\": \"\ud83d\udd90\ud83c\udffe\",\n    \"hand_with_fingers_splayed_medium-light_skin_tone\": \"\ud83d\udd90\ud83c\udffc\",\n    \"hand_with_fingers_splayed_medium_skin_tone\": \"\ud83d\udd90\ud83c\udffd\",\n    \"hand_with_index_finger_and_thumb_crossed\": \"\ud83e\udef0\",\n    \"hand_with_index_finger_and_thumb_crossed_dark_skin_tone\": \"\ud83e\udef0\ud83c\udfff\","
    },
    {
      "chunk_id": 1571,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "import re\n\nfrom pathlib import Path\nfrom textwrap import indent\n\nfrom emoji import EMOJI"
    },
    {
      "chunk_id": 1572,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "COLUMN_PATTERN = re.compile(r\"---:1\\s*(.*?)\\s*:--:1\\s*(.*?)\\s*:---\", re.DOTALL)\nPYTHON_HIGHLIGHT_PATTERN = re.compile(r\"```python\\{+.*?\\}\", re.DOTALL)\nBASH_HIGHLIGHT_PATTERN = re.compile(r\"```bash\\{+.*?\\}\", re.DOTALL)\nNOTIFICATION_PATTERN = re.compile(\n    r\":::\\s*(\\w+)\\s*(.*?)\\n([\\s\\S]*?):::\", re.MULTILINE\n)\nEMOJI_PATTERN = re.compile(r\":(\\w+):\")\nCURRENT_DIR = Path(__file__).parent\nSOURCE_DIR = (\n    CURRENT_DIR.parent.parent.parent.parent / \"sanic-guide\" / \"src\" / \"en\"\n)"
    },
    {
      "chunk_id": 1573,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert_columns(content: str):\n    def replacer(match: re.Match):\n        left, right = match.groups()\n        left = indent(left.strip(), \" \" * 4)\n        right = indent(right.strip(), \" \" * 4)\n        return f\"\"\"\n.. column::\n\n{left}\n\n.. column::\n\n{right}\n\"\"\"\n\n    return COLUMN_PATTERN.sub(replacer, content)"
    },
    {
      "chunk_id": 1574,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def cleanup_highlights(content: str):\n    content = PYTHON_HIGHLIGHT_PATTERN.sub(\"```python\", content)\n    content = BASH_HIGHLIGHT_PATTERN.sub(\"```bash\", content)\n    return content"
    },
    {
      "chunk_id": 1575,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert_notifications(content: str):\n    def replacer(match: re.Match):\n        type_, title, body = match.groups()\n        body = indent(body.strip(), \" \" * 4)\n        return f\"\"\"\n\n.. {type_}:: {title}\n\n{body}\n\n\"\"\"\n\n    return NOTIFICATION_PATTERN.sub(replacer, content)"
    },
    {
      "chunk_id": 1576,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert_emoji(content: str):\n    def replace(match):\n        return EMOJI.get(match.group(1), match.group(0))\n\n    return EMOJI_PATTERN.sub(replace, content)"
    },
    {
      "chunk_id": 1577,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert_code_blocks(content: str):\n    for src, dest in (\n        (\"yml\", \"yaml\"),\n        (\"caddy\", \"\"),\n        (\"systemd\", \"\"),\n        (\"mermaid\", \"\\nmermaid\"),\n    ):\n        content = content.replace(f\"```{src}\", f\"```{dest}\")\n    return content"
    },
    {
      "chunk_id": 1578,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def cleanup_multibreaks(content: str):\n    return content.replace(\"\\n\\n\\n\", \"\\n\\n\")"
    },
    {
      "chunk_id": 1579,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert(content: str):\n    content = convert_emoji(content)\n    content = convert_columns(content)\n    content = cleanup_highlights(content)\n    content = convert_code_blocks(content)\n    content = convert_notifications(content)\n    content = cleanup_multibreaks(content)\n    return content"
    },
    {
      "chunk_id": 1580,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def convert_file(src: Path, dest: Path):\n    short_src = src.relative_to(SOURCE_DIR)\n    short_dest = dest.relative_to(CURRENT_DIR)\n    print(f\"Converting {short_src} -> {short_dest}\")\n    content = src.read_text()\n    new_content = convert(content)\n    dest.parent.mkdir(parents=True, exist_ok=True)\n    dest.touch()\n    dest.write_text(new_content)"
    },
    {
      "chunk_id": 1581,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def translate_path(source_dir: Path, source_path: Path, dest_dir: Path):\n    rel_path = source_path.relative_to(source_dir)\n    dest_path = dest_dir / rel_path\n    return dest_path"
    },
    {
      "chunk_id": 1582,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "def main():\n    print(f\"Source: {SOURCE_DIR}\")\n\n    for path in SOURCE_DIR.glob(\"**/*.md\"):\n        if path.name in (\"index.md\", \"README.md\"):\n            continue\n        dest_path = translate_path(SOURCE_DIR, path, CURRENT_DIR)\n        convert_file(path, dest_path)"
    },
    {
      "chunk_id": 1583,
      "source": "__internal__/data_repo/sanic/guide/content/en/migrate.py",
      "content": "if __name__ == \"__main__\":\n    main()"
    },
    {
      "chunk_id": 1584,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "#!/usr/bin/env python"
    },
    {
      "chunk_id": 1585,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "import sys"
    },
    {
      "chunk_id": 1586,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "from os import path"
    },
    {
      "chunk_id": 1587,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "if __name__ == \"__main__\":\n    try:\n        import click\n        import towncrier\n    except ImportError:\n        print(\n            \"Please make sure you have installed towncrier and \"\n            \"click before using this tool\"\n        )\n        sys.exit(1)"
    },
    {
      "chunk_id": 1588,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "@click.command()\n@click.option(\n    \"--draft\",\n    \"draft\",\n    default=False,\n    flag_value=True,\n    help=\"Render the news fragments, don't write to files, \"\n    \"don't check versions.\",\n)\n@click.option(\n    \"--dir\", \"directory\", default=path.dirname(path.abspath(__file__))\n)\n@click.option(\"--name\", \"project_name\", default=None)\n@click.option(\n    \"--version\",\n    \"project_version\",\n    default=None,\n    help=\"Render the news fragments using given version.\",\n)\n@click.option(\"--date\", \"project_date\", default=None)\n@click.option(\n    \"--yes\",\n    \"answer_yes\",\n    default=False,\n    flag_value=True,\n    help=\"Do not ask for confirmation to remove news fragments.\",\n)\ndef _main(\n    draft,\n    directory,\n    project_name,\n    project_version,\n    project_date,\n    answer_yes,\n):\n    return towncrier.__main__(\n        draft,\n        directory,\n        project_name,\n        project_version,\n        project_date,\n        answer_yes,\n    )"
    },
    {
      "chunk_id": 1589,
      "source": "__internal__/data_repo/sanic/scripts/changelog.py",
      "content": "_main()"
    },
    {
      "chunk_id": 1590,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "#!/usr/bin/env python"
    },
    {
      "chunk_id": 1591,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "import sys\n\nfrom argparse import ArgumentParser, Namespace\nfrom collections import OrderedDict\nfrom configparser import RawConfigParser\nfrom datetime import datetime\nfrom json import dumps\nfrom os import chdir, path\nfrom subprocess import PIPE, Popen\n\nimport towncrier\n\nfrom jinja2 import BaseLoader, Environment\nfrom requests import patch"
    },
    {
      "chunk_id": 1592,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "GIT_COMMANDS = {\n    \"get_tag\": [\"git describe --tags --abbrev=0\"],\n    \"commit_version_change\": [\n        \"git add . && git commit -m 'Bumping up version from \"\n        \"{current_version} to {new_version}'\"\n    ],\n    \"create_new_tag\": [\n        \"git tag -a {new_version} -m 'Bumping up version from \"\n        \"{current_version} to {new_version}'\"\n    ],\n    \"push_tag\": [\"git push origin {new_version}\"],\n    \"get_change_log\": [\n        'git log --no-merges --pretty=format:\"%h::: %cn::: %s\" '\n        \"{current_version}..\"\n    ],\n}"
    },
    {
      "chunk_id": 1593,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "RELEASE_NOTE_TEMPLATE = \"\"\"\n# {{ release_name }} - {% now 'utc', '%Y-%m-%d' %}\n\nTo see the exhaustive list of pull requests included in this release see:\nhttps://github.com/huge-success/sanic/milestone/{{milestone}}?closed=1\n\n# Changelog\n{% for row in changelogs %}\n* {{ row -}}\n{% endfor %}\n\n# Credits\n{% for author in authors %}\n* {{ author -}}\n{% endfor %}\n\"\"\""
    },
    {
      "chunk_id": 1594,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "JINJA_RELEASE_NOTE_TEMPLATE = Environment(\n    loader=BaseLoader, extensions=[\"jinja2_time.TimeExtension\"]\n).from_string(RELEASE_NOTE_TEMPLATE)"
    },
    {
      "chunk_id": 1595,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "RELEASE_NOTE_UPDATE_URL = (\n    \"https://api.github.com/repos/huge-success/sanic/releases/tags/\"\n    \"{new_version}?access_token={token}\"\n)"
    },
    {
      "chunk_id": 1596,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "class Directory:\n    def __init__(self):\n        self._old_path = path.dirname(path.abspath(__file__))\n        self._new_path = path.dirname(self._old_path)\n\n    def __enter__(self):\n        chdir(self._new_path)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        chdir(self._old_path)"
    },
    {
      "chunk_id": 1597,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _run_shell_command(command: list):\n    try:\n        process = Popen(\n            command, stderr=PIPE, stdout=PIPE, stdin=PIPE, shell=True\n        )\n        output, error = process.communicate()\n        return_code = process.returncode\n        return output.decode(\"utf-8\"), error, return_code\n    except Exception:\n        return None, None, -1"
    },
    {
      "chunk_id": 1598,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _fetch_default_calendar_release_version():\n    return datetime.now().strftime(\"%y.%m.0\")"
    },
    {
      "chunk_id": 1599,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _fetch_current_version(config_file: str) -> str:\n    if path.isfile(config_file):\n        config_parser = RawConfigParser()\n        with open(config_file) as cfg:\n            config_parser.read_file(cfg)\n            return (\n                config_parser.get(\"version\", \"current_version\")\n                or _fetch_default_calendar_release_version()\n            )\n    else:\n        return _fetch_default_calendar_release_version()"
    },
    {
      "chunk_id": 1600,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _change_micro_version(current_version: str):\n    version_string = current_version.split(\".\")\n    version_string[-1] = str((int(version_string[-1]) + 1))\n    return \".\".join(version_string)"
    },
    {
      "chunk_id": 1601,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _get_new_version(\n    config_file: str = \"./setup.cfg\",\n    current_version: str = None,\n    micro_release: bool = False,\n):\n    if micro_release:\n        if current_version:\n            return _change_micro_version(current_version)\n        elif config_file:\n            return _change_micro_version(_fetch_current_version(config_file))\n        else:\n            return _fetch_default_calendar_release_version()\n    else:\n        return _fetch_default_calendar_release_version()"
    },
    {
      "chunk_id": 1602,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _get_current_tag(git_command_name=\"get_tag\"):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(git_command_name)\n    out, err, ret = _run_shell_command(command)\n    if str(out):\n        return str(out).split(\"\\n\")[0]\n    else:\n        return None"
    },
    {
      "chunk_id": 1603,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _update_release_version_for_sanic(\n    current_version, new_version, config_file, generate_changelog\n):\n    config_parser = RawConfigParser()\n    with open(config_file) as cfg:\n        config_parser.read_file(cfg)\n    config_parser.set(\"version\", \"current_version\", new_version)\n\n    version_files = config_parser.get(\"version\", \"files\")\n    current_version_line = config_parser.get(\n        \"version\", \"current_version_pattern\"\n    ).format(current_version=current_version)\n    new_version_line = config_parser.get(\n        \"version\", \"new_version_pattern\"\n    ).format(new_version=new_version)\n\n    for version_file in version_files.split(\",\"):\n        with open(version_file) as init_file:\n            data = init_file.read()\n\n        new_data = data.replace(current_version_line, new_version_line)\n        with open(version_file, \"w\") as init_file:\n            init_file.write(new_data)\n\n    with open(config_file, \"w\") as config:\n        config_parser.write(config)\n\n    if generate_changelog:\n        towncrier.__main(\n            draft=False,\n            directory=path.dirname(path.abspath(__file__)),\n            project_name=None,\n            project_version=new_version,\n            project_date=None,\n            answer_yes=True,\n        )\n\n    command = GIT_COMMANDS.get(\"commit_version_change\")\n    command[0] = command[0].format(\n        new_version=new_version, current_version=current_version\n    )\n    _, err, ret = _run_shell_command(command)\n    if int(ret) != 0:\n        print(\n            \"Failed to Commit Version upgrade changes to Sanic: {}\".format(\n                err.decode(\"utf-8\")\n            )\n        )\n        sys.exit(1)"
    },
    {
      "chunk_id": 1604,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _generate_change_log(current_version: str = None):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(\"get_change_log\")\n    command[0] = command[0].format(current_version=current_version)\n    output, error, ret = _run_shell_command(command=command)\n    if not str(output):\n        print(\"Unable to Fetch Change log details to update the Release Note\")\n        sys.exit(1)\n\n    commit_details = OrderedDict()\n    commit_details[\"authors\"] = {}\n    commit_details[\"commits\"] = []\n\n    for line in str(output).split(\"\\n\"):\n        commit, author, description = line.split(\":::\")\n        if \"GitHub\" not in author:\n            commit_details[\"authors\"][author] = 1\n        commit_details[\"commits\"].append(\" - \".join([commit, description]))\n\n    return commit_details"
    },
    {
      "chunk_id": 1605,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _generate_markdown_document(\n    milestone, release_name, current_version, release_version\n):\n    global JINJA_RELEASE_NOTE_TEMPLATE\n    release_name = release_name or release_version\n    change_log = _generate_change_log(current_version=current_version)\n    return JINJA_RELEASE_NOTE_TEMPLATE.render(\n        release_name=release_name,\n        milestone=milestone,\n        changelogs=change_log[\"commits\"],\n        authors=change_log[\"authors\"].keys(),\n    )"
    },
    {
      "chunk_id": 1606,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def _tag_release(new_version, current_version, milestone, release_name, token):\n    global GIT_COMMANDS\n    global RELEASE_NOTE_UPDATE_URL\n    for command_name in [\"create_new_tag\", \"push_tag\"]:\n        command = GIT_COMMANDS.get(command_name)\n        command[0] = command[0].format(\n            new_version=new_version, current_version=current_version\n        )\n        out, error, ret = _run_shell_command(command=command)\n        if int(ret) != 0:\n            print(\"Failed to execute the command: {}\".format(command[0]))\n            sys.exit(1)\n\n    change_log = _generate_markdown_document(\n        milestone, release_name, current_version, new_version\n    )\n\n    body = {\"name\": release_name or new_version, \"body\": change_log}\n\n    headers = {\"content-type\": \"application/json\"}\n\n    response = patch(\n        RELEASE_NOTE_UPDATE_URL.format(new_version=new_version, token=token),\n        data=dumps(body),\n        headers=headers,\n    )\n    response.raise_for_status()"
    },
    {
      "chunk_id": 1607,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "def release(args: Namespace):\n    current_tag = _get_current_tag()\n    current_version = _fetch_current_version(args.config)\n    if current_tag and current_version not in current_tag:\n        print(\n            \"Tag mismatch between what's in git and what was provided by \"\n            \"--current-version. Existing: {}, Give: {}\".format(\n                current_tag, current_version\n            )\n        )\n        sys.exit(1)\n    new_version = args.release_version or _get_new_version(\n        args.config, current_version, args.micro_release\n    )\n    _update_release_version_for_sanic(\n        current_version=current_version,\n        new_version=new_version,\n        config_file=args.config,\n        generate_changelog=args.generate_changelog,\n    )\n    if args.tag_release:\n        _tag_release(\n            current_version=current_version,\n            new_version=new_version,\n            milestone=args.milestone,\n            release_name=args.release_name,\n            token=args.token,\n        )"
    },
    {
      "chunk_id": 1608,
      "source": "__internal__/data_repo/sanic/scripts/release.py",
      "content": "if __name__ == \"__main__\":\n    cli = ArgumentParser(description=\"Sanic Release Manager\")\n    cli.add_argument(\n        \"--release-version\",\n        \"-r\",\n        help=\"New Version to use for Release\",\n        default=_fetch_default_calendar_release_version(),\n        required=False,\n    )\n    cli.add_argument(\n        \"--current-version\",\n        \"-cv\",\n        help=\"Current Version to default in case if you don't want to \"\n        \"use the version configuration files\",\n        default=None,\n        required=False,\n    )\n    cli.add_argument(\n        \"--config\",\n        \"-c\",\n        help=\"Configuration file used for release\",\n        default=\"./setup.cfg\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--token\",\n        \"-t\",\n        help=\"Git access token with necessary access to Huge Sanic Org\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--milestone\",\n        \"-ms\",\n        help=\"Git Release milestone information to include in release note\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--release-name\",\n        \"-n\",\n        help=\"Release Name to use if any\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--micro-release\",\n        \"-m\",\n        help=\"Micro Release with patches only\",\n        default=False,\n        action=\"store_true\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--tag-release\",\n        help=\"Tag a new release for Sanic\",\n        default=False,\n        action=\"store_true\",\n        required=False,\n    )\n    cli.add_argument(\n        \"--generate-changelog\",\n        help=\"Generate changelog for Sanic as part of release\",\n        default=False,\n        action=\"store_true\",\n        required=False,\n    )\n    args = cli.parse_args()\n    if args.tag_release:\n        for key, value in {\n            \"--token/-t\": args.token,\n            \"--milestone/-m\": args.milestone,\n        }.items():\n            if not value:\n                print(f\"{key} is mandatory while using --tag-release\")\n                sys.exit(1)\n    with Directory():\n        release(args)"
    },
    {
      "chunk_id": 1609,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# Sanic documentation build configuration file, created by\n# sphinx-quickstart on Sun Dec 25 18:07:21 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir."
    },
    {
      "chunk_id": 1610,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "import os\nimport sys"
    },
    {
      "chunk_id": 1611,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# Add support for auto-doc\n\n# Ensure that sanic is present in the path, to allow sphinx-apidoc to\n# autogenerate documentation from docstrings\nroot_directory = os.path.dirname(os.getcwd())\nsys.path.insert(0, root_directory)\n\nimport sanic  #  noqa"
    },
    {
      "chunk_id": 1612,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- General configuration ------------------------------------------------\n\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"m2r2\",\n    \"enum_tools.autoenum\",\n]\n\ntemplates_path = [\"_templates\"]\n\n# Enable support for both Restructured Text and Markdown\nsource_suffix = [\".rst\", \".md\"]\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"Sanic\"\ncopyright = \"2021, Sanic Community Organization\"\nauthor = \"Sanic Community Organization\"\n\nhtml_logo = \"./_static/sanic-framework-logo-white-400x97.png\"\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = sanic.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = sanic.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"en\"\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\n#\n# modules.rst is generated by sphinx-apidoc but is unused. This suppresses\n# a warning about it.\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\", \"modules.rst\"]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False"
    },
    {
      "chunk_id": 1613,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"sphinx_rtd_theme\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\nhtml_css_files = [\"custom.css\"]"
    },
    {
      "chunk_id": 1614,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"Sanicdoc\""
    },
    {
      "chunk_id": 1615,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        \"Sanic.tex\",\n        \"Sanic Documentation\",\n        \"Sanic contributors\",\n        \"manual\",\n    ),\n]"
    },
    {
      "chunk_id": 1616,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, \"sanic\", \"Sanic Documentation\", [author], 1)]"
    },
    {
      "chunk_id": 1617,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"Sanic\",\n        \"Sanic Documentation\",\n        author,\n        \"Sanic\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]"
    },
    {
      "chunk_id": 1618,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Options for Epub output ----------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\nepub_author = author\nepub_publisher = author\nepub_copyright = copyright\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\"search.html\"]"
    },
    {
      "chunk_id": 1619,
      "source": "__internal__/data_repo/sanic/docs/conf.py",
      "content": "# -- Custom Settings -------------------------------------------------------\n\nsuppress_warnings = [\"image.nonlocal_uri\"]\n\nautodoc_typehints = \"description\"\nautodoc_default_options = {\n    \"member-order\": \"groupwise\",\n}\n\nhtml_theme_options = {\n    \"style_external_links\": False,\n}\n\nrst_prolog = \"\"\".. warning::\n    These documents are **OUTDATED** as of 2023-12-31.\n\n    Please refer to the latest version of the documentation at `sanic.dev <https://sanic.dev>`__.\n\"\"\""
    },
    {
      "chunk_id": 1620,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "import json\n\nfrom sanic import Sanic, text\nfrom sanic.application.constants import Mode\nfrom sanic.config import Config\nfrom sanic.log import LOGGING_CONFIG_DEFAULTS, logger"
    },
    {
      "chunk_id": 1621,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "LOGGING_CONFIG = {**LOGGING_CONFIG_DEFAULTS}\nLOGGING_CONFIG[\"formatters\"][\"generic\"][\"format\"] = \"%(message)s\"\nLOGGING_CONFIG[\"loggers\"][\"sanic.root\"][\"level\"] = \"DEBUG\"\n\napp = Sanic(\"FakeServer\", log_config=LOGGING_CONFIG)"
    },
    {
      "chunk_id": 1622,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.get(\"/\")\nasync def handler(request):\n    return text(request.ip)"
    },
    {
      "chunk_id": 1623,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.main_process_start\nasync def app_info_dump(app: Sanic, _):\n    app_data = {\n        \"access_log\": app.config.ACCESS_LOG,\n        \"auto_reload\": app.auto_reload,\n        \"debug\": app.debug,\n        \"noisy_exceptions\": app.config.NOISY_EXCEPTIONS,\n    }\n    logger.info(json.dumps(app_data))"
    },
    {
      "chunk_id": 1624,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.main_process_stop\nasync def app_cleanup(app: Sanic, _):\n    app.state.auto_reload = False\n    app.state.mode = Mode.PRODUCTION\n    app.config = Config()"
    },
    {
      "chunk_id": 1625,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.after_server_start\nasync def shutdown(app: Sanic, _):\n    app.stop()"
    },
    {
      "chunk_id": 1626,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "def create_app():\n    return app"
    },
    {
      "chunk_id": 1627,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "def create_app_with_args(args):\n    try:\n        logger.info(f\"foo={args.foo}\")\n    except AttributeError:\n        logger.info(f\"target={args.target}\")\n\n    return app"
    },
    {
      "chunk_id": 1628,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.command\nasync def foo(one, two: str, three: str = \"...\"):\n    logger.info(f\"FOO {one=} {two=} {three=}\")"
    },
    {
      "chunk_id": 1629,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.command\ndef bar():\n    logger.info(\"BAR\")"
    },
    {
      "chunk_id": 1630,
      "source": "__internal__/data_repo/sanic/tests/fake/server.py",
      "content": "@app.command(name=\"qqq\")\nasync def baz():\n    logger.info(\"BAZ\")"
    },
    {
      "chunk_id": 1631,
      "source": "__internal__/data_repo/sanic/tests/typing/test_typing.py",
      "content": "import subprocess\n\nfrom pathlib import Path\n\nimport pytest\n\n\nCURRENT_DIR = Path(__file__).parent"
    },
    {
      "chunk_id": 1632,
      "source": "__internal__/data_repo/sanic/tests/typing/test_typing.py",
      "content": "def run_check(path_location: str) -> str:\n    \"\"\"Use mypy to check the given path location and return the output.\"\"\"\n\n    mypy_path = \"mypy\"\n    path = CURRENT_DIR / path_location\n    command = [mypy_path, path.resolve().as_posix()]\n\n    process = subprocess.run(\n        command,\n        capture_output=True,\n        text=True,\n    )\n    output = process.stdout + process.stderr\n    return output"
    },
    {
      "chunk_id": 1633,
      "source": "__internal__/data_repo/sanic/tests/typing/test_typing.py",
      "content": "@pytest.mark.parametrize(\n    \"path_location,expected\",\n    (\n        (\n            \"app_default.py\",\n            [\n                (\n                    \"sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]\",\n                    5,\n                )\n            ],\n        ),\n        (\n            \"app_custom_config.py\",\n            [\n                (\n                    \"sanic.app.Sanic[app_custom_config.CustomConfig, types.SimpleNamespace]\",\n                    10,\n                )\n            ],\n        ),\n        (\n            \"app_custom_ctx.py\",\n            [(\"sanic.app.Sanic[sanic.config.Config, app_custom_ctx.Foo]\", 9)],\n        ),\n        (\n            \"app_fully_custom.py\",\n            [\n                (\n                    \"sanic.app.Sanic[app_fully_custom.CustomConfig, app_fully_custom.Foo]\",\n                    14,\n                )\n            ],\n        ),\n        (\n            \"request_custom_sanic.py\",\n            [\n                (\"types.SimpleNamespace\", 18),\n                (\n                    \"sanic.app.Sanic[request_custom_sanic.CustomConfig, types.SimpleNamespace]\",\n                    19,\n                ),\n            ],\n        ),\n        (\n            \"request_custom_ctx.py\",\n            [\n                (\"request_custom_ctx.Foo\", 16),\n                (\n                    \"sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]\",\n                    17,\n                ),\n            ],\n        ),\n        (\n            \"request_fully_custom.py\",\n            [\n                (\"request_fully_custom.CustomRequest\", 32),\n                (\"request_fully_custom.RequestContext\", 33),\n                (\n                    \"sanic.app.Sanic[request_fully_custom.CustomConfig, request_fully_custom.Foo]\",\n                    34,\n                ),\n            ],\n        ),\n    ),\n)\ndef test_check_app_default(\n    path_location: str, expected: list[tuple[str, int]]\n) -> None:\n    output = run_check(f\"samples/{path_location}\")\n\n    for text, number in expected:\n        current = CURRENT_DIR / f\"samples/{path_location}\"\n        path = current.relative_to(CURRENT_DIR.parent)\n\n        target = Path.cwd()\n        while True:\n            note = _text_from_path(current, path, target, number, text)\n            try:\n                assert note in output, output\n            except AssertionError:\n                target = target.parent\n                if not target.exists() or target == target.parent:\n                    raise\n            else:\n                break"
    },
    {
      "chunk_id": 1634,
      "source": "__internal__/data_repo/sanic/tests/typing/test_typing.py",
      "content": "def _text_from_path(\n    base: Path, path: Path, target: Path, number: int, text: str\n) -> str:\n    relative_to_cwd = base.relative_to(target)\n    prefix = \".\".join(relative_to_cwd.parts[:-1])\n    text = text.replace(path.stem, f\"{prefix}.{path.stem}\")\n    return f'{path}:{number}: note: Revealed type is \"{text}\"'"
    },
    {
      "chunk_id": 1635,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_fully_custom.py",
      "content": "from sanic import Sanic\nfrom sanic.config import Config"
    },
    {
      "chunk_id": 1636,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_fully_custom.py",
      "content": "class CustomConfig(Config):\n    pass"
    },
    {
      "chunk_id": 1637,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_fully_custom.py",
      "content": "class Foo:\n    pass"
    },
    {
      "chunk_id": 1638,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_fully_custom.py",
      "content": "app = Sanic(\"test\", config=CustomConfig(), ctx=Foo())\nreveal_type(app)  # noqa"
    },
    {
      "chunk_id": 1639,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_sanic.py",
      "content": "from types import SimpleNamespace\n\nfrom sanic import Request, Sanic\nfrom sanic.config import Config"
    },
    {
      "chunk_id": 1640,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_sanic.py",
      "content": "class CustomConfig(Config):\n    \"\"\"Custom configuration class for Sanic.\"\"\"\n    pass"
    },
    {
      "chunk_id": 1641,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_sanic.py",
      "content": "app = Sanic(\"test\", config=CustomConfig())"
    },
    {
      "chunk_id": 1642,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_sanic.py",
      "content": "@app.get(\"/\")\nasync def handler(\n    request: Request[Sanic[CustomConfig, SimpleNamespace], SimpleNamespace],\n):\n    reveal_type(request.ctx)  # noqa\n    reveal_type(request.app)  # noqa"
    },
    {
      "chunk_id": 1643,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_default.py",
      "content": "from sanic import Sanic"
    },
    {
      "chunk_id": 1644,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_default.py",
      "content": "app = Sanic(\"test\")\nreveal_type(app)  # noqa"
    },
    {
      "chunk_id": 1645,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_config.py",
      "content": "from sanic import Sanic\nfrom sanic.config import Config"
    },
    {
      "chunk_id": 1646,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_config.py",
      "content": "class CustomConfig(Config):\n    \"\"\"Custom configuration class.\"\"\"\n    pass"
    },
    {
      "chunk_id": 1647,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_config.py",
      "content": "app = Sanic(\"test\", config=CustomConfig())"
    },
    {
      "chunk_id": 1648,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_config.py",
      "content": "reveal_type(app)  # noqa"
    },
    {
      "chunk_id": 1649,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_ctx.py",
      "content": "from types import SimpleNamespace\n\nfrom sanic import Request, Sanic\nfrom sanic.config import Config"
    },
    {
      "chunk_id": 1650,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_ctx.py",
      "content": "class Foo:\n    \"\"\"A simple class.\"\"\"\n    pass"
    },
    {
      "chunk_id": 1651,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_ctx.py",
      "content": "app = Sanic(\"test\")"
    },
    {
      "chunk_id": 1652,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_custom_ctx.py",
      "content": "@app.get(\"/\")\nasync def handler(request: Request[Sanic[Config, SimpleNamespace], Foo]):\n    reveal_type(request.ctx)  # noqa\n    reveal_type(request.app)  # noqa"
    },
    {
      "chunk_id": 1653,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "from sanic import Request, Sanic\nfrom sanic.config import Config"
    },
    {
      "chunk_id": 1654,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "class CustomConfig(Config):\n    pass"
    },
    {
      "chunk_id": 1655,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "class Foo:\n    pass"
    },
    {
      "chunk_id": 1656,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "class RequestContext:\n    foo: Foo"
    },
    {
      "chunk_id": 1657,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "class CustomRequest(Request[Sanic[CustomConfig, Foo], RequestContext]):\n    @staticmethod\n    def make_context() -> RequestContext:\n        ctx = RequestContext()\n        ctx.foo = Foo()\n        return ctx"
    },
    {
      "chunk_id": 1658,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "app = Sanic(\n    \"test\", config=CustomConfig(), ctx=Foo(), request_class=CustomRequest\n)"
    },
    {
      "chunk_id": 1659,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/request_fully_custom.py",
      "content": "@app.get(\"/\")\nasync def handler(request: CustomRequest):\n    reveal_type(request)  # noqa\n    reveal_type(request.ctx)  # noqa\n    reveal_type(request.app)  # noqa"
    },
    {
      "chunk_id": 1660,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_ctx.py",
      "content": "from sanic import Sanic"
    },
    {
      "chunk_id": 1661,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_ctx.py",
      "content": "class Foo:\n    pass"
    },
    {
      "chunk_id": 1662,
      "source": "__internal__/data_repo/sanic/tests/typing/samples/app_custom_ctx.py",
      "content": "app = Sanic(\"test\", ctx=Foo())\nreveal_type(app)  # noqa"
    },
    {
      "chunk_id": 1663,
      "source": "__internal__/data_repo/sanic/tests/static/app_test_config.py",
      "content": "TEST_SETTING_VALUE = 1"
    },
    {
      "chunk_id": 1664,
      "source": "__internal__/data_repo/sanic/tests/benchmark/test_route_resolution_benchmark.py",
      "content": "from random import choice, seed\n\nfrom pytest import mark\n\nimport sanic.router\n\nfrom sanic.request import Request"
    },
    {
      "chunk_id": 1665,
      "source": "__internal__/data_repo/sanic/tests/benchmark/test_route_resolution_benchmark.py",
      "content": "seed(\"Pack my box with five dozen liquor jugs.\")\n\n# Disable Caching for testing purpose\nsanic.router.ROUTER_CACHE_SIZE = 0"
    },
    {
      "chunk_id": 1666,
      "source": "__internal__/data_repo/sanic/tests/benchmark/test_route_resolution_benchmark.py",
      "content": "class TestSanicRouteResolution:\n    \"\"\"Test class for Sanic route resolution.\"\"\"\n\n    def __init__(self):\n        pass"
    },
    {
      "chunk_id": 1667,
      "source": "__internal__/data_repo/sanic/tests/benchmark/test_route_resolution_benchmark.py",
      "content": "@mark.asyncio\n    async def test_resolve_route_no_arg_string_path(\n        self, sanic_router, route_generator, benchmark\n    ):\n        simple_routes = route_generator.generate_random_direct_route(\n            max_route_depth=4\n        )\n        router, simple_routes = sanic_router(route_details=simple_routes)\n        route_to_call = choice(simple_routes)\n        request = Request(\n            f\"/{route_to_call[-1]}\".encode(),\n            {\"host\": \"localhost\"},\n            \"v1\",\n            route_to_call[0],\n            None,\n            None,\n        )\n\n        result = benchmark.pedantic(\n            router.get,\n            (\n                request.path,\n                request.method,\n                request.headers.get(\"host\"),\n            ),\n            iterations=1000,\n            rounds=1000,\n        )\n        assert await result[1](None) == 1"
    },
    {
      "chunk_id": 1668,
      "source": "__internal__/data_repo/sanic/tests/benchmark/test_route_resolution_benchmark.py",
      "content": "@mark.asyncio\n    async def test_resolve_route_with_typed_args(\n        self, sanic_router, route_generator, benchmark\n    ):\n        typed_routes = route_generator.add_typed_parameters(\n            route_generator.generate_random_direct_route(max_route_depth=4),\n            max_route_depth=8,\n        )\n        router, typed_routes = sanic_router(route_details=typed_routes)\n        route_to_call = choice(typed_routes)\n        url = route_generator.generate_url_for_template(\n            template=route_to_call[-1]\n        )\n\n        print(f\"{route_to_call[-1]} -> {url}\")\n        request = Request(\n            f\"/{url}\".encode(),\n            {\"host\": \"localhost\"},\n            \"v1\",\n            route_to_call[0],\n            None,\n            None,\n        )\n\n        result = benchmark.pedantic(\n            router.get,\n            (\n                request.path,\n                request.method,\n                request.headers.get(\"host\"),\n            ),\n            iterations=1000,\n            rounds=1000,\n        )\n        assert await result[1](None) == 1"
    },
    {
      "chunk_id": 1669,
      "source": "__internal__/data_repo/sanic/tests/http3/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 1670,
      "source": "__internal__/data_repo/sanic/tests/http3/test_session_ticket_store.py",
      "content": "from datetime import datetime\n\nfrom aioquic.tls import CipherSuite, SessionTicket\n\nfrom sanic.http.http3 import SessionTicketStore"
    },
    {
      "chunk_id": 1671,
      "source": "__internal__/data_repo/sanic/tests/http3/test_session_ticket_store.py",
      "content": "def _generate_ticket(label):\n    return SessionTicket(\n        1,\n        CipherSuite.AES_128_GCM_SHA256,\n        datetime.now(),\n        datetime.now(),\n        label,\n        label.decode(),\n        label,\n        None,\n        [],\n    )"
    },
    {
      "chunk_id": 1672,
      "source": "__internal__/data_repo/sanic/tests/http3/test_session_ticket_store.py",
      "content": "def test_session_ticket_store():\n    store = SessionTicketStore()\n\n    assert len(store.tickets) == 0\n\n    ticket1 = _generate_ticket(b\"foo\")\n    store.add(ticket1)\n\n    assert len(store.tickets) == 1\n\n    ticket2 = _generate_ticket(b\"bar\")\n    store.add(ticket2)\n\n    assert len(store.tickets) == 2\n    assert len(store.tickets) == 2\n\n    popped2 = store.pop(ticket2.ticket)\n\n    assert len(store.tickets) == 1\n    assert popped2 is ticket2\n\n    popped1 = store.pop(ticket1.ticket)\n\n    assert len(store.tickets) == 0\n    assert popped1 is ticket1"
    },
    {
      "chunk_id": 1673,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "from unittest.mock import Mock\n\nimport pytest\n\nfrom aioquic.h3.connection import H3Connection\nfrom aioquic.h3.events import DataReceived, HeadersReceived\nfrom aioquic.quic.configuration import QuicConfiguration\nfrom aioquic.quic.connection import QuicConnection\nfrom aioquic.quic.events import ProtocolNegotiated\n\nfrom sanic import Request, Sanic\nfrom sanic.compat import Header\nfrom sanic.config import DEFAULT_CONFIG\nfrom sanic.exceptions import BadRequest, PayloadTooLarge\nfrom sanic.http.constants import Stage\nfrom sanic.http.http3 import Http3, HTTPReceiver\nfrom sanic.models.server_types import ConnInfo\nfrom sanic.response import empty, json\nfrom sanic.server.protocols.http_protocol import Http3Protocol\n\n\ntry:\n    from unittest.mock import AsyncMock\nexcept ImportError:\n    from tests.asyncmock import AsyncMock  # type: ignore\n\npytestmark = pytest.mark.asyncio"
    },
    {
      "chunk_id": 1674,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "@pytest.fixture(autouse=True)\nasync def setup(app: Sanic):\n    @app.get(\"/\")\n    async def handler(*_):\n        return empty()\n\n    app.router.finalize()\n    app.signal_router.finalize()\n    app.signal_router.allow_fail_builtin = False"
    },
    {
      "chunk_id": 1675,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "@pytest.fixture\ndef http_request(app):\n    return Request(b\"/\", Header({}), \"3\", \"GET\", Mock(), app)"
    },
    {
      "chunk_id": 1676,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda: None\n    connection.datagrams_to_send = Mock(return_value=[])  # type: ignore\n    return Http3Protocol(\n        connection,\n        app=app,\n        stream_handler=None,\n    )"
    },
    {
      "chunk_id": 1677,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(\n        protocol.transmit,\n        protocol,\n        http_request,\n    )\n    http_request.stream = receiver\n    return receiver"
    },
    {
      "chunk_id": 1678,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_http_receiver_init(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    assert receiver.request_body is None\n    assert receiver.stage is Stage.IDLE\n    assert receiver.headers_sent is False\n    assert receiver.response is None\n    assert receiver.request_max_size == DEFAULT_CONFIG[\"REQUEST_MAX_SIZE\"]\n    assert receiver.request_bytes == 0"
    },
    {
      "chunk_id": 1679,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "async def test_http_receiver_run_request(app: Sanic, http_request: Request):\n    handler = AsyncMock()\n\n    class mock_handle(Sanic):\n        handle_request = handler\n\n    app.__class__ = mock_handle\n    receiver = generate_http_receiver(app, http_request)\n    receiver.protocol.quic_event_received(\n        ProtocolNegotiated(alpn_protocol=\"h3\")\n    )\n    await receiver.run()\n    handler.assert_awaited_once_with(receiver.request)"
    },
    {
      "chunk_id": 1680,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "async def test_http_receiver_run_exception(app: Sanic, http_request: Request):\n    handler = AsyncMock()\n\n    class mock_handle(Sanic):\n        handle_exception = handler\n\n    app.__class__ = mock_handle\n    receiver = generate_http_receiver(app, http_request)\n    receiver.protocol.quic_event_received(\n        ProtocolNegotiated(alpn_protocol=\"h3\")\n    )\n    exception = Exception(\"Oof\")\n    await receiver.run(exception)\n    handler.assert_awaited_once_with(receiver.request, exception)\n\n    handler.reset_mock()\n    receiver.stage = Stage.REQUEST\n    await receiver.run(exception)\n    handler.assert_awaited_once_with(receiver.request, exception)"
    },
    {
      "chunk_id": 1681,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_http_receiver_respond(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    response = empty()\n\n    receiver.stage = Stage.RESPONSE\n    with pytest.raises(RuntimeError, match=\"Response already started\"):\n        receiver.respond(response)\n\n    receiver.stage = Stage.HANDLER\n    receiver.response = Mock()\n    resp = receiver.respond(response)\n\n    assert receiver.response is resp\n    assert resp is response\n    assert response.stream is receiver"
    },
    {
      "chunk_id": 1682,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_http_receiver_receive_body(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    receiver.request_max_size = 4\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"..\"\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"....\"\n\n    with pytest.raises(\n        PayloadTooLarge, match=\"Request body exceeds the size limit\"\n    ):\n        receiver.receive_body(b\"..\")"
    },
    {
      "chunk_id": 1683,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_http3_events(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(DataReceived(b\"foobar\", 1, False))\n    receiver = http3.receivers[1]\n\n    assert len(http3.receivers) == 1\n    assert receiver.request.stream_id == 1\n    assert receiver.request.path == \"/location\"\n    assert receiver.request.method == \"GET\"\n    assert receiver.request.headers[\"foo\"] == \"bar\"\n    assert receiver.request.body == b\"foobar\""
    },
    {
      "chunk_id": 1684,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "async def test_send_headers(app: Sanic, http_request: Request):\n    send_headers_mock = Mock()\n    existing_send_headers = H3Connection.send_headers\n    receiver = generate_http_receiver(app, http_request)\n    receiver.protocol.quic_event_received(\n        ProtocolNegotiated(alpn_protocol=\"h3\")\n    )\n\n    http_request._protocol = receiver.protocol\n\n    def send_headers(*args, **kwargs):\n        send_headers_mock(*args, **kwargs)\n        return existing_send_headers(\n            receiver.protocol.connection, *args, **kwargs\n        )\n\n    receiver.protocol.connection.send_headers = send_headers\n    receiver.head_only = False\n    response = json({}, status=201, headers={\"foo\": \"bar\"})\n\n    with pytest.raises(RuntimeError, match=\"no response\"):\n        receiver.send_headers()\n\n    receiver.response = response\n    receiver.send_headers()\n\n    assert receiver.headers_sent\n    assert receiver.stage is Stage.RESPONSE\n    send_headers_mock.assert_called_once_with(\n        stream_id=0,\n        headers=[\n            (b\":status\", b\"201\"),\n            (b\"foo\", b\"bar\"),\n            (b\"content-length\", b\"2\"),\n            (b\"content-type\", b\"application/json\"),\n        ],\n    )"
    },
    {
      "chunk_id": 1685,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_multiple_streams(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            2,\n            False,\n        )\n    )\n\n    receiver1 = http3.get_receiver_by_stream_id(1)\n    receiver2 = http3.get_receiver_by_stream_id(2)\n    assert len(http3.receivers) == 2\n    assert isinstance(receiver1, HTTPReceiver)\n    assert isinstance(receiver2, HTTPReceiver)\n    assert receiver1 is not receiver2"
    },
    {
      "chunk_id": 1686,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_request_stream_id(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request, Request)\n    assert receiver.request.stream_id == 1"
    },
    {
      "chunk_id": 1687,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_request_conn_info(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request.conn_info, ConnInfo)"
    },
    {
      "chunk_id": 1688,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_request_header_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (\"foo\\u00a0\".encode(), b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert (\n        str(exc_info.value)\n        == \"Header names may only contain US-ASCII characters.\"\n    )"
    },
    {
      "chunk_id": 1689,
      "source": "__internal__/data_repo/sanic/tests/http3/test_http_receiver.py",
      "content": "def test_request_url_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\\xa0\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (b\"foo\", b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert str(exc_info.value) == \"URL may only contain US-ASCII characters.\""
    },
    {
      "chunk_id": 1690,
      "source": "__internal__/data_repo/sanic/tests/http3/test_server.py",
      "content": "import logging\n\nfrom asyncio import Event\nfrom pathlib import Path\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.http.constants import HTTP"
    },
    {
      "chunk_id": 1691,
      "source": "__internal__/data_repo/sanic/tests/http3/test_server.py",
      "content": "parent_dir = Path(__file__).parent.parent\nlocalhost_dir = parent_dir / \"certs/localhost\""
    },
    {
      "chunk_id": 1692,
      "source": "__internal__/data_repo/sanic/tests/http3/test_server.py",
      "content": "@pytest.mark.parametrize(\"version\", (3, HTTP.VERSION_3))\ndef test_server_starts_http3(app: Sanic, version, caplog):\n    ev = Event()\n\n    @app.after_server_start\n    def shutdown(*_):\n        ev.set()\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(\n            version=version,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n            single_process=True,\n        )\n\n    assert ev.is_set()\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples"
    },
    {
      "chunk_id": 1693,
      "source": "__internal__/data_repo/sanic/tests/http3/test_server.py",
      "content": "def test_server_starts_http1_and_http3(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=3,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    with caplog.at_level(logging.INFO):\n        Sanic.serve_single()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/1.1\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples"
    },
    {
      "chunk_id": 1694,
      "source": "__internal__/data_repo/sanic/tests/http3/test_server.py",
      "content": "def test_server_starts_http1_and_http3_bad_order(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    message = (\n        \"Serving HTTP/3 instances as a secondary server is not supported. \"\n        \"There can only be a single HTTP/3 worker and it must be the first \"\n        \"instance prepared.\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.prepare(\n            version=3,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n        )"
    },
    {
      "chunk_id": 1695,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/http_response.py",
      "content": "import inspect\nimport os\nimport sys\nimport timeit\n\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1696,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/http_response.py",
      "content": "currentdir = os.path.dirname(\n    os.path.abspath(inspect.getfile(inspect.currentframe()))\n)\nsys.path.insert(0, currentdir + \"/../../../\")"
    },
    {
      "chunk_id": 1697,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/http_response.py",
      "content": "print(json({\"test\": True}).output())"
    },
    {
      "chunk_id": 1698,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/http_response.py",
      "content": "print(\"Running New 100,000 times\")\ntimes = 0\ntotal_time = 0\nfor n in range(6):\n    time = timeit.timeit(\n        'json({ \"test\":True }).output()',\n        setup=\"from sanic.response import json\",\n        number=100000,\n    )\n    print(f\"Took {time} seconds\")\n    total_time += time\n    times += 1\nprint(f\"Average: {total_time / times}\")"
    },
    {
      "chunk_id": 1699,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/http_response.py",
      "content": "print(\"Running Old 100,000 times\")\ntimes = 0\ntotal_time = 0\nfor n in range(6):\n    time = timeit.timeit(\n        'json({ \"test\":True }).output_old()',\n        setup=\"from sanic.response import json\",\n        number=100000,\n    )\n    print(f\"Took {time} seconds\")\n    total_time += time\n    times += 1\nprint(f\"Average: {total_time / times}\")"
    },
    {
      "chunk_id": 1700,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "import inspect\nimport os\nimport sys\n\nfrom sanic import Sanic\nfrom sanic.exceptions import ServerError\nfrom sanic.response import json, text"
    },
    {
      "chunk_id": 1701,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "currentdir = os.path.dirname(\n    os.path.abspath(inspect.getfile(inspect.currentframe()))\n)\nsys.path.insert(0, currentdir + \"/../../../\")"
    },
    {
      "chunk_id": 1702,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "app = Sanic(\"test\")"
    },
    {
      "chunk_id": 1703,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    return json({\"test\": True})"
    },
    {
      "chunk_id": 1704,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/sync\", methods=[\"GET\", \"POST\"])\ndef test_json_response(request):\n    return json({\"test\": True})"
    },
    {
      "chunk_id": 1705,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/text/<name>/<butt:int>\")\ndef rtext(request, name, butt):\n    return text(f\"yeehaww {name} {butt}\")"
    },
    {
      "chunk_id": 1706,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/exception\")\ndef exception(request):\n    raise ServerError(\"yep\")"
    },
    {
      "chunk_id": 1707,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/exception/async\")\nasync def test_server_error(request):\n    raise ServerError(\"asunk\")"
    },
    {
      "chunk_id": 1708,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/post_json\")\ndef post_json(request):\n    return json({\"received\": True, \"message\": request.json})"
    },
    {
      "chunk_id": 1709,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "@app.route(\"/query_string\")\ndef query_string(request):\n    return json(\n        {\n            \"parsed\": True,\n            \"args\": request.args,\n            \"url\": request.url,\n            \"query_string\": request.query_string,\n        }\n    )"
    },
    {
      "chunk_id": 1710,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "app.run(host=\"0.0.0.0\", port=sys.argv[1])"
    },
    {
      "chunk_id": 1711,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "# import asyncio_redis\n# import asyncpg\n# async def setup(sanic, loop):\n#     sanic.conn = []\n#     sanic.redis = []\n#     for x in range(10):\n#         sanic.conn.append(await asyncpg.connect(\n#           user='postgres',\n#           password='zomgdev',\n#           database='postgres',\n#           host='192.168.99.100'\n#         ))\n#     for n in range(30):\n#         connection = await asyncio_redis.Connection.create(\n#           host='192.168.99.100', port=6379\n#         )\n#         sanic.redis.append(connection)"
    },
    {
      "chunk_id": 1712,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "# c=0\n# @app.route(\"/postgres\")\n# async def postgres(request):\n#     global c\n#     values = await app.conn[c].fetch('''SELECT * FROM players''')\n#     c += 1\n#     if c == 10:\n#         c = 0\n#     return text(\"yep\")"
    },
    {
      "chunk_id": 1713,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/varied_server.py",
      "content": "# r=0\n# @app.route(\"/redis\")\n# async def redis(request):\n#     global r\n#     try:\n#         values = await app.redis[r].get('my_key')\n#     except asyncio_redis.exceptions.ConnectionLostError:\n#         app.redis[r] = await asyncio_redis.Connection.create(\n#           host='127.0.0.1', port=6379\n#         )\n#         values = await app.redis[r].get('my_key')\n\n#     r += 1\n#     if r == 30:\n#         r = 0\n#     return text(values)"
    },
    {
      "chunk_id": 1714,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/simple_server.py",
      "content": "import inspect\nimport os\nimport sys\n\nfrom sanic import Sanic\nfrom sanic.response import json"
    },
    {
      "chunk_id": 1715,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/simple_server.py",
      "content": "currentdir = os.path.dirname(\n    os.path.abspath(inspect.getfile(inspect.currentframe())))\n)\nsys.path.insert(0, currentdir + \"/../../../\")"
    },
    {
      "chunk_id": 1716,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/simple_server.py",
      "content": "app = Sanic(\"test\")"
    },
    {
      "chunk_id": 1717,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/simple_server.py",
      "content": "@app.route(\"/\")\nasync def test(request):\n    return json({\"test\": True})"
    },
    {
      "chunk_id": 1718,
      "source": "__internal__/data_repo/sanic/tests/performance/sanic/simple_server.py",
      "content": "if __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=sys.argv[1])"
    },
    {
      "chunk_id": 1719,
      "source": "__internal__/data_repo/sanic/tests/worker/test_restarter.py",
      "content": "from unittest.mock import Mock\n\nimport pytest\n\nfrom sanic.worker.constants import ProcessState, RestartOrder\nfrom sanic.worker.process import WorkerProcess\nfrom sanic.worker.restarter import Restarter"
    },
    {
      "chunk_id": 1720,
      "source": "__internal__/data_repo/sanic/tests/worker/test_restarter.py",
      "content": "def noop(*args, **kwargs):\n    pass"
    },
    {
      "chunk_id": 1721,
      "source": "__internal__/data_repo/sanic/tests/worker/test_restarter.py",
      "content": "def make_worker_process(\n    name: str, state: ProcessState = ProcessState.STARTED\n) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
    },
    {
      "chunk_id": 1722,
      "source": "__internal__/data_repo/sanic/tests/worker/test_restarter.py",
      "content": "def test_restart_transient():\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable])\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.SHUTDOWN_FIRST\n    )\n    durable.restart.assert_not_called()\n    transient.restart.reset_mock()\n    restarter.restart(\n        [transient], [durable], restart_order=RestartOrder.STARTUP_FIRST\n    )\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.STARTUP_FIRST\n    )"
    },
    {
      "chunk_id": 1723,
      "source": "__internal__/data_repo/sanic/tests/worker/test_restarter.py",
      "content": "@pytest.mark.parametrize(\n    \"state,called\",\n    (\n        (ProcessState.IDLE, False),\n        (ProcessState.RESTARTING, False),\n        (ProcessState.STARTING, False),\n        (ProcessState.STARTED, False),\n        (ProcessState.ACKED, False),\n        (ProcessState.JOINED, False),\n        (ProcessState.TERMINATED, False),\n        (ProcessState.FAILED, True),\n        (ProcessState.COMPLETED, True),\n        (ProcessState.NONE, True),\n    ),\n)\ndef test_restart_durable(caplog, state, called):\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    durable.restart.assert_not_called()\n\n    assert (\n        \"sanic.error\",\n        40,\n        \"Cannot restart process Durable because it is not in a \"\n        \"final state. Current state is: STARTED.\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.error\",\n        40,\n        \"Failed to restart processes: Durable\",\n    ) in caplog.record_tuples\n\n    durable.state = state\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    if called:\n        durable.restart.assert_called_once_with(\n            restart_order=RestartOrder.SHUTDOWN_FIRST\n        )\n    else:\n        durable.restart.assert_not_called()"
    },
    {
      "chunk_id": 1724,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "```python"
    },
    {
      "chunk_id": 1725,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "from logging import ERROR, INFO\nfrom signal import SIGINT\nfrom unittest.mock import Mock, call, patch\n\nimport pytest\n\nfrom sanic.compat import OS_IS_WINDOWS\nfrom sanic.exceptions import ServerKilled\nfrom sanic.worker.constants import RestartOrder\nfrom sanic.worker.manager import WorkerManager\nfrom sanic.worker.process import Worker\n\n\nif not OS_IS_WINDOWS:\n    from signal import SIGKILL\nelse:\n    SIGKILL = SIGINT"
    },
    {
      "chunk_id": 1726,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def fake_serve(): ..."
    },
    {
      "chunk_id": 1727,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@pytest.fixture\ndef manager() -> WorkerManager:\n    p1 = Mock()\n    p1.pid = 1234\n    context = Mock()\n    context.Process.return_value = p1\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n    return manager"
    },
    {
      "chunk_id": 1728,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manager_no_workers():\n    message = \"Cannot serve with no workers\"\n    with pytest.raises(RuntimeError, match=message):\n        WorkerManager(0, fake_serve, {}, Mock(), (Mock(), Mock()), {})"
    },
    {
      "chunk_id": 1729,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@patch(\"sanic.worker.process.os\")\ndef test_terminate(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.terminate()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)"
    },
    {
      "chunk_id": 1730,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@patch(\"sanic.worker.process.os\")\ndef test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)"
    },
    {
      "chunk_id": 1731,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@patch(\"sanic.worker.manager.os\")\ndef test_kill(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    os_mock.getpgid.return_value = 5678\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    with pytest.raises(ServerKilled):\n        manager.kill()\n    os_mock.getpgid.assert_called_once_with(1234)\n    os_mock.killpg.assert_called_once_with(5678, SIGKILL)"
    },
    {
      "chunk_id": 1732,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@patch(\"sanic.worker.process.os\")\n@patch(\"sanic.worker.manager.os\")\ndef test_shutdown_signal_send_kill(\n    manager_os_mock: Mock, process_os_mock: Mock\n):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager_os_mock.getpgid.return_value = 5678\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert manager._shutting_down is False\n    manager.shutdown_signal(SIGINT, None)\n    assert manager._shutting_down is True\n    process_os_mock.kill.assert_called_once_with(1234, SIGINT)\n    manager.shutdown_signal(SIGINT, None)\n    manager_os_mock.getpgid.assert_called_once_with(1234)\n    manager_os_mock.killpg.assert_called_once_with(5678, SIGKILL)"
    },
    {
      "chunk_id": 1733,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_restart_all():\n    p1 = Mock()\n    p2 = Mock()\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert len(list(manager.transient_processes))\n    manager.restart()\n    p1.terminate.assert_called_once()\n    p2.terminate.assert_called_once()\n    context.Process.assert_has_calls(\n        [\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n        ]\n    )"
    },
    {
      "chunk_id": 1734,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@pytest.mark.parametrize(\"zero_downtime\", (False, True))\ndef test_monitor_all(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__::STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"\",\n        restart_order=restart_order,\n    )"
    },
    {
      "chunk_id": 1735,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@pytest.mark.parametrize(\"zero_downtime\", (False, True))\ndef test_monitor_all_with_files(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )"
    },
    {
      "chunk_id": 1736,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "@pytest.mark.parametrize(\"zero_downtime\", (False, True))\ndef test_monitor_one_process(zero_downtime):\n    p1 = Mock()\n    p1.name = \"Testing\"\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        f\"{p1.name}:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else f\"{p1.name}:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=[p1.name],\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )"
    },
    {
      "chunk_id": 1737,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_shutdown_signal():\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, Mock(), (pub, Mock()), {})\n    manager.shutdown = Mock()  # type: ignore\n\n    manager.shutdown_signal(SIGINT, None)\n    pub.send.assert_called_with(None)\n    manager.shutdown.assert_called_once_with()"
    },
    {
      "chunk_id": 1738,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_shutdown_servers(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    context = Mock()\n    context.Process.side_effect = [p1]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with caplog.at_level(ERROR):\n            manager.shutdown_server()\n\n            kill.assert_called_once_with(1234, SIGINT)\n            kill.reset_mock()\n\n            assert not caplog.record_tuples\n\n            manager.shutdown_server()\n\n            kill.assert_not_called()\n\n            assert (\n                \"sanic.error\",\n                ERROR,\n                \"Server shutdown failed because a server was not found.\",\n            ) in caplog.record_tuples"
    },
    {
      "chunk_id": 1739,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_shutdown_servers_named():\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 6543\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    pub = Mock()\n    manager = WorkerManager(2, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with pytest.raises(KeyError):\n            manager.shutdown_server(\"foo\")\n        manager.shutdown_server(\"Server-1\")\n\n        kill.assert_called_once_with(6543, SIGINT)"
    },
    {
      "chunk_id": 1740,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_scale(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 3456\n    p3 = Mock()\n    p3.pid = 5678\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p3]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    assert len(manager.transient) == 1\n\n    manager.scale(3)\n    assert len(manager.transient) == 3\n\n    with patch(\"os.kill\") as kill:\n        manager.scale(2)\n        assert len(manager.transient) == 2\n\n        manager.scale(1)\n        assert len(manager.transient) == 1\n\n        kill.call_count == 2\n\n    with caplog.at_level(INFO):\n        manager.scale(1)\n\n    assert (\n        \"sanic.root\",\n        INFO,\n        \"No change needed. There are already 1 workers.\",\n    ) in caplog.record_tuples\n\n    with pytest.raises(ValueError, match=r\"Cannot scale to 0 workers\\.\"):\n        manager.scale(0)"
    },
    {
      "chunk_id": 1741,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manage_basic(manager: WorkerManager):\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.server_settings == {\"foo\": \"bar\"}\n    assert worker_process.restartable is False\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 1"
    },
    {
      "chunk_id": 1742,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manage_transient(manager: WorkerManager):\n    manager.manage(\n        \"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, workers=3, transient=True\n    )\n    assert len(manager.transient) == 2\n    assert len(manager.durable) == 0\n\n    worker_process = manager.transient[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 3"
    },
    {
      "chunk_id": 1743,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manage_restartable(manager: WorkerManager):\n    manager.manage(\n        \"TEST\",\n        fake_serve,\n        kwargs={\"foo\": \"bar\"},\n        restartable=True,\n        auto_start=False,\n    )\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is False"
    },
    {
      "chunk_id": 1744,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manage_untracked(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, tracked=False)\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is False\n    assert worker_process.tracked is False\n    assert worker_process.auto_start is True"
    },
    {
      "chunk_id": 1745,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_manage_duplicate_ident(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    message = \"Worker TEST already exists\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})"
    },
    {
      "chunk_id": 1746,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_transient_not_restartable(manager: WorkerManager):\n    message = \"Cannot create a transient worker that is not restartable\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\n            \"TEST\",\n            fake_serve,\n            kwargs={\"foo\": \"bar\"},\n            transient=True,\n            restartable=False,\n        )"
    },
    {
      "chunk_id": 1747,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_remove_worker(manager: WorkerManager, caplog):\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={})\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST is tracked and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples"
    },
    {
      "chunk_id": 1748,
      "source": "__internal__/data_repo/sanic/tests/worker/test_manager.py",
      "content": "def test_remove_untracked_worker(manager: WorkerManager, caplog):\n    caplog.set_level(20)\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={}, tracked=False)\n    worker.has_alive_processes = Mock(return_value=True)\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST has alive processes and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples\n\n    worker.has_alive_processes = Mock(return_value=False)\n    manager.remove_worker(worker)\n    message = \"Removed worker TEST\"\n\n    assert \"Sanic-TEST-0\" not in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    assert (\"sanic.root\", 20, message) in caplog.record_tuples\n```"
    },
    {
      "chunk_id": 1749,
      "source": "__internal__/data_repo/sanic/tests/worker/test_startup.py",
      "content": "import sys\n\nfrom multiprocessing import set_start_method\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom sanic import Sanic"
    },
    {
      "chunk_id": 1750,
      "source": "__internal__/data_repo/sanic/tests/worker/test_startup.py",
      "content": "@pytest.mark.parametrize(\n    \"start_method,platform,expected\",\n    (\n        (None, \"linux\", \"spawn\"),\n        (None, \"other\", \"spawn\"),\n        (\"fork\", \"linux\", \"fork\"),\n        (\"fork\", \"other\", \"fork\"),\n        (\"forkserver\", \"linux\", \"forkserver\"),\n        (\"forkserver\", \"other\", \"forkserver\"),\n        (\"spawn\", \"linux\", \"spawn\"),\n        (\"spawn\", \"other\", \"spawn\"),\n    ),\n)\ndef test_get_context(start_method, platform, expected):\n    if start_method:\n        Sanic.start_method = start_method\n    with patch(\"sys.platform\", platform):\n        assert Sanic._get_startup_method() == expected"
    },
    {
      "chunk_id": 1751,
      "source": "__internal__/data_repo/sanic/tests/worker/test_startup.py",
      "content": "@pytest.mark.skipif(\n    not sys.platform.startswith(\"linux\"), reason=\"Only test on Linux\"\n)\ndef test_set_startup_catch():\n    Sanic.START_METHOD_SET = False\n    set_start_method(\"fork\", force=True)\n    Sanic.test_mode = False\n    message = (\n        \"Start method 'spawn' was requested, but 'fork' was already set.\\n\"\n        \"For more information, see: https://sanic.dev/en/guide/running/manager.html#overcoming-a-coderuntimeerrorcode\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        Sanic._set_startup_method()\n    Sanic.test_mode = True"
    },
    {
      "chunk_id": 1752,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "import sys\n\nfrom os import getcwd\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom sanic.app import Sanic\nfrom sanic.worker.loader import AppLoader, CertLoader\n\n\nSTATIC = Path.cwd() / \"tests\" / \"static\""
    },
    {
      "chunk_id": 1753,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "@pytest.mark.parametrize(\n    \"module_input\", (\"tests.fake.server:app\", \"tests.fake.server.app\")\n)\ndef test_load_app_instance(module_input):\n    loader = AppLoader(module_input)\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1754,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "@pytest.mark.parametrize(\n    \"module_input\",\n    (\"tests.fake.server:create_app\", \"tests.fake.server:create_app()\"),\n)\ndef test_load_app_factory(module_input):\n    loader = AppLoader(module_input, as_factory=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1755,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_load_app_simple():\n    loader = AppLoader(str(STATIC), as_simple=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1756,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_create_with_factory():\n    loader = AppLoader(factory=lambda: Sanic(\"Test\"))\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1757,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_cwd_in_path():\n    AppLoader(\"tests.fake.server:app\").load()\n    assert getcwd() in sys.path"
    },
    {
      "chunk_id": 1758,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_input_is_dir():\n    loader = AppLoader(str(STATIC))\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1759,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_input_is_factory():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server:create_app\", args=ns)\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1760,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "def test_input_is_module():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server\", args=ns)\n\n    app = loader.load()\n    assert isinstance(app, Sanic)"
    },
    {
      "chunk_id": 1761,
      "source": "__internal__/data_repo/sanic/tests/worker/test_loader.py",
      "content": "@pytest.mark.parametrize(\"creator\", (\"mkcert\", \"trustme\"))\n@patch(\"sanic.worker.loader.TrustmeCreator\")\n@patch(\"sanic.worker.loader.MkcertCreator\")\ndef test_cert_loader(MkcertCreator: Mock, TrustmeCreator: Mock, creator: str):\n    CertLoader._creators = {\n        \"mkcert\": MkcertCreator,\n        \"trustme\": TrustmeCreator,\n    }\n    MkcertCreator.return_value = MkcertCreator\n    TrustmeCreator.return_value = TrustmeCreator\n    data = {\n        \"creator\": creator,\n        \"key\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"privkey.pem\",\n        \"cert\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"fullchain.pem\",\n        \"localhost\": \"localhost\",\n    }\n    app = Sanic(\"Test\")\n    loader = CertLoader(data)  # type: ignore\n    loader.load(app)\n    creator_class = MkcertCreator if creator == \"mkcert\" else TrustmeCreator\n    creator_class.assert_called_once_with(app, data[\"key\"], data[\"cert\"])\n    creator_class.generate_cert.assert_called_once_with(\"localhost\")"
    },
    {
      "chunk_id": 1762,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "try:  # no cov\n    from ujson import dumps\nexcept ModuleNotFoundError:  # no cov\n    from json import dumps  # type: ignore\n\nfrom datetime import datetime\nfrom unittest.mock import Mock, patch\nfrom urllib.error import URLError\n\nimport pytest\n\nfrom sanic_testing import TestManager\n\nfrom sanic.cli.inspector_client import InspectorClient\nfrom sanic.helpers import Default\nfrom sanic.log import Colors\nfrom sanic.worker.inspector import Inspector"
    },
    {
      "chunk_id": 1763,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "DATA = {\n    \"info\": {\n        \"packages\": [\"foo\"],\n    },\n    \"extra\": {\n        \"more\": \"data\",\n    },\n    \"workers\": {\"Worker-Name\": {\"some\": \"state\"}},\n}\nFULL_SERIALIZED = dumps({\"result\": DATA})\nOUT_SERIALIZED = dumps(DATA)"
    },
    {
      "chunk_id": 1764,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "class FooInspector(Inspector):\n    async def foo(self, bar):\n        return f\"bar is {bar}\""
    },
    {
      "chunk_id": 1765,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "@pytest.fixture\ndef publisher():\n    publisher = Mock()\n    return publisher"
    },
    {
      "chunk_id": 1766,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "@pytest.fixture\ndef inspector(publisher):\n    inspector = FooInspector(\n        publisher, {}, {}, \"localhost\", 9999, \"\", Default(), Default()\n    )\n    inspector(False)\n    return inspector"
    },
    {
      "chunk_id": 1767,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "@pytest.fixture\ndef http_client(inspector):\n    manager = TestManager(inspector.app)\n    return manager.test_client"
    },
    {
      "chunk_id": 1768,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "@pytest.mark.parametrize(\"command\", (\"info\",))\n@patch(\"sanic.cli.inspector_client.sys.stdout.write\")\ndef test_send_inspect(write, urlopen, command: str):\n    urlopen.read.return_value = FULL_SERIALIZED.encode()\n    InspectorClient(\"localhost\", 9999, False, False, None).do(command)\n    write.assert_called()\n    write.reset_mock()\n    InspectorClient(\"localhost\", 9999, False, True, None).do(command)\n    write.assert_called_with(OUT_SERIALIZED + \"\\n\")"
    },
    {
      "chunk_id": 1769,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "@patch(\"sanic.cli.inspector_client.sys\")\ndef test_send_inspect_conn_refused(sys: Mock, urlopen):\n    urlopen.side_effect = URLError(\"\")\n    InspectorClient(\"localhost\", 9999, False, False, None).do(\"info\")\n\n    message = (\n        f\"{Colors.RED}Could not connect to inspector at: \"\n        f\"{Colors.YELLOW}http://localhost:9999{Colors.END}\\n\"\n        \"Either the application is not running, or it did not start \"\n        \"an inspector instance.\\n<urlopen error >\\n\"\n    )\n    sys.exit.assert_called_once_with(1)\n    sys.stderr.write.assert_called_once_with(message)"
    },
    {
      "chunk_id": 1770,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_reload(publisher, http_client):\n    _, response = http_client.post(\"/reload\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:\")"
    },
    {
      "chunk_id": 1771,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_reload_zero_downtime(publisher, http_client):\n    _, response = http_client.post(\"/reload\", json={\"zero_downtime\": True})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__::STARTUP_FIRST\")"
    },
    {
      "chunk_id": 1772,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_shutdown(publisher, http_client):\n    _, response = http_client.post(\"/shutdown\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__TERMINATE__\")"
    },
    {
      "chunk_id": 1773,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_scale(publisher, http_client):\n    _, response = http_client.post(\"/scale\", json={\"replicas\": 4})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__SCALE__:4\")"
    },
    {
      "chunk_id": 1774,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_arbitrary(http_client):\n    _, response = http_client.post(\"/foo\", json={\"bar\": 99})\n    assert response.status == 200\n    assert response.json == {\"meta\": {\"action\": \"foo\"}, \"result\": \"bar is 99\"}"
    },
    {
      "chunk_id": 1775,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_state_to_json():\n    now = datetime.now()\n    now_iso = now.isoformat()\n    app_info = {\"app\": \"hello\"}\n    worker_state = {\"Test\": {\"now\": now, \"nested\": {\"foo\": now}}}\n    inspector = Inspector(\n        Mock(), app_info, worker_state, \"\", 0, \"\", Default(), Default()\n    )\n    state = inspector._state_to_json()\n\n    assert state == {\n        \"info\": app_info,\n        \"workers\": {\"Test\": {\"now\": now_iso, \"nested\": {\"foo\": now_iso}}},\n    }"
    },
    {
      "chunk_id": 1776,
      "source": "__internal__/data_repo/sanic/tests/worker/test_inspector.py",
      "content": "def test_run_inspector_authentication():\n    inspector = Inspector(\n        Mock(), {}, {}, \"\", 0, \"super-secret\", Default(), Default()\n    )(False)\n    manager = TestManager(inspector.app)\n    _, response = manager.test_client.get(\"/\")\n    assert response.status == 401\n    _, response = manager.test_client.get(\n        \"/\", headers={\"Authorization\": \"Bearer super-secret\"}\n    )\n    assert response.status == 200"
    },
    {
      "chunk_id": 1777,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "import re\nimport signal\nimport threading\n\nfrom asyncio import Event\nfrom logging import DEBUG\nfrom pathlib import Path\nfrom time import sleep\nfrom unittest.mock import Mock\n\nimport pytest\n\nfrom sanic.app import Sanic\nfrom sanic.worker.constants import ProcessState, RestartOrder\nfrom sanic.worker.loader import AppLoader\nfrom sanic.worker.process import WorkerProcess\nfrom sanic.worker.reloader import Reloader"
    },
    {
      "chunk_id": 1778,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "@pytest.fixture\ndef reloader(): ..."
    },
    {
      "chunk_id": 1779,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "@pytest.fixture\ndef app():\n    app = Sanic(\"Test\")\n\n    @app.route(\"/\")\n    def handler(_): ...\n\n    return app"
    },
    {
      "chunk_id": 1780,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "@pytest.fixture\ndef app_loader(app):\n    return AppLoader(factory=lambda: app)"
    },
    {
      "chunk_id": 1781,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def run_reloader(reloader):\n    def stop(*_):\n        reloader.stop()\n\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
    },
    {
      "chunk_id": 1782,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def is_python_file(filename):\n    return (isinstance(filename, Path) and (filename.suffix == \"py\")) or (\n        isinstance(filename, str) and filename.endswith(\".py\")\n    )"
    },
    {
      "chunk_id": 1783,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_reload_send():\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, set(), Mock())\n    reloader.reload(\"foobar\")\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:foobar\")"
    },
    {
      "chunk_id": 1784,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_iter_files():\n    reloader = Reloader(Mock(), 0.1, set(), Mock())\n    len_python_files = len(list(reloader.files()))\n    assert len_python_files > 0\n\n    static_dir = Path(__file__).parent.parent / \"static\"\n    len_static_files = len(list(static_dir.glob(\"**/*\")))\n    reloader = Reloader(Mock(), 0.1, set({static_dir}), Mock())\n    len_total_files = len(list(reloader.files()))\n    assert len_static_files > 0\n    assert len_total_files == len_python_files + len_static_files"
    },
    {
      "chunk_id": 1785,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "@pytest.mark.parametrize(\n    \"order,expected\",\n    (\n        (\n            RestartOrder.SHUTDOWN_FIRST,\n            [\n                \"Restarting a process\",\n                \"Begin restart termination\",\n                \"Starting a process\",\n            ],\n        ),\n        (\n            RestartOrder.STARTUP_FIRST,\n            [\n                \"Restarting a process\",\n                \"Starting a process\",\n                \"Begin restart termination\",\n                \"Waiting for process to be acked\",\n                \"Process acked. Terminating\",\n            ],\n        ),\n    ),\n)\ndef test_default_reload_shutdown_order(monkeypatch, caplog, order, expected):\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        worker_process.set_state(ProcessState.ACKED)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    with caplog.at_level(DEBUG):\n        worker_process.restart(restart_order=order)\n\n    ansi = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\n    def clean(msg: str):\n        msg, _ = ansi.sub(\"\", msg).split(\":\", 1)\n        return msg\n\n    debug = [clean(record[2]) for record in caplog.record_tuples]\n    assert debug == expected\n    current_process.start.assert_called_once()\n    current_process.terminate.assert_called_once()\n    monkeypatch.setattr(threading.Thread, \"start\", orig)"
    },
    {
      "chunk_id": 1786,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_reload_delayed(monkeypatch):\n    WorkerProcess.THRESHOLD = 1\n\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        sleep(0.2)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    message = \"Worker Test failed to come ack within 0.1 seconds\"\n    with pytest.raises(TimeoutError, match=message):\n        worker_process.restart(restart_order=RestartOrder.STARTUP_FIRST)\n\n    monkeypatch.setattr(threading.Thread, \"start\", orig)"
    },
    {
      "chunk_id": 1787,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]"
    },
    {
      "chunk_id": 1788,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()"
    },
    {
      "chunk_id": 1789,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg"
    },
    {
      "chunk_id": 1790,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())"
    },
    {
      "chunk_id": 1791,
      "source": "__internal__/data_repo/sanic/tests/worker/test_reloader.py",
      "content": "def test_check_file(tmp_path):\n    current = tmp_path / \"testing.txt\"\n    current.touch()\n    mtimes = {}\n    assert Reloader.check_file(current, mtimes) is False\n    assert len(mtimes) == 1\n    assert Reloader.check_file(current, mtimes) is False\n    mtimes[current] = mtimes[current] - 1\n    assert Reloader.check_file(current, mtimes) is True"
    },
    {
      "chunk_id": 1792,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "import pytest\n\nfrom sanic.worker.state import WorkerState"
    },
    {
      "chunk_id": 1793,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def gen_state(**kwargs):\n    return WorkerState({\"foo\": kwargs}, \"foo\")"
    },
    {
      "chunk_id": 1794,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_set_get_state():\n    state = gen_state()\n    state[\"additional\"] = 123\n    assert state[\"additional\"] == 123\n    assert state.get(\"additional\") == 123\n    assert state._state == {\"foo\": {\"additional\": 123}}"
    },
    {
      "chunk_id": 1795,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_del_state():\n    state = gen_state(one=1)\n    assert state[\"one\"] == 1\n    del state[\"one\"]\n    assert state._state == {\"foo\": {}}"
    },
    {
      "chunk_id": 1796,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_iter_state():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert result == [\"one\", \"two\"]"
    },
    {
      "chunk_id": 1797,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_len():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert len(result) == 2"
    },
    {
      "chunk_id": 1798,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_repr():\n    assert repr(gen_state(one=1, two=2)) == repr({\"one\": 1, \"two\": 2})"
    },
    {
      "chunk_id": 1799,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_eq():\n    state = gen_state(one=1, two=2)\n    assert state == {\"one\": 1, \"two\": 2}\n    assert state != {\"one\": 1}"
    },
    {
      "chunk_id": 1800,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_keys():\n    assert list(gen_state(one=1, two=2).keys()) == list(\n        {\"one\": 1, \"two\": 2}.keys()\n    )"
    },
    {
      "chunk_id": 1801,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_values():\n    assert list(gen_state(one=1, two=2).values()) == list(\n        {\"one\": 1, \"two\": 2}.values()\n    )"
    },
    {
      "chunk_id": 1802,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_items():\n    assert list(gen_state(one=1, two=2).items()) == list(\n        {\"one\": 1, \"two\": 2}.items()\n    )"
    },
    {
      "chunk_id": 1803,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_update():\n    state = gen_state()\n    assert len(state) == 0\n    state.update({\"nine\": 9})\n    assert len(state) == 1\n    assert state[\"nine\"] == 9"
    },
    {
      "chunk_id": 1804,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_pop():\n    state = gen_state(one=1)\n    with pytest.raises(NotImplementedError):\n        state.pop()"
    },
    {
      "chunk_id": 1805,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "def test_state_full():\n    state = gen_state(one=1)\n    assert state.full() == {\"foo\": {\"one\": 1}}"
    },
    {
      "chunk_id": 1806,
      "source": "__internal__/data_repo/sanic/tests/worker/test_state.py",
      "content": "@pytest.mark.parametrize(\"key\", WorkerState.RESTRICTED)\ndef test_state_restricted_operation(key):\n    state = gen_state()\n    message = f\"Cannot set restricted key on WorkerState: {key}\"\n    with pytest.raises(LookupError, match=message):\n        state[key] = \"Nope\"\n        del state[key]\n\n    with pytest.raises(LookupError, match=message):\n        state.update({\"okay\": True, key: \"bad\"})"
    },
    {
      "chunk_id": 1807,
      "source": "__internal__/data_repo/sanic/tests/worker/test_runner.py",
      "content": "from unittest.mock import Mock, call, patch\n\nimport pytest\n\nfrom sanic.app import Sanic\nfrom sanic.http.constants import HTTP\nfrom sanic.server.runners import _run_server_forever, serve"
    },
    {
      "chunk_id": 1808,
      "source": "__internal__/data_repo/sanic/tests/worker/test_runner.py",
      "content": "@patch(\"sanic.server.runners._serve_http_1\")\n@patch(\"sanic.server.runners._serve_http_3\")\ndef test_run_http_1(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app)\n    _serve_http_3.assert_not_called()\n    _serve_http_1.assert_called_once()"
    },
    {
      "chunk_id": 1809,
      "source": "__internal__/data_repo/sanic/tests/worker/test_runner.py",
      "content": "@patch(\"sanic.server.runners._serve_http_1\")\n@patch(\"sanic.server.runners._serve_http_3\")\ndef test_run_http_3(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app, version=HTTP.VERSION_3)\n    _serve_http_1.assert_not_called()\n    _serve_http_3.assert_called_once()"
    },
    {
      "chunk_id": 1810,
      "source": "__internal__/data_repo/sanic/tests/worker/test_runner.py",
      "content": "@patch(\"sanic.server.runners.remove_unix_socket\")\n@pytest.mark.parametrize(\"do_cleanup\", (True, False))\ndef test_run_server_forever(remove_unix_socket: Mock, do_cleanup: bool):\n    loop = Mock()\n    cleanup = Mock()\n    loop.run_forever = Mock(side_effect=KeyboardInterrupt())\n    before_stop = Mock()\n    before_stop.return_value = Mock()\n    after_stop = Mock()\n    after_stop.return_value = Mock()\n    unix = Mock()\n\n    with pytest.raises(KeyboardInterrupt):\n        _run_server_forever(\n            loop,\n            before_stop,\n            after_stop,\n            cleanup if do_cleanup else None,\n            unix,\n        )\n\n    loop.run_forever.assert_called_once_with()\n    loop.run_until_complete.assert_has_calls(\n        [call(before_stop.return_value), call(after_stop.return_value)]\n    )\n\n    if do_cleanup:\n        cleanup.assert_called_once_with()\n    else:\n        cleanup.assert_not_called()\n\n    remove_unix_socket.assert_called_once_with(unix)\n    loop.close.assert_called_once_with()"
    },
    {
      "chunk_id": 1811,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "import logging\n\nfrom os import environ\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom sanic.app import Sanic\nfrom sanic.worker.loader import AppLoader\nfrom sanic.worker.multiplexer import WorkerMultiplexer\nfrom sanic.worker.process import Worker, WorkerProcess\nfrom sanic.worker.serve import worker_serve"
    },
    {
      "chunk_id": 1812,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@pytest.fixture\ndef mock_app():\n    app = Mock()\n    server_info = Mock()\n    server_info.settings = {\"app\": app}\n    app.state.workers = 1\n    app.listeners = {\"main_process_ready\": []}\n    app.get_motd_data.return_value = ({\"packages\": \"\"}, {})\n    app.state.server_info = [server_info]\n    return app"
    },
    {
      "chunk_id": 1813,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault(\"host\", \"127.0.0.1\")\n    params.setdefault(\"port\", 9999)\n    params.setdefault(\"app_name\", \"test_config_app\")\n    params.setdefault(\"monitor_publisher\", None)\n    params.setdefault(\"app_loader\", AppLoader(factory=lambda: app))\n    return params"
    },
    {
      "chunk_id": 1814,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "def test_config_app(mock_app: Mock):\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(**args(mock_app, config={\"FOO\": \"BAR\"}))\n    mock_app.update_config.assert_called_once_with({\"FOO\": \"BAR\"})"
    },
    {
      "chunk_id": 1815,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "def test_bad_process(mock_app: Mock, caplog):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    message = \"No restart publisher found in worker process\"\n    with pytest.raises(RuntimeError, match=message):\n        worker_serve(**args(mock_app))\n\n    message = \"No worker state found in worker process\"\n    publisher = Mock()\n    with caplog.at_level(logging.ERROR):\n        worker_serve(**args(mock_app, monitor_publisher=publisher))\n\n    assert (\"sanic.error\", logging.ERROR, message) in caplog.record_tuples\n    publisher.send.assert_called_once_with(\"__TERMINATE_EARLY__\")\n\n    del environ[\"SANIC_WORKER_NAME\"]"
    },
    {
      "chunk_id": 1816,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "def test_has_multiplexer(app: Sanic):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    Sanic.register_app(app)\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(\n            **args(app, monitor_publisher=Mock(), worker_state=Mock())\n        )\n    assert isinstance(app.multiplexer, WorkerMultiplexer)\n\n    del environ[\"SANIC_WORKER_NAME\"]"
    },
    {
      "chunk_id": 1817,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@patch(\"sanic.mixins.startup.WorkerManager\")\ndef test_serve_app_implicit(wm: Mock, app):\n    app.prepare()\n    Sanic.serve()\n    wm.call_args[0] == app.state.workers"
    },
    {
      "chunk_id": 1818,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@patch(\"sanic.mixins.startup.WorkerManager\")\ndef test_serve_app_explicit(wm: Mock, mock_app):\n    Sanic.serve(mock_app)\n    wm.call_args[0] == mock_app.state.workers"
    },
    {
      "chunk_id": 1819,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@patch(\"sanic.mixins.startup.WorkerManager\")\ndef test_serve_app_loader(wm: Mock, mock_app):\n    Sanic.serve(app_loader=AppLoader(factory=lambda: mock_app))\n    wm.call_args[0] == mock_app.state.workers"
    },
    {
      "chunk_id": 1820,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@patch(\"sanic.mixins.startup.WorkerManager\")\ndef test_serve_app_factory(wm: Mock, mock_app):\n    Sanic.serve(factory=lambda: mock_app)\n    wm.call_args[0] == mock_app.state.workers"
    },
    {
      "chunk_id": 1821,
      "source": "__internal__/data_repo/sanic/tests/worker/test_worker_serve.py",
      "content": "@patch(\"sanic.mixins.startup.WorkerManager\")\n@pytest.mark.parametrize(\"config\", (True, False))\ndef test_serve_with_inspector(\n    WorkerManager: Mock, mock_app: Mock, config: bool\n):\n    Inspector = Mock()\n    mock_app.config.INSPECTOR = config\n    mock_app.inspector_class = Inspector\n    inspector = Mock()\n    Inspector.return_value = inspector\n    WorkerManager.return_value = WorkerManager\n\n    Sanic.serve(mock_app)\n\n    if config:\n        Inspector.assert_called_once()\n        WorkerManager.manage.assert_called_once_with(\n            \"Inspector\", inspector, {}, transient=False\n        )\n    else:\n        Inspector.assert_not_called()\n        WorkerManager.manage.assert_not_called()"
    },
    {
      "chunk_id": 1822,
      "source": "__internal__/data_repo/sanic/tests/worker/test_shared_ctx.py",
      "content": "import logging\n\nfrom ctypes import c_int32\nfrom multiprocessing import Pipe, Queue, Value\nfrom os import environ\nfrom typing import Any\n\nimport pytest\n\nfrom sanic.types.shared_ctx import SharedContext"
    },
    {
      "chunk_id": 1823,
      "source": "__internal__/data_repo/sanic/tests/worker/test_shared_ctx.py",
      "content": "@pytest.mark.parametrize(\n    \"item,okay\",\n    (\n        (Pipe(), True),\n        (Value(\"i\", 0), True),\n        (Queue(), True),\n        (c_int32(1), True),\n        (1, False),\n        (\"thing\", False),\n        (object(), False),\n    ),\n)\ndef test_set_items(item: Any, okay: bool, caplog):\n    ctx = SharedContext()\n\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0 if okay else 1\n    if not okay:\n        assert caplog.record_tuples[0][0] == \"sanic.error\"\n        assert caplog.record_tuples[0][1] == logging.WARNING\n        assert \"Unsafe object\" in caplog.record_tuples[0][2]"
    },
    {
      "chunk_id": 1824,
      "source": "__internal__/data_repo/sanic/tests/worker/test_shared_ctx.py",
      "content": "@pytest.mark.parametrize(\n    \"item\",\n    (\n        Pipe(),\n        Value(\"i\", 0),\n        Queue(),\n        c_int32(1),\n        1,\n        \"thing\",\n        object(),\n    ),\n)\ndef test_set_items_in_worker(item: Any, caplog):\n    ctx = SharedContext()\n\n    environ[\"SANIC_WORKER_NAME\"] = \"foo\"\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n    del environ[\"SANIC_WORKER_NAME\"]\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0"
    },
    {
      "chunk_id": 1825,
      "source": "__internal__/data_repo/sanic/tests/worker/test_shared_ctx.py",
      "content": "def test_lock():\n    ctx = SharedContext()\n\n    assert ctx.is_locked is False\n\n    ctx.lock()\n\n    assert ctx.is_locked is True\n\n    message = \"Cannot set item on locked SharedContext object\"\n    with pytest.raises(RuntimeError, match=message):\n        ctx.item = 1"
    },
    {
      "chunk_id": 1826,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "import sys\n\nfrom multiprocessing import Event\nfrom os import environ, getpid\nfrom typing import Any, Union\nfrom unittest.mock import Mock\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.compat import use_context\nfrom sanic.worker.multiplexer import WorkerMultiplexer\nfrom sanic.worker.state import WorkerState"
    },
    {
      "chunk_id": 1827,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def noop(*args, **kwargs):\n    pass"
    },
    {
      "chunk_id": 1828,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "@pytest.fixture\ndef monitor_publisher():\n    return Mock()"
    },
    {
      "chunk_id": 1829,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "@pytest.fixture\ndef worker_state():\n    return {}"
    },
    {
      "chunk_id": 1830,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "@pytest.fixture\ndef m(monitor_publisher, worker_state):\n    environ[\"SANIC_WORKER_NAME\"] = \"Test\"\n    worker_state[\"Test\"] = {}\n    yield WorkerMultiplexer(monitor_publisher, worker_state)\n    del environ[\"SANIC_WORKER_NAME\"]"
    },
    {
      "chunk_id": 1831,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "@pytest.mark.skipif(\n    sys.platform not in (\"linux\", \"darwin\"),\n    reason=\"This test requires fork context\",\n)\ndef test_has_multiplexer_default(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    with use_context(\"fork\"):\n        app.run()\n\n    assert event.is_set()"
    },
    {
      "chunk_id": 1832,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_not_have_multiplexer_single(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    app.run(single_process=True)\n\n    assert not event.is_set()"
    },
    {
      "chunk_id": 1833,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_ack(worker_state: dict[str, Any], m: WorkerMultiplexer):\n    worker_state[\"Test\"] = {\"foo\": \"bar\"}\n    m.ack()\n    assert worker_state[\"Test\"] == {\"foo\": \"bar\", \"state\": \"ACKED\"}"
    },
    {
      "chunk_id": 1834,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_restart_self(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")"
    },
    {
      "chunk_id": 1835,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_restart_foo(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart(\"foo\")\n    monitor_publisher.send.assert_called_once_with(\"foo:\")"
    },
    {
      "chunk_id": 1836,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_reload_alias(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.reload()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")"
    },
    {
      "chunk_id": 1837,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_terminate(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.terminate()\n    monitor_publisher.send.assert_called_once_with(\"__TERMINATE__\")"
    },
    {
      "chunk_id": 1838,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_scale(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.scale(99)\n    monitor_publisher.send.assert_called_once_with(\"__SCALE__:99\")"
    },
    {
      "chunk_id": 1839,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_manage(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.manage(\"NEW\", noop, auto_start=False, kwargs={\"foo\": 99})\n    monitor_publisher.send.assert_called_once_with(\n        (\"NEW\", noop, {\"foo\": 99}, False, None, False, False, 1)\n    )"
    },
    {
      "chunk_id": 1840,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "def test_properties(\n    monitor_publisher: Mock, worker_state: dict[str, Any], m: WorkerMultiplexer\n):\n    assert m.reload == m.restart\n    assert m.pid == getpid()\n    assert m.name == \"Test\"\n    assert m.workers == worker_state\n    assert m.state == worker_state[\"Test\"]\n    assert isinstance(m.state, WorkerState)"
    },
    {
      "chunk_id": 1841,
      "source": "__internal__/data_repo/sanic/tests/worker/test_multiplexer.py",
      "content": "@pytest.mark.parametrize(\n    \"params,expected\",\n    (\n        ({}, \"Test:\"),\n        ({\"name\": \"foo\"}, \"foo:\"),\n        ({\"all_workers\": True}, \"__ALL_PROCESSES__:\"),\n        ({\"zero_downtime\": True}, \"Test::STARTUP_FIRST\"),\n        ({\"name\": \"foo\", \"all_workers\": True}, ValueError),\n        ({\"name\": \"foo\", \"zero_downtime\": True}, \"foo::STARTUP_FIRST\"),\n        (\n            {\"all_workers\": True, \"zero_downtime\": True},\n            \"__ALL_PROCESSES__::STARTUP_FIRST\",\n        ),\n        (\n            {\"name\": \"foo\", \"all_workers\": True, \"zero_downtime\": True},\n            ValueError,\n        ),\n    ),\n)\ndef test_restart_params(\n    monitor_publisher: Mock,\n    m: WorkerMultiplexer,\n    params: dict[str, Any],\n    expected: Union[str, type[Exception]],\n):\n    if isinstance(expected, str):\n        m.restart(**params)\n        monitor_publisher.send.assert_called_once_with(expected)\n    else:\n        with pytest.raises(expected):\n            m.restart(**params)"
    },
    {
      "chunk_id": 1842,
      "source": "__internal__/data_repo/sanic/tests/worker/test_socket.py",
      "content": "from pathlib import Path"
    },
    {
      "chunk_id": 1843,
      "source": "__internal__/data_repo/sanic/tests/worker/test_socket.py",
      "content": "from sanic.server.socket import (\n    bind_unix_socket,\n    configure_socket,\n    remove_unix_socket,\n)"
    },
    {
      "chunk_id": 1844,
      "source": "__internal__/data_repo/sanic/tests/worker/test_socket.py",
      "content": "def test_setup_and_teardown_unix():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    bind_unix_socket(socket_address)\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()"
    },
    {
      "chunk_id": 1845,
      "source": "__internal__/data_repo/sanic/tests/worker/test_socket.py",
      "content": "def test_configure_socket():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    configure_socket({\"unix\": socket_address, \"backlog\": 100})\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()"
    },
    {
      "chunk_id": 1846,
      "source": "__internal__/data_repo/sanic/tests/certs/createcerts.py",
      "content": "from datetime import datetime, timedelta\nfrom ipaddress import ip_address\nfrom os import path\n\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, rsa\nfrom cryptography.x509 import (\n    BasicConstraints,\n    CertificateBuilder,\n    DNSName,\n    ExtendedKeyUsage,\n    IPAddress,\n    KeyUsage,\n    Name,\n    NameAttribute,\n    SubjectAlternativeName,\n    random_serial_number,\n)\nfrom cryptography.x509.oid import ExtendedKeyUsageOID, NameOID"
    },
    {
      "chunk_id": 1847,
      "source": "__internal__/data_repo/sanic/tests/certs/createcerts.py",
      "content": "def writefiles(key, cert):\n    cn = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)[0].value\n    folder = path.join(path.dirname(__file__), cn)\n    with open(path.join(folder, \"fullchain.pem\"), \"wb\") as f:\n        f.write(cert.public_bytes(serialization.Encoding.PEM))\n\n    with open(path.join(folder, \"privkey.pem\"), \"wb\") as f:\n        f.write(\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.NoEncryption(),\n            )\n        )"
    },
    {
      "chunk_id": 1848,
      "source": "__internal__/data_repo/sanic/tests/certs/createcerts.py",
      "content": "def selfsigned(key, common_name, san):\n    subject = issuer = Name(\n        [\n            NameAttribute(NameOID.COMMON_NAME, common_name),\n            NameAttribute(NameOID.ORGANIZATION_NAME, \"Sanic Org\"),\n        ]\n    )\n    cert = (\n        CertificateBuilder()\n        .subject_name(subject)\n        .issuer_name(issuer)\n        .public_key(key.public_key())\n        .serial_number(random_serial_number())\n        .not_valid_before(datetime.utcnow())\n        .not_valid_after(datetime.utcnow() + timedelta(days=365.25 * 8))\n        .add_extension(\n            KeyUsage(\n                True, False, False, False, False, False, False, False, False\n            ),\n            critical=True,\n        )\n        .add_extension(\n            ExtendedKeyUsage(\n                [\n                    ExtendedKeyUsageOID.SERVER_AUTH,\n                    ExtendedKeyUsageOID.CLIENT_AUTH,\n                ]\n            ),\n            critical=False,\n        )\n        .add_extension(\n            BasicConstraints(ca=True, path_length=None),\n            critical=True,\n        )\n        .add_extension(\n            SubjectAlternativeName(\n                [\n                    IPAddress(ip_address(n))\n                    if n[0].isdigit() or \":\" in n\n                    else DNSName(n)\n                    for n in san\n                ]\n            ),\n            critical=False,\n        )\n        .sign(key, hashes.SHA256())\n    )\n    return cert"
    },
    {
      "chunk_id": 1849,
      "source": "__internal__/data_repo/sanic/tests/certs/createcerts.py",
      "content": "key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\ncert = selfsigned(\n    key,\n    \"sanic.example\",\n    [\n        \"sanic.example\",\n        \"www.sanic.example\",\n        \"*.sanic.test\",\n        \"2001:db8::541c\",\n    ],\n)\nwritefiles(key, cert)"
    },
    {
      "chunk_id": 1850,
      "source": "__internal__/data_repo/sanic/tests/certs/createcerts.py",
      "content": "key = ec.generate_private_key(ec.SECP256R1)\ncert = selfsigned(\n    key,\n    \"localhost\",\n    [\n        \"localhost\",\n        \"127.0.0.1\",\n        \"::1\",\n    ],\n)\nwritefiles(key, cert)"
    }
  ]
}