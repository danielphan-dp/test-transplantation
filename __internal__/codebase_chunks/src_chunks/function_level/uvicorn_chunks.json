{
  "chunks": [
    {
      "chunk_id": 0,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__init__.py",
      "content": "from uvicorn.config import Config\nfrom uvicorn.main import Server, main, run"
    },
    {
      "chunk_id": 1,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__init__.py",
      "content": "__version__ = \"0.34.0\"\n__all__ = [\"main\", \"run\", \"Config\", \"Server\"]"
    },
    {
      "chunk_id": 2,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport os\nimport platform\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom typing import IO, Any, Callable\n\nimport click\n\nimport uvicorn\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.config import (\n    HTTP_PROTOCOLS,\n    INTERFACES,\n    LIFESPAN,\n    LOG_LEVELS,\n    LOGGING_CONFIG,\n    LOOP_SETUPS,\n    SSL_PROTOCOL_VERSION,\n    WS_PROTOCOLS,\n    Config,\n    HTTPProtocolType,\n    InterfaceType,\n    LifespanType,\n    LoopSetupType,\n    WSProtocolType,\n)\nfrom uvicorn.server import Server, ServerState  # noqa: F401  # Used to be defined here.\nfrom uvicorn.supervisors import ChangeReload, Multiprocess\n\nLEVEL_CHOICES = click.Choice(list(LOG_LEVELS.keys()))\nHTTP_CHOICES = click.Choice(list(HTTP_PROTOCOLS.keys()))\nWS_CHOICES = click.Choice(list(WS_PROTOCOLS.keys()))\nLIFESPAN_CHOICES = click.Choice(list(LIFESPAN.keys()))\nLOOP_CHOICES = click.Choice([key for key in LOOP_SETUPS.keys() if key != \"none\"])\nINTERFACE_CHOICES = click.Choice(INTERFACES)\n\nSTARTUP_FAILURE = 3\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 3,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "def print_version(ctx: click.Context, param: click.Parameter, value: bool) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(\n        \"Running uvicorn {version} with {py_implementation} {py_version} on {system}\".format(  # noqa: UP032\n            version=uvicorn.__version__,\n            py_implementation=platform.python_implementation(),\n            py_version=platform.python_version(),\n            system=platform.system(),\n        )\n    )\n    ctx.exit()"
    },
    {
      "chunk_id": 4,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "@click.command(context_settings={\"auto_envvar_prefix\": \"UVICORN\"})\n@click.argument(\"app\", envvar=\"UVICORN_APP\")\n@click.option(\n    \"--host\",\n    type=str,\n    default=\"127.0.0.1\",\n    help=\"Bind socket to this host.\",\n    show_default=True,\n)\n@click.option(\n    \"--port\",\n    type=int,\n    default=8000,\n    help=\"Bind socket to this port. If 0, an available port will be picked.\",\n    show_default=True,\n)\n@click.option(\"--uds\", type=str, default=None, help=\"Bind to a UNIX domain socket.\")\n@click.option(\"--fd\", type=int, default=None, help=\"Bind to socket from this file descriptor.\")\n@click.option(\"--reload\", is_flag=True, default=False, help=\"Enable auto-reload.\")\n@click.option(\n    \"--reload-dir\",\n    \"reload_dirs\",\n    multiple=True,\n    help=\"Set reload directories explicitly, instead of using the current working\" \" directory.\",\n    type=click.Path(exists=True),\n)\n@click.option(\n    \"--reload-include\",\n    \"reload_includes\",\n    multiple=True,\n    help=\"Set glob patterns to include while watching for files. Includes '*.py' \"\n    \"by default; these defaults can be overridden with `--reload-exclude`. \"\n    \"This option has no effect unless watchfiles is installed.\",\n)\n@click.option(\n    \"--reload-exclude\",\n    \"reload_excludes\",\n    multiple=True,\n    help=\"Set glob patterns to exclude while watching for files. Includes \"\n    \"'.*, .py[cod], .sw.*, ~*' by default; these defaults can be overridden \"\n    \"with `--reload-include`. This option has no effect unless watchfiles is \"\n    \"installed.\",\n)\n@click.option(\n    \"--reload-delay\",\n    type=float,\n    default=0.25,\n    show_default=True,\n    help=\"Delay between previous and next check if application needs to be.\" \" Defaults to 0.25s.\",\n)\n@click.option(\n    \"--workers\",\n    default=None,\n    type=int,\n    help=\"Number of worker processes. Defaults to the $WEB_CONCURRENCY environment\"\n    \" variable if available, or 1. Not valid with --reload.\",\n)\n@click.option(\n    \"--loop\",\n    type=LOOP_CHOICES,\n    default=\"auto\",\n    help=\"Event loop implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--http\",\n    type=HTTP_CHOICES,\n    default=\"auto\",\n    help=\"HTTP protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws\",\n    type=WS_CHOICES,\n    default=\"auto\",\n    help=\"WebSocket protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-size\",\n    type=int,\n    default=16777216,\n    help=\"WebSocket max size message in bytes\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-queue\",\n    type=int,\n    default=32,\n    help=\"The maximum length of the WebSocket message queue.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-interval\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping interval in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-timeout\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping timeout in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-per-message-deflate\",\n    type=bool,\n    default=True,\n    help=\"WebSocket per-message-deflate compression\",\n    show_default=True,\n)\n@click.option(\n    \"--lifespan\",\n    type=LIFESPAN_CHOICES,\n    default=\"auto\",\n    help=\"Lifespan implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--interface\",\n    type=INTERFACE_CHOICES,\n    default=\"auto\",\n    help=\"Select ASGI3, ASGI2, or WSGI as the application interface.\",\n    show_default=True,\n)\n@click.option(\n    \"--env-file\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Environment configuration file.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-config\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Logging configuration file. Supported formats: .ini, .json, .yaml.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-level\",\n    type=LEVEL_CHOICES,\n    default=None,\n    help=\"Log level. [default: info]\",\n    show_default=True,\n)\n@click.option(\n    \"--access-log/--no-access-log\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable access log.\",\n)\n@click.option(\n    \"--use-colors/--no-use-colors\",\n    is_flag=True,\n    default=None,\n    help=\"Enable/Disable colorized logging.\",\n)\n@click.option(\n    \"--proxy-headers/--no-proxy-headers\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable X-Forwarded-Proto, X-Forwarded-For, X-Forwarded-Port to \" \"populate remote address info.\",\n)\n@click.option(\n    \"--server-header/--no-server-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Server header.\",\n)\n@click.option(\n    \"--date-header/--no-date-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Date header.\",\n)\n@click.option(\n    \"--forwarded-allow-ips\",\n    type=str,\n    default=None,\n    help=\"Comma separated list of IP Addresses, IP Networks, or literals \"\n    \"(e.g. UNIX Socket path) to trust with proxy headers. Defaults to the \"\n    \"$FORWARDED_ALLOW_IPS environment variable if available, or '127.0.0.1'. \"\n    \"The literal '*' means trust everything.\",\n)\n@click.option(\n    \"--root-path\",\n    type=str,\n    default=\"\",\n    help=\"Set the ASGI 'root_path' for applications submounted below a given URL path.\",\n)\n@click.option(\n    \"--limit-concurrency\",\n    type=int,\n    default=None,\n    help=\"Maximum number of concurrent connections or tasks to allow, before issuing\" \" HTTP 503 responses.\",\n)\n@click.option(\n    \"--backlog\",\n    type=int,\n    default=2048,\n    help=\"Maximum number of connections to hold in backlog\",\n)\n@click.option(\n    \"--limit-max-requests\",\n    type=int,\n    default=None,\n    help=\"Maximum number of requests to service before terminating the process.\",\n)\n@click.option(\n    \"--timeout-keep-alive\",\n    type=int,\n    default=5,\n    help=\"Close Keep-Alive connections if no new data is received within this timeout.\",\n    show_default=True,\n)\n@click.option(\n    \"--timeout-graceful-shutdown\",\n    type=int,\n    default=None,\n    help=\"Maximum number of seconds to wait for graceful shutdown.\",\n)\n@click.option(\"--ssl-keyfile\", type=str, default=None, help=\"SSL key file\", show_default=True)\n@click.option(\n    \"--ssl-certfile\",\n    type=str,\n    default=None,\n    help=\"SSL certificate file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-keyfile-password\",\n    type=str,\n    default=None,\n    help=\"SSL keyfile password\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-version\",\n    type=int,\n    default=int(SSL_PROTOCOL_VERSION),\n    help=\"SSL version to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-cert-reqs\",\n    type=int,\n    default=int(ssl.CERT_NONE),\n    help=\"Whether client certificate is required (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ca-certs\",\n    type=str,\n    default=None,\n    help=\"CA certificates file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ciphers\",\n    type=str,\n    default=\"TLSv1\",\n    help=\"Ciphers to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--header\",\n    \"headers\",\n    multiple=True,\n    help=\"Specify custom default HTTP response headers as a Name:Value pair\",\n)\n@click.option(\n    \"--version\",\n    is_flag=True,\n    callback=print_version,\n    expose_value=False,\n    is_eager=True,\n    help=\"Display the uvicorn version and exit.\",\n)\n@click.option(\n    \"--app-dir\",\n    default=\"\",\n    show_default=True,\n    help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n    \" Defaults to the current working directory.\",\n)\n@click.option(\n    \"--h11-max-incomplete-event-size\",\n    \"h11_max_incomplete_event_size\",\n    type=int,\n    default=None,\n    help=\"For h11, the maximum number of bytes to buffer of an incomplete event.\",\n)\n@click.option(\n    \"--factory\",\n    is_flag=True,\n    default=False,\n    help=\"Treat APP as an application factory, i.e. a () -> <ASGI app> callable.\",\n    show_default=True,\n)\ndef main(\n    app: str,\n    host: str,\n    port: int,\n    uds: str,\n    fd: int,\n    loop: LoopSetupType,\n    http: HTTPProtocolType,\n    ws: WSProtocolType,\n    ws_max_size: int,\n    ws_max_queue: int,\n    ws_ping_interval: float,\n    ws_ping_timeout: float,\n    ws_per_message_deflate: bool,\n    lifespan: LifespanType,\n    interface: InterfaceType,\n    reload: bool,\n    reload_dirs: list[str],\n    reload_includes: list[str],\n    reload_excludes: list[str],\n    reload_delay: float,\n    workers: int,\n    env_file: str,\n    log_config: str,\n    log_level: str,\n    access_log: bool,\n    proxy_headers: bool,\n    server_header: bool,\n    date_header: bool,\n    forwarded_allow_ips: str,\n    root_path: str,\n    limit_concurrency: int,\n    backlog: int,\n    limit_max_requests: int,\n    timeout_keep_alive: int,\n    timeout_graceful_shutdown: int | None,\n    ssl_keyfile: str,\n    ssl_certfile: str,\n    ssl_keyfile_password: str,\n    ssl_version: int,\n    ssl_cert_reqs: int,\n    ssl_ca_certs: str,\n    ssl_ciphers: str,\n    headers: list[str],\n    use_colors: bool,\n    app_dir: str,\n    h11_max_incomplete_event_size: int | None,\n    factory: bool,\n) -> None:\n    run(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        env_file=env_file,\n        log_config=LOGGING_CONFIG if log_config is None else log_config,\n        log_level=log_level,\n        access_log=access_log,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs or None,\n        reload_includes=reload_includes or None,\n        reload_excludes=reload_excludes or None,\n        reload_delay=reload_delay,\n        workers=workers,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=[header.split(\":\", 1) for header in headers],  # type: ignore[misc]\n        use_colors=use_colors,\n        factory=factory,\n        app_dir=app_dir,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )"
    },
    {
      "chunk_id": 5,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "def run(\n    app: ASGIApplication | Callable[..., Any] | str,\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    uds: str | None = None,\n    fd: int | None = None,\n    loop: LoopSetupType = \"auto\",\n    http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n    ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n    ws_max_size: int = 16777216,\n    ws_max_queue: int = 32,\n    ws_ping_interval: float | None = 20.0,\n    ws_ping_timeout: float | None = 20.0,\n    ws_per_message_deflate: bool = True,\n    lifespan: LifespanType = \"auto\",\n    interface: InterfaceType = \"auto\",\n    reload: bool = False,\n    reload_dirs: list[str] | str | None = None,\n    reload_includes: list[str] | str | None = None,\n    reload_excludes: list[str] | str | None = None,\n    reload_delay: float = 0.25,\n    workers: int | None = None,\n    env_file: str | os.PathLike[str] | None = None,\n    log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n    log_level: str | int | None = None,\n    access_log: bool = True,\n    proxy_headers: bool = True,\n    server_header: bool = True,\n    date_header: bool = True,\n    forwarded_allow_ips: list[str] | str | None = None,\n    root_path: str = \"\",\n    limit_concurrency: int | None = None,\n    backlog: int = 2048,\n    limit_max_requests: int | None = None,\n    timeout_keep_alive: int = 5,\n    timeout_graceful_shutdown: int | None = None,\n    ssl_keyfile: str | os.PathLike[str] | None = None,\n    ssl_certfile: str | os.PathLike[str] | None = None,\n    ssl_keyfile_password: str | None = None,\n    ssl_version: int = SSL_PROTOCOL_VERSION,\n    ssl_cert_reqs: int = ssl.CERT_NONE,\n    ssl_ca_certs: str | None = None,\n    ssl_ciphers: str = \"TLSv1\",\n    headers: list[tuple[str, str]] | None = None,\n    use_colors: bool | None = None,\n    app_dir: str | None = None,\n    factory: bool = False,\n    h11_max_incomplete_event_size: int | None = None,\n) -> None:\n    if app_dir is not None:\n        sys.path.insert(0, app_dir)\n\n    config = Config(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs,\n        reload_includes=reload_includes,\n        reload_excludes=reload_excludes,\n        reload_delay=reload_delay,\n        workers=workers,\n        env_file=env_file,\n        log_config=log_config,\n        log_level=log_level,\n        access_log=access_log,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=headers,\n        use_colors=use_colors,\n        factory=factory,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )\n    server = Server(config=config)\n\n    if (config.reload or config.workers > 1) and not isinstance(app, str):\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.warning(\"You must pass the application as an import string to enable 'reload' or \" \"'workers'.\")\n        sys.exit(1)\n\n    try:\n        if config.should_reload:\n            sock = config.bind_socket()\n            ChangeReload(config, target=server.run, sockets=[sock]).run()\n        elif config.workers > 1:\n            sock = config.bind_socket()\n            Multiprocess(config, target=server.run, sockets=[sock]).run()\n        else:\n            server.run()\n    except KeyboardInterrupt:\n        pass  # pragma: full coverage\n    finally:\n        if config.uds and os.path.exists(config.uds):\n            os.remove(config.uds)  # pragma: py-win32\n\n    if not server.started and not config.should_reload and config.workers == 1:\n        sys.exit(STARTUP_FAILURE)"
    },
    {
      "chunk_id": 6,
      "source": "__internal__/data_repo/uvicorn/uvicorn/main.py",
      "content": "if __name__ == \"__main__\":\n    main()  # pragma: no cover"
    },
    {
      "chunk_id": 7,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "import importlib\nfrom typing import Any"
    },
    {
      "chunk_id": 8,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "class ImportFromStringError(Exception):\n    \"\"\"Custom exception for import errors from string.\"\"\"\n    pass"
    },
    {
      "chunk_id": 9,
      "source": "__internal__/data_repo/uvicorn/uvicorn/importer.py",
      "content": "def import_from_string(import_str: Any) -> Any:\n    if not isinstance(import_str, str):\n        return import_str\n\n    module_str, _, attrs_str = import_str.partition(\":\")\n    if not module_str or not attrs_str:\n        message = 'Import string \"{import_str}\" must be in format \"<module>:<attribute>\".'\n        raise ImportFromStringError(message.format(import_str=import_str))\n\n    try:\n        module = importlib.import_module(module_str)\n    except ModuleNotFoundError as exc:\n        if exc.name != module_str:\n            raise exc from None\n        message = 'Could not import module \"{module_str}\".'\n        raise ImportFromStringError(message.format(module_str=module_str))\n\n    instance = module\n    try:\n        for attr_str in attrs_str.split(\".\"):\n            instance = getattr(instance, attr_str)\n    except AttributeError:\n        message = 'Attribute \"{attrs_str}\" not found in module \"{module_str}\".'\n        raise ImportFromStringError(message.format(attrs_str=attrs_str, module_str=module_str))\n\n    return instance"
    },
    {
      "chunk_id": 10,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport platform\nimport signal\nimport socket\nimport sys\nimport threading\nimport time\nfrom collections.abc import Generator, Sequence\nfrom email.utils import formatdate\nfrom types import FrameType\nfrom typing import TYPE_CHECKING, Union\n\nimport click\n\nfrom uvicorn.config import Config\n\nif TYPE_CHECKING:\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n    Protocols = Union[H11Protocol, HttpToolsProtocol, WSProtocol, WebSocketProtocol]\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\nif sys.platform == \"win32\":  # pragma: py-not-win32\n    HANDLED_SIGNALS += (signal.SIGBREAK,)  # Windows signal 21. Sent by Ctrl+Break.\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 11,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "class ServerState:\n    \"\"\"\n    Shared servers state that is available between all protocol instances.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.total_requests = 0\n        self.connections: set[Protocols] = set()\n        self.tasks: set[asyncio.Task[None]] = set()\n        self.default_headers: list[tuple[bytes, bytes]] = []"
    },
    {
      "chunk_id": 12,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "class Server:\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.server_state = ServerState()\n\n        self.started = False\n        self.should_exit = False\n        self.force_exit = False\n        self.last_notified = 0.0\n\n        self._captured_signals: list[int] = []"
    },
    {
      "chunk_id": 13,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "def run(self, sockets: list[socket.socket] | None = None) -> None:\n        self.config.setup_event_loop()\n        return asyncio.run(self.serve(sockets=sockets))"
    },
    {
      "chunk_id": 14,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def serve(self, sockets: list[socket.socket] | None = None) -> None:\n        with self.capture_signals():\n            await self._serve(sockets)"
    },
    {
      "chunk_id": 15,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def _serve(self, sockets: list[socket.socket] | None = None) -> None:\n        process_id = os.getpid()\n\n        config = self.config\n        if not config.loaded:\n            config.load()\n\n        self.lifespan = config.lifespan_class(config)\n\n        message = \"Started server process [%d]\"\n        color_message = \"Started server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n        await self.startup(sockets=sockets)\n        if self.should_exit:\n            return\n        await self.main_loop()\n        await self.shutdown(sockets=sockets)\n\n        message = \"Finished server process [%d]\"\n        color_message = \"Finished server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})"
    },
    {
      "chunk_id": 16,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def startup(self, sockets: list[socket.socket] | None = None) -> None:\n        await self.lifespan.startup()\n        if self.lifespan.should_exit:\n            self.should_exit = True\n            return\n\n        config = self.config\n\n        def create_protocol(\n            _loop: asyncio.AbstractEventLoop | None = None,\n        ) -> asyncio.Protocol:\n            return config.http_protocol_class(  # type: ignore[call-arg]\n                config=config,\n                server_state=self.server_state,\n                app_state=self.lifespan.state,\n                _loop=_loop,\n            )\n\n        loop = asyncio.get_running_loop()\n\n        listeners: Sequence[socket.SocketType]\n        if sockets is not None:  # pragma: full coverage\n            # Explicitly passed a list of open sockets.\n            # We use this when the server is run from a Gunicorn worker.\n\n            def _share_socket(\n                sock: socket.SocketType,\n            ) -> socket.SocketType:  # pragma py-linux pragma: py-darwin\n                # Windows requires the socket be explicitly shared across\n                # multiple workers (processes).\n                from socket import fromshare  # type: ignore[attr-defined]\n\n                sock_data = sock.share(os.getpid())  # type: ignore[attr-defined]\n                return fromshare(sock_data)\n\n            self.servers: list[asyncio.base_events.Server] = []\n            for sock in sockets:\n                is_windows = platform.system() == \"Windows\"\n                if config.workers > 1 and is_windows:  # pragma: py-not-win32\n                    sock = _share_socket(sock)  # type: ignore[assignment]\n                server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n                self.servers.append(server)\n            listeners = sockets\n\n        elif config.fd is not None:  # pragma: py-win32\n            # Use an existing socket, from a file descriptor.\n            sock = socket.fromfd(config.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        elif config.uds is not None:  # pragma: py-win32\n            # Create a socket using UNIX domain socket.\n            uds_perms = 0o666\n            if os.path.exists(config.uds):\n                uds_perms = os.stat(config.uds).st_mode  # pragma: full coverage\n            server = await loop.create_unix_server(\n                create_protocol, path=config.uds, ssl=config.ssl, backlog=config.backlog\n            )\n            os.chmod(config.uds, uds_perms)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        else:\n            # Standard case. Create a socket from a host/port pair.\n            try:\n                server = await loop.create_server(\n                    create_protocol,\n                    host=config.host,\n                    port=config.port,\n                    ssl=config.ssl,\n                    backlog=config.backlog,\n                )\n            except OSError as exc:\n                logger.error(exc)\n                await self.lifespan.shutdown()\n                sys.exit(1)\n\n            assert server.sockets is not None\n            listeners = server.sockets\n            self.servers = [server]\n\n        if sockets is None:\n            self._log_started_message(listeners)\n        else:\n            # We're most likely running multiple workers, so a message has already been\n            # logged by `config.bind_socket()`.\n            pass  # pragma: full coverage\n\n        self.started = True"
    },
    {
      "chunk_id": 17,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "def _log_started_message(self, listeners: Sequence[socket.SocketType]) -> None:\n        config = self.config\n\n        if config.fd is not None:  # pragma: py-win32\n            sock = listeners[0]\n            logger.info(\n                \"Uvicorn running on socket %s (Press CTRL+C to quit)\",\n                sock.getsockname(),\n            )\n\n        elif config.uds is not None:  # pragma: py-win32\n            logger.info(\"Uvicorn running on unix socket %s (Press CTRL+C to quit)\", config.uds)\n\n        else:\n            addr_format = \"%s://%s:%d\"\n            host = \"0.0.0.0\" if config.host is None else config.host\n            if \":\" in host:\n                # It's an IPv6 address.\n                addr_format = \"%s://[%s]:%d\"\n\n            port = config.port\n            if port == 0:\n                port = listeners[0].getsockname()[1]\n\n            protocol_name = \"https\" if config.ssl else \"http\"\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger.info(\n                message,\n                protocol_name,\n                host,\n                port,\n                extra={\"color_message\": color_message},\n            )"
    },
    {
      "chunk_id": 18,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def main_loop(self) -> None:\n        counter = 0\n        should_exit = await self.on_tick(counter)\n        while not should_exit:\n            counter += 1\n            counter = counter % 864000\n            await asyncio.sleep(0.1)\n            should_exit = await self.on_tick(counter)"
    },
    {
      "chunk_id": 19,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def on_tick(self, counter: int) -> bool:\n        # Update the default headers, once per second.\n        if counter % 10 == 0:\n            current_time = time.time()\n            current_date = formatdate(current_time, usegmt=True).encode()\n\n            if self.config.date_header:\n                date_header = [(b\"date\", current_date)]\n            else:\n                date_header = []\n\n            self.server_state.default_headers = date_header + self.config.encoded_headers\n\n            # Callback to `callback_notify` once every `timeout_notify` seconds.\n            if self.config.callback_notify is not None:\n                if current_time - self.last_notified > self.config.timeout_notify:  # pragma: full coverage\n                    self.last_notified = current_time\n                    await self.config.callback_notify()\n\n        # Determine if we should exit.\n        if self.should_exit:\n            return True\n\n        max_requests = self.config.limit_max_requests\n        if max_requests is not None and self.server_state.total_requests >= max_requests:\n            logger.warning(f\"Maximum request limit of {max_requests} exceeded. Terminating process.\")\n            return True\n\n        return False"
    },
    {
      "chunk_id": 20,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def shutdown(self, sockets: list[socket.socket] | None = None) -> None:\n        logger.info(\"Shutting down\")\n\n        # Stop accepting new connections.\n        for server in self.servers:\n            server.close()\n        for sock in sockets or []:\n            sock.close()  # pragma: full coverage\n\n        # Request shutdown on all existing connections.\n        for connection in list(self.server_state.connections):\n            connection.shutdown()\n        await asyncio.sleep(0.1)\n\n        # When 3.10 is not supported anymore, use `async with asyncio.timeout(...):`.\n        try:\n            await asyncio.wait_for(\n                self._wait_tasks_to_complete(),\n                timeout=self.config.timeout_graceful_shutdown,\n            )\n        except asyncio.TimeoutError:\n            logger.error(\n                \"Cancel %s running task(s), timeout graceful shutdown exceeded\",\n                len(self.server_state.tasks),\n            )\n            for t in self.server_state.tasks:\n                t.cancel(msg=\"Task cancelled, timeout graceful shutdown exceeded\")\n\n        # Send the lifespan shutdown event, and wait for application shutdown.\n        if not self.force_exit:\n            await self.lifespan.shutdown()"
    },
    {
      "chunk_id": 21,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "async def _wait_tasks_to_complete(self) -> None:\n        # Wait for existing connections to finish sending responses.\n        if self.server_state.connections and not self.force_exit:\n            msg = \"Waiting for connections to close. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.connections and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        # Wait for existing tasks to complete.\n        if self.server_state.tasks and not self.force_exit:\n            msg = \"Waiting for background tasks to complete. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.tasks and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        for server in self.servers:\n            await server.wait_closed()"
    },
    {
      "chunk_id": 22,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "@contextlib.contextmanager\n    def capture_signals(self) -> Generator[None, None, None]:\n        # Signals can only be listened to from the main thread.\n        if threading.current_thread() is not threading.main_thread():\n            yield\n            return\n        # always use signal.signal, even if loop.add_signal_handler is available\n        # this allows to restore previous signal handlers later on\n        original_handlers = {sig: signal.signal(sig, self.handle_exit) for sig in HANDLED_SIGNALS}\n        try:\n            yield\n        finally:\n            for sig, handler in original_handlers.items():\n                signal.signal(sig, handler)\n        # If we did gracefully shut down due to a signal, try to\n        # trigger the expected behaviour now; multiple signals would be\n        # done LIFO, see https://stackoverflow.com/questions/48434964\n        for captured_signal in reversed(self._captured_signals):\n            signal.raise_signal(captured_signal)"
    },
    {
      "chunk_id": 23,
      "source": "__internal__/data_repo/uvicorn/uvicorn/server.py",
      "content": "def handle_exit(self, sig: int, frame: FrameType | None) -> None:\n        self._captured_signals.append(sig)\n        if self.should_exit and sig == signal.SIGINT:\n            self.force_exit = True  # pragma: full coverage\n        else:\n            self.should_exit = True"
    },
    {
      "chunk_id": 24,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport signal\nimport sys\nimport warnings\nfrom typing import Any\n\nfrom gunicorn.arbiter import Arbiter\nfrom gunicorn.workers.base import Worker\n\nfrom uvicorn.config import Config\nfrom uvicorn.server import Server\n\nwarnings.warn(\n    \"The `uvicorn.workers` module is deprecated. Please use `uvicorn-worker` package instead.\\n\"\n    \"For more details, see https://github.com/Kludex/uvicorn-worker.\",\n    DeprecationWarning,\n)"
    },
    {
      "chunk_id": 25,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "class UvicornWorker(Worker):\n    \"\"\"\n    A worker class for Gunicorn that interfaces with an ASGI consumer callable,\n    rather than a WSGI callable.\n    \"\"\"\n\n    CONFIG_KWARGS: dict[str, Any] = {\"loop\": \"auto\", \"http\": \"auto\"}\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.handlers = self.log.error_log.handlers\n        logger.setLevel(self.log.error_log.level)\n        logger.propagate = False\n\n        logger = logging.getLogger(\"uvicorn.access\")\n        logger.handlers = self.log.access_log.handlers\n        logger.setLevel(self.log.access_log.level)\n        logger.propagate = False\n\n        config_kwargs: dict = {\n            \"app\": None,\n            \"log_config\": None,\n            \"timeout_keep_alive\": self.cfg.keepalive,\n            \"timeout_notify\": self.timeout,\n            \"callback_notify\": self.callback_notify,\n            \"limit_max_requests\": self.max_requests,\n            \"forwarded_allow_ips\": self.cfg.forwarded_allow_ips,\n        }\n\n        if self.cfg.is_ssl:\n            ssl_kwargs = {\n                \"ssl_keyfile\": self.cfg.ssl_options.get(\"keyfile\"),\n                \"ssl_certfile\": self.cfg.ssl_options.get(\"certfile\"),\n                \"ssl_keyfile_password\": self.cfg.ssl_options.get(\"password\"),\n                \"ssl_version\": self.cfg.ssl_options.get(\"ssl_version\"),\n                \"ssl_cert_reqs\": self.cfg.ssl_options.get(\"cert_reqs\"),\n                \"ssl_ca_certs\": self.cfg.ssl_options.get(\"ca_certs\"),\n                \"ssl_ciphers\": self.cfg.ssl_options.get(\"ciphers\"),\n            }\n            config_kwargs.update(ssl_kwargs)\n\n        if self.cfg.settings[\"backlog\"].value:\n            config_kwargs[\"backlog\"] = self.cfg.settings[\"backlog\"].value\n\n        config_kwargs.update(self.CONFIG_KWARGS)\n\n        self.config = Config(**config_kwargs)"
    },
    {
      "chunk_id": 26,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "def init_process(self) -> None:\n        self.config.setup_event_loop()\n        super().init_process()"
    },
    {
      "chunk_id": 27,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "def init_signals(self) -> None:\n        # Reset signals so Gunicorn doesn't swallow subprocess return codes\n        # other signals are set up by Server.install_signal_handlers()\n        # See: https://github.com/encode/uvicorn/issues/894\n        for s in self.SIGNALS:\n            signal.signal(s, signal.SIG_DFL)\n\n        signal.signal(signal.SIGUSR1, self.handle_usr1)\n        # Don't let SIGUSR1 disturb active requests by interrupting system calls\n        signal.siginterrupt(signal.SIGUSR1, False)"
    },
    {
      "chunk_id": 28,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "def _install_sigquit_handler(self) -> None:\n        \"\"\"Install a SIGQUIT handler on workers.\n\n        - https://github.com/encode/uvicorn/issues/1116\n        - https://github.com/benoitc/gunicorn/issues/2604\n        \"\"\"\n\n        loop = asyncio.get_running_loop()\n        loop.add_signal_handler(signal.SIGQUIT, self.handle_exit, signal.SIGQUIT, None)"
    },
    {
      "chunk_id": 29,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "async def _serve(self) -> None:\n        self.config.app = self.wsgi\n        server = Server(config=self.config)\n        self._install_sigquit_handler()\n        await server.serve(sockets=self.sockets)\n        if not server.started:\n            sys.exit(Arbiter.WORKER_BOOT_ERROR)"
    },
    {
      "chunk_id": 30,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "def run(self) -> None:\n        return asyncio.run(self._serve())"
    },
    {
      "chunk_id": 31,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "async def callback_notify(self) -> None:\n        self.notify()"
    },
    {
      "chunk_id": 32,
      "source": "__internal__/data_repo/uvicorn/uvicorn/workers.py",
      "content": "class UvicornH11Worker(UvicornWorker):\n    CONFIG_KWARGS = {\"loop\": \"asyncio\", \"http\": \"h11\"}"
    },
    {
      "chunk_id": 33,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__main__.py",
      "content": "import uvicorn"
    },
    {
      "chunk_id": 34,
      "source": "__internal__/data_repo/uvicorn/uvicorn/__main__.py",
      "content": "if __name__ == \"__main__\":\n    uvicorn.main()"
    },
    {
      "chunk_id": 35,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "\"\"\"\nSome light wrappers around Python's multiprocessing, to deal with cleanly\nstarting child processes.\n\"\"\""
    },
    {
      "chunk_id": 36,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "from __future__ import annotations\n\nimport multiprocessing\nimport os\nimport sys\nfrom multiprocessing.context import SpawnProcess\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\n\nmultiprocessing.allow_connection_pickling()\nspawn = multiprocessing.get_context(\"spawn\")"
    },
    {
      "chunk_id": 37,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "def get_subprocess(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n) -> SpawnProcess:\n    \"\"\"\n    Called in the parent process, to instantiate a new child process instance.\n    The child is not yet started at this point.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    \"\"\"\n    # We pass across the stdin fileno, and reopen it in the child process.\n    # This is required for some debugging environments.\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    # The `sys.stdin` can be `None`, see https://docs.python.org/3/library/sys.html#sys.__stdin__.\n    except (AttributeError, OSError):\n        stdin_fileno = None\n\n    kwargs = {\n        \"config\": config,\n        \"target\": target,\n        \"sockets\": sockets,\n        \"stdin_fileno\": stdin_fileno,\n    }\n\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)"
    },
    {
      "chunk_id": 38,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_subprocess.py",
      "content": "def subprocess_started(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n    stdin_fileno: int | None,\n) -> None:\n    \"\"\"\n    Called when the child process starts.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    * stdin_fileno - The file number of sys.stdin, so that it can be reattached\n                     to the child process.\n    \"\"\"\n    # Re-open stdin.\n    if stdin_fileno is not None:\n        sys.stdin = os.fdopen(stdin_fileno)  # pragma: full coverage\n\n    # Logging needs to be setup again for each child.\n    config.configure_logging()\n\n    try:\n        # Now we can call into `Server.run(sockets=sockets)`\n        target(sockets=sockets)\n    except KeyboardInterrupt:  # pragma: no cover\n        # supress the exception to avoid a traceback from subprocess.Popen\n        # the parent already expects us to end, so no vital information is lost\n        pass"
    },
    {
      "chunk_id": 39,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "from __future__ import annotations\n\nimport http\nimport logging\nimport sys\nfrom copy import copy\nfrom typing import Literal\n\nimport click\n\nTRACE_LOG_LEVEL = 5"
    },
    {
      "chunk_id": 40,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class ColourizedFormatter(logging.Formatter):\n    \"\"\"\n    A custom log formatter class that:\n\n    * Outputs the LOG_LEVEL with an appropriate color.\n    * If a log call includes an `extra={\"color_message\": ...}` it will be used\n      for formatting the output, instead of the plain text message.\n    \"\"\"\n\n    level_name_colors = {\n        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),\n        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),\n        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),\n        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),\n        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),\n        logging.CRITICAL: lambda level_name: click.style(str(level_name), fg=\"bright_red\"),\n    }\n\n    def __init__(\n        self,\n        fmt: str | None = None,\n        datefmt: str | None = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: bool | None = None,\n    ):\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)"
    },
    {
      "chunk_id": 41,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "def color_level_name(self, level_name: str, level_no: int) -> str:\n        def default(level_name: str) -> str:\n            return str(level_name)  # pragma: no cover\n\n        func = self.level_name_colors.get(level_no, default)\n        return func(level_name)"
    },
    {
      "chunk_id": 42,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "def should_use_colors(self) -> bool:\n        return True  # pragma: no cover"
    },
    {
      "chunk_id": 43,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        levelname = recordcopy.levelname\n        seperator = \" \" * (8 - len(recordcopy.levelname))\n        if self.use_colors:\n            levelname = self.color_level_name(levelname, recordcopy.levelno)\n            if \"color_message\" in recordcopy.__dict__:\n                recordcopy.msg = recordcopy.__dict__[\"color_message\"]\n                recordcopy.__dict__[\"message\"] = recordcopy.getMessage()\n        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator\n        return super().formatMessage(recordcopy)"
    },
    {
      "chunk_id": 44,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class DefaultFormatter(ColourizedFormatter):\n    def should_use_colors(self) -> bool:\n        return sys.stderr.isatty()  # pragma: no cover"
    },
    {
      "chunk_id": 45,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "class AccessFormatter(ColourizedFormatter):\n    status_code_colours = {\n        1: lambda code: click.style(str(code), fg=\"bright_white\"),\n        2: lambda code: click.style(str(code), fg=\"green\"),\n        3: lambda code: click.style(str(code), fg=\"yellow\"),\n        4: lambda code: click.style(str(code), fg=\"red\"),\n        5: lambda code: click.style(str(code), fg=\"bright_red\"),\n    }"
    },
    {
      "chunk_id": 46,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "def get_status_code(self, status_code: int) -> str:\n        try:\n            status_phrase = http.HTTPStatus(status_code).phrase\n        except ValueError:\n            status_phrase = \"\"\n        status_and_phrase = f\"{status_code} {status_phrase}\"\n        if self.use_colors:\n\n            def default(code: int) -> str:\n                return status_and_phrase  # pragma: no cover\n\n            func = self.status_code_colours.get(status_code // 100, default)\n            return func(status_and_phrase)\n        return status_and_phrase"
    },
    {
      "chunk_id": 47,
      "source": "__internal__/data_repo/uvicorn/uvicorn/logging.py",
      "content": "def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        (\n            client_addr,\n            method,\n            full_path,\n            http_version,\n            status_code,\n        ) = recordcopy.args  # type: ignore[misc]\n        status_code = self.get_status_code(int(status_code))  # type: ignore[arg-type]\n        request_line = f\"{method} {full_path} HTTP/{http_version}\"\n        if self.use_colors:\n            request_line = click.style(request_line, bold=True)\n        recordcopy.__dict__.update(\n            {\n                \"client_addr\": client_addr,\n                \"request_line\": request_line,\n                \"status_code\": status_code,\n            }\n        )\n        return super().formatMessage(recordcopy)"
    },
    {
      "chunk_id": 48,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom collections.abc import Awaitable\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Callable, Literal\n\nimport click\n\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware"
    },
    {
      "chunk_id": 49,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "HTTPProtocolType = Literal[\"auto\", \"h11\", \"httptools\"]\nWSProtocolType = Literal[\"auto\", \"none\", \"websockets\", \"wsproto\"]\nLifespanType = Literal[\"auto\", \"on\", \"off\"]\nLoopSetupType = Literal[\"none\", \"auto\", \"asyncio\", \"uvloop\"]\nInterfaceType = Literal[\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nLOG_LEVELS: dict[str, int] = {\n    \"critical\": logging.CRITICAL,\n    \"error\": logging.ERROR,\n    \"warning\": logging.WARNING,\n    \"info\": logging.INFO,\n    \"debug\": logging.DEBUG,\n    \"trace\": TRACE_LOG_LEVEL,\n}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {\n    \"auto\": \"uvicorn.protocols.http.auto:AutoHTTPProtocol\",\n    \"h11\": \"uvicorn.protocols.http.h11_impl:H11Protocol\",\n    \"httptools\": \"uvicorn.protocols.http.httptools_impl:HttpToolsProtocol\",\n}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {\n    \"auto\": \"uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol\",\n    \"none\": None,\n    \"websockets\": \"uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol\",\n    \"wsproto\": \"uvicorn.protocols.websockets.wsproto_impl:WSProtocol\",\n}\nLIFESPAN: dict[LifespanType, str] = {\n    \"auto\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"on\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"off\": \"uvicorn.lifespan.off:LifespanOff\",\n}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {\n    \"none\": None,\n    \"auto\": \"uvicorn.loops.auto:auto_loop_setup\",\n    \"asyncio\": \"uvicorn.loops.asyncio:asyncio_setup\",\n    \"uvloop\": \"uvicorn.loops.uvloop:uvloop_setup\",\n}\nINTERFACES: list[InterfaceType] = [\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\n\nLOGGING_CONFIG: dict[str, Any] = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": \"%(levelprefix)s %(message)s\",\n            \"use_colors\": None,\n        },\n        \"access\": {\n            \"()\": \"uvicorn.logging.AccessFormatter\",\n            \"fmt\": '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n        },\n    },\n    \"handlers\": {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n        \"access\": {\n            \"formatter\": \"access\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"loggers\": {\n        \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"INFO\", \"propagate\": False},\n        \"uvicorn.error\": {\"level\": \"INFO\"},\n        \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"INFO\", \"propagate\": False},\n    },\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 50,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def create_ssl_context(\n    certfile: str | os.PathLike[str],\n    keyfile: str | os.PathLike[str] | None,\n    password: str | None,\n    ssl_version: int,\n    cert_reqs: int,\n    ca_certs: str | os.PathLike[str] | None,\n    ciphers: str | None,\n) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx"
    },
    {
      "chunk_id": 51,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:  # pragma: full coverage\n        return False"
    },
    {
      "chunk_id": 52,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        if pattern == \".*\":\n            continue  # pragma: py-darwin\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):  # pragma: full coverage\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n\n    directories = list(set(directories).difference(set(children)))\n\n    return list(set(patterns)), directories"
    },
    {
      "chunk_id": 53,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))"
    },
    {
      "chunk_id": 54,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "class Config:\n    def __init__(\n        self,\n        app: ASGIApplication | Callable[..., Any] | str,\n        host: str = \"127.0.0.1\",\n        port: int = 8000,\n        uds: str | None = None,\n        fd: int | None = None,\n        loop: LoopSetupType = \"auto\",\n        http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n        ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n        ws_max_size: int = 16 * 1024 * 1024,\n        ws_max_queue: int = 32,\n        ws_ping_interval: float | None = 20.0,\n        ws_ping_timeout: float | None = 20.0,\n        ws_per_message_deflate: bool = True,\n        lifespan: LifespanType = \"auto\",\n        env_file: str | os.PathLike[str] | None = None,\n        log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n        log_level: str | int | None = None,\n        access_log: bool = True,\n        use_colors: bool | None = None,\n        interface: InterfaceType = \"auto\",\n        reload: bool = False,\n        reload_dirs: list[str] | str | None = None,\n        reload_delay: float = 0.25,\n        reload_includes: list[str] | str | None = None,\n        reload_excludes: list[str] | str | None = None,\n        workers: int | None = None,\n        proxy_headers: bool = True,\n        server_header: bool = True,\n        date_header: bool = True,\n        forwarded_allow_ips: list[str] | str | None = None,\n        root_path: str = \"\",\n        limit_concurrency: int | None = None,\n        limit_max_requests: int | None = None,\n        backlog: int = 2048,\n        timeout_keep_alive: int = 5,\n        timeout_notify: int = 30,\n        timeout_graceful_shutdown: int | None = None,\n        callback_notify: Callable[..., Awaitable[None]] | None = None,\n        ssl_keyfile: str | os.PathLike[str] | None = None,\n        ssl_certfile: str | os.PathLike[str] | None = None,\n        ssl_keyfile_password: str | None = None,\n        ssl_version: int = SSL_PROTOCOL_VERSION,\n        ssl_cert_reqs: int = ssl.CERT_NONE,\n        ssl_ca_certs: str | None = None,\n        ssl_ciphers: str = \"TLSv1\",\n        headers: list[tuple[str, str]] | None = None,\n        factory: bool = False,\n        h11_max_incomplete_event_size: int | None = None,\n    ):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n\n        self.loaded = False\n        self.configure_logging()\n\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n\n        if (reload_dirs or reload_includes or reload_excludes) and not self.should_reload:\n            logger.warning(\n                \"Current configuration will not reload as not all conditions are met, \" \"please refer to documentation.\"\n            )\n\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n\n            reload_dirs_tmp = self.reload_dirs.copy()\n\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:  # pragma: full coverage\n                            pass\n\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)  # pragma: full coverage\n\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning(\n                        \"Provided reload directories %s did not contain valid \"\n                        + \"directories, watching current working directory.\",\n                        reload_dirs,\n                    )\n                self.reload_dirs = [Path(os.getcwd())]\n\n            logger.info(\n                \"Will watch for changes in these directories: %s\",\n                sorted(list(map(str, self.reload_dirs))),\n            )\n\n        if env_file is not None:\n            from dotenv import load_dotenv\n\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n\n        if workers is None and \"WEB_CONCURRENCY\" in os.environ:\n            self.workers = int(os.environ[\"WEB_CONCURRENCY\"])\n\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1\")\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips  # pragma: full coverage\n\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')"
    },
    {
      "chunk_id": 55,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "@property\n    def asgi_version(self) -> Literal[\"2.0\", \"3.0\"]:\n        mapping: dict[str, Literal[\"2.0\", \"3.0\"]] = {\n            \"asgi2\": \"2.0\",\n            \"asgi3\": \"3.0\",\n            \"wsgi\": \"3.0\",\n        }\n        return mapping[self.interface]"
    },
    {
      "chunk_id": 56,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "@property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)"
    },
    {
      "chunk_id": 57,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "@property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)"
    },
    {
      "chunk_id": 58,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, \"TRACE\")\n\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config[\"formatters\"][\"default\"][\"use_colors\"] = self.use_colors\n                    self.log_config[\"formatters\"][\"access\"][\"use_colors\"] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(\".json\"):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith((\".yaml\", \".yml\")):\n                import yaml\n\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger(\"uvicorn.error\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.access\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.asgi\").setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger(\"uvicorn.access\").handlers = []\n            logging.getLogger(\"uvicorn.access\").propagate = False"
    },
    {
      "chunk_id": 59,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def load(self) -> None:\n        assert not self.loaded\n\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(\n                keyfile=self.ssl_keyfile,\n                certfile=self.ssl_certfile,\n                password=self.ssl_keyfile_password,\n                ssl_version=self.ssl_version,\n                cert_reqs=self.ssl_cert_reqs,\n                ca_certs=self.ssl_ca_certs,\n                ciphers=self.ssl_ciphers,\n            )\n        else:\n            self.ssl = None\n\n        encoded_headers = [(key.lower().encode(\"latin1\"), value.encode(\"latin1\")) for key, value in self.headers]\n        self.encoded_headers = (\n            [(b\"server\", b\"uvicorn\")] + encoded_headers\n            if b\"server\" not in dict(encoded_headers) and self.server_header\n            else encoded_headers\n        )\n\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error(\"Error loading ASGI app. %s\" % exc)\n            sys.exit(1)\n\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error(\"Error loading ASGI app factory: %s\", exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning(\n                    \"ASGI app factory detected. Using it, \" \"but please consider setting the --factory flag explicitly.\"\n                )\n\n        if self.interface == \"auto\":\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, \"__await__\")\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, \"__call__\", None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = \"asgi3\" if use_asgi_3 else \"asgi2\"\n\n        if self.interface == \"wsgi\":\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == \"asgi2\":\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n\n        self.loaded = True"
    },
    {
      "chunk_id": 60,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)"
    },
    {
      "chunk_id": 61,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:  # pragma: py-win32\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 0o666\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = \"Uvicorn running on unix socket %s (Press CTRL+C to quit)\"\n            sock_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(sock_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [self.uds]\n        elif self.fd:  # pragma: py-win32\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = \"Uvicorn running on socket %s (Press CTRL+C to quit)\"\n            fd_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(fd_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = \"%s://%s:%d\"\n\n            if self.host and \":\" in self.host:  # pragma: full coverage\n                family = socket.AF_INET6\n                addr_format = \"%s://[%s]:%d\"\n\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            protocol_name = \"https\" if self.is_ssl else \"http\"\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={\"color_message\": color_message})\n        sock.set_inheritable(True)\n        return sock"
    },
    {
      "chunk_id": 62,
      "source": "__internal__/data_repo/uvicorn/uvicorn/config.py",
      "content": "@property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload"
    },
    {
      "chunk_id": 63,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "```"
    },
    {
      "chunk_id": 64,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "\"\"\"\nCopyright (c) Django Software Foundation and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n\n    3. Neither the name of Django nor the names of its contributors may be used\n       to endorse or promote products derived from this software without\n       specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\""
    },
    {
      "chunk_id": 65,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "from __future__ import annotations\n\nimport sys\nimport types\nfrom collections.abc import Awaitable, Iterable, MutableMapping\nfrom typing import Any, Callable, Literal, Optional, Protocol, TypedDict, Union\n\nif sys.version_info >= (3, 11):  # pragma: py-lt-311\n    from typing import NotRequired\nelse:  # pragma: py-gte-311\n    from typing_extensions import NotRequired"
    },
    {
      "chunk_id": 66,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "# WSGI\nEnviron = MutableMapping[str, Any]\nExcInfo = tuple[type[BaseException], BaseException, Optional[types.TracebackType]]\nStartResponse = Callable[[str, Iterable[tuple[str, str]], Optional[ExcInfo]], None]\nWSGIApp = Callable[[Environ, StartResponse], Union[Iterable[bytes], BaseException]]"
    },
    {
      "chunk_id": 67,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class ASGIVersions(TypedDict):\n    spec_version: str\n    version: Literal[\"2.0\"] | Literal[\"3.0\"]"
    },
    {
      "chunk_id": 68,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPScope(TypedDict):\n    type: Literal[\"http\"]\n    asgi: ASGIVersions\n    http_version: str\n    method: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]"
    },
    {
      "chunk_id": 69,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketScope(TypedDict):\n    type: Literal[\"websocket\"]\n    asgi: ASGIVersions\n    http_version: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    subprotocols: Iterable[str]\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]"
    },
    {
      "chunk_id": 70,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanScope(TypedDict):\n    type: Literal[\"lifespan\"]\n    asgi: ASGIVersions\n    state: NotRequired[dict[str, Any]]"
    },
    {
      "chunk_id": 71,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "WWWScope = Union[HTTPScope, WebSocketScope]\nScope = Union[HTTPScope, WebSocketScope, LifespanScope]"
    },
    {
      "chunk_id": 72,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPRequestEvent(TypedDict):\n    type: Literal[\"http.request\"]\n    body: bytes\n    more_body: bool"
    },
    {
      "chunk_id": 73,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseDebugEvent(TypedDict):\n    type: Literal[\"http.response.debug\"]\n    info: dict[str, object]"
    },
    {
      "chunk_id": 74,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseStartEvent(TypedDict):\n    type: Literal[\"http.response.start\"]\n    status: int\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]\n    trailers: NotRequired[bool]"
    },
    {
      "chunk_id": 75,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseBodyEvent(TypedDict):\n    type: Literal[\"http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]"
    },
    {
      "chunk_id": 76,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPResponseTrailersEvent(TypedDict):\n    type: Literal[\"http.response.trailers\"]\n    headers: Iterable[tuple[bytes, bytes]]\n    more_trailers: bool"
    },
    {
      "chunk_id": 77,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPServerPushEvent(TypedDict):\n    type: Literal[\"http.response.push\"]\n    path: str\n    headers: Iterable[tuple[bytes, bytes]]"
    },
    {
      "chunk_id": 78,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class HTTPDisconnectEvent(TypedDict):\n    type: Literal[\"http.disconnect\"]"
    },
    {
      "chunk_id": 79,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketConnectEvent(TypedDict):\n    type: Literal[\"websocket.connect\"]"
    },
    {
      "chunk_id": 80,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketAcceptEvent(TypedDict):\n    type: Literal[\"websocket.accept\"]\n    subprotocol: NotRequired[str | None]\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]"
    },
    {
      "chunk_id": 81,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketReceiveEventBytes(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: bytes\n    text: NotRequired[None]"
    },
    {
      "chunk_id": 82,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketReceiveEventText(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: NotRequired[None]\n    text: str"
    },
    {
      "chunk_id": 83,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "WebSocketReceiveEvent = Union[_WebSocketReceiveEventBytes, _WebSocketReceiveEventText]"
    },
    {
      "chunk_id": 84,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketSendEventBytes(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: bytes\n    text: NotRequired[None]"
    },
    {
      "chunk_id": 85,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class _WebSocketSendEventText(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: NotRequired[None]\n    text: str"
    },
    {
      "chunk_id": 86,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "WebSocketSendEvent = Union[_WebSocketSendEventBytes, _WebSocketSendEventText]"
    },
    {
      "chunk_id": 87,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketResponseStartEvent(TypedDict):\n    type: Literal[\"websocket.http.response.start\"]\n    status: int\n    headers: Iterable[tuple[bytes, bytes]]"
    },
    {
      "chunk_id": 88,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketResponseBodyEvent(TypedDict):\n    type: Literal[\"websocket.http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]"
    },
    {
      "chunk_id": 89,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketDisconnectEvent(TypedDict):\n    type: Literal[\"websocket.disconnect\"]\n    code: int\n    reason: NotRequired[str | None]"
    },
    {
      "chunk_id": 90,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class WebSocketCloseEvent(TypedDict):\n    type: Literal[\"websocket.close\"]\n    code: NotRequired[int]\n    reason: NotRequired[str | None]"
    },
    {
      "chunk_id": 91,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupEvent(TypedDict):\n    type: Literal[\"lifespan.startup\"]"
    },
    {
      "chunk_id": 92,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown\"]"
    },
    {
      "chunk_id": 93,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.startup.complete\"]"
    },
    {
      "chunk_id": 94,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanStartupFailedEvent(TypedDict):\n    type: Literal[\"lifespan.startup.failed\"]\n    message: str"
    },
    {
      "chunk_id": 95,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.complete\"]"
    },
    {
      "chunk_id": 96,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class LifespanShutdownFailedEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.failed\"]\n    message: str"
    },
    {
      "chunk_id": 97,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "WebSocketEvent = Union[WebSocketReceiveEvent, WebSocketDisconnectEvent, WebSocketConnectEvent]"
    },
    {
      "chunk_id": 98,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGIReceiveEvent = Union[\n    HTTPRequestEvent,\n    HTTPDisconnectEvent,\n    WebSocketConnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketDisconnectEvent,\n    LifespanStartupEvent,\n    LifespanShutdownEvent,\n]"
    },
    {
      "chunk_id": 99,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGISendEvent = Union[\n    HTTPResponseStartEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseTrailersEvent,\n    HTTPServerPushEvent,\n    HTTPDisconnectEvent,\n    WebSocketAcceptEvent,\n    WebSocketSendEvent,\n    WebSocketResponseStartEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketCloseEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupFailedEvent,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownFailedEvent,\n]"
    },
    {
      "chunk_id": 100,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGIReceiveCallable = Callable[[], Awaitable[ASGIReceiveEvent]]\nASGISendCallable = Callable[[ASGISendEvent], Awaitable[None]]"
    },
    {
      "chunk_id": 101,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "class ASGI2Protocol(Protocol):\n    def __init__(self, scope: Scope) -> None: ...  # pragma: no cover\n\n    async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None: ...  # pragma: no cover"
    },
    {
      "chunk_id": 102,
      "source": "__internal__/data_repo/uvicorn/uvicorn/_types.py",
      "content": "ASGI2Application = type[ASGI2Protocol]\nASGI3Application = Callable[\n    [\n        Scope,\n        ASGIReceiveCallable,\n        ASGISendCallable,\n    ],\n    Awaitable[None],\n]\nASGIApplication = Union[ASGI2Application, ASGI3Application]\n```"
    },
    {
      "chunk_id": 103,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "from __future__ import annotations"
    },
    {
      "chunk_id": 104,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "from typing import TYPE_CHECKING"
    },
    {
      "chunk_id": 105,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "from uvicorn.supervisors.basereload import BaseReload\nfrom uvicorn.supervisors.multiprocess import Multiprocess"
    },
    {
      "chunk_id": 106,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "if TYPE_CHECKING:\n    ChangeReload: type[BaseReload]\nelse:\n    try:\n        from uvicorn.supervisors.watchfilesreload import WatchFilesReload as ChangeReload\n    except ImportError:  # pragma: no cover\n        from uvicorn.supervisors.statreload import StatReload as ChangeReload"
    },
    {
      "chunk_id": 107,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/__init__.py",
      "content": "__all__ = [\"Multiprocess\", \"ChangeReload\"]"
    },
    {
      "chunk_id": 108,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "from __future__ import annotations\n\nimport logging\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 109,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "class StatReload(BaseReload):\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"StatReload\"\n        self.mtimes: dict[Path, float] = {}\n\n        if config.reload_excludes or config.reload_includes:\n            logger.warning(\"--reload-include and --reload-exclude have no effect unless \" \"watchfiles is installed.\")"
    },
    {
      "chunk_id": 110,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        for file in self.iter_py_files():\n            try:\n                mtime = file.stat().st_mtime\n            except OSError:  # pragma: nocover\n                continue\n\n            old_time = self.mtimes.get(file)\n            if old_time is None:\n                self.mtimes[file] = mtime\n                continue\n            elif mtime > old_time:\n                return [file]\n        return None"
    },
    {
      "chunk_id": 111,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "def restart(self) -> None:\n        self.mtimes = {}\n        return super().restart()"
    },
    {
      "chunk_id": 112,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/statreload.py",
      "content": "def iter_py_files(self) -> Iterator[Path]:\n        for reload_dir in self.config.reload_dirs:\n            for path in list(reload_dir.rglob(\"*.py\")):\n                yield path.resolve()"
    },
    {
      "chunk_id": 113,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport threading\nfrom multiprocessing import Pipe\nfrom socket import socket\nfrom typing import Any, Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nSIGNALS = {\n    getattr(signal, f\"SIG{x}\"): x\n    for x in \"INT TERM BREAK HUP QUIT TTIN TTOU USR1 USR2 WINCH\".split()\n    if hasattr(signal, f\"SIG{x}\")\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 114,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "class Process:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.real_target = target\n\n        self.parent_conn, self.child_conn = Pipe()\n        self.process = get_subprocess(config, self.target, sockets)"
    },
    {
      "chunk_id": 115,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def ping(self, timeout: float = 5) -> bool:\n        self.parent_conn.send(b\"ping\")\n        if self.parent_conn.poll(timeout):\n            self.parent_conn.recv()\n            return True\n        return False"
    },
    {
      "chunk_id": 116,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def pong(self) -> None:\n        self.child_conn.recv()\n        self.child_conn.send(b\"pong\")"
    },
    {
      "chunk_id": 117,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def always_pong(self) -> None:\n        while True:\n            self.pong()"
    },
    {
      "chunk_id": 118,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def target(self, sockets: list[socket] | None = None) -> Any:  # pragma: no cover\n        if os.name == \"nt\":  # pragma: py-not-win32\n            signal.signal(\n                signal.SIGBREAK,  # type: ignore[attr-defined]\n                lambda sig, frame: signal.raise_signal(signal.SIGTERM),\n            )\n\n        threading.Thread(target=self.always_pong, daemon=True).start()\n        return self.real_target(sockets)"
    },
    {
      "chunk_id": 119,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def is_alive(self, timeout: float = 5) -> bool:\n        if not self.process.is_alive():\n            return False  # pragma: full coverage\n\n        return self.ping(timeout)"
    },
    {
      "chunk_id": 120,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def start(self) -> None:\n        self.process.start()"
    },
    {
      "chunk_id": 121,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def terminate(self) -> None:\n        if self.process.exitcode is None:  # Process is still running\n            assert self.process.pid is not None\n            if os.name == \"nt\":  # pragma: py-not-win32\n                os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)  # type: ignore[attr-defined]\n            else:\n                os.kill(self.process.pid, signal.SIGTERM)\n            logger.info(f\"Terminated child process [{self.process.pid}]\")\n\n            self.parent_conn.close()\n            self.child_conn.close()"
    },
    {
      "chunk_id": 122,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def kill(self) -> None:\n        self.process.kill()"
    },
    {
      "chunk_id": 123,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def join(self) -> None:\n        logger.info(f\"Waiting for child process [{self.process.pid}]\")\n        self.process.join()"
    },
    {
      "chunk_id": 124,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "@property\n    def pid(self) -> int | None:\n        return self.process.pid"
    },
    {
      "chunk_id": 125,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "class Multiprocess:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n\n        self.processes_num = config.workers\n        self.processes: list[Process] = []\n\n        self.should_exit = threading.Event()\n\n        self.signal_queue: list[int] = []\n        for sig in SIGNALS:\n            signal.signal(sig, lambda sig, frame: self.signal_queue.append(sig))"
    },
    {
      "chunk_id": 126,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def init_processes(self) -> None:\n        for _ in range(self.processes_num):\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes.append(process)"
    },
    {
      "chunk_id": 127,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def terminate_all(self) -> None:\n        for process in self.processes:\n            process.terminate()"
    },
    {
      "chunk_id": 128,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def join_all(self) -> None:\n        for process in self.processes:\n            process.join()"
    },
    {
      "chunk_id": 129,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def restart_all(self) -> None:\n        for idx, process in enumerate(self.processes):\n            process.terminate()\n            process.join()\n            new_process = Process(self.config, self.target, self.sockets)\n            new_process.start()\n            self.processes[idx] = new_process"
    },
    {
      "chunk_id": 130,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def run(self) -> None:\n        message = f\"Started parent process [{os.getpid()}]\"\n        color_message = \"Started parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n        self.init_processes()\n\n        while not self.should_exit.wait(0.5):\n            self.handle_signals()\n            self.keep_subprocess_alive()\n\n        self.terminate_all()\n        self.join_all()\n\n        message = f\"Stopping parent process [{os.getpid()}]\"\n        color_message = \"Stopping parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})"
    },
    {
      "chunk_id": 131,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def keep_subprocess_alive(self) -> None:\n        if self.should_exit.is_set():\n            return  # parent process is exiting, no need to keep subprocess alive\n\n        for idx, process in enumerate(self.processes):\n            if process.is_alive():\n                continue\n\n            process.kill()  # process is hung, kill it\n            process.join()\n\n            if self.should_exit.is_set():\n                return  # pragma: full coverage\n\n            logger.info(f\"Child process [{process.pid}] died\")\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes[idx] = process"
    },
    {
      "chunk_id": 132,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_signals(self) -> None:\n        for sig in tuple(self.signal_queue):\n            self.signal_queue.remove(sig)\n            sig_name = SIGNALS[sig]\n            sig_handler = getattr(self, f\"handle_{sig_name.lower()}\", None)\n            if sig_handler is not None:\n                sig_handler()\n            else:  # pragma: no cover\n                logger.debug(f\"Received signal {sig_name}, but no handler is defined for it.\")"
    },
    {
      "chunk_id": 133,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_int(self) -> None:\n        logger.info(\"Received SIGINT, exiting.\")\n        self.should_exit.set()"
    },
    {
      "chunk_id": 134,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_term(self) -> None:\n        logger.info(\"Received SIGTERM, exiting.\")\n        self.should_exit.set()"
    },
    {
      "chunk_id": 135,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_break(self) -> None:  # pragma: py-not-win32\n        logger.info(\"Received SIGBREAK, exiting.\")\n        self.should_exit.set()"
    },
    {
      "chunk_id": 136,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_hup(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGHUP, restarting processes.\")\n        self.restart_all()"
    },
    {
      "chunk_id": 137,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_ttin(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTIN, increasing the number of processes.\")\n        self.processes_num += 1\n        process = Process(self.config, self.target, self.sockets)\n        process.start()\n        self.processes.append(process)"
    },
    {
      "chunk_id": 138,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/multiprocess.py",
      "content": "def handle_ttou(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTOU, decreasing number of processes.\")\n        if self.processes_num <= 1:\n            logger.info(\"Already reached one process, cannot decrease the number of processes anymore.\")\n            return\n        self.processes_num -= 1\n        process = self.processes.pop()\n        process.terminate()\n        process.join()"
    },
    {
      "chunk_id": 139,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport sys\nimport threading\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom types import FrameType\nfrom typing import Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 140,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "class BaseReload:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n        self.should_exit = threading.Event()\n        self.pid = os.getpid()\n        self.is_restarting = False\n        self.reloader_name: str | None = None\n\n    def signal_handler(self, sig: int, frame: FrameType | None) -> None:  # pragma: full coverage\n        \"\"\"\n        A signal handler that is registered with the parent process.\n        \"\"\"\n        if sys.platform == \"win32\" and self.is_restarting:\n            self.is_restarting = False\n        else:\n            self.should_exit.set()"
    },
    {
      "chunk_id": 141,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def run(self) -> None:\n        self.startup()\n        for changes in self:\n            if changes:\n                logger.warning(\n                    \"%s detected changes in %s. Reloading...\",\n                    self.reloader_name,\n                    \", \".join(map(_display_path, changes)),\n                )\n                self.restart()\n\n        self.shutdown()"
    },
    {
      "chunk_id": 142,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def pause(self) -> None:\n        if self.should_exit.wait(self.config.reload_delay):\n            raise StopIteration()"
    },
    {
      "chunk_id": 143,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def __iter__(self) -> Iterator[list[Path] | None]:\n        return self"
    },
    {
      "chunk_id": 144,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def __next__(self) -> list[Path] | None:\n        return self.should_restart()"
    },
    {
      "chunk_id": 145,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def startup(self) -> None:\n        message = f\"Started reloader process [{self.pid}] using {self.reloader_name}\"\n        color_message = \"Started reloader process [{}] using {}\".format(\n            click.style(str(self.pid), fg=\"cyan\", bold=True),\n            click.style(str(self.reloader_name), fg=\"cyan\", bold=True),\n        )\n        logger.info(message, extra={\"color_message\": color_message})\n\n        for sig in HANDLED_SIGNALS:\n            signal.signal(sig, self.signal_handler)\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()"
    },
    {
      "chunk_id": 146,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def restart(self) -> None:\n        if sys.platform == \"win32\":  # pragma: py-not-win32\n            self.is_restarting = True\n            assert self.process.pid is not None\n            os.kill(self.process.pid, signal.CTRL_C_EVENT)\n        else:  # pragma: py-win32\n            self.process.terminate()\n        self.process.join()\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()"
    },
    {
      "chunk_id": 147,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def shutdown(self) -> None:\n        if sys.platform == \"win32\":\n            self.should_exit.set()  # pragma: py-not-win32\n        else:\n            self.process.terminate()  # pragma: py-win32\n        self.process.join()\n\n        for sock in self.sockets:\n            sock.close()\n\n        message = f\"Stopping reloader process [{str(self.pid)}]\"\n        color_message = \"Stopping reloader process [{}]\".format(click.style(str(self.pid), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})"
    },
    {
      "chunk_id": 148,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def should_restart(self) -> list[Path] | None:\n        raise NotImplementedError(\"Reload strategies should override should_restart()\")"
    },
    {
      "chunk_id": 149,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/basereload.py",
      "content": "def _display_path(path: Path) -> str:\n    try:\n        return f\"'{path.relative_to(Path.cwd())}'\"\n    except ValueError:\n        return f\"'{path}'\""
    },
    {
      "chunk_id": 150,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom watchfiles import watch\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload"
    },
    {
      "chunk_id": 151,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "class FileFilter:\n    def __init__(self, config: Config):\n        default_includes = [\"*.py\"]\n        self.includes = [default for default in default_includes if default not in config.reload_excludes]\n        self.includes.extend(config.reload_includes)\n        self.includes = list(set(self.includes))\n\n        default_excludes = [\".*\", \".py[cod]\", \".sw.*\", \"~*\"]\n        self.excludes = [default for default in default_excludes if default not in config.reload_includes]\n        self.exclude_dirs = []\n        for e in config.reload_excludes:\n            p = Path(e)\n            try:\n                is_dir = p.is_dir()\n            except OSError:  # pragma: no cover\n                # gets raised on Windows for values like \"*.py\"\n                is_dir = False\n\n            if is_dir:\n                self.exclude_dirs.append(p)\n            else:\n                self.excludes.append(e)  # pragma: full coverage\n        self.excludes = list(set(self.excludes))"
    },
    {
      "chunk_id": 152,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "def __call__(self, path: Path) -> bool:\n        for include_pattern in self.includes:\n            if path.match(include_pattern):\n                if str(path).endswith(include_pattern):\n                    return True  # pragma: full coverage\n\n                for exclude_dir in self.exclude_dirs:\n                    if exclude_dir in path.parents:\n                        return False\n\n                for exclude_pattern in self.excludes:\n                    if path.match(exclude_pattern):\n                        return False  # pragma: full coverage\n\n                return True\n        return False"
    },
    {
      "chunk_id": 153,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "class WatchFilesReload(BaseReload):\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"WatchFiles\"\n        self.reload_dirs = []\n        for directory in config.reload_dirs:\n            if Path.cwd() not in directory.parents:\n                self.reload_dirs.append(directory)\n        if Path.cwd() not in self.reload_dirs:\n            self.reload_dirs.append(Path.cwd())\n\n        self.watch_filter = FileFilter(config)\n        self.watcher = watch(\n            *self.reload_dirs,\n            watch_filter=None,\n            stop_event=self.should_exit,\n            # using yield_on_timeout here mostly to make sure tests don't\n            # hang forever, won't affect the class's behavior\n            yield_on_timeout=True,\n        )"
    },
    {
      "chunk_id": 154,
      "source": "__internal__/data_repo/uvicorn/uvicorn/supervisors/watchfilesreload.py",
      "content": "def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        changes = next(self.watcher)\n        if changes:\n            unique_paths = {Path(c[1]) for c in changes}\n            return [p for p in unique_paths if self.watch_filter(p)]\n        return None"
    },
    {
      "chunk_id": 155,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 156,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/asyncio.py",
      "content": "import asyncio\nimport logging\nimport sys\n\nlogger = logging.getLogger(\"uvicorn.error\")"
    },
    {
      "chunk_id": 157,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/asyncio.py",
      "content": "def asyncio_setup(use_subprocess: bool = False) -> None:\n    if sys.platform == \"win32\" and use_subprocess:\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())  # pragma: full coverage"
    },
    {
      "chunk_id": 158,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/uvloop.py",
      "content": "import asyncio"
    },
    {
      "chunk_id": 159,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/uvloop.py",
      "content": "import uvloop"
    },
    {
      "chunk_id": 160,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/uvloop.py",
      "content": "def uvloop_setup(use_subprocess: bool = False) -> None:\n    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())"
    },
    {
      "chunk_id": 161,
      "source": "__internal__/data_repo/uvicorn/uvicorn/loops/auto.py",
      "content": "def auto_loop_setup(use_subprocess: bool = False) -> None:\n    try:\n        import uvloop  # noqa\n    except ImportError:  # pragma: no cover\n        from uvicorn.loops.asyncio import asyncio_setup as loop_setup\n\n        loop_setup(use_subprocess=use_subprocess)\n    else:  # pragma: no cover\n        from uvicorn.loops.uvloop import uvloop_setup\n\n        uvloop_setup(use_subprocess=use_subprocess)"
    },
    {
      "chunk_id": 162,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 163,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport urllib.parse\n\nfrom uvicorn._types import WWWScope"
    },
    {
      "chunk_id": 164,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "class ClientDisconnected(OSError): ..."
    },
    {
      "chunk_id": 165,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        try:\n            info = socket_info.getpeername()\n            return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n        except OSError:  # pragma: no cover\n            return None\n\n    info = transport.get_extra_info(\"peername\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None"
    },
    {
      "chunk_id": 166,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        info = socket_info.getsockname()\n\n        return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n    info = transport.get_extra_info(\"sockname\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None"
    },
    {
      "chunk_id": 167,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def is_ssl(transport: asyncio.Transport) -> bool:\n    return bool(transport.get_extra_info(\"sslcontext\"))"
    },
    {
      "chunk_id": 168,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_client_addr(scope: WWWScope) -> str:\n    client = scope.get(\"client\")\n    if not client:\n        return \"\"\n    return \"%s:%d\" % client"
    },
    {
      "chunk_id": 169,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/utils.py",
      "content": "def get_path_with_query_string(scope: WWWScope) -> str:\n    path_with_query_string = urllib.parse.quote(scope[\"path\"])\n    if scope[\"query_string\"]:\n        path_with_query_string = \"{}?{}\".format(path_with_query_string, scope[\"query_string\"].decode(\"ascii\"))\n    return path_with_query_string"
    },
    {
      "chunk_id": 170,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 171,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "import asyncio\n\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\n\nCLOSE_HEADER = (b\"connection\", b\"close\")\n\nHIGH_WATER_LIMIT = 65536"
    },
    {
      "chunk_id": 172,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "class FlowControl:\n    def __init__(self, transport: asyncio.Transport) -> None:\n        self._transport = transport\n        self.read_paused = False\n        self.write_paused = False\n        self._is_writable_event = asyncio.Event()\n        self._is_writable_event.set()"
    },
    {
      "chunk_id": 173,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "async def drain(self) -> None:\n        await self._is_writable_event.wait()  # pragma: full coverage"
    },
    {
      "chunk_id": 174,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "def pause_reading(self) -> None:\n        if not self.read_paused:\n            self.read_paused = True\n            self._transport.pause_reading()"
    },
    {
      "chunk_id": 175,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "def resume_reading(self) -> None:\n        if self.read_paused:\n            self.read_paused = False\n            self._transport.resume_reading()"
    },
    {
      "chunk_id": 176,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "def pause_writing(self) -> None:\n        if not self.write_paused:  # pragma: full coverage\n            self.write_paused = True\n            self._is_writable_event.clear()"
    },
    {
      "chunk_id": 177,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "def resume_writing(self) -> None:\n        if self.write_paused:  # pragma: full coverage\n            self.write_paused = False\n            self._is_writable_event.set()"
    },
    {
      "chunk_id": 178,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/flow_control.py",
      "content": "async def service_unavailable(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 503,\n            \"headers\": [\n                (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                (b\"content-length\", b\"19\"),\n                (b\"connection\", b\"close\"),\n            ],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"Service Unavailable\", \"more_body\": False})"
    },
    {
      "chunk_id": 179,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom typing import Any, Callable, Literal, cast\nfrom urllib.parse import unquote\n\nimport h11\nfrom h11._connection import DEFAULT_MAX_INCOMPLETE_EVENT_SIZE\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 180,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "def _get_status_phrase(status_code: int) -> bytes:\n    try:\n        return http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        return b\"\""
    },
    {
      "chunk_id": 181,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "STATUS_PHRASES = {status_code: _get_status_phrase(status_code) for status_code in range(100, 600)}"
    },
    {
      "chunk_id": 182,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "class H11Protocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.conn = h11.Connection(\n            h11.SERVER,\n            config.h11_max_incomplete_event_size\n            if config.h11_max_incomplete_event_size is not None\n            else DEFAULT_MAX_INCOMPLETE_EVENT_SIZE,\n        )\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        # Timeouts\n        self.timeout_keep_alive_task: asyncio.TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        # Shared server state\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Per-connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n\n        # Per-request state\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]"
    },
    {
      "chunk_id": 183,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/h11_impl.py",
      "content": "# Protocol interface\n    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self"
    },
    {
      "chunk_id": 184,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "from __future__ import annotations"
    },
    {
      "chunk_id": 185,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "import asyncio"
    },
    {
      "chunk_id": 186,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/auto.py",
      "content": "AutoHTTPProtocol: type[asyncio.Protocol]\ntry:\n    import httptools  # noqa\nexcept ImportError:  # pragma: no cover\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n\n    AutoHTTPProtocol = H11Protocol\nelse:  # pragma: no cover\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n\n    AutoHTTPProtocol = HttpToolsProtocol"
    },
    {
      "chunk_id": 187,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nimport re\nimport urllib\nfrom asyncio.events import TimerHandle\nfrom collections import deque\nfrom typing import Any, Callable, Literal, cast\n\nimport httptools\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 188,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "HEADER_RE = re.compile(b'[\\x00-\\x1f\\x7f()<>@,;:[]={} \\t\\\\\"]')\nHEADER_VALUE_RE = re.compile(b\"[\\x00-\\x08\\x0a-\\x1f\\x7f]\")"
    },
    {
      "chunk_id": 189,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _get_status_line(status_code: int) -> bytes:\n    try:\n        phrase = http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        phrase = b\"\"\n    return b\"\".join([b\"HTTP/1.1 \", str(status_code).encode(), b\" \", phrase, b\"\\r\\n\"])"
    },
    {
      "chunk_id": 190,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "STATUS_LINE = {status_code: _get_status_line(status_code) for status_code in range(100, 600)}"
    },
    {
      "chunk_id": 191,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "class HttpToolsProtocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.parser = httptools.HttpRequestParser(self)\n\n        try:\n            self.parser.set_dangerous_leniencies(lenient_data_after_close=True)\n        except AttributeError:  # pragma: no cover\n            pass\n\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        self.timeout_keep_alive_task: TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n        self.pipeline: deque[tuple[RequestResponseCycle, ASGI3Application]] = deque()\n\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.expect_100_continue = False\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]"
    },
    {
      "chunk_id": 192,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)"
    },
    {
      "chunk_id": 193,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n\n        self.parser = None"
    },
    {
      "chunk_id": 194,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def eof_received(self) -> None:\n        pass"
    },
    {
      "chunk_id": 195,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None"
    },
    {
      "chunk_id": 196,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None  # pragma: full coverage"
    },
    {
      "chunk_id": 197,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True"
    },
    {
      "chunk_id": 198,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _unsupported_upgrade_warning(self) -> None:\n        self.logger.warning(\"Unsupported upgrade request.\")\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)"
    },
    {
      "chunk_id": 199,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        return upgrade == b\"websocket\" and self._should_upgrade_to_ws()"
    },
    {
      "chunk_id": 200,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        try:\n            self.parser.feed_data(data)\n        except httptools.HttpParserError:\n            msg = \"Invalid HTTP request received.\"\n            self.logger.warning(msg)\n            self.send_400_response(msg)\n            return\n        except httptools.HttpParserUpgrade:\n            if self._should_upgrade():\n                self.handle_websocket_upgrade()\n            else:\n                self._unsupported_upgrade_warning()"
    },
    {
      "chunk_id": 201,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def handle_websocket_upgrade(self) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        method = self.scope[\"method\"].encode()\n        output = [method, b\" \", self.url, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.scope[\"headers\"]:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)"
    },
    {
      "chunk_id": 202,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def send_400_response(self, msg: str) -> None:\n        content = [STATUS_LINE[400]]\n        for name, value in self.server_state.default_headers:\n            content.extend([name, b\": \", value, b\"\\r\\n\"])  # pragma: full coverage\n        content.extend(\n            [\n                b\"content-type: text/plain; charset=utf-8\\r\\n\",\n                b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n                b\"connection: close\\r\\n\",\n                b\"\\r\\n\",\n                msg.encode(\"ascii\"),\n            ]\n        )\n        self.transport.write(b\"\".join(content))\n        self.transport.close()"
    },
    {
      "chunk_id": 203,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_message_begin(self) -> None:\n        self.url = b\"\"\n        self.expect_100_continue = False\n        self.headers = []\n        self.scope = {  # type: ignore[typeddict-item]\n            \"type\": \"http\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n            \"http_version\": \"1.1\",\n            \"server\": self.server,\n            \"client\": self.client,\n            \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n            \"root_path\": self.root_path,\n            \"headers\": self.headers,\n            \"state\": self.app_state.copy(),\n        }"
    },
    {
      "chunk_id": 204,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_url(self, url: bytes) -> None:\n        self.url += url"
    },
    {
      "chunk_id": 205,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_header(self, name: bytes, value: bytes) -> None:\n        name = name.lower()\n        if name == b\"expect\" and value.lower() == b\"100-continue\":\n            self.expect_100_continue = True\n        self.headers.append((name, value))"
    },
    {
      "chunk_id": 206,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_headers_complete(self) -> None:\n        http_version = self.parser.get_http_version()\n        method = self.parser.get_method()\n        self.scope[\"method\"] = method.decode(\"ascii\")\n        if http_version != \"1.1\":\n            self.scope[\"http_version\"] = http_version\n        if self.parser.should_upgrade() and self._should_upgrade():\n            return\n        parsed_url = httptools.parse_url(self.url)\n        raw_path = parsed_url.path\n        path = raw_path.decode(\"ascii\")\n        if \"%\" in path:\n            path = urllib.parse.unquote(path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n        self.scope[\"path\"] = full_path\n        self.scope[\"raw_path\"] = full_raw_path\n        self.scope[\"query_string\"] = parsed_url.query or b\"\"\n\n        if self.limit_concurrency is not None and (\n            len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n        ):\n            app = service_unavailable\n            message = \"Exceeded concurrency limit.\"\n            self.logger.warning(message)\n        else:\n            app = self.app\n\n        existing_cycle = self.cycle\n        self.cycle = RequestResponseCycle(\n            scope=self.scope,\n            transport=self.transport,\n            flow=self.flow,\n            logger=self.logger,\n            access_logger=self.access_logger,\n            access_log=self.access_log,\n            default_headers=self.server_state.default_headers,\n            message_event=asyncio.Event(),\n            expect_100_continue=self.expect_100_continue,\n            keep_alive=http_version != \"1.0\",\n            on_response=self.on_response_complete,\n        )\n        if existing_cycle is None or existing_cycle.response_complete:\n            task = self.loop.create_task(self.cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.flow.pause_reading()\n            self.pipeline.appendleft((self.cycle, app))"
    },
    {
      "chunk_id": 207,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_body(self, body: bytes) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.body += body\n        if len(self.cycle.body) > HIGH_WATER_LIMIT:\n            self.flow.pause_reading()\n        self.cycle.message_event.set()"
    },
    {
      "chunk_id": 208,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_message_complete(self) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.more_body = False\n        self.cycle.message_event.set()"
    },
    {
      "chunk_id": 209,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def on_response_complete(self) -> None:\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        self._unset_keepalive_if_required()\n\n        self.flow.resume_reading()\n\n        if self.pipeline:\n            cycle, app = self.pipeline.pop()\n            task = self.loop.create_task(cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.timeout_keep_alive_task = self.loop.call_later(\n                self.timeout_keep_alive, self.timeout_keep_alive_handler\n            )"
    },
    {
      "chunk_id": 210,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def shutdown(self) -> None:\n        \"\"\"\n        Called by the server to commence a graceful shutdown.\n        \"\"\"\n        if self.cycle is None or self.cycle.response_complete:\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False"
    },
    {
      "chunk_id": 211,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.flow.pause_writing()  # pragma: full coverage"
    },
    {
      "chunk_id": 212,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.flow.resume_writing()  # pragma: full coverage"
    },
    {
      "chunk_id": 213,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "def timeout_keep_alive_handler(self) -> None:\n        \"\"\"\n        Called on a keep-alive connection if no new data is received after a short\n        delay.\n        \"\"\"\n        if not self.transport.is_closing():\n            self.transport.close()"
    },
    {
      "chunk_id": 214,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "class RequestResponseCycle:\n    def __init__(\n        self,\n        scope: HTTPScope,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        expect_100_continue: bool,\n        keep_alive: bool,\n        on_response: Callable[..., None],\n    ):\n        self.scope = scope\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        self.disconnected = False\n        self.keep_alive = keep_alive\n        self.waiting_for_100_continue = expect_100_continue\n\n        self.body = b\"\"\n        self.more_body = True\n\n        self.response_started = False\n        self.response_complete = False\n        self.chunked_encoding: bool | None = None\n        self.expected_content_length = 0"
    },
    {
      "chunk_id": 215,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None"
    },
    {
      "chunk_id": 216,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "async def send_500_response(self) -> None:\n        await self.send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 500,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                    (b\"content-length\", b\"21\"),\n                    (b\"connection\", b\"close\"),\n                ],\n            }\n        )\n        await self.send({\"type\": \"http.response.body\", \"body\": b\"Internal Server Error\", \"more_body\": False})"
    },
    {
      "chunk_id": 217,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status_code = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status_code,\n                )\n\n            content = [STATUS_LINE[status_code]]\n\n            for name, value in headers:\n                if HEADER_RE.search(name):\n                    raise RuntimeError(\"Invalid HTTP header name.\")  # pragma: full coverage\n                if HEADER_VALUE_RE.search(value):\n                    raise RuntimeError(\"Invalid HTTP header value.\")\n\n                name = name.lower()\n                if name == b\"content-length\" and self.chunked_encoding is None:\n                    self.expected_content_length = int(value.decode())\n                    self.chunked_encoding = False\n                elif name == b\"transfer-encoding\" and value.lower() == b\"chunked\":\n                    self.expected_content_length = 0\n                    self.chunked_encoding = True\n                elif name == b\"connection\" and value.lower() == b\"close\":\n                    self.keep_alive = False\n                content.extend([name, b\": \", value, b\"\\r\\n\"])\n\n            if self.chunked_encoding is None and self.scope[\"method\"] != \"HEAD\" and status_code not in (204, 304):\n                self.chunked_encoding = True\n                content.append(b\"transfer-encoding: chunked\\r\\n\")\n\n            content.append(b\"\\r\\n\")\n            self.transport.write(b\"\".join(content))\n\n        elif not self.response_complete:\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n            body = cast(bytes, message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n\n            if self.scope[\"method\"] == \"HEAD\":\n                self.expected_content_length = 0\n            elif self.chunked_encoding:\n                if body:\n                    content = [b\"%x\\r\\n\" % len(body), body, b\"\\r\\n\"]\n                else:\n                    content = []\n                if not more_body:\n                    content.append(b\"0\\r\\n\\r\\n\")\n                self.transport.write(b\"\".join(content))\n            else:\n                num_bytes = len(body)\n                if num_bytes > self.expected_content_length:\n                    raise RuntimeError(\"Response content longer than Content-Length\")\n                else:\n                    self.expected_content_length -= num_bytes\n                self.transport.write(body)\n\n            if not more_body:\n                if self.expected_content_length != 0:\n                    raise RuntimeError(\"Response content shorter than Content-Length\")\n                self.response_complete = True\n                self.message_event.set()\n                if not self.keep_alive:\n                    self.transport.close()\n                self.on_response()\n\n        else:\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)"
    },
    {
      "chunk_id": 218,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/http/httptools_impl.py",
      "content": "async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n        message: HTTPRequestEvent = {\"type\": \"http.request\", \"body\": self.body, \"more_body\": self.more_body}\n        self.body = b\"\"\n        return message"
    },
    {
      "chunk_id": 219,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 220,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport typing\nfrom typing import Literal, cast\nfrom urllib.parse import unquote\n\nimport wsproto\nfrom wsproto import ConnectionType, events\nfrom wsproto.connection import ConnectionState\nfrom wsproto.extensions import Extension, PerMessageDeflate\nfrom wsproto.utilities import LocalProtocolError, RemoteProtocolError\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 221,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "class WSProtocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, typing.Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()  # pragma: full coverage\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n        self.default_headers = server_state.default_headers\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # WebSocket state\n        self.queue: asyncio.Queue[WebSocketEvent] = asyncio.Queue()\n        self.handshake_complete = False\n        self.close_sent = False\n\n        # Rejection state\n        self.response_started = False\n\n        self.conn = wsproto.WSConnection(connection_type=ConnectionType.SERVER)\n\n        self.read_paused = False\n        self.writable = asyncio.Event()\n        self.writable.set()\n\n        # Buffers\n        self.bytes = b\"\"\n        self.text = \"\""
    },
    {
      "chunk_id": 222,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)"
    },
    {
      "chunk_id": 223,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def connection_lost(self, exc: Exception | None) -> None:\n        code = 1005 if self.handshake_complete else 1006\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code})\n        self.connections.remove(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.handshake_complete = True\n        if exc is None:\n            self.transport.close()"
    },
    {
      "chunk_id": 224,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def eof_received(self) -> None:\n        pass"
    },
    {
      "chunk_id": 225,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def data_received(self, data: bytes) -> None:\n        try:\n            self.conn.receive_data(data)\n        except RemoteProtocolError as err:\n            # TODO: Remove `type: ignore` when wsproto fixes the type annotation.\n            self.transport.write(self.conn.send(err.event_hint))  # type: ignore[arg-type]  # noqa: E501\n            self.transport.close()\n        else:\n            self.handle_events()"
    },
    {
      "chunk_id": 226,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_events(self) -> None:\n        for event in self.conn.events():\n            if isinstance(event, events.Request):\n                self.handle_connect(event)\n            elif isinstance(event, events.TextMessage):\n                self.handle_text(event)\n            elif isinstance(event, events.BytesMessage):\n                self.handle_bytes(event)\n            elif isinstance(event, events.CloseConnection):\n                self.handle_close(event)\n            elif isinstance(event, events.Ping):\n                self.handle_ping(event)"
    },
    {
      "chunk_id": 227,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.writable.clear()  # pragma: full coverage"
    },
    {
      "chunk_id": 228,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.writable.set()  # pragma: full coverage"
    },
    {
      "chunk_id": 229,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def shutdown(self) -> None:\n        if self.handshake_complete:\n            self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1012})\n            output = self.conn.send(wsproto.events.CloseConnection(code=1012))\n            self.transport.write(output)\n        else:\n            self.send_500_response()\n        self.transport.close()"
    },
    {
      "chunk_id": 230,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)"
    },
    {
      "chunk_id": 231,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_connect(self, event: events.Request) -> None:\n        headers = [(b\"host\", event.host.encode())]\n        headers += [(key.lower(), value) for key, value in event.extra_headers]\n        raw_path, _, query_string = event.target.partition(\"?\")\n        path = unquote(raw_path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path.encode(\"ascii\")\n        self.scope: WebSocketScope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": headers,\n            \"subprotocols\": event.subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        self.queue.put_nowait({\"type\": \"websocket.connect\"})\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)"
    },
    {
      "chunk_id": 232,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_text(self, event: events.TextMessage) -> None:\n        self.text += event.data\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"text\": self.text})\n            self.text = \"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()"
    },
    {
      "chunk_id": 233,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_bytes(self, event: events.BytesMessage) -> None:\n        self.bytes += event.data\n        # todo: we may want to guard the size of self.bytes and self.text\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"bytes\": self.bytes})\n            self.bytes = b\"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()"
    },
    {
      "chunk_id": 234,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_close(self, event: events.CloseConnection) -> None:\n        if self.conn.state == ConnectionState.REMOTE_CLOSING:\n            self.transport.write(self.conn.send(event.response()))\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": event.code, \"reason\": event.reason})\n        self.transport.close()"
    },
    {
      "chunk_id": 235,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def handle_ping(self, event: events.Ping) -> None:\n        self.transport.write(self.conn.send(event.response()))"
    },
    {
      "chunk_id": 236,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "def send_500_response(self) -> None:\n        if self.response_started or self.handshake_complete:\n            return  # we cannot send responses anymore\n        headers: list[tuple[bytes, bytes]] = [\n            (b\"content-type\", b\"text/plain; charset=utf-8\"),\n            (b\"connection\", b\"close\"),\n            (b\"content-length\", b\"21\"),\n        ]\n        output = self.conn.send(wsproto.events.RejectConnection(status_code=500, headers=headers, has_body=True))\n        output += self.conn.send(wsproto.events.RejectData(data=b\"Internal Server Error\"))\n        self.transport.write(output)"
    },
    {
      "chunk_id": 237,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "async def run_asgi(self) -> None:\n        try:\n            result = await self.app(self.scope, self.receive, self.send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:\n            self.transport.close()  # pragma: full coverage\n        except BaseException:\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            self.send_500_response()\n            self.transport.close()\n        else:\n            if not self.handshake_complete:\n                self.logger.error(\"ASGI callable returned without completing handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                self.transport.close()"
    },
    {
      "chunk_id": 238,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "async def send(self, message: ASGISendEvent) -> None:\n        await self.writable.wait()\n\n        message_type = message[\"type\"]\n\n        if not self.handshake_complete:\n            if message_type == \"websocket.accept\":\n                message = typing.cast(WebSocketAcceptEvent, message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                subprotocol = message.get(\"subprotocol\")\n                extra_headers = self.default_headers + list(message.get(\"headers\", []))\n                extensions: list[Extension] = []\n                if self.config.ws_per_message_deflate:\n                    extensions.append(PerMessageDeflate())\n                if not self.transport.is_closing():\n                    self.handshake_complete = True\n                    output = self.conn.send(\n                        wsproto.events.AcceptConnection(\n                            subprotocol=subprotocol,\n                            extensions=extensions,\n                            extra_headers=extra_headers,\n                        )\n                    )\n                    self.transport.write(output)\n\n            elif message_type == \"websocket.close\":\n                self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.handshake_complete = True\n                self.close_sent = True\n                event = events.RejectConnection(status_code=403, headers=[])\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.transport.close()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = typing.cast(WebSocketResponseStartEvent, message)\n                # ensure status code is in the valid range\n                if not (100 <= message[\"status\"] < 600):\n                    msg = \"Invalid HTTP status code '%d' in response.\"\n                    raise RuntimeError(msg % message[\"status\"])\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                self.handshake_complete = True\n                event = events.RejectConnection(\n                    status_code=message[\"status\"],\n                    headers=list(message[\"headers\"]),\n                    has_body=True,\n                )\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.response_started = True\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close' \"\n                    \"or 'websocket.http.response.start' \"\n                    \"but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.close_sent and not self.response_started:\n            try:\n                if message_type == \"websocket.send\":\n                    message = typing.cast(WebSocketSendEvent, message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    output = self.conn.send(wsproto.events.Message(data=data))  # type: ignore\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n\n                elif message_type == \"websocket.close\":\n                    message = typing.cast(WebSocketCloseEvent, message)\n                    self.close_sent = True\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n                    output = self.conn.send(wsproto.events.CloseConnection(code=code, reason=reason))\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n                        self.transport.close()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close',\" \" but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except LocalProtocolError as exc:\n                raise ClientDisconnected from exc\n        elif self.response_started:\n            if message_type == \"websocket.http.response.body\":\n                message = typing.cast(\"WebSocketResponseBodyEvent\", message)\n                body_finished = not message.get(\"more_body\", False)\n                reject_data = events.RejectData(data=message[\"body\"], body_finished=body_finished)\n                output = self.conn.send(reject_data)\n                self.transport.write(output)\n\n                if body_finished:\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                    self.close_sent = True\n                    self.transport.close()\n\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' \" \"but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close'.\"\n            raise RuntimeError(msg % message_type)"
    },
    {
      "chunk_id": 239,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/wsproto_impl.py",
      "content": "async def receive(self) -> WebSocketEvent:\n        message = await self.queue.get()\n        if self.read_paused and self.queue.empty():\n            self.read_paused = False\n            self.transport.resume_reading()\n        return message"
    },
    {
      "chunk_id": 240,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom collections.abc import Sequence\nfrom typing import Any, Literal, Optional, cast\nfrom urllib.parse import unquote\n\nimport websockets\nimport websockets.legacy.handshake\nfrom websockets.datastructures import Headers\nfrom websockets.exceptions import ConnectionClosed\nfrom websockets.extensions.base import ServerExtensionFactory\nfrom websockets.extensions.permessage_deflate import ServerPerMessageDeflateFactory\nfrom websockets.legacy.server import HTTPResponse\nfrom websockets.server import WebSocketServerProtocol\nfrom websockets.typing import Subprotocol\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketConnectEvent,\n    WebSocketDisconnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState"
    },
    {
      "chunk_id": 241,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "class Server:\n    closing = False\n\n    def register(self, ws: WebSocketServerProtocol) -> None:\n        pass\n\n    def unregister(self, ws: WebSocketServerProtocol) -> None:\n        pass\n\n    def is_serving(self) -> bool:\n        return not self.closing"
    },
    {
      "chunk_id": 242,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "class WebSocketProtocol(WebSocketServerProtocol):\n    extra_headers: list[tuple[str, str]]\n    logger: logging.Logger | logging.LoggerAdapter[Any]\n\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ):\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # Connection events\n        self.scope: WebSocketScope\n        self.handshake_started_event = asyncio.Event()\n        self.handshake_completed_event = asyncio.Event()\n        self.closed_event = asyncio.Event()\n        self.initial_response: HTTPResponse | None = None\n        self.connect_sent = False\n        self.lost_connection_before_handshake = False\n        self.accepted_subprotocol: Subprotocol | None = None\n\n        self.ws_server: Server = Server()  # type: ignore[assignment]\n\n        extensions: list[ServerExtensionFactory] = []\n        if self.config.ws_per_message_deflate:\n            extensions.append(ServerPerMessageDeflateFactory())\n\n        super().__init__(\n            ws_handler=self.ws_handler,\n            ws_server=self.ws_server,  # type: ignore[arg-type]\n            max_size=self.config.ws_max_size,\n            max_queue=self.config.ws_max_queue,\n            ping_interval=self.config.ws_ping_interval,\n            ping_timeout=self.config.ws_ping_timeout,\n            extensions=extensions,\n            logger=logging.getLogger(\"uvicorn.error\"),\n        )\n        self.server_header = None\n        self.extra_headers = [\n            (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in server_state.default_headers\n        ]"
    },
    {
      "chunk_id": 243,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n\n        super().connection_made(transport)"
    },
    {
      "chunk_id": 244,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.remove(self)\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.lost_connection_before_handshake = not self.handshake_completed_event.is_set()\n        self.handshake_completed_event.set()\n        super().connection_lost(exc)\n        if exc is None:\n            self.transport.close()"
    },
    {
      "chunk_id": 245,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def shutdown(self) -> None:\n        self.ws_server.closing = True\n        if self.handshake_completed_event.is_set():\n            self.fail_connection(1012)\n        else:\n            self.send_500_response()\n        self.transport.close()"
    },
    {
      "chunk_id": 246,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)"
    },
    {
      "chunk_id": 247,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "async def process_request(self, path: str, request_headers: Headers) -> HTTPResponse | None:\n        \"\"\"\n        This hook is called to determine if the websocket should return\n        an HTTP response and close.\n\n        Our behavior here is to start the ASGI application, and then wait\n        for either `accept` or `close` in order to determine if we should\n        close the connection.\n        \"\"\"\n        path_portion, _, query_string = path.partition(\"?\")\n\n        websockets.legacy.handshake.check_request(request_headers)\n\n        subprotocols: list[str] = []\n        for header in request_headers.get_all(\"Sec-WebSocket-Protocol\"):\n            subprotocols.extend([token.strip() for token in header.split(\",\")])\n\n        asgi_headers = [\n            (name.encode(\"ascii\"), value.encode(\"ascii\", errors=\"surrogateescape\"))\n            for name, value in request_headers.raw_items()\n        ]\n        path = unquote(path_portion)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + path_portion.encode(\"ascii\")\n\n        self.scope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": asgi_headers,\n            \"subprotocols\": subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n        await self.handshake_started_event.wait()\n        return self.initial_response"
    },
    {
      "chunk_id": 248,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def process_subprotocol(\n        self, headers: Headers, available_subprotocols: Sequence[Subprotocol] | None\n    ) -> Subprotocol | None:\n        \"\"\"\n        We override the standard 'process_subprotocol' behavior here so that\n        we return whatever subprotocol is sent in the 'accept' message.\n        \"\"\"\n        return self.accepted_subprotocol"
    },
    {
      "chunk_id": 249,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "def send_500_response(self) -> None:\n        msg = b\"Internal Server Error\"\n        content = [\n            b\"HTTP/1.1 500 Internal Server Error\\r\\n\" b\"content-type: text/plain; charset=utf-8\\r\\n\",\n            b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n            b\"connection: close\\r\\n\",\n            b\"\\r\\n\",\n            msg,\n        ]\n        self.transport.write(b\"\".join(content))\n        # Allow handler task to terminate cleanly, as websockets doesn't cancel it by\n        # itself (see https://github.com/encode/uvicorn/issues/920)\n        self.handshake_started_event.set()"
    },
    {
      "chunk_id": 250,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "async def ws_handler(self, protocol: WebSocketServerProtocol, path: str) -> Any:  # type: ignore[override]\n        \"\"\"\n        This is the main handler function for the 'websockets' implementation\n        to call into. We just wait for close then return, and instead allow\n        'send' and 'receive' events to drive the flow.\n        \"\"\"\n        self.handshake_completed_event.set()\n        await self.wait_closed()"
    },
    {
      "chunk_id": 251,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "async def run_asgi(self) -> None:\n        \"\"\"\n        Wrapper around the ASGI callable, handling exceptions and unexpected\n        termination states.\n        \"\"\"\n        try:\n            result = await self.app(self.scope, self.asgi_receive, self.asgi_send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:  # pragma: full coverage\n            self.closed_event.set()\n            self.transport.close()\n        except BaseException:\n            self.closed_event.set()\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            if not self.handshake_started_event.is_set():\n                self.send_500_response()\n            else:\n                await self.handshake_completed_event.wait()\n            self.transport.close()\n        else:\n            self.closed_event.set()\n            if not self.handshake_started_event.is_set():\n                self.logger.error(\"ASGI callable returned without sending handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                await self.handshake_completed_event.wait()\n                self.transport.close()"
    },
    {
      "chunk_id": 252,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "async def asgi_send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if not self.handshake_started_event.is_set():\n            if message_type == \"websocket.accept\":\n                message = cast(\"WebSocketAcceptEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = None\n                self.accepted_subprotocol = cast(Optional[Subprotocol], message.get(\"subprotocol\"))\n                if \"headers\" in message:\n                    self.extra_headers.extend(\n                        # ASGI spec requires bytes\n                        # But for compatibility we need to convert it to strings\n                        (name.decode(\"latin-1\"), value.decode(\"latin-1\"))\n                        for name, value in message[\"headers\"]\n                    )\n                self.handshake_started_event.set()\n\n            elif message_type == \"websocket.close\":\n                message = cast(\"WebSocketCloseEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = (http.HTTPStatus.FORBIDDEN, [], b\"\")\n                self.handshake_started_event.set()\n                self.closed_event.set()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = cast(\"WebSocketResponseStartEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                # websockets requires the status to be an enum. look it up.\n                status = http.HTTPStatus(message[\"status\"])\n                headers = [\n                    (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in message.get(\"headers\", [])\n                ]\n                self.initial_response = (status, headers, b\"\")\n                self.handshake_started_event.set()\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close', \"\n                    \"or 'websocket.http.response.start' but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.closed_event.is_set() and self.initial_response is None:\n            await self.handshake_completed_event.wait()\n\n            try:\n                if message_type == \"websocket.send\":\n                    message = cast(\"WebSocketSendEvent\", message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    await self.send(data)  # type: ignore[arg-type]\n\n                elif message_type == \"websocket.close\":\n                    message = cast(\"WebSocketCloseEvent\", message)\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    await self.close(code, reason)\n                    self.closed_event.set()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close',\" \" but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except ConnectionClosed as exc:\n                raise ClientDisconnected from exc\n\n        elif self.initial_response is not None:\n            if message_type == \"websocket.http.response.body\":\n                message = cast(\"WebSocketResponseBodyEvent\", message)\n                body = self.initial_response[2] + message[\"body\"]\n                self.initial_response = self.initial_response[:2] + (body,)\n                if not message.get(\"more_body\", False):\n                    self.closed_event.set()\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' \" \"but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close' \" \"or response already completed.\"\n            raise RuntimeError(msg % message_type)"
    },
    {
      "chunk_id": 253,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/websockets_impl.py",
      "content": "async def asgi_receive(self) -> WebSocketDisconnectEvent | WebSocketConnectEvent | WebSocketReceiveEvent:\n        if not self.connect_sent:\n            self.connect_sent = True\n            return {\"type\": \"websocket.connect\"}\n\n        await self.handshake_completed_event.wait()\n\n        if self.lost_connection_before_handshake:\n            # If the handshake failed or the app closed before handshake completion,\n            # use 1006 Abnormal Closure.\n            return {\"type\": \"websocket.disconnect\", \"code\": 1006}\n\n        if self.closed_event.is_set():\n            return {\"type\": \"websocket.disconnect\", \"code\": 1005}\n\n        try:\n            data = await self.recv()\n        except ConnectionClosed:\n            self.closed_event.set()\n            if self.ws_server.closing:\n                return {\"type\": \"websocket.disconnect\", \"code\": 1012}\n            return {\"type\": \"websocket.disconnect\", \"code\": self.close_code or 1005, \"reason\": self.close_reason}\n\n        if isinstance(data, str):\n            return {\"type\": \"websocket.receive\", \"text\": data}\n        return {\"type\": \"websocket.receive\", \"bytes\": data}"
    },
    {
      "chunk_id": 254,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/auto.py",
      "content": "from __future__ import annotations"
    },
    {
      "chunk_id": 255,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/auto.py",
      "content": "import asyncio\nimport typing"
    },
    {
      "chunk_id": 256,
      "source": "__internal__/data_repo/uvicorn/uvicorn/protocols/websockets/auto.py",
      "content": "AutoWebSocketsProtocol: typing.Callable[..., asyncio.Protocol] | None\ntry:\n    import websockets  # noqa\nexcept ImportError:  # pragma: no cover\n    try:\n        import wsproto  # noqa\n    except ImportError:\n        AutoWebSocketsProtocol = None\n    else:\n        from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n        AutoWebSocketsProtocol = WSProtocol\nelse:\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n\n    AutoWebSocketsProtocol = WebSocketProtocol"
    },
    {
      "chunk_id": 257,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/asgi2.py",
      "content": "from uvicorn._types import (\n    ASGI2Application,\n    ASGIReceiveCallable,\n    ASGISendCallable,\n    Scope,\n)"
    },
    {
      "chunk_id": 258,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/asgi2.py",
      "content": "class ASGI2Middleware:\n    def __init__(self, app: \"ASGI2Application\"):\n        self.app = app"
    },
    {
      "chunk_id": 259,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/asgi2.py",
      "content": "async def __call__(self, scope: \"Scope\", receive: \"ASGIReceiveCallable\", send: \"ASGISendCallable\") -> None:\n        instance = self.app(scope)\n        await instance(receive, send)"
    },
    {
      "chunk_id": 260,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 261,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "from __future__ import annotations\n\nimport ipaddress\n\nfrom uvicorn._types import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope"
    },
    {
      "chunk_id": 262,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "class ProxyHeadersMiddleware:\n    \"\"\"Middleware for handling known proxy headers\n\n    This middleware can be used when a known proxy is fronting the application,\n    and is trusted to be properly setting the `X-Forwarded-Proto` and\n    `X-Forwarded-For` headers with the connecting client information.\n\n    Modifies the `client` and `scheme` information so that they reference\n    the connecting client, rather that the connecting proxy.\n\n    References:\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#Proxies>\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For>\n    \"\"\"\n\n    def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str = \"127.0.0.1\") -> None:\n        self.app = app\n        self.trusted_hosts = _TrustedHosts(trusted_hosts)"
    },
    {
      "chunk_id": 263,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        if scope[\"type\"] == \"lifespan\":\n            return await self.app(scope, receive, send)\n\n        client_addr = scope.get(\"client\")\n        client_host = client_addr[0] if client_addr else None\n\n        if client_host in self.trusted_hosts:\n            headers = dict(scope[\"headers\"])\n\n            if b\"x-forwarded-proto\" in headers:\n                x_forwarded_proto = headers[b\"x-forwarded-proto\"].decode(\"latin1\").strip()\n\n                if x_forwarded_proto in {\"http\", \"https\", \"ws\", \"wss\"}:\n                    if scope[\"type\"] == \"websocket\":\n                        scope[\"scheme\"] = x_forwarded_proto.replace(\"http\", \"ws\")\n                    else:\n                        scope[\"scheme\"] = x_forwarded_proto\n\n            if b\"x-forwarded-for\" in headers:\n                x_forwarded_for = headers[b\"x-forwarded-for\"].decode(\"latin1\")\n                host = self.trusted_hosts.get_trusted_client_host(x_forwarded_for)\n\n                if host:\n                    # If the x-forwarded-for header is empty then host is an empty string.\n                    # Only set the client if we actually got something usable.\n                    # See: https://github.com/encode/uvicorn/issues/1068\n\n                    # We've lost the connecting client's port information by now,\n                    # so only include the host.\n                    port = 0\n                    scope[\"client\"] = (host, port)\n\n        return await self.app(scope, receive, send)"
    },
    {
      "chunk_id": 264,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "def _parse_raw_hosts(value: str) -> list[str]:\n    return [item.strip() for item in value.split(\",\")]"
    },
    {
      "chunk_id": 265,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "class _TrustedHosts:\n    \"\"\"Container for trusted hosts and networks\"\"\"\n\n    def __init__(self, trusted_hosts: list[str] | str) -> None:\n        self.always_trust: bool = trusted_hosts in (\"*\", [\"*\"])\n\n        self.trusted_literals: set[str] = set()\n        self.trusted_hosts: set[ipaddress.IPv4Address | ipaddress.IPv6Address] = set()\n        self.trusted_networks: set[ipaddress.IPv4Network | ipaddress.IPv6Network] = set()\n\n        # Notes:\n        # - We separate hosts from literals as there are many ways to write\n        #   an IPv6 Address so we need to compare by object.\n        # - We don't convert IP Address to single host networks (e.g. /32 / 128) as\n        #   it more efficient to do an address lookup in a set than check for\n        #   membership in each network.\n        # - We still allow literals as it might be possible that we receive a\n        #   something that isn't an IP Address e.g. a unix socket.\n\n        if not self.always_trust:\n            if isinstance(trusted_hosts, str):\n                trusted_hosts = _parse_raw_hosts(trusted_hosts)\n\n            for host in trusted_hosts:\n                # Note: because we always convert invalid IP types to literals it\n                # is not possible for the user to know they provided a malformed IP\n                # type - this may lead to unexpected / difficult to debug behaviour.\n\n                if \"/\" in host:\n                    # Looks like a network\n                    try:\n                        self.trusted_networks.add(ipaddress.ip_network(host))\n                    except ValueError:\n                        # Was not a valid IP Network\n                        self.trusted_literals.add(host)\n                else:\n                    try:\n                        self.trusted_hosts.add(ipaddress.ip_address(host))\n                    except ValueError:\n                        # Was not a valid IP Address\n                        self.trusted_literals.add(host)"
    },
    {
      "chunk_id": 266,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "def __contains__(self, host: str | None) -> bool:\n        if self.always_trust:\n            return True\n\n        if not host:\n            return False\n\n        try:\n            ip = ipaddress.ip_address(host)\n            if ip in self.trusted_hosts:\n                return True\n            return any(ip in net for net in self.trusted_networks)\n\n        except ValueError:\n            return host in self.trusted_literals"
    },
    {
      "chunk_id": 267,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/proxy_headers.py",
      "content": "def get_trusted_client_host(self, x_forwarded_for: str) -> str:\n        \"\"\"Extract the client host from x_forwarded_for header\n\n        In general this is the first \"untrusted\" host in the forwarded for list.\n        \"\"\"\n        x_forwarded_for_hosts = _parse_raw_hosts(x_forwarded_for)\n\n        if self.always_trust:\n            return x_forwarded_for_hosts[0]\n\n        # Note: each proxy appends to the header list so check it in reverse order\n        for host in reversed(x_forwarded_for_hosts):\n            if host not in self:\n                return host\n\n        # All hosts are trusted meaning that the client was also a trusted proxy\n        # See https://github.com/encode/uvicorn/issues/1068#issuecomment-855371576\n        return x_forwarded_for_hosts[0]"
    },
    {
      "chunk_id": 268,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport concurrent.futures\nimport io\nimport sys\nimport warnings\nfrom collections import deque\nfrom collections.abc import Iterable\n\nfrom uvicorn._types import (\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    ASGISendEvent,\n    Environ,\n    ExcInfo,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n    StartResponse,\n    WSGIApp,\n)"
    },
    {
      "chunk_id": 269,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "def build_environ(scope: HTTPScope, message: ASGIReceiveEvent, body: io.BytesIO) -> Environ:\n    \"\"\"\n    Builds a scope and request message into a WSGI environ object.\n    \"\"\"\n    script_name = scope.get(\"root_path\", \"\").encode(\"utf8\").decode(\"latin1\")\n    path_info = scope[\"path\"].encode(\"utf8\").decode(\"latin1\")\n    if path_info.startswith(script_name):\n        path_info = path_info[len(script_name) :]\n    environ = {\n        \"REQUEST_METHOD\": scope[\"method\"],\n        \"SCRIPT_NAME\": script_name,\n        \"PATH_INFO\": path_info,\n        \"QUERY_STRING\": scope[\"query_string\"].decode(\"ascii\"),\n        \"SERVER_PROTOCOL\": \"HTTP/%s\" % scope[\"http_version\"],\n        \"wsgi.version\": (1, 0),\n        \"wsgi.url_scheme\": scope.get(\"scheme\", \"http\"),\n        \"wsgi.input\": body,\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multithread\": True,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.run_once\": False,\n    }\n\n    # Get server name and port - required in WSGI, not in ASGI\n    server = scope.get(\"server\")\n    if server is None:\n        server = (\"localhost\", 80)\n    environ[\"SERVER_NAME\"] = server[0]\n    environ[\"SERVER_PORT\"] = server[1]\n\n    # Get client IP address\n    client = scope.get(\"client\")\n    if client is not None:\n        environ[\"REMOTE_ADDR\"] = client[0]\n\n    # Go through headers and make them into environ entries\n    for name, value in scope.get(\"headers\", []):\n        name_str: str = name.decode(\"latin1\")\n        if name_str == \"content-length\":\n            corrected_name = \"CONTENT_LENGTH\"\n        elif name_str == \"content-type\":\n            corrected_name = \"CONTENT_TYPE\"\n        else:\n            corrected_name = \"HTTP_%s\" % name_str.upper().replace(\"-\", \"_\")\n        # HTTPbis say only ASCII chars are allowed in headers, but we latin1\n        # just in case\n        value_str: str = value.decode(\"latin1\")\n        if corrected_name in environ:\n            corrected_name_environ = environ[corrected_name]\n            assert isinstance(corrected_name_environ, str)\n            value_str = corrected_name_environ + \",\" + value_str\n        environ[corrected_name] = value_str\n    return environ"
    },
    {
      "chunk_id": 270,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "class _WSGIMiddleware:\n    def __init__(self, app: WSGIApp, workers: int = 10):\n        warnings.warn(\n            \"Uvicorn's native WSGI implementation is deprecated, you \"\n            \"should switch to a2wsgi (`pip install a2wsgi`).\",\n            DeprecationWarning,\n        )\n        self.app = app\n        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=workers)"
    },
    {
      "chunk_id": 271,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "async def __call__(\n        self,\n        scope: HTTPScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -> None:\n        assert scope[\"type\"] == \"http\"\n        instance = WSGIResponder(self.app, self.executor, scope)\n        await instance(receive, send)"
    },
    {
      "chunk_id": 272,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "class WSGIResponder:\n    def __init__(\n        self,\n        app: WSGIApp,\n        executor: concurrent.futures.ThreadPoolExecutor,\n        scope: HTTPScope,\n    ):\n        self.app = app\n        self.executor = executor\n        self.scope = scope\n        self.status = None\n        self.response_headers = None\n        self.send_event = asyncio.Event()\n        self.send_queue: deque[ASGISendEvent | None] = deque()\n        self.loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()\n        self.response_started = False\n        self.exc_info: ExcInfo | None = None"
    },
    {
      "chunk_id": 273,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        message: HTTPRequestEvent = await receive()  # type: ignore[assignment]\n        body = io.BytesIO(message.get(\"body\", b\"\"))\n        more_body = message.get(\"more_body\", False)\n        if more_body:\n            body.seek(0, io.SEEK_END)\n            while more_body:\n                body_message: HTTPRequestEvent = (\n                    await receive()  # type: ignore[assignment]\n                )\n                body.write(body_message.get(\"body\", b\"\"))\n                more_body = body_message.get(\"more_body\", False)\n            body.seek(0)\n        environ = build_environ(self.scope, message, body)\n        self.loop = asyncio.get_event_loop()\n        wsgi = self.loop.run_in_executor(self.executor, self.wsgi, environ, self.start_response)\n        sender = self.loop.create_task(self.sender(send))\n        try:\n            await asyncio.wait_for(wsgi, None)\n        finally:\n            self.send_queue.append(None)\n            self.send_event.set()\n            await asyncio.wait_for(sender, None)\n        if self.exc_info is not None:\n            raise self.exc_info[0].with_traceback(self.exc_info[1], self.exc_info[2])"
    },
    {
      "chunk_id": 274,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "async def sender(self, send: ASGISendCallable) -> None:\n        while True:\n            if self.send_queue:\n                message = self.send_queue.popleft()\n                if message is None:\n                    return\n                await send(message)\n            else:\n                await self.send_event.wait()\n                self.send_event.clear()"
    },
    {
      "chunk_id": 275,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "def start_response(\n        self,\n        status: str,\n        response_headers: Iterable[tuple[str, str]],\n        exc_info: ExcInfo | None = None,\n    ) -> None:\n        self.exc_info = exc_info\n        if not self.response_started:\n            self.response_started = True\n            status_code_str, _ = status.split(\" \", 1)\n            status_code = int(status_code_str)\n            headers = [(name.encode(\"ascii\"), value.encode(\"ascii\")) for name, value in response_headers]\n            http_response_start_event: HTTPResponseStartEvent = {\n                \"type\": \"http.response.start\",\n                \"status\": status_code,\n                \"headers\": headers,\n            }\n            self.send_queue.append(http_response_start_event)\n            self.loop.call_soon_threadsafe(self.send_event.set)"
    },
    {
      "chunk_id": 276,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "def wsgi(self, environ: Environ, start_response: StartResponse) -> None:\n        for chunk in self.app(environ, start_response):  # type: ignore\n            response_body: HTTPResponseBodyEvent = {\n                \"type\": \"http.response.body\",\n                \"body\": chunk,\n                \"more_body\": True,\n            }\n            self.send_queue.append(response_body)\n            self.loop.call_soon_threadsafe(self.send_event.set)\n\n        empty_body: HTTPResponseBodyEvent = {\n            \"type\": \"http.response.body\",\n            \"body\": b\"\",\n            \"more_body\": False,\n        }\n        self.send_queue.append(empty_body)\n        self.loop.call_soon_threadsafe(self.send_event.set)"
    },
    {
      "chunk_id": 277,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/wsgi.py",
      "content": "try:\n    from a2wsgi import WSGIMiddleware\nexcept ModuleNotFoundError:  # pragma: no cover\n    WSGIMiddleware = _WSGIMiddleware  # type: ignore[misc, assignment]"
    },
    {
      "chunk_id": 278,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "import logging\nfrom typing import Any\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    ASGISendEvent,\n    WWWScope,\n)\nfrom uvicorn.logging import TRACE_LOG_LEVEL\n\nPLACEHOLDER_FORMAT = {\n    \"body\": \"<{length} bytes>\",\n    \"bytes\": \"<{length} bytes>\",\n    \"text\": \"<{length} chars>\",\n    \"headers\": \"<...>\",\n}"
    },
    {
      "chunk_id": 279,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "def message_with_placeholders(message: Any) -> Any:\n    \"\"\"\n    Return an ASGI message, with any body-type content omitted and replaced\n    with a placeholder.\n    \"\"\"\n    new_message = message.copy()\n    for attr in PLACEHOLDER_FORMAT.keys():\n        if message.get(attr) is not None:\n            content = message[attr]\n            placeholder = PLACEHOLDER_FORMAT[attr].format(length=len(content))\n            new_message[attr] = placeholder\n    return new_message"
    },
    {
      "chunk_id": 280,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "class MessageLoggerMiddleware:\n    def __init__(self, app: \"ASGI3Application\"):\n        self.task_counter = 0\n        self.app = app\n        self.logger = logging.getLogger(\"uvicorn.asgi\")\n\n        def trace(message: Any, *args: Any, **kwargs: Any) -> None:\n            self.logger.log(TRACE_LOG_LEVEL, message, *args, **kwargs)\n\n        self.logger.trace = trace  # type: ignore"
    },
    {
      "chunk_id": 281,
      "source": "__internal__/data_repo/uvicorn/uvicorn/middleware/message_logger.py",
      "content": "async def __call__(\n        self,\n        scope: \"WWWScope\",\n        receive: \"ASGIReceiveCallable\",\n        send: \"ASGISendCallable\",\n    ) -> None:\n        self.task_counter += 1\n\n        task_counter = self.task_counter\n        client = scope.get(\"client\")\n        prefix = \"%s:%d - ASGI\" % (client[0], client[1]) if client else \"ASGI\"\n\n        async def inner_receive() -> \"ASGIReceiveEvent\":\n            message = await receive()\n            logged_message = message_with_placeholders(message)\n            log_text = \"%s [%d] Receive %s\"\n            self.logger.trace(  # type: ignore\n                log_text, prefix, task_counter, logged_message\n            )\n            return message\n\n        async def inner_send(message: \"ASGISendEvent\") -> None:\n            logged_message = message_with_placeholders(message)\n            log_text = \"%s [%d] Send %s\"\n            self.logger.trace(  # type: ignore\n                log_text, prefix, task_counter, logged_message\n            )\n            await send(message)\n\n        logged_scope = message_with_placeholders(scope)\n        log_text = \"%s [%d] Started scope=%s\"\n        self.logger.trace(log_text, prefix, task_counter, logged_scope)  # type: ignore\n        try:\n            await self.app(scope, inner_receive, inner_send)\n        except BaseException as exc:\n            log_text = \"%s [%d] Raised exception\"\n            self.logger.trace(log_text, prefix, task_counter)  # type: ignore\n            raise exc from None\n        else:\n            log_text = \"%s [%d] Completed\"\n            self.logger.trace(log_text, prefix, task_counter)  # type: ignore"
    },
    {
      "chunk_id": 282,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 283,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nfrom asyncio import Queue\nfrom typing import Any, Union\n\nfrom uvicorn import Config\nfrom uvicorn._types import (\n    LifespanScope,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupEvent,\n    LifespanStartupFailedEvent,\n)\n\nLifespanReceiveMessage = Union[LifespanStartupEvent, LifespanShutdownEvent]\nLifespanSendMessage = Union[\n    LifespanStartupFailedEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanShutdownCompleteEvent,\n]\n\nSTATE_TRANSITION_ERROR = \"Got invalid state transition on lifespan protocol.\""
    },
    {
      "chunk_id": 284,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "class LifespanOn:\n    def __init__(self, config: Config) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.startup_event = asyncio.Event()\n        self.shutdown_event = asyncio.Event()\n        self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue()\n        self.error_occured = False\n        self.startup_failed = False\n        self.shutdown_failed = False\n        self.should_exit = False\n        self.state: dict[str, Any] = {}"
    },
    {
      "chunk_id": 285,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "async def startup(self) -> None:\n        self.logger.info(\"Waiting for application startup.\")\n\n        loop = asyncio.get_event_loop()\n        main_lifespan_task = loop.create_task(self.main())  # noqa: F841\n        startup_event: LifespanStartupEvent = {\"type\": \"lifespan.startup\"}\n        await self.receive_queue.put(startup_event)\n        await self.startup_event.wait()\n\n        if self.startup_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application startup failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application startup complete.\")"
    },
    {
      "chunk_id": 286,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "async def shutdown(self) -> None:\n        if self.error_occured:\n            return\n        self.logger.info(\"Waiting for application shutdown.\")\n        shutdown_event: LifespanShutdownEvent = {\"type\": \"lifespan.shutdown\"}\n        await self.receive_queue.put(shutdown_event)\n        await self.shutdown_event.wait()\n\n        if self.shutdown_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application shutdown failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application shutdown complete.\")"
    },
    {
      "chunk_id": 287,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "async def main(self) -> None:\n        try:\n            app = self.config.loaded_app\n            scope: LifespanScope = {\n                \"type\": \"lifespan\",\n                \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.0\"},\n                \"state\": self.state,\n            }\n            await app(scope, self.receive, self.send)\n        except BaseException as exc:\n            self.asgi = None\n            self.error_occured = True\n            if self.startup_failed or self.shutdown_failed:\n                return\n            if self.config.lifespan == \"auto\":\n                msg = \"ASGI 'lifespan' protocol appears unsupported.\"\n                self.logger.info(msg)\n            else:\n                msg = \"Exception in 'lifespan' protocol\\n\"\n                self.logger.error(msg, exc_info=exc)\n        finally:\n            self.startup_event.set()\n            self.shutdown_event.set()"
    },
    {
      "chunk_id": 288,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "async def send(self, message: LifespanSendMessage) -> None:\n        assert message[\"type\"] in (\n            \"lifespan.startup.complete\",\n            \"lifespan.startup.failed\",\n            \"lifespan.shutdown.complete\",\n            \"lifespan.shutdown.failed\",\n        )\n\n        if message[\"type\"] == \"lifespan.startup.complete\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n\n        elif message[\"type\"] == \"lifespan.startup.failed\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n            self.startup_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])\n\n        elif message[\"type\"] == \"lifespan.shutdown.complete\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n\n        elif message[\"type\"] == \"lifespan.shutdown.failed\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n            self.shutdown_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])"
    },
    {
      "chunk_id": 289,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/on.py",
      "content": "async def receive(self) -> LifespanReceiveMessage:\n        return await self.receive_queue.get()"
    },
    {
      "chunk_id": 290,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "from __future__ import annotations\n\nfrom typing import Any\n\nfrom uvicorn import Config"
    },
    {
      "chunk_id": 291,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "class LifespanOff:\n    def __init__(self, config: Config) -> None:\n        self.should_exit = False\n        self.state: dict[str, Any] = {}"
    },
    {
      "chunk_id": 292,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "async def startup(self) -> None:\n        pass"
    },
    {
      "chunk_id": 293,
      "source": "__internal__/data_repo/uvicorn/uvicorn/lifespan/off.py",
      "content": "async def shutdown(self) -> None:\n        pass"
    },
    {
      "chunk_id": 294,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "from __future__ import annotations as _annotations\n\nimport re\nimport subprocess\n\nfrom mkdocs.config import Config\nfrom mkdocs.structure.files import Files\nfrom mkdocs.structure.pages import Page"
    },
    {
      "chunk_id": 295,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def on_page_content(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each page after the markdown is converted to HTML.\"\"\"\n    html = add_hyperlink_to_pull_request(html, page, config, files)\n    return html"
    },
    {
      "chunk_id": 296,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def add_hyperlink_to_pull_request(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Add hyperlink on PRs mentioned on the release notes page.\n\n    If we find \"(#\\\\d+)\" it will be added an hyperlink to https://github.com/encode/uvicorn/pull/$1.\n    \"\"\"\n    if not page.file.name == \"release-notes\":\n        return html\n\n    return re.sub(r\"\\(#(\\d+)\\)\", r\"(<a href='https://github.com/encode/uvicorn/pull/\\1'>#\\1</a>)\", html)"
    },
    {
      "chunk_id": 297,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def on_page_markdown(markdown: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each file after it is read and before it is converted to HTML.\"\"\"\n    markdown = uvicorn_print_help(markdown, page)\n    return markdown"
    },
    {
      "chunk_id": 298,
      "source": "__internal__/data_repo/uvicorn/docs/plugins/main.py",
      "content": "def uvicorn_print_help(markdown: str, page: Page) -> str:\n    # if you don't filter to the specific route that needs this substitution, things will be very slow\n    if page.file.src_uri not in (\"index.md\", \"deployment.md\"):\n        return markdown\n\n    output = subprocess.run([\"uvicorn\", \"--help\"], capture_output=True, check=True)\n    logfire_help = output.stdout.decode()\n    return re.sub(r\"{{ *uvicorn_help *}}\", logfire_help, markdown)"
    },
    {
      "chunk_id": 299,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 300,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_signal.py",
      "content": "import asyncio\nimport signal\nfrom asyncio import Event\n\nimport httpx\nimport pytest\n\nfrom tests.utils import assert_signal, run_server\nfrom uvicorn import Server\nfrom uvicorn.config import Config"
    },
    {
      "chunk_id": 301,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_signal.py",
      "content": "@pytest.mark.anyio\nasync def test_sigint_finish_req(unused_tcp_port: int):\n    \"\"\"\n    1. Request is sent\n    2. Sigint is sent to uvicorn\n    3. Shutdown sequence start\n    4. Request is finished before timeout_graceful_shutdown=1\n\n    Result: Request should go through, even though the server was cancelled.\n    \"\"\"\n\n    server_event = Event()\n\n    async def wait_app(scope, receive, send):\n        await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n        await send({\"type\": \"http.response.body\", \"body\": b\"start\", \"more_body\": True})\n        await server_event.wait()\n        await send({\"type\": \"http.response.body\", \"body\": b\"end\", \"more_body\": False})\n\n    config = Config(app=wait_app, reload=False, port=unused_tcp_port, timeout_graceful_shutdown=1)\n    server: Server\n    with assert_signal(signal.SIGINT):\n        async with run_server(config) as server, httpx.AsyncClient() as client:\n            req = asyncio.create_task(client.get(f\"http://127.0.0.1:{unused_tcp_port}\"))\n            await asyncio.sleep(0.1)  # ensure next tick\n            server.handle_exit(sig=signal.SIGINT, frame=None)  # exit\n            server_event.set()  # continue request\n            # ensure httpx has processed the response and result is complete\n            await req\n            assert req.result().status_code == 200\n            await asyncio.sleep(0.1)  # ensure shutdown is complete"
    },
    {
      "chunk_id": 302,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_signal.py",
      "content": "@pytest.mark.anyio\nasync def test_sigint_abort_req(unused_tcp_port: int, caplog):\n    \"\"\"\n    1. Request is sent\n    2. Sigint is sent to uvicorn\n    3. Shutdown sequence start\n    4. Request is _NOT_ finished before timeout_graceful_shutdown=1\n\n    Result: Request is cancelled mid-execution, and httpx will raise a\n        `RemoteProtocolError`.\n    \"\"\"\n\n    async def forever_app(scope, receive, send):\n        server_event = Event()\n        await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n        await send({\"type\": \"http.response.body\", \"body\": b\"start\", \"more_body\": True})\n        # we never continue this one, so this request will time out\n        await server_event.wait()\n        await send({\"type\": \"http.response.body\", \"body\": b\"end\", \"more_body\": False})  # pragma: full coverage\n\n    config = Config(app=forever_app, reload=False, port=unused_tcp_port, timeout_graceful_shutdown=1)\n    server: Server\n    with assert_signal(signal.SIGINT):\n        async with run_server(config) as server, httpx.AsyncClient() as client:\n            req = asyncio.create_task(client.get(f\"http://127.0.0.1:{unused_tcp_port}\"))\n            await asyncio.sleep(0.1)  # next tick\n            # trigger exit, this request should time out in ~1 sec\n            server.handle_exit(sig=signal.SIGINT, frame=None)\n            with pytest.raises(httpx.RemoteProtocolError):\n                await req\n\n        # req.result()\n    assert \"Cancel 1 running task(s), timeout graceful shutdown exceeded\" in caplog.messages"
    },
    {
      "chunk_id": 303,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_signal.py",
      "content": "@pytest.mark.anyio\nasync def test_sigint_deny_request_after_triggered(unused_tcp_port: int, caplog):\n    \"\"\"\n    1. Server is started\n    2. Shutdown sequence start\n    3. Request is sent, but not accepted\n\n    Result: Request should fail, and not be able to be sent, since server is no longer\n        accepting connections.\n    \"\"\"\n\n    async def app(scope, receive, send):\n        await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n        await asyncio.sleep(1)  # pragma: full coverage\n\n    config = Config(app=app, reload=False, port=unused_tcp_port, timeout_graceful_shutdown=1)\n    server: Server\n    with assert_signal(signal.SIGINT):\n        async with run_server(config) as server, httpx.AsyncClient() as client:\n            # exit and ensure we do not accept more requests\n            server.handle_exit(sig=signal.SIGINT, frame=None)\n            await asyncio.sleep(0.1)  # next tick\n            with pytest.raises(httpx.ConnectError):\n                await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")"
    },
    {
      "chunk_id": 304,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "from __future__ import annotations\n\nimport functools\nimport os\nimport signal\nimport socket\nimport threading\nimport time\nfrom typing import Any, Callable\n\nimport pytest\n\nfrom uvicorn import Config\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\nfrom uvicorn.supervisors import Multiprocess\nfrom uvicorn.supervisors.multiprocess import Process"
    },
    {
      "chunk_id": 305,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "def new_console_in_windows(test_function: Callable[[], Any]) -> Callable[[], Any]:  # pragma: no cover\n    if os.name != \"nt\":\n        return test_function\n\n    @functools.wraps(test_function)\n    def new_function():\n        import subprocess\n        import sys\n\n        module = test_function.__module__\n        name = test_function.__name__\n\n        subprocess.check_call(\n            [\n                sys.executable,\n                \"-c\",\n                f\"from {module} import {name}; {name}.__wrapped__()\",\n            ],\n            creationflags=subprocess.CREATE_NO_WINDOW,  # type: ignore[attr-defined]\n        )\n\n    return new_function"
    },
    {
      "chunk_id": 306,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    pass  # pragma: no cover"
    },
    {
      "chunk_id": 307,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "def run(sockets: list[socket.socket] | None) -> None:\n    while True:  # pragma: no cover\n        time.sleep(1)"
    },
    {
      "chunk_id": 308,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "def test_process_ping_pong() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    threading.Thread(target=process.always_pong, daemon=True).start()\n    assert process.ping()"
    },
    {
      "chunk_id": 309,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "def test_process_ping_pong_timeout() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    assert not process.ping(0.1)"
    },
    {
      "chunk_id": 310,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@new_console_in_windows\ndef test_multiprocess_run() -> None:\n    \"\"\"\n    A basic sanity check.\n\n    Simply run the supervisor against a no-op server, and signal for it to\n    quit immediately.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 311,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@new_console_in_windows\ndef test_multiprocess_health_check() -> None:\n    \"\"\"\n    Ensure that the health check works as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    process = supervisor.processes[0]\n    process.kill()\n    assert not process.is_alive()\n    time.sleep(1)\n    for p in supervisor.processes:\n        assert p.is_alive()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 312,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@new_console_in_windows\ndef test_multiprocess_sigterm() -> None:\n    \"\"\"\n    Ensure that the SIGTERM signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(signal.SIGTERM)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 313,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@pytest.mark.skipif(not hasattr(signal, \"SIGBREAK\"), reason=\"platform unsupports SIGBREAK\")\n@new_console_in_windows\ndef test_multiprocess_sigbreak() -> None:  # pragma: py-not-win32\n    \"\"\"\n    Ensure that the SIGBREAK signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(getattr(signal, \"SIGBREAK\"))\n    supervisor.join_all()"
    },
    {
      "chunk_id": 314,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@pytest.mark.skipif(not hasattr(signal, \"SIGHUP\"), reason=\"platform unsupports SIGHUP\")\ndef test_multiprocess_sighup() -> None:\n    \"\"\"\n    Ensure that the SIGHUP signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    pids = [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGHUP)\n    time.sleep(1)\n    assert pids != [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 315,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@pytest.mark.skipif(not hasattr(signal, \"SIGTTIN\"), reason=\"platform unsupports SIGTTIN\")\ndef test_multiprocess_sigttin() -> None:\n    \"\"\"\n    Ensure that the SIGTTIN signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTIN)\n    time.sleep(1)\n    assert len(supervisor.processes) == 3\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 316,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_multiprocess.py",
      "content": "@pytest.mark.skipif(not hasattr(signal, \"SIGTTOU\"), reason=\"platform unsupports SIGTTOU\")\ndef test_multiprocess_sigttou() -> None:\n    \"\"\"\n    Ensure that the SIGTTOU signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()"
    },
    {
      "chunk_id": 317,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "from __future__ import annotations\n\nimport platform\nimport signal\nimport socket\nimport sys\nfrom collections.abc import Generator\nfrom pathlib import Path\nfrom threading import Thread\nfrom time import sleep\nfrom typing import Callable\n\nimport pytest\nfrom pytest_mock import MockerFixture\n\nfrom tests.utils import as_cwd\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload, _display_path\nfrom uvicorn.supervisors.statreload import StatReload\n\ntry:\n    from uvicorn.supervisors.watchfilesreload import WatchFilesReload\nexcept ImportError:  # pragma: no cover\n    WatchFilesReload = None  # type: ignore[misc,assignment]\n\n\n# TODO: Investigate why this is flaky on MacOS M1.\nskip_if_m1 = pytest.mark.skipif(\n    sys.platform == \"darwin\" and platform.processor() == \"arm\",\n    reason=\"Flaky on MacOS M1\",\n)"
    },
    {
      "chunk_id": 318,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def run(sockets: list[socket.socket] | None) -> None:\n    pass  # pragma: no cover"
    },
    {
      "chunk_id": 319,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def sleep_touch(*paths: Path):\n    sleep(0.1)\n    for p in paths:\n        p.touch()"
    },
    {
      "chunk_id": 320,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "@pytest.fixture\ndef touch_soon() -> Generator[Callable[[Path], None]]:\n    threads: list[Thread] = []\n\n    def start(*paths: Path) -> None:\n        thread = Thread(target=sleep_touch, args=paths)\n        thread.start()\n        threads.append(thread)\n\n    yield start\n\n    for t in threads:\n        t.join()"
    },
    {
      "chunk_id": 321,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "class TestBaseReload:\n    @pytest.fixture(autouse=True)\n    def setup(self, reload_directory_structure: Path, reloader_class: type[BaseReload] | None):\n        if reloader_class is None:  # pragma: no cover\n            pytest.skip(\"Needed dependency not installed\")\n        self.reload_path = reload_directory_structure\n        self.reloader_class = reloader_class\n\n    def _setup_reloader(self, config: Config) -> BaseReload:\n        config.reload_delay = 0  # save time\n\n        reloader = self.reloader_class(config, target=run, sockets=[])\n\n        assert config.should_reload\n        reloader.startup()\n        return reloader\n\n    def _reload_tester(\n        self, touch_soon: Callable[[Path], None], reloader: BaseReload, *files: Path\n    ) -> list[Path] | None:\n        reloader.restart()\n        if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n            touch_soon(*files)\n        else:\n            assert not next(reloader)\n            sleep(0.1)\n            for file in files:\n                file.touch()\n        return next(reloader)\n\n    @pytest.mark.parametrize(\"reloader_class\", [StatReload, WatchFilesReload])\n    def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [StatReload, WatchFilesReload])\n    def test_reload_when_python_file_is_changed(self, touch_soon: Callable[[Path], None]):\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [StatReload, WatchFilesReload])\n    def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon: Callable[[Path], None]):\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [WatchFilesReload])\n    def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon: Callable[[Path], None]):\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class, result\", [(StatReload, False), (WatchFilesReload, True)])\n    def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon: Callable[[Path], None]):\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [pytest.param(WatchFilesReload, marks=skip_if_m1)])\n    def test_should_not_reload_when_exclude_pattern_match_file_is_changed(\n        self, touch_soon: Callable[[Path], None]\n    ):  # pragma: py-darwin\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [StatReload, WatchFilesReload])\n    def test_should_not_reload_when_dot_file_is_changed(self, touch_soon: Callable[[Path], None]):\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [StatReload, WatchFilesReload])\n    def test_should_reload_when_directories_have_same_prefix(self, touch_soon: Callable[[Path], None]):\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\n        \"reloader_class\",\n        [StatReload, pytest.param(WatchFilesReload, marks=skip_if_m1)],\n    )\n    def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon: Callable[[Path], None]):\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [pytest.param(WatchFilesReload, marks=skip_if_m1)])\n    def test_override_defaults(self, touch_soon: Callable[[Path], None]) -> None:  # pragma: py-darwin\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()\n\n    @pytest.mark.parametrize(\"reloader_class\", [pytest.param(WatchFilesReload, marks=skip_if_m1)])\n    def test_explicit_paths(self, touch_soon: Callable[[Path], None]) -> None:  # pragma: py-darwin\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()\n\n    @pytest.mark.skipif(WatchFilesReload is None, reason=\"watchfiles not available\")\n    @pytest.mark.parametrize(\"reloader_class\", [WatchFilesReload])\n    def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()"
    },
    {
      "chunk_id": 322,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "@pytest.mark.skipif(WatchFilesReload is None, reason=\"watchfiles not available\")\ndef test_should_watch_one_dir_cwd(mocker: MockerFixture, reload_directory_structure: Path):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir), str(app_first_dir)],\n        )\n        WatchFilesReload(config, target=run, sockets=[])\n        mock_watch.assert_called_once()\n        assert mock_watch.call_args[0] == (Path.cwd(),)"
    },
    {
      "chunk_id": 323,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "@pytest.mark.skipif(WatchFilesReload is None, reason=\"watchfiles not available\")\ndef test_should_watch_separate_dirs_outside_cwd(mocker: MockerFixture, reload_directory_structure: Path):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n    config = Config(\n        app=\"tests.test_config:asgi_app\",\n        reload=True,\n        reload_dirs=[str(app_dir), str(app_first_dir)],\n    )\n    WatchFilesReload(config, target=run, sockets=[])\n    mock_watch.assert_called_once()\n    assert set(mock_watch.call_args[0]) == {\n        app_dir,\n        app_first_dir,\n        Path.cwd(),\n    }"
    },
    {
      "chunk_id": 324,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def test_display_path_relative(tmp_path: Path):\n    with as_cwd(tmp_path):\n        p = tmp_path / \"app\" / \"foobar.py\"\n        # accept windows paths as wells as posix\n        assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")"
    },
    {
      "chunk_id": 325,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def test_display_path_non_relative():\n    p = Path(\"/foo/bar.py\")\n    assert _display_path(p) in (\"'/foo/bar.py'\", \"'\\\\foo\\\\bar.py'\")"
    },
    {
      "chunk_id": 326,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def test_base_reloader_run(tmp_path: Path):\n    calls: list[str] = []\n    step = 0\n\n    class CustomReload(BaseReload):\n        def startup(self):\n            calls.append(\"startup\")\n\n        def restart(self):\n            calls.append(\"restart\")\n\n        def shutdown(self):\n            calls.append(\"shutdown\")\n\n        def should_restart(self):\n            nonlocal step\n            step += 1\n            if step == 1:\n                return None\n            elif step == 2:\n                return [tmp_path / \"foobar.py\"]\n            else:\n                raise StopIteration()\n\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = CustomReload(config, target=run, sockets=[])\n    reloader.run()\n\n    assert calls == [\"startup\", \"restart\", \"shutdown\"]"
    },
    {
      "chunk_id": 327,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def test_base_reloader_should_exit(tmp_path: Path):\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[])\n    assert not reloader.should_exit.is_set()\n    reloader.pause()\n\n    if sys.platform == \"win32\":\n        reloader.signal_handler(signal.CTRL_C_EVENT, None)  # pragma: py-not-win32\n    else:\n        reloader.signal_handler(signal.SIGINT, None)  # pragma: py-win32\n\n    assert reloader.should_exit.is_set()\n    with pytest.raises(StopIteration):\n        reloader.pause()"
    },
    {
      "chunk_id": 328,
      "source": "__internal__/data_repo/uvicorn/tests/supervisors/test_reload.py",
      "content": "def test_base_reloader_closes_sockets_on_shutdown():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[sock])\n    reloader.startup()\n    assert sock.fileno() != -1\n    reloader.shutdown()\n    assert sock.fileno() == -1"
    },
    {
      "chunk_id": 329,
      "source": "__internal__/data_repo/uvicorn/tests/importer/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 330,
      "source": "__internal__/data_repo/uvicorn/tests/importer/raise_import_error.py",
      "content": "myattr = 123"
    },
    {
      "chunk_id": 331,
      "source": "__internal__/data_repo/uvicorn/tests/importer/raise_import_error.py",
      "content": "import does_not_exist  # noqa"
    },
    {
      "chunk_id": 332,
      "source": "__internal__/data_repo/uvicorn/tests/importer/circular_import_a.py",
      "content": "# Used by test_importer.py\nfrom .circular_import_b import foo  # noqa"
    },
    {
      "chunk_id": 333,
      "source": "__internal__/data_repo/uvicorn/tests/importer/circular_import_a.py",
      "content": "bar = 123  # pragma: no cover"
    },
    {
      "chunk_id": 334,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "import pytest\n\nfrom uvicorn.importer import ImportFromStringError, import_from_string"
    },
    {
      "chunk_id": 335,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_invalid_format() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"example:\")\n    expected = 'Import string \"example:\" must be in format \"<module>:<attribute>\".'\n    assert expected in str(exc_info.value)"
    },
    {
      "chunk_id": 336,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_invalid_module() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"module_does_not_exist:myattr\")\n    expected = 'Could not import module \"module_does_not_exist\".'\n    assert expected in str(exc_info.value)"
    },
    {
      "chunk_id": 337,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_invalid_attr() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"tempfile:attr_does_not_exist\")\n    expected = 'Attribute \"attr_does_not_exist\" not found in module \"tempfile\".'\n    assert expected in str(exc_info.value)"
    },
    {
      "chunk_id": 338,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_internal_import_error() -> None:\n    with pytest.raises(ImportError):\n        import_from_string(\"tests.importer.raise_import_error:myattr\")"
    },
    {
      "chunk_id": 339,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_valid_import() -> None:\n    instance = import_from_string(\"tempfile:TemporaryFile\")\n    from tempfile import TemporaryFile\n\n    assert instance == TemporaryFile"
    },
    {
      "chunk_id": 340,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_no_import_needed() -> None:\n    from tempfile import TemporaryFile\n\n    instance = import_from_string(TemporaryFile)\n    assert instance == TemporaryFile"
    },
    {
      "chunk_id": 341,
      "source": "__internal__/data_repo/uvicorn/tests/importer/test_importer.py",
      "content": "def test_circular_import_error() -> None:\n    with pytest.raises(ImportError) as exc_info:\n        import_from_string(\"tests.importer.circular_import_a:bar\")\n    expected = (\n        \"cannot import name 'bar' from partially initialized module \"\n        \"'tests.importer.circular_import_a' (most likely due to a circular import)\"\n    )\n    assert expected in str(exc_info.value)"
    },
    {
      "chunk_id": 342,
      "source": "__internal__/data_repo/uvicorn/tests/importer/circular_import_b.py",
      "content": "# Used by test_importer.py\nfrom .circular_import_a import bar  # noqa"
    },
    {
      "chunk_id": 343,
      "source": "__internal__/data_repo/uvicorn/tests/importer/circular_import_b.py",
      "content": "foo = 123  # pragma: no cover"
    },
    {
      "chunk_id": 344,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 345,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "```python"
    },
    {
      "chunk_id": 346,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "from __future__ import annotations\n\nimport asyncio\nimport typing\nfrom copy import deepcopy\n\nimport httpx\nimport pytest\nimport websockets\nimport websockets.client\nimport websockets.exceptions\nfrom typing_extensions import TypedDict\nfrom websockets.extensions.permessage_deflate import ClientPerMessageDeflateFactory\nfrom websockets.typing import Subprotocol\n\nfrom tests.response import Response\nfrom tests.utils import run_server\nfrom uvicorn._types import (\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    Scope,\n    WebSocketCloseEvent,\n    WebSocketConnectEvent,\n    WebSocketDisconnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketResponseStartEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n\ntry:\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol as _WSProtocol\n\n    skip_if_no_wsproto = pytest.mark.skipif(False, reason=\"wsproto is installed.\")\nexcept ModuleNotFoundError:  # pragma: no cover\n    skip_if_no_wsproto = pytest.mark.skipif(True, reason=\"wsproto is not installed.\")\n\nif typing.TYPE_CHECKING:\n    import sys\n\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol as _WSProtocol\n\n    if sys.version_info >= (3, 10):  # pragma: no cover\n        from typing import TypeAlias\n    else:  # pragma: no cover\n        from typing_extensions import TypeAlias\n\n    HTTPProtocol: TypeAlias = \"type[H11Protocol | HttpToolsProtocol]\"\n    WSProtocol: TypeAlias = \"type[_WSProtocol | WebSocketProtocol]\"\n\npytestmark = pytest.mark.anyio"
    },
    {
      "chunk_id": 347,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "class WebSocketResponse:\n    def __init__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n\n    def __await__(self):\n        return self.asgi().__await__()\n\n    async def asgi(self):\n        while True:\n            message = await self.receive()\n            message_type = message[\"type\"].replace(\".\", \"_\")\n            handler = getattr(self, message_type, None)\n            if handler is not None:\n                await handler(message)\n            if message_type == \"websocket_disconnect\":\n                break"
    },
    {
      "chunk_id": 348,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def wsresponse(url: str):\n    \"\"\"\n    A simple websocket connection request and response helper\n    \"\"\"\n    url = url.replace(\"ws:\", \"http:\")\n    headers = {\n        \"connection\": \"upgrade\",\n        \"upgrade\": \"websocket\",\n        \"Sec-WebSocket-Key\": \"x3JJHMbDL1EzLkh9GBhXDw==\",\n        \"Sec-WebSocket-Version\": \"13\",\n    }\n    async with httpx.AsyncClient() as client:\n        return await client.get(url, headers=headers)"
    },
    {
      "chunk_id": 349,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_invalid_upgrade(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    def app(scope: Scope):\n        return None\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, port=unused_tcp_port)\n    async with run_server(config):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"http://127.0.0.1:{unused_tcp_port}\",\n                headers={\n                    \"upgrade\": \"websocket\",\n                    \"connection\": \"upgrade\",\n                    \"sec-webSocket-version\": \"11\",\n                },\n            )\n        if response.status_code == 426:\n            # response.text == \"\"\n            pass  # ok, wsproto 0.13\n        else:\n            assert response.status_code == 400\n            assert (\n                response.text.lower().strip().rstrip(\".\")\n                in [\n                    \"missing sec-websocket-key header\",\n                    \"missing sec-websocket-version header\",  # websockets\n                    \"missing or empty sec-websocket-key header\",  # wsproto\n                    \"failed to open a websocket connection: missing \" \"sec-websocket-key header\",\n                    \"failed to open a websocket connection: missing or empty \" \"sec-websocket-key header\",\n                    \"failed to open a websocket connection: missing sec-websocket-key header; 'sec-websocket-key'\",\n                ]\n            )"
    },
    {
      "chunk_id": 350,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_accept_connection(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.open\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert is_open"
    },
    {
      "chunk_id": 351,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_shutdown(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config) as server:\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\"):\n            # Attempt shutdown while connection is still open\n            await server.shutdown()"
    },
    {
      "chunk_id": 352,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_supports_permessage_deflate_extension(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        extension_factories = [ClientPerMessageDeflateFactory()]\n        async with websockets.client.connect(url, extensions=extension_factories) as websocket:\n            return [extension.name for extension in websocket.extensions]\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        extension_names = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert \"permessage-deflate\" in extension_names"
    },
    {
      "chunk_id": 353,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_can_disable_permessage_deflate_extension(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        # enable per-message deflate on the client, so that we can check the server\n        # won't support it when it's disabled.\n        extension_factories = [ClientPerMessageDeflateFactory()]\n        async with websockets.client.connect(url, extensions=extension_factories) as websocket:\n            return [extension.name for extension in websocket.extensions]\n\n    config = Config(\n        app=App,\n        ws=ws_protocol_cls,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        ws_per_message_deflate=False,\n        port=unused_tcp_port,\n    )\n    async with run_server(config):\n        extension_names = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert \"permessage-deflate\" not in extension_names"
    },
    {
      "chunk_id": 354,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_close_connection(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.close\"})\n\n    async def open_connection(url: str):\n        try:\n            await websockets.client.connect(url)\n        except websockets.exceptions.InvalidHandshake:\n            return False\n        return True  # pragma: no cover\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert not is_open"
    },
    {
      "chunk_id": 355,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_headers(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            headers = self.scope.get(\"headers\")\n            headers = dict(headers)  # type: ignore\n            assert headers[b\"host\"].startswith(b\"127.0.0.1\")  # type: ignore\n            assert headers[b\"username\"] == bytes(\"abra\u00e3o\", \"utf-8\")  # type: ignore\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url, extra_headers=[(\"username\", \"abra\u00e3o\")]) as websocket:\n            return websocket.open\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert is_open"
    },
    {
      "chunk_id": 356,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_extra_headers(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\", \"headers\": [(b\"extra\", b\"header\")]})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.response_headers\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        extra_headers = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert extra_headers.get(\"extra\") == \"header\""
    },
    {
      "chunk_id": 357,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_path_and_raw_path(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            path = self.scope.get(\"path\")\n            raw_path = self.scope.get(\"raw_path\")\n            assert path == \"/one/two\"\n            assert raw_path == b\"/one%2Ftwo\"\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.open\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}/one%2Ftwo\")\n        assert is_open"
    },
    {
      "chunk_id": 358,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_text_data_to_client(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n            await self.send({\"type\": \"websocket.send\", \"text\": \"123\"})\n\n    async def get_data(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return await websocket.recv()\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        data = await get_data(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == \"123\""
    },
    {
      "chunk_id": 359,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_binary_data_to_client(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n            await self.send({\"type\": \"websocket.send\", \"bytes\": b\"123\"})\n\n    async def get_data(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return await websocket.recv()\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        data = await get_data(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == b\"123\""
    },
    {
      "chunk_id": 360,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_and_close_connection(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n            await self.send({\"type\": \"websocket.send\", \"text\": \"123\"})\n            await self.send({\"type\": \"websocket.close\"})\n\n    async def get_data(url: str):\n        async with websockets.client.connect(url) as websocket:\n            data = await websocket.recv()\n            is_open = True\n            try:\n                await websocket.recv()\n            except Exception:\n                is_open = False\n            return (data, is_open)\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        (data, is_open) = await get_data(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == \"123\"\n        assert not is_open"
    },
    {
      "chunk_id": 361,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_text_data_to_server(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n        async def websocket_receive(self, message: WebSocketReceiveEvent):\n            _text = message.get(\"text\")\n            assert _text is not None\n            await self.send({\"type\": \"websocket.send\", \"text\": _text})\n\n    async def send_text(url: str):\n        async with websockets.client.connect(url) as websocket:\n            await websocket.send(\"abc\")\n            return await websocket.recv()\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        data = await send_text(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == \"abc\""
    },
    {
      "chunk_id": 362,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_binary_data_to_server(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n        async def websocket_receive(self, message: WebSocketReceiveEvent):\n            _bytes = message.get(\"bytes\")\n            assert _bytes is not None\n            await self.send({\"type\": \"websocket.send\", \"bytes\": _bytes})\n\n    async def send_text(url: str):\n        async with websockets.client.connect(url) as websocket:\n            await websocket.send(b\"abc\")\n            return await websocket.recv()\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        data = await send_text(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == b\"abc\""
    },
    {
      "chunk_id": 363,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_after_protocol_close(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n            await self.send({\"type\": \"websocket.send\", \"text\": \"123\"})\n            await self.send({\"type\": \"websocket.close\"})\n            with pytest.raises(Exception):\n                await self.send({\"type\": \"websocket.send\", \"text\": \"123\"})\n\n    async def get_data(url: str):\n        async with websockets.client.connect(url) as websocket:\n            data = await websocket.recv()\n            is_open = True\n            try:\n                await websocket.recv()\n            except Exception:\n                is_open = False\n            return (data, is_open)\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        (data, is_open) = await get_data(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert data == \"123\"\n        assert not is_open"
    },
    {
      "chunk_id": 364,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_missing_handshake(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        pass\n\n    async def connect(url: str):\n        await websockets.client.connect(url)\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            await connect(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert exc_info.value.status_code == 500"
    },
    {
      "chunk_id": 365,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_before_handshake(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"websocket.send\", \"text\": \"123\"})\n\n    async def connect(url: str):\n        await websockets.client.connect(url)\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            await connect(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert exc_info.value.status_code == 500"
    },
    {
      "chunk_id": 366,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_duplicate_handshake(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"websocket.accept\"})\n        await send({\"type\": \"websocket.accept\"})\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            with pytest.raises(websockets.exceptions.ConnectionClosed):\n                _ = await websocket.recv()\n        assert websocket.close_code == 1006"
    },
    {
      "chunk_id": 367,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_asgi_return_value(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    \"\"\"\n    The ASGI callable should return 'None'. If it doesn't, make sure that\n    the connection is closed with an error condition.\n    \"\"\"\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"websocket.accept\"})\n        return 123\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            with pytest.raises(websockets.exceptions.ConnectionClosed):\n                _ = await websocket.recv()\n        assert websocket.close_code == 1006"
    },
    {
      "chunk_id": 368,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "@pytest.mark.parametrize(\"code\", [None, 1000, 1001])\n@pytest.mark.parametrize(\"reason\", [None, \"test\", False], ids=[\"none_as_reason\", \"normal_reason\", \"without_reason\"])\nasync def test_app_close(\n    ws_protocol_cls: WSProtocol,\n    http_protocol_cls: HTTPProtocol,\n    unused_tcp_port: int,\n    code: int | None,\n    reason: str | None,\n):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"websocket.connect\":\n                await send({\"type\": \"websocket.accept\"})\n            elif message[\"type\"] == \"websocket.receive\":\n                reply: WebSocketCloseEvent = {\"type\": \"websocket.close\"}\n\n                if code is not None:\n                    reply[\"code\"] = code\n\n                if reason is not False:\n                    reply[\"reason\"] = reason\n\n                await send(reply)\n            elif message[\"type\"] == \"websocket.disconnect\":\n                break\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            await websocket.ping()\n            await websocket.send(\"abc\")\n            with pytest.raises(websockets.exceptions.ConnectionClosed):\n                await websocket.recv()\n        assert websocket.close_code == (code or 1000)\n        assert websocket.close_reason == (reason or \"\")"
    },
    {
      "chunk_id": 369,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_client_close(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    disconnect_message: WebSocketDisconnectEvent | None = None\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnect_message\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"websocket.connect\":\n                await send({\"type\": \"websocket.accept\"})\n            elif message[\"type\"] == \"websocket.receive\":\n                pass\n            elif message[\"type\"] == \"websocket.disconnect\":\n                disconnect_message = message\n                break\n\n    async def websocket_session(url: str):\n        async with websockets.client.connect(url) as websocket:\n            await websocket.ping()\n            await websocket.send(\"abc\")\n            await websocket.close(code=1001, reason=\"custom reason\")\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")\n\n    assert disconnect_message == {\"type\": \"websocket.disconnect\", \"code\": 1001, \"reason\": \"custom reason\"}"
    },
    {
      "chunk_id": 370,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_client_connection_lost(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    got_disconnect_event = False\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal got_disconnect_event\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"websocket.connect\":\n                await send({\"type\": \"websocket.accept\"})\n            elif message[\"type\"] == \"websocket.disconnect\":\n                break\n\n        got_disconnect_event = True\n\n    config = Config(\n        app=app,\n        ws=ws_protocol_cls,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        ws_ping_interval=0.0,\n        port=unused_tcp_port,\n    )\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            websocket.transport.close()\n            await asyncio.sleep(0.1)\n            got_disconnect_event_before_shutdown = got_disconnect_event\n\n    assert got_disconnect_event_before_shutdown is True"
    },
    {
      "chunk_id": 371,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_client_connection_lost_on_send(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    disconnect = asyncio.Event()\n    got_disconnect_event = False\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal got_disconnect_event\n        message = await receive()\n        if message[\"type\"] == \"websocket.connect\":\n            await send({\"type\": \"websocket.accept\"})\n        try:\n            await disconnect.wait()\n            await send({\"type\": \"websocket.send\", \"text\": \"123\"})\n        except OSError:\n            got_disconnect_event = True\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        url = f\"ws://127.0.0.1:{unused_tcp_port}\"\n        async with websockets.client.connect(url):\n            await asyncio.sleep(0.1)\n        disconnect.set()\n\n    assert got_disconnect_event is True"
    },
    {
      "chunk_id": 372,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_connection_lost_before_handshake_complete(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    send_accept_task = asyncio.Event()\n    disconnect_message: WebSocketDisconnectEvent = {}  # type: ignore\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnect_message\n        message = await receive()\n        if message[\"type\"] == \"websocket.connect\":\n            await send_accept_task.wait()\n        disconnect_message = await receive()  # type: ignore\n\n    response: httpx.Response | None = None\n\n    async def websocket_session(uri: str):\n        nonlocal response\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"http://127.0.0.1:{unused_tcp_port}\",\n                headers={\n                    \"upgrade\": \"websocket\",\n                    \"connection\": \"upgrade\",\n                    \"sec-websocket-version\": \"13\",\n                    \"sec-websocket-key\": \"dGhlIHNhbXBsZSBub25jZQ==\",\n                },\n            )\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        task = asyncio.create_task(websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\"))\n        await asyncio.sleep(0.1)\n        send_accept_task.set()\n        await asyncio.sleep(0.1)\n\n    assert response is not None\n    assert response.status_code == 500, response.text\n    assert response.text == \"Internal Server Error\"\n    assert disconnect_message == {\"type\": \"websocket.disconnect\", \"code\": 1006}\n    await task"
    },
    {
      "chunk_id": 373,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_send_close_on_server_shutdown(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    disconnect_message: WebSocketDisconnectEvent = {}  # type: ignore\n    server_shutdown_event = asyncio.Event()\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnect_message\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"websocket.connect\":\n                await send({\"type\": \"websocket.accept\"})\n            elif message[\"type\"] == \"websocket.disconnect\":\n                disconnect_message = message\n                break\n\n    websocket: websockets.client.WebSocketClientProtocol | None = None\n\n    async def websocket_session(uri: str):\n        nonlocal websocket\n        async with websockets.client.connect(uri) as ws_connection:\n            websocket = ws_connection\n            await server_shutdown_event.wait()\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        task = asyncio.create_task(websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\"))\n        await asyncio.sleep(0.1)\n        disconnect_message_before_shutdown = disconnect_message\n    server_shutdown_event.set()\n\n    assert websocket is not None\n    assert websocket.close_code == 1012\n    assert disconnect_message_before_shutdown == {}\n    assert disconnect_message == {\"type\": \"websocket.disconnect\", \"code\": 1012}\n    task.cancel()"
    },
    {
      "chunk_id": 374,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "@pytest.mark.parametrize(\"subprotocol\", [\"proto1\", \"proto2\"])\nasync def test_subprotocols(\n    ws_protocol_cls: WSProtocol,\n    http_protocol_cls: HTTPProtocol,\n    subprotocol: str,\n    unused_tcp_port: int,\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\", \"subprotocol\": subprotocol})\n\n    async def get_subprotocol(url: str):\n        async with websockets.client.connect(\n            url, subprotocols=[Subprotocol(\"proto1\"), Subprotocol(\"proto2\")]\n        ) as websocket:\n            return websocket.subprotocol\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        accepted_subprotocol = await get_subprotocol(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert accepted_subprotocol == subprotocol"
    },
    {
      "chunk_id": 375,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "MAX_WS_BYTES = 1024 * 1024 * 16\nMAX_WS_BYTES_PLUS1 = MAX_WS_BYTES + 1"
    },
    {
      "chunk_id": 376,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "@pytest.mark.parametrize(\n    \"client_size_sent, server_size_max, expected_result\",\n    [\n        (MAX_WS_BYTES, MAX_WS_BYTES, 0),\n        (MAX_WS_BYTES_PLUS1, MAX_WS_BYTES, 1009),\n        (10, 10, 0),\n        (11, 10, 1009),\n    ],\n    ids=[\n        \"max=defaults sent=defaults\",\n        \"max=defaults sent=defaults+1\",\n        \"max=10 sent=10\",\n        \"max=10 sent=11\",\n    ],\n)\nasync def test_send_binary_data_to_server_bigger_than_default_on_websockets(\n    http_protocol_cls: HTTPProtocol,\n    client_size_sent: int,\n    server_size_max: int,\n    expected_result: int,\n    unused_tcp_port: int,\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n        async def websocket_receive(self, message: WebSocketReceiveEvent):\n            _bytes = message.get(\"bytes\")\n            assert _bytes is not None\n            await self.send({\"type\": \"websocket.send\", \"bytes\": _bytes})\n\n    config = Config(\n        app=App,\n        ws=WebSocketProtocol,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        ws_max_size=server_size_max,\n        port=unused_tcp_port,\n    )\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\", max_size=client_size_sent) as ws:\n            await ws.send(b\"\\x01\" * client_size_sent)\n            if expected_result == 0:\n                data = await ws.recv()\n                assert data == b\"\\x01\" * client_size_sent\n            else:\n                with pytest.raises(websockets.exceptions.ConnectionClosedError):\n                    await ws.recv()\n                assert ws.close_code == expected_result"
    },
    {
      "chunk_id": 377,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    disconnected_message: ASGIReceiveEvent = {}  # type: ignore\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnected_message\n        assert scope[\"type\"] == \"websocket\"\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        # Reject the connection.\n        await send({\"type\": \"websocket.close\"})\n        # -- At this point websockets' recv() is unusable. --\n\n        # This doesn't raise `TypeError`:\n        # See https://github.com/encode/uvicorn/issues/244\n        disconnected_message = await receive()\n\n    async def websocket_session(url: str):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            async with websockets.client.connect(url):\n                pass  # pragma: no cover\n        assert exc_info.value.status_code == 403\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")\n\n    assert disconnected_message == {\"type\": \"websocket.disconnect\", \"code\": 1006}"
    },
    {
      "chunk_id": 378,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "class EmptyDict(TypedDict): ..."
    },
    {
      "chunk_id": 379,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_response(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    disconnected_message: WebSocketDisconnectEvent | EmptyDict = {}\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnected_message\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope and \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        # Reject the connection with a response\n        response = Response(b\"goodbye\", status_code=400)\n        await response(scope, receive, send)\n        disconnected_message = await receive()\n\n    async def websocket_session(url: str):\n        response = await wsresponse(url)\n        assert response.status_code == 400\n        assert response.content == b\"goodbye\"\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")\n\n    assert disconnected_message == {\"type\": \"websocket.disconnect\", \"code\": 1006}"
    },
    {
      "chunk_id": 380,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_multibody_response(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    disconnected_message: ASGIReceiveEvent = {}  # type: ignore\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal disconnected_message\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope\n        assert \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n        await send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": 400,\n                \"headers\": [\n                    (b\"Content-Length\", b\"20\"),\n                    (b\"Content-Type\", b\"text/plain\"),\n                ],\n            }\n        )\n        await send({\"type\": \"websocket.http.response.body\", \"body\": b\"x\" * 10, \"more_body\": True})\n        await send({\"type\": \"websocket.http.response.body\", \"body\": b\"y\" * 10})\n        disconnected_message = await receive()\n\n    async def websocket_session(url: str):\n        response = await wsresponse(url)\n        assert response.status_code == 400\n        assert response.content == (b\"x\" * 10) + (b\"y\" * 10)\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")\n\n    assert disconnected_message == {\"type\": \"websocket.disconnect\", \"code\": 1006}"
    },
    {
      "chunk_id": 381,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_invalid_status(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    # this test checks that even if there is an error in the response, the server\n    # can successfully send a 500 error back to the client\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope and \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        await send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": 700,  # invalid status code\n                \"headers\": [(b\"Content-Length\", b\"0\"), (b\"Content-Type\", b\"text/plain\")],\n            }\n        )\n\n    async def websocket_session(url: str):\n        response = await wsresponse(url)\n        assert response.status_code == 500\n        assert response.content == b\"Internal Server Error\"\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")"
    },
    {
      "chunk_id": 382,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_body_nolength(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    # test that the server can send a response with a body but no content-length\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope\n        assert \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        await send({\"type\": \"websocket.http.response.start\", \"status\": 403, \"headers\": []})\n        await send({\"type\": \"websocket.http.response.body\", \"body\": b\"hardbody\"})\n\n    async def websocket_session(url: str):\n        response = await wsresponse(url)\n        assert response.status_code == 403\n        assert response.content == b\"hardbody\"\n        if ws_protocol_cls == _WSProtocol:\n            # wsproto automatically makes the message chunked\n            assert response.headers[\"transfer-encoding\"] == \"chunked\"\n        else:\n            # websockets automatically adds a content-length\n            assert response.headers[\"content-length\"] == \"8\"\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")"
    },
    {
      "chunk_id": 383,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_invalid_msg(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope and \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message_rcvd = await receive()\n        assert message_rcvd[\"type\"] == \"websocket.connect\"\n\n        message: WebSocketResponseStartEvent = {\n            \"type\": \"websocket.http.response.start\",\n            \"status\": 404,\n            \"headers\": [(b\"Content-Length\", b\"0\"), (b\"Content-Type\", b\"text/plain\")],\n        }\n        await send(message)\n        # send invalid message.  This will raise an exception here\n        await send(message)\n\n    async def websocket_session(url: str):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            async with websockets.client.connect(url):\n                pass  # pragma: no cover\n        assert exc_info.value.status_code == 404\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")"
    },
    {
      "chunk_id": 384,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_reject_connection_with_missing_body(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope and \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        await send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": 404,\n                \"headers\": [(b\"Content-Length\", b\"0\"), (b\"Content-Type\", b\"text/plain\")],\n            }\n        )\n        # no further message\n\n    async def websocket_session(url: str):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            async with websockets.client.connect(url):\n                pass  # pragma: no cover\n        assert exc_info.value.status_code == 404\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")"
    },
    {
      "chunk_id": 385,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_multiple_websocket_http_response_start_events(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    \"\"\"\n    The server should raise an exception if it sends multiple\n    websocket.http.response.start events.\n    \"\"\"\n    exception_message: str | None = None\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal exception_message\n        assert scope[\"type\"] == \"websocket\"\n        assert \"extensions\" in scope\n        assert \"websocket.http.response\" in scope[\"extensions\"]\n\n        # Pull up first recv message.\n        message = await receive()\n        assert message[\"type\"] == \"websocket.connect\"\n\n        start_event: WebSocketResponseStartEvent = {\n            \"type\": \"websocket.http.response.start\",\n            \"status\": 404,\n            \"headers\": [(b\"Content-Length\", b\"0\"), (b\"Content-Type\", b\"text/plain\")],\n        }\n        await send(start_event)\n        try:\n            await send(start_event)\n        except Exception as exc:\n            exception_message = str(exc)\n\n    async def websocket_session(url: str):\n        with pytest.raises(websockets.exceptions.InvalidStatusCode) as exc_info:\n            async with websockets.client.connect(url):\n                pass  # pragma: no cover\n        assert exc_info.value.status_code == 404\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        await websocket_session(f\"ws://127.0.0.1:{unused_tcp_port}\")\n\n    assert exception_message == (\n        \"Expected ASGI message 'websocket.http.response.body' but got \" \"'websocket.http.response.start'.\"\n    )"
    },
    {
      "chunk_id": 386,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_server_can_read_messages_in_buffer_after_close(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    frames: list[bytes] = []\n    disconnect_message: WebSocketDisconnectEvent | EmptyDict = {}\n\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n            # Ensure server doesn't start reading frames from read buffer until\n            # after client has sent close frame, but server is still able to\n            # read these frames\n            await asyncio.sleep(0.2)\n\n        async def websocket_disconnect(self, message: WebSocketDisconnectEvent):\n            nonlocal disconnect_message\n            disconnect_message = message\n\n        async def websocket_receive(self, message: WebSocketReceiveEvent):\n            _bytes = message.get(\"bytes\")\n            assert _bytes is not None\n            frames.append(_bytes)\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            await websocket.send(b\"abc\")\n            await websocket.send(b\"abc\")\n            await websocket.send(b\"abc\")\n\n    assert frames == [b\"abc\", b\"abc\", b\"abc\"]\n    assert disconnect_message == {\"type\": \"websocket.disconnect\", \"code\": 1000, \"reason\": \"\"}"
    },
    {
      "chunk_id": 387,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_default_server_headers(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.response_headers\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        headers = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert headers.get(\"server\") == \"uvicorn\" and \"date\" in headers"
    },
    {
      "chunk_id": 388,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_no_server_headers(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.response_headers\n\n    config = Config(\n        app=App,\n        ws=ws_protocol_cls,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        server_header=False,\n        port=unused_tcp_port,\n    )\n    async with run_server(config):\n        headers = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert \"server\" not in headers"
    },
    {
      "chunk_id": 389,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "@skip_if_no_wsproto\nasync def test_no_date_header_on_wsproto(http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.response_headers\n\n    config = Config(\n        app=App,\n        ws=_WSProtocol,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        date_header=False,\n        port=unused_tcp_port,\n    )\n    async with run_server(config):\n        headers = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert \"date\" not in headers"
    },
    {
      "chunk_id": 390,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_multiple_server_header(\n    ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int\n):\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            await self.send(\n                {\n                    \"type\": \"websocket.accept\",\n                    \"headers\": [\n                        (b\"Server\", b\"over-ridden\"),\n                        (b\"Server\", b\"another-value\"),\n                    ],\n                }\n            )\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.response_headers\n\n    config = Config(app=App, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        headers = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert headers.get_all(\"Server\") == [\"uvicorn\", \"over-ridden\", \"another-value\"]"
    },
    {
      "chunk_id": 391,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_websocket.py",
      "content": "async def test_lifespan_state(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    expected_states: list[dict[str, typing.Any]] = [\n        {\"a\": 123, \"b\": [1]},\n        {\"a\": 123, \"b\": [1, 2]},\n    ]\n\n    actual_states: list[dict[str, typing.Any]] = []\n\n    async def lifespan_app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\" and \"state\" in scope\n        scope[\"state\"][\"a\"] = 123\n        scope[\"state\"][\"b\"] = [1]\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    class App(WebSocketResponse):\n        async def websocket_connect(self, message: WebSocketConnectEvent):\n            assert \"state\" in self.scope\n            actual_states.append(deepcopy(self.scope[\"state\"]))\n            self.scope[\"state\"][\"a\"] = 456\n            self.scope[\"state\"][\"b\"].append(2)\n            await self.send({\"type\": \"websocket.accept\"})\n\n    async def open_connection(url: str):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.open\n\n    async def app_wrapper(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        if scope[\"type\"] == \"lifespan\":\n            return await lifespan_app(scope, receive, send)\n        return await App(scope, receive, send)\n\n    config = Config(app=app_wrapper, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"on\", port=unused_tcp_port)\n    async with run_server(config):\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert is_open\n        is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert is_open\n\n    assert expected_states == actual_states\n```"
    },
    {
      "chunk_id": 392,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "```python"
    },
    {
      "chunk_id": 393,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "from __future__ import annotations\n\nimport logging\nimport socket\nimport threading\nimport time\nfrom typing import TYPE_CHECKING, Any\n\nimport pytest\n\nfrom tests.response import Response\nfrom uvicorn import Server\nfrom uvicorn._types import ASGIApplication, ASGIReceiveCallable, ASGISendCallable, Scope\nfrom uvicorn.config import WS_PROTOCOLS, Config\nfrom uvicorn.lifespan.off import LifespanOff\nfrom uvicorn.lifespan.on import LifespanOn\nfrom uvicorn.main import ServerState\nfrom uvicorn.protocols.http.h11_impl import H11Protocol\n\ntry:\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n\n    skip_if_no_httptools = pytest.mark.skipif(False, reason=\"httptools is installed\")\nexcept ModuleNotFoundError:  # pragma: no cover\n    skip_if_no_httptools = pytest.mark.skipif(True, reason=\"httptools is not installed\")\n\nif TYPE_CHECKING:\n    import sys\n\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol as _WSProtocol\n\n    if sys.version_info >= (3, 10):  # pragma: no cover\n        from typing import TypeAlias\n    else:  # pragma: no cover\n        from typing_extensions import TypeAlias\n\n    HTTPProtocol: TypeAlias = \"type[HttpToolsProtocol | H11Protocol]\"\n    WSProtocol: TypeAlias = \"type[WebSocketProtocol | _WSProtocol]\"\n\npytestmark = pytest.mark.anyio\n\n\nWEBSOCKET_PROTOCOLS = WS_PROTOCOLS.keys()\n\nSIMPLE_GET_REQUEST = b\"\\r\\n\".join([b\"GET / HTTP/1.1\", b\"Host: example.org\", b\"\", b\"\"])\n\nSIMPLE_HEAD_REQUEST = b\"\\r\\n\".join([b\"HEAD / HTTP/1.1\", b\"Host: example.org\", b\"\", b\"\"])\n\nSIMPLE_POST_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"POST / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Content-Type: application/json\",\n        b\"Content-Length: 18\",\n        b\"\",\n        b'{\"hello\": \"world\"}',\n    ]\n)\n\nCONNECTION_CLOSE_REQUEST = b\"\\r\\n\".join([b\"GET / HTTP/1.1\", b\"Host: example.org\", b\"Connection: close\", b\"\", b\"\"])\n\nCONNECTION_CLOSE_POST_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"POST / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Connection: close\",\n        b\"Content-Type: application/json\",\n        b\"Content-Length: 18\",\n        b\"\",\n        b\"{'hello': 'world'}\",\n    ]\n)\n\nREQUEST_AFTER_CONNECTION_CLOSE = b\"\\r\\n\".join(\n    [\n        b\"GET / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Connection: close\",\n        b\"\",\n        b\"\",\n        b\"GET / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"\",\n        b\"\",\n    ]\n)\n\nLARGE_POST_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"POST / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Content-Type: text/plain\",\n        b\"Content-Length: 100000\",\n        b\"\",\n        b\"x\" * 100000,\n    ]\n)\n\nSTART_POST_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"POST / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Content-Type: application/json\",\n        b\"Content-Length: 18\",\n        b\"\",\n        b\"\",\n    ]\n)\n\nFINISH_POST_REQUEST = b'{\"hello\": \"world\"}'\n\nHTTP10_GET_REQUEST = b\"\\r\\n\".join([b\"GET / HTTP/1.0\", b\"Host: example.org\", b\"\", b\"\"])\n\nGET_REQUEST_WITH_RAW_PATH = b\"\\r\\n\".join([b\"GET /one%2Ftwo HTTP/1.1\", b\"Host: example.org\", b\"\", b\"\"])\n\nUPGRADE_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"GET / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Connection: upgrade\",\n        b\"Upgrade: websocket\",\n        b\"Sec-WebSocket-Version: 11\",\n        b\"\",\n        b\"\",\n    ]\n)\n\nUPGRADE_HTTP2_REQUEST = b\"\\r\\n\".join(\n    [\n        b\"GET / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Connection: upgrade\",\n        b\"Upgrade: h2c\",\n        b\"Sec-WebSocket-Version: 11\",\n        b\"\",\n        b\"\",\n    ]\n)\n\nINVALID_REQUEST_TEMPLATE = b\"\\r\\n\".join(\n    [\n        b\"%s\",\n        b\"Host: example.org\",\n        b\"\",\n        b\"\",\n    ]\n)\n\nGET_REQUEST_HUGE_HEADERS = [\n    b\"\".join(\n        [\n            b\"GET / HTTP/1.1\\r\\n\",\n            b\"Host: example.org\\r\\n\",\n            b\"Cookie: \" + b\"x\" * 32 * 1024,\n        ]\n    ),\n    b\"\".join([b\"x\" * 32 * 1024 + b\"\\r\\n\", b\"\\r\\n\", b\"\\r\\n\"]),\n]\n\nUPGRADE_REQUEST_ERROR_FIELD = b\"\\r\\n\".join(\n    [\n        b\"GET / HTTP/1.1\",\n        b\"Host: example.org\",\n        b\"Connection: upgrade\",\n        b\"Upgrade: not-websocket\",\n        b\"Sec-WebSocket-Version: 11\",\n        b\"\",\n        b\"\",\n    ]\n)"
    },
    {
      "chunk_id": 394,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "class MockTransport:\n    def __init__(self, sockname=None, peername=None, sslcontext=False):\n        self.sockname = (\"127.0.0.1\", 8000) if sockname is None else sockname\n        self.peername = (\"127.0.0.1\", 8001) if peername is None else peername\n        self.sslcontext = sslcontext\n        self.closed = False\n        self.buffer = b\"\"\n        self.read_paused = False\n\n    def get_extra_info(self, key):\n        return {\n            \"sockname\": self.sockname,\n            \"peername\": self.peername,\n            \"sslcontext\": self.sslcontext,\n        }.get(key)\n\n    def write(self, data):\n        assert not self.closed\n        self.buffer += data\n\n    def close(self):\n        assert not self.closed\n        self.closed = True\n\n    def pause_reading(self):\n        self.read_paused = True\n\n    def resume_reading(self):\n        self.read_paused = False\n\n    def is_closing(self):\n        return self.closed\n\n    def clear_buffer(self):\n        self.buffer = b\"\"\n\n    def set_protocol(self, protocol):\n        pass"
    },
    {
      "chunk_id": 395,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "class MockTimerHandle:\n    def __init__(self, loop_later_list, delay, callback, args):\n        self.loop_later_list = loop_later_list\n        self.delay = delay\n        self.callback = callback\n        self.args = args\n        self.cancelled = False\n\n    def cancel(self):\n        if not self.cancelled:\n            self.cancelled = True\n            self.loop_later_list.remove(self)"
    },
    {
      "chunk_id": 396,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "class MockLoop:\n    def __init__(self):\n        self._tasks = []\n        self._later = []\n\n    def create_task(self, coroutine):\n        self._tasks.insert(0, coroutine)\n        return MockTask()\n\n    def call_later(self, delay, callback, *args):\n        handle = MockTimerHandle(self._later, delay, callback, args)\n        self._later.insert(0, handle)\n        return handle\n\n    async def run_one(self):\n        return await self._tasks.pop()\n\n    def run_later(self, with_delay):\n        later = []\n        for timer_handle in self._later:\n            if with_delay >= timer_handle.delay:\n                timer_handle.callback(*timer_handle.args)\n            else:\n                later.append(timer_handle)\n        self._later = later"
    },
    {
      "chunk_id": 397,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "class MockTask:\n    def add_done_callback(self, callback):\n        pass"
    },
    {
      "chunk_id": 398,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "def get_connected_protocol(\n    app: ASGIApplication,\n    http_protocol_cls: HTTPProtocol,\n    lifespan: LifespanOff | LifespanOn | None = None,\n    **kwargs: Any,\n):\n    loop = MockLoop()\n    transport = MockTransport()\n    config = Config(app=app, **kwargs)\n    lifespan = lifespan or LifespanOff(config)\n    server_state = ServerState()\n    protocol = http_protocol_cls(\n        config=config,\n        server_state=server_state,\n        app_state=lifespan.state,\n        _loop=loop,  # type: ignore\n    )\n    protocol.connection_made(transport)  # type: ignore\n    return protocol"
    },
    {
      "chunk_id": 399,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_get_request(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 400,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@pytest.mark.parametrize(\n    \"char\",\n    [\n        pytest.param(\"c\", id=\"allow_ascii_letter\"),\n        pytest.param(\"\\t\", id=\"allow_tab\"),\n        pytest.param(\" \", id=\"allow_space\"),\n        pytest.param(\"\u00b5\", id=\"allow_non_ascii_char\"),\n    ],\n)\nasync def test_header_value_allowed_characters(http_protocol_cls: HTTPProtocol, char: str):\n    app = Response(\"Hello, world\", media_type=\"text/plain\", headers={\"key\": f\"<{char}>\"})\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert (b\"\\r\\nkey: <\" + char.encode() + b\">\\r\\n\") in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 401,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@pytest.mark.parametrize(\"path\", [\"/\", \"/?foo\", \"/?foo=bar\", \"/?foo=bar&baz=1\"])\nasync def test_request_logging(path: str, http_protocol_cls: HTTPProtocol, caplog: pytest.LogCaptureFixture):\n    get_request_with_query_string = b\"\\r\\n\".join(\n        [f\"GET {path} HTTP/1.1\".encode(\"ascii\"), b\"Host: example.org\", b\"\", b\"\"]\n    )\n    caplog.set_level(logging.INFO, logger=\"uvicorn.access\")\n    logging.getLogger(\"uvicorn.access\").propagate = True\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, log_config=None)\n    protocol.data_received(get_request_with_query_string)\n    await protocol.loop.run_one()\n    assert f'\"GET {path} HTTP/1.1\" 200' in caplog.records[0].message"
    },
    {
      "chunk_id": 402,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_head_request(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_HEAD_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" not in protocol.transport.buffer"
    },
    {
      "chunk_id": 403,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_post_request(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await receive()\n            assert message[\"type\"] == \"http.request\"\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n        response = Response(b\"Body: \" + body, media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_POST_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b'Body: {\"hello\": \"world\"}' in protocol.transport.buffer"
    },
    {
      "chunk_id": 404,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_keepalive(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"\", status_code=204)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n\n    assert b\"HTTP/1.1 204 No Content\" in protocol.transport.buffer\n    assert not protocol.transport.is_closing()"
    },
    {
      "chunk_id": 405,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_keepalive_timeout(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"\", status_code=204)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 204 No Content\" in protocol.transport.buffer\n    assert not protocol.transport.is_closing()\n    protocol.loop.run_later(with_delay=1)\n    assert not protocol.transport.is_closing()\n    protocol.loop.run_later(with_delay=5)\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 406,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_keepalive_timeout_with_pipelined_requests(\n    http_protocol_cls: HTTPProtocol,\n):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n\n    # After processing the first request, the keep-alive task should be\n    # disabled because the second request is not responded yet.\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    assert protocol.timeout_keep_alive_task is None\n\n    # Process the second request and ensure that the keep-alive task\n    # has been enabled again as the connection is now idle.\n    protocol.transport.clear_buffer()\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    assert protocol.timeout_keep_alive_task is not None"
    },
    {
      "chunk_id": 407,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_close(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"\", status_code=204, headers={\"connection\": \"close\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 204 No Content\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 408,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_chunked_encoding(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"Hello, world!\", status_code=200, headers={\"transfer-encoding\": \"chunked\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"0\\r\\n\\r\\n\" in protocol.transport.buffer\n    assert not protocol.transport.is_closing()"
    },
    {
      "chunk_id": 409,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_chunked_encoding_empty_body(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"Hello, world!\", status_code=200, headers={\"transfer-encoding\": \"chunked\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert protocol.transport.buffer.count(b\"0\\r\\n\\r\\n\") == 1\n    assert not protocol.transport.is_closing()"
    },
    {
      "chunk_id": 410,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_chunked_encoding_head_request(\n    http_protocol_cls: HTTPProtocol,\n):\n    app = Response(b\"Hello, world!\", status_code=200, headers={\"transfer-encoding\": \"chunked\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_HEAD_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert not protocol.transport.is_closing()"
    },
    {
      "chunk_id": 411,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_pipelined_requests(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    protocol.transport.clear_buffer()\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    protocol.transport.clear_buffer()\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    protocol.transport.clear_buffer()"
    },
    {
      "chunk_id": 412,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_undersized_request(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"xxx\", headers={\"content-length\": \"10\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 413,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_oversized_request(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"xxx\" * 20, headers={\"content-length\": \"10\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 414,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_large_post_request(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(LARGE_POST_REQUEST)\n    assert protocol.transport.read_paused\n    await protocol.loop.run_one()\n    assert not protocol.transport.read_paused"
    },
    {
      "chunk_id": 415,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_invalid_http(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(b\"x\" * 100000)\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 416,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_app_exception(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        raise Exception()\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 417,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_exception_during_response(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n        await send({\"type\": \"http.response.body\", \"body\": b\"1\", \"more_body\": True})\n        raise Exception()\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" not in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 418,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_no_response_returned(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable): ...\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 419,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_partial_response_returned(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" not in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 420,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_response_header_splitting(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"\", headers={\"key\": \"value\\r\\nCookie: smuggled=value\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" not in protocol.transport.buffer\n    assert b\"\\r\\nCookie: smuggled=value\\r\\n\" not in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 421,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_duplicate_start_message(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" not in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 422,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_missing_start_message(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 500 Internal Server Error\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 423,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_message_after_body_complete(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 424,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_value_returned(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"http.response.start\", \"status\": 200})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n        return 123\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 425,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_early_disconnect(http_protocol_cls: HTTPProtocol):\n    got_disconnect_event = False\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal got_disconnect_event\n\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"http.disconnect\":\n                break\n\n        got_disconnect_event = True\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_POST_REQUEST)\n    protocol.eof_received()\n    protocol.connection_lost(None)\n    await protocol.loop.run_one()\n    assert got_disconnect_event"
    },
    {
      "chunk_id": 426,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_early_response(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(START_POST_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    protocol.data_received(FINISH_POST_REQUEST)\n    assert not protocol.transport.is_closing()"
    },
    {
      "chunk_id": 427,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_read_after_response(http_protocol_cls: HTTPProtocol):\n    message_after_response = None\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        nonlocal message_after_response\n\n        response = Response(\"Hello, world\", media_type=\"text/plain\")\n        await response(scope, receive, send)\n        message_after_response = await receive()\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_POST_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert message_after_response == {\"type\": \"http.disconnect\"}"
    },
    {
      "chunk_id": 428,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_http10_request(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"http\"\n        content = \"Version: %s\" % scope[\"http_version\"]\n        response = Response(content, media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(HTTP10_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Version: 1.0\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 429,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_root_path(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"http\"\n        root_path = scope.get(\"root_path\", \"\")\n        path = scope[\"path\"]\n        response = Response(f\"root_path={root_path} path={path}\", media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls, root_path=\"/app\")\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"root_path=/app path=/app/\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 430,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_raw_path(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"http\"\n        path = scope[\"path\"]\n        raw_path = scope.get(\"raw_path\", None)\n        assert \"/app/one/two\" == path\n        assert b\"/app/one%2Ftwo\" == raw_path\n\n        response = Response(\"Done\", media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls, root_path=\"/app\")\n    protocol.data_received(GET_REQUEST_WITH_RAW_PATH)\n    await protocol.loop.run_one()\n    assert b\"Done\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 431,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_max_concurrency(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, limit_concurrency=1)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert (\n        b\"\\r\\n\".join(\n            [\n                b\"HTTP/1.1 503 Service Unavailable\",\n                b\"content-type: text/plain; charset=utf-8\",\n                b\"content-length: 19\",\n                b\"connection: close\",\n                b\"\",\n                b\"Service Unavailable\",\n            ]\n        )\n        == protocol.transport.buffer\n    )"
    },
    {
      "chunk_id": 432,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_shutdown_during_request(http_protocol_cls: HTTPProtocol):\n    app = Response(b\"\", status_code=204)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    protocol.shutdown()\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 204 No Content\" in protocol.transport.buffer\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 433,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_shutdown_during_idle(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.shutdown()\n    assert protocol.transport.buffer == b\"\"\n    assert protocol.transport.is_closing()"
    },
    {
      "chunk_id": 434,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_100_continue_sent_when_body_consumed(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await receive()\n            assert message[\"type\"] == \"http.request\"\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n        response = Response(b\"Body: \" + body, media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    EXPECT_100_REQUEST = b\"\\r\\n\".join(\n        [\n            b\"POST / HTTP/1.1\",\n            b\"Host: example.org\",\n            b\"Expect: 100-continue\",\n            b\"Content-Type: application/json\",\n            b\"Content-Length: 18\",\n            b\"\",\n            b'{\"hello\": \"world\"}',\n        ]\n    )\n    protocol.data_received(EXPECT_100_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 100 Continue\" in protocol.transport.buffer\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b'Body: {\"hello\": \"world\"}' in protocol.transport.buffer"
    },
    {
      "chunk_id": 435,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_100_continue_not_sent_when_body_not_consumed(\n    http_protocol_cls: HTTPProtocol,\n):\n    app = Response(b\"\", status_code=204)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    EXPECT_100_REQUEST = b\"\\r\\n\".join(\n        [\n            b\"POST / HTTP/1.1\",\n            b\"Host: example.org\",\n            b\"Expect: 100-continue\",\n            b\"Content-Type: application/json\",\n            b\"Content-Length: 18\",\n            b\"\",\n            b'{\"hello\": \"world\"}',\n        ]\n    )\n    protocol.data_received(EXPECT_100_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 100 Continue\" not in protocol.transport.buffer\n    assert b\"HTTP/1.1 204 No Content\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 436,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_supported_upgrade_request(http_protocol_cls: HTTPProtocol):\n    pytest.importorskip(\"wsproto\")\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, ws=\"wsproto\")\n    protocol.data_received(UPGRADE_REQUEST)\n    assert b\"HTTP/1.1 426 \" in protocol.transport.buffer"
    },
    {
      "chunk_id": 437,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_unsupported_ws_upgrade_request(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, ws=\"none\")\n    protocol.data_received(UPGRADE_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 438,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_unsupported_ws_upgrade_request_warn_on_auto(\n    caplog: pytest.LogCaptureFixture, http_protocol_cls: HTTPProtocol\n):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, ws=\"auto\")\n    protocol.ws_protocol_class = None\n    protocol.data_received(UPGRADE_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n    warnings = [record.msg for record in filter(lambda record: record.levelname == \"WARNING\", caplog.records)]\n    assert \"Unsupported upgrade request.\" in warnings\n    msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n    assert msg in warnings"
    },
    {
      "chunk_id": 439,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_http2_upgrade_request(http_protocol_cls: HTTPProtocol, ws_protocol_cls: WSProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, ws=ws_protocol_cls)\n    protocol.data_received(UPGRADE_HTTP2_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 440,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def asgi3app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n    pass"
    },
    {
      "chunk_id": 441,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "def asgi2app(scope: Scope):\n    async def asgi(receive: ASGIReceiveCallable, send: ASGISendCallable):\n        pass\n\n    return asgi"
    },
    {
      "chunk_id": 442,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@pytest.mark.parametrize(\n    \"asgi2or3_app, expected_scopes\",\n    [\n        (asgi3app, {\"version\": \"3.0\", \"spec_version\": \"2.3\"}),\n        (asgi2app, {\"version\": \"2.0\", \"spec_version\": \"2.3\"}),\n    ],\n)\nasync def test_scopes(\n    asgi2or3_app: ASGIApplication,\n    expected_scopes: dict[str, str],\n    http_protocol_cls: HTTPProtocol,\n):\n    protocol = get_connected_protocol(asgi2or3_app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert expected_scopes == protocol.scope.get(\"asgi\")"
    },
    {
      "chunk_id": 443,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@pytest.mark.parametrize(\n    \"request_line\",\n    [\n        pytest.param(b\"G?T / HTTP/1.1\", id=\"invalid-method\"),\n        pytest.param(b\"GET /?x=y z HTTP/1.1\", id=\"invalid-path\"),\n        pytest.param(b\"GET / HTTP1.1\", id=\"invalid-http-version\"),\n    ],\n)\nasync def test_invalid_http_request(\n    request_line: str, http_protocol_cls: HTTPProtocol, caplog: pytest.LogCaptureFixture\n):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n    request = INVALID_REQUEST_TEMPLATE % request_line\n\n    caplog.set_level(logging.INFO, logger=\"uvicorn.error\")\n    logging.getLogger(\"uvicorn.error\").propagate = True\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(request)\n    assert b\"HTTP/1.1 400 Bad Request\" in protocol.transport.buffer\n    assert b\"Invalid HTTP request received.\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 444,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@skip_if_no_httptools\ndef test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()"
    },
    {
      "chunk_id": 445,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_huge_headers_h11protocol_failure():\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, H11Protocol)\n    # Huge headers make h11 fail in it's default config\n    # h11 sends back a 400 in this case\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[0])\n    assert b\"HTTP/1.1 400 Bad Request\" in protocol.transport.buffer\n    assert b\"Connection: close\" in protocol.transport.buffer\n    assert b\"Invalid HTTP request received.\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 446,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@skip_if_no_httptools\nasync def test_huge_headers_httptools_will_pass():\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, HttpToolsProtocol)\n    # Huge headers make h11 fail in it's default config\n    # httptools protocol will always pass\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[0])\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[1])\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 447,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_huge_headers_h11protocol_failure_with_setting():\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, H11Protocol, h11_max_incomplete_event_size=20 * 1024)\n    # Huge headers make h11 fail in it's default config\n    # h11 sends back a 400 in this case\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[0])\n    assert b\"HTTP/1.1 400 Bad Request\" in protocol.transport.buffer\n    assert b\"Connection: close\" in protocol.transport.buffer\n    assert b\"Invalid HTTP request received.\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 448,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "@skip_if_no_httptools\nasync def test_huge_headers_httptools():\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, HttpToolsProtocol)\n    # Huge headers make h11 fail in it's default config\n    # httptools protocol will always pass\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[0])\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[1])\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 449,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_huge_headers_h11_max_incomplete():\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, H11Protocol, h11_max_incomplete_event_size=64 * 1024)\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[0])\n    protocol.data_received(GET_REQUEST_HUGE_HEADERS[1])\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 450,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_return_close_header(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(CONNECTION_CLOSE_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"content-type: text/plain\" in protocol.transport.buffer\n    assert b\"content-length: 12\" in protocol.transport.buffer\n    # NOTE: We need to use `.lower()` because H11 implementation doesn't allow Uvicorn\n    # to lowercase them. See: https://github.com/python-hyper/h11/issues/156\n    assert b\"connection: close\" in protocol.transport.buffer.lower()"
    },
    {
      "chunk_id": 451,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_close_connection_with_multiple_requests(http_protocol_cls: HTTPProtocol):\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(REQUEST_AFTER_CONNECTION_CLOSE)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"content-type: text/plain\" in protocol.transport.buffer\n    assert b\"content-length: 12\" in protocol.transport.buffer\n    # NOTE: We need to use `.lower()` because H11 implementation doesn't allow Uvicorn\n    # to lowercase them. See: https://github.com/python-hyper/h11/issues/156\n    assert b\"connection: close\" in protocol.transport.buffer.lower()"
    },
    {
      "chunk_id": 452,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_close_connection_with_post_request(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await receive()\n            assert message[\"type\"] == \"http.request\"\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n        response = Response(b\"Body: \" + body, media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(CONNECTION_CLOSE_POST_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Body: {'hello': 'world'}\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 453,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_iterator_headers(http_protocol_cls: HTTPProtocol):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        headers = iter([(b\"x-test-header\", b\"test value\")])\n        await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": headers})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(SIMPLE_GET_REQUEST)\n    await protocol.loop.run_one()\n    assert b\"x-test-header: test value\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 454,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_lifespan_state(http_protocol_cls: HTTPProtocol):\n    expected_states = [{\"a\": 123, \"b\": [1]}, {\"a\": 123, \"b\": [1, 2]}]\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert \"state\" in scope\n        expected_state = expected_states.pop(0)\n        assert scope[\"state\"] == expected_state\n        # modifications to keys are not preserved\n        scope[\"state\"][\"a\"] = 456\n        # unless of course the value itself is mutated\n        scope[\"state\"][\"b\"].append(2)\n        return await Response(\"Hi!\")(scope, receive, send)\n\n    lifespan = LifespanOn(config=Config(app=app))\n    # skip over actually running the lifespan, that is tested\n    # in the lifespan tests\n    lifespan.state.update({\"a\": 123, \"b\": [1]})\n\n    protocol = get_connected_protocol(app, http_protocol_cls, lifespan=lifespan)\n    for _ in range(2):\n        protocol.data_received(SIMPLE_GET_REQUEST)\n        await protocol.loop.run_one()\n        assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n        assert b\"Hi!\" in protocol.transport.buffer\n\n    assert not expected_states  # consumed"
    },
    {
      "chunk_id": 455,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_header_upgrade_is_not_websocket_depend_installed(\n    caplog: pytest.LogCaptureFixture, http_protocol_cls: HTTPProtocol\n):\n    caplog.set_level(logging.WARNING, logger=\"uvicorn.error\")\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls)\n    protocol.data_received(UPGRADE_REQUEST_ERROR_FIELD)\n    await protocol.loop.run_one()\n    assert \"Unsupported upgrade request.\" in caplog.text\n    msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n    assert msg not in caplog.text\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer"
    },
    {
      "chunk_id": 456,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_http.py",
      "content": "async def test_header_upgrade_is_websocket_depend_not_installed(\n    caplog: pytest.LogCaptureFixture, http_protocol_cls: HTTPProtocol\n):\n    caplog.set_level(logging.WARNING, logger=\"uvicorn.error\")\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    protocol = get_connected_protocol(app, http_protocol_cls, ws=\"none\")\n    protocol.data_received(UPGRADE_REQUEST_ERROR_FIELD)\n    await protocol.loop.run_one()\n    assert \"Unsupported upgrade request.\" in caplog.text\n    msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n    assert msg in caplog.text\n    assert b\"HTTP/1.1 200 OK\" in protocol.transport.buffer\n    assert b\"Hello, world\" in protocol.transport.buffer\n```"
    },
    {
      "chunk_id": 457,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "from __future__ import annotations\n\nimport socket\nfrom asyncio import Transport\nfrom typing import Any\n\nimport pytest\n\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_remote_addr"
    },
    {
      "chunk_id": 458,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "class MockSocket:\n    def __init__(self, family, peername=None, sockname=None):\n        self.peername = peername\n        self.sockname = sockname\n        self.family = family\n\n    def getpeername(self):\n        return self.peername\n\n    def getsockname(self):\n        return self.sockname"
    },
    {
      "chunk_id": 459,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "class MockTransport(Transport):\n    def __init__(self, info: dict[str, Any]) -> None:\n        self.info = info\n\n    def get_extra_info(self, name: str, default: Any = None) -> Any:\n        return self.info.get(name)"
    },
    {
      "chunk_id": 460,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "def test_get_local_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, sockname=(\"::1\", 123))})\n    assert get_local_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, sockname=(\"123.45.6.7\", 123))})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, sockname=(\"127.0.0.1\", 8000))})\n        assert get_local_addr(transport) == (\"127.0.0.1\", 8000)"
    },
    {
      "chunk_id": 461,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "def test_get_remote_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, peername=(\"::1\", 123))})\n    assert get_remote_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, peername=(\"123.45.6.7\", 123))})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, peername=(\"127.0.0.1\", 8000))})\n        assert get_remote_addr(transport) == (\"127.0.0.1\", 8000)"
    },
    {
      "chunk_id": 462,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "def test_get_local_addr():\n    transport = MockTransport({\"sockname\": \"path/to/unix-domain-socket\"})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"sockname\": (\"123.45.6.7\", 123)})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)"
    },
    {
      "chunk_id": 463,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "def test_get_remote_addr():\n    transport = MockTransport({\"peername\": None})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"peername\": (\"123.45.6.7\", 123)})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)"
    },
    {
      "chunk_id": 464,
      "source": "__internal__/data_repo/uvicorn/tests/protocols/test_utils.py",
      "content": "@pytest.mark.parametrize(\n    \"scope, expected_client\",\n    [({\"client\": (\"127.0.0.1\", 36000)}, \"127.0.0.1:36000\"), ({\"client\": None}, \"\")],\n    ids=[\"ip:port client\", \"None client\"],\n)\ndef test_get_client_addr(scope, expected_client):\n    assert get_client_addr(scope) == expected_client"
    },
    {
      "chunk_id": 465,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/__init__.py",
      "content": "Sure! Please provide the Python code you would like me to analyze and chunk."
    },
    {
      "chunk_id": 466,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_message_logger.py",
      "content": "import httpx\nimport pytest\n\nfrom tests.middleware.test_logging import caplog_for_logger\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware"
    },
    {
      "chunk_id": 467,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_message_logger.py",
      "content": "@pytest.mark.anyio\nasync def test_message_logger(caplog):\n    async def app(scope, receive, send):\n        await receive()\n        await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n\n    with caplog_for_logger(caplog, \"uvicorn.asgi\"):\n        caplog.set_level(TRACE_LOG_LEVEL, logger=\"uvicorn.asgi\")\n        caplog.set_level(TRACE_LOG_LEVEL)\n\n        transport = httpx.ASGITransport(MessageLoggerMiddleware(app))  # type: ignore\n        async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n            response = await client.get(\"/\")\n        assert response.status_code == 200\n        messages = [record.msg % record.args for record in caplog.records]\n        assert sum([\"ASGI [1] Started\" in message for message in messages]) == 1\n        assert sum([\"ASGI [1] Send\" in message for message in messages]) == 2\n        assert sum([\"ASGI [1] Receive\" in message for message in messages]) == 1\n        assert sum([\"ASGI [1] Completed\" in message for message in messages]) == 1\n        assert sum([\"ASGI [1] Raised exception\" in message for message in messages]) == 0"
    },
    {
      "chunk_id": 468,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_message_logger.py",
      "content": "@pytest.mark.anyio\nasync def test_message_logger_exc(caplog):\n    async def app(scope, receive, send):\n        raise RuntimeError()\n\n    with caplog_for_logger(caplog, \"uvicorn.asgi\"):\n        caplog.set_level(TRACE_LOG_LEVEL, logger=\"uvicorn.asgi\")\n        caplog.set_level(TRACE_LOG_LEVEL)\n        transport = httpx.ASGITransport(MessageLoggerMiddleware(app))  # type: ignore\n        async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n            with pytest.raises(RuntimeError):\n                await client.get(\"/\")\n        messages = [record.msg % record.args for record in caplog.records]\n        assert sum([\"ASGI [1] Started\" in message for message in messages]) == 1\n        assert sum([\"ASGI [1] Send\" in message for message in messages]) == 0\n        assert sum([\"ASGI [1] Receive\" in message for message in messages]) == 0\n        assert sum([\"ASGI [1] Completed\" in message for message in messages]) == 0\n        assert sum([\"ASGI [1] Raised exception\" in message for message in messages]) == 1"
    },
    {
      "chunk_id": 469,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "from __future__ import annotations\n\nimport io\nimport sys\nfrom collections.abc import AsyncGenerator\nfrom typing import Callable\n\nimport a2wsgi\nimport httpx\nimport pytest\n\nfrom uvicorn._types import Environ, HTTPRequestEvent, HTTPScope, StartResponse\nfrom uvicorn.middleware import wsgi"
    },
    {
      "chunk_id": 470,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "def hello_world(environ: Environ, start_response: StartResponse) -> list[bytes]:\n    status = \"200 OK\"\n    output = b\"Hello World!\\n\"\n    headers = [\n        (\"Content-Type\", \"text/plain; charset=utf-8\"),\n        (\"Content-Length\", str(len(output))),\n    ]\n    start_response(status, headers, None)\n    return [output]"
    },
    {
      "chunk_id": 471,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "def echo_body(environ: Environ, start_response: StartResponse) -> list[bytes]:\n    status = \"200 OK\"\n    output = environ[\"wsgi.input\"].read()\n    headers = [\n        (\"Content-Type\", \"text/plain; charset=utf-8\"),\n        (\"Content-Length\", str(len(output))),\n    ]\n    start_response(status, headers, None)\n    return [output]"
    },
    {
      "chunk_id": 472,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "def raise_exception(environ: Environ, start_response: StartResponse) -> list[bytes]:\n    raise RuntimeError(\"Something went wrong\")"
    },
    {
      "chunk_id": 473,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "def return_exc_info(environ: Environ, start_response: StartResponse) -> list[bytes]:\n    try:\n        raise RuntimeError(\"Something went wrong\")\n    except RuntimeError:\n        status = \"500 Internal Server Error\"\n        output = b\"Internal Server Error\"\n        headers = [\n            (\"Content-Type\", \"text/plain; charset=utf-8\"),\n            (\"Content-Length\", str(len(output))),\n        ]\n        start_response(status, headers, sys.exc_info())  # type: ignore[arg-type]\n        return [output]"
    },
    {
      "chunk_id": 474,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.fixture(params=[wsgi._WSGIMiddleware, a2wsgi.WSGIMiddleware])\ndef wsgi_middleware(request: pytest.FixtureRequest) -> Callable:\n    return request.param"
    },
    {
      "chunk_id": 475,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.mark.anyio\nasync def test_wsgi_get(wsgi_middleware: Callable) -> None:\n    transport = httpx.ASGITransport(wsgi_middleware(hello_world))\n    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        response = await client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello World!\\n\""
    },
    {
      "chunk_id": 476,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.mark.anyio\nasync def test_wsgi_post(wsgi_middleware: Callable) -> None:\n    transport = httpx.ASGITransport(wsgi_middleware(echo_body))\n    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        response = await client.post(\"/\", json={\"example\": 123})\n    assert response.status_code == 200\n    assert response.text == '{\"example\":123}'"
    },
    {
      "chunk_id": 477,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.mark.anyio\nasync def test_wsgi_put_more_body(wsgi_middleware: Callable) -> None:\n    async def generate_body() -> AsyncGenerator[bytes, None]:\n        for _ in range(1024):\n            yield b\"123456789abcdef\\n\" * 64\n\n    transport = httpx.ASGITransport(wsgi_middleware(echo_body))\n    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        response = await client.put(\"/\", content=generate_body())\n    assert response.status_code == 200\n    assert response.text == \"123456789abcdef\\n\" * 64 * 1024"
    },
    {
      "chunk_id": 478,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.mark.anyio\nasync def test_wsgi_exception(wsgi_middleware: Callable) -> None:\n    transport = httpx.ASGITransport(wsgi_middleware(raise_exception))\n    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        with pytest.raises(RuntimeError):\n            await client.get(\"/\")"
    },
    {
      "chunk_id": 479,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "@pytest.mark.anyio\nasync def test_wsgi_exc_info(wsgi_middleware: Callable) -> None:\n    app = wsgi_middleware(return_exc_info)\n    transport = httpx.ASGITransport(\n        app=app,\n        raise_app_exceptions=False,\n    )\n    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        response = await client.get(\"/\")\n    assert response.status_code == 500\n    assert response.text == \"Internal Server Error\""
    },
    {
      "chunk_id": 480,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_wsgi.py",
      "content": "def test_build_environ_encoding() -> None:\n    scope: HTTPScope = {\n        \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n        \"scheme\": \"http\",\n        \"raw_path\": b\"/\\xe6\\x96\\x87%2Fall\",\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"path\": \"/\u6587/all\",\n        \"root_path\": \"/\u6587\",\n        \"client\": None,\n        \"server\": None,\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [(b\"key\", b\"value1\"), (b\"key\", b\"value2\")],\n        \"extensions\": {},\n    }\n    message: HTTPRequestEvent = {\n        \"type\": \"http.request\",\n        \"body\": b\"\",\n        \"more_body\": False,\n    }\n    environ = wsgi.build_environ(scope, message, io.BytesIO(b\"\"))\n    assert environ[\"SCRIPT_NAME\"] == \"/\u6587\".encode().decode(\"latin-1\")\n    assert environ[\"PATH_INFO\"] == b\"/all\".decode(\"latin-1\")\n    assert environ[\"HTTP_KEY\"] == \"value1,value2\""
    },
    {
      "chunk_id": 481,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport httpx\nimport httpx._transports.asgi\nimport pytest\nimport websockets.client\n\nfrom tests.response import Response\nfrom tests.utils import run_server\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\nfrom uvicorn.config import Config\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware, _TrustedHosts\n\nif TYPE_CHECKING:\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol"
    },
    {
      "chunk_id": 482,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "X_FORWARDED_FOR = \"X-Forwarded-For\"\nX_FORWARDED_PROTO = \"X-Forwarded-Proto\""
    },
    {
      "chunk_id": 483,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "async def default_app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    scheme = scope[\"scheme\"]  # type: ignore\n    if (client := scope[\"client\"]) is None:  # type: ignore\n        client_addr = \"NONE\"  # pragma: no cover\n    else:\n        host, port = client\n        client_addr = f\"{host}:{port}\"\n\n    response = Response(f\"{scheme}://{client_addr}\", media_type=\"text/plain\")\n    await response(scope, receive, send)"
    },
    {
      "chunk_id": 484,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "def make_httpx_client(\n    trusted_hosts: str | list[str],\n    client: tuple[str, int] = (\"127.0.0.1\", 123),\n) -> httpx.AsyncClient:\n    \"\"\"Create async client for use in test cases.\n\n    Args:\n        trusted_hosts: trusted_hosts for proxy middleware\n        client: transport client to use\n    \"\"\"\n\n    app = ProxyHeadersMiddleware(default_app, trusted_hosts)\n    transport = httpx.ASGITransport(app=app, client=client)  # type: ignore\n    return httpx.AsyncClient(transport=transport, base_url=\"http://testserver\")"
    },
    {
      "chunk_id": 485,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "_TRUSTED_NOTHING: list[str] = []\n_TRUSTED_EVERYTHING = \"*\"\n_TRUSTED_EVERYTHING_LIST = [\"*\"]\n_TRUSTED_IPv4_ADDRESSES = \"127.0.0.1, 10.0.0.1\"\n_TRUSTED_IPv4_NETWORKS = [\"127.0.0.0/8\", \"10.0.0.0/8\"]\n_TRUSTED_IPv6_ADDRESSES = [\n    \"2001:db8::\",\n    \"2001:0db8:0001:0000:0000:0ab9:C0A8:0102\",\n    \"2001:db8:3333:4444:5555:6666:1.2.3.4\",  # This is a dual address\n    \"::11.22.33.44\",  # This is a dual address\n]\n_TRUSTED_IPv6_NETWORKS = \"2001:db8:abcd:0012::0/64\"\n_TRUSTED_LITERALS = \"some-literal , unix:///foo/bar  ,  /foo/bar, garba*gewith*\""
    },
    {
      "chunk_id": 486,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.parametrize(\n    (\"init_hosts\", \"test_host\", \"expected\"),\n    [\n        ## Never Trust trust\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_NOTHING, \"127.0.0.0\", False),\n        (_TRUSTED_NOTHING, \"127.0.0.1\", False),\n        (_TRUSTED_NOTHING, \"127.1.1.1\", False),\n        (_TRUSTED_NOTHING, \"127.255.255.255\", False),\n        (_TRUSTED_NOTHING, \"10.0.0.0\", False),\n        (_TRUSTED_NOTHING, \"10.0.0.1\", False),\n        (_TRUSTED_NOTHING, \"10.1.1.1\", False),\n        (_TRUSTED_NOTHING, \"10.255.255.255\", False),\n        (_TRUSTED_NOTHING, \"192.168.0.0\", False),\n        (_TRUSTED_NOTHING, \"192.168.0.1\", False),\n        (_TRUSTED_NOTHING, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_NOTHING, \"2001:db8::\", False),\n        (_TRUSTED_NOTHING, \"2001:db8:abcd:0012::0\", False),\n        (_TRUSTED_NOTHING, \"2001:db8:abcd:0012::1:1\", False),\n        (_TRUSTED_NOTHING, \"::\", False),\n        (_TRUSTED_NOTHING, \"::1\", False),\n        (\n            _TRUSTED_NOTHING,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            False,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_NOTHING, \"::b16:212c\", False),  # aka ::11.22.33.44\n        (_TRUSTED_NOTHING, \"a:b:c:d::\", False),\n        (_TRUSTED_NOTHING, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_NOTHING, \"some-literal\", False),\n        (_TRUSTED_NOTHING, \"unix:///foo/bar\", False),\n        (_TRUSTED_NOTHING, \"/foo/bar\", False),\n        (_TRUSTED_NOTHING, \"*\", False),\n        (_TRUSTED_NOTHING, \"another-literal\", False),\n        (_TRUSTED_NOTHING, \"unix:///another/path\", False),\n        (_TRUSTED_NOTHING, \"/another/path\", False),\n        (_TRUSTED_NOTHING, \"\", False),\n        ## Always trust\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_EVERYTHING, \"127.0.0.0\", True),\n        (_TRUSTED_EVERYTHING, \"127.0.0.1\", True),\n        (_TRUSTED_EVERYTHING, \"127.1.1.1\", True),\n        (_TRUSTED_EVERYTHING, \"127.255.255.255\", True),\n        (_TRUSTED_EVERYTHING, \"10.0.0.0\", True),\n        (_TRUSTED_EVERYTHING, \"10.0.0.1\", True),\n        (_TRUSTED_EVERYTHING, \"10.1.1.1\", True),\n        (_TRUSTED_EVERYTHING, \"10.255.255.255\", True),\n        (_TRUSTED_EVERYTHING, \"192.168.0.0\", True),\n        (_TRUSTED_EVERYTHING, \"192.168.0.1\", True),\n        (_TRUSTED_EVERYTHING, \"1.1.1.1\", True),\n        (_TRUSTED_EVERYTHING_LIST, \"1.1.1.1\", True),\n        # Test IPv6 Addresses\n        (_TRUSTED_EVERYTHING, \"2001:db8::\", True),\n        (_TRUSTED_EVERYTHING, \"2001:db8:abcd:0012::0\", True),\n        (_TRUSTED_EVERYTHING, \"2001:db8:abcd:0012::1:1\", True),\n        (_TRUSTED_EVERYTHING, \"::\", True),\n        (_TRUSTED_EVERYTHING, \"::1\", True),\n        (\n            _TRUSTED_EVERYTHING,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            True,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_EVERYTHING, \"::b16:212c\", True),  # aka ::11.22.33.44\n        (_TRUSTED_EVERYTHING, \"a:b:c:d::\", True),\n        (_TRUSTED_EVERYTHING, \"::a:b:c:d\", True),\n        (_TRUSTED_EVERYTHING_LIST, \"::a:b:c:d\", True),\n        # Test Literals\n        (_TRUSTED_EVERYTHING, \"some-literal\", True),\n        (_TRUSTED_EVERYTHING, \"unix:///foo/bar\", True),\n        (_TRUSTED_EVERYTHING, \"/foo/bar\", True),\n        (_TRUSTED_EVERYTHING, \"*\", True),\n        (_TRUSTED_EVERYTHING, \"another-literal\", True),\n        (_TRUSTED_EVERYTHING, \"unix:///another/path\", True),\n        (_TRUSTED_EVERYTHING, \"/another/path\", True),\n        (_TRUSTED_EVERYTHING, \"\", True),\n        (_TRUSTED_EVERYTHING_LIST, \"\", True),\n        ## Trust IPv4 Addresses\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_IPv4_ADDRESSES, \"127.0.0.0\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"127.0.0.1\", True),\n        (_TRUSTED_IPv4_ADDRESSES, \"127.1.1.1\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"127.255.255.255\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"10.0.0.0\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"10.0.0.1\", True),\n        (_TRUSTED_IPv4_ADDRESSES, \"10.1.1.1\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"10.255.255.255\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"192.168.0.0\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"192.168.0.1\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_IPv4_ADDRESSES, \"2001:db8::\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"2001:db8:abcd:0012::0\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"2001:db8:abcd:0012::1:1\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"::\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"::1\", False),\n        (\n            _TRUSTED_IPv4_ADDRESSES,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            False,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_IPv4_ADDRESSES, \"::b16:212c\", False),  # aka ::11.22.33.44\n        (_TRUSTED_IPv4_ADDRESSES, \"a:b:c:d::\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_IPv4_ADDRESSES, \"some-literal\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"unix:///foo/bar\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"*\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"/foo/bar\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"another-literal\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"unix:///another/path\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"/another/path\", False),\n        (_TRUSTED_IPv4_ADDRESSES, \"\", False),\n        ## Trust IPv6 Addresses\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_IPv6_ADDRESSES, \"127.0.0.0\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"127.0.0.1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"127.1.1.1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"127.255.255.255\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"10.0.0.0\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"10.0.0.1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"10.1.1.1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"10.255.255.255\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"192.168.0.0\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"192.168.0.1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_IPv6_ADDRESSES, \"2001:db8::\", True),\n        (_TRUSTED_IPv6_ADDRESSES, \"2001:db8:abcd:0012::0\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"2001:db8:abcd:0012::1:1\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"::\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"::1\", False),\n        (\n            _TRUSTED_IPv6_ADDRESSES,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            True,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_IPv6_ADDRESSES, \"::b16:212c\", True),  # aka ::11.22.33.44\n        (_TRUSTED_IPv6_ADDRESSES, \"a:b:c:d::\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_IPv6_ADDRESSES, \"some-literal\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"unix:///foo/bar\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"*\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"/foo/bar\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"another-literal\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"unix:///another/path\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"/another/path\", False),\n        (_TRUSTED_IPv6_ADDRESSES, \"\", False),\n        ## Trust IPv4 Networks\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_IPv4_NETWORKS, \"127.0.0.0\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"127.0.0.1\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"127.1.1.1\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"127.255.255.255\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"10.0.0.0\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"10.0.0.1\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"10.1.1.1\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"10.255.255.255\", True),\n        (_TRUSTED_IPv4_NETWORKS, \"192.168.0.0\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"192.168.0.1\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_IPv4_NETWORKS, \"2001:db8::\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"2001:db8:abcd:0012::0\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"2001:db8:abcd:0012::1:1\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"::\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"::1\", False),\n        (\n            _TRUSTED_IPv4_NETWORKS,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            False,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_IPv4_NETWORKS, \"::b16:212c\", False),  # aka ::11.22.33.44\n        (_TRUSTED_IPv4_NETWORKS, \"a:b:c:d::\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_IPv4_NETWORKS, \"some-literal\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"unix:///foo/bar\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"*\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"/foo/bar\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"another-literal\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"unix:///another/path\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"/another/path\", False),\n        (_TRUSTED_IPv4_NETWORKS, \"\", False),\n        ## Trust IPv6 Networks\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_IPv6_NETWORKS, \"127.0.0.0\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"127.0.0.1\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"127.1.1.1\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"127.255.255.255\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"10.0.0.0\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"10.0.0.1\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"10.1.1.1\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"10.255.255.255\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"192.168.0.0\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"192.168.0.1\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_IPv6_NETWORKS, \"2001:db8::\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"2001:db8:abcd:0012::0\", True),\n        (_TRUSTED_IPv6_NETWORKS, \"2001:db8:abcd:0012::1:1\", True),\n        (_TRUSTED_IPv6_NETWORKS, \"::\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"::1\", False),\n        (\n            _TRUSTED_IPv6_NETWORKS,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            False,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_IPv6_NETWORKS, \"::b16:212c\", False),  # aka ::11.22.33.44\n        (_TRUSTED_IPv6_NETWORKS, \"a:b:c:d::\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_IPv6_NETWORKS, \"some-literal\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"unix:///foo/bar\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"*\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"/foo/bar\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"another-literal\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"unix:///another/path\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"/another/path\", False),\n        (_TRUSTED_IPv6_NETWORKS, \"\", False),\n        ## Trust Literals\n        ## -----------------------------\n        # Test IPv4 Addresses\n        (_TRUSTED_LITERALS, \"127.0.0.0\", False),\n        (_TRUSTED_LITERALS, \"127.0.0.1\", False),\n        (_TRUSTED_LITERALS, \"127.1.1.1\", False),\n        (_TRUSTED_LITERALS, \"127.255.255.255\", False),\n        (_TRUSTED_LITERALS, \"10.0.0.0\", False),\n        (_TRUSTED_LITERALS, \"10.0.0.1\", False),\n        (_TRUSTED_LITERALS, \"10.1.1.1\", False),\n        (_TRUSTED_LITERALS, \"10.255.255.255\", False),\n        (_TRUSTED_LITERALS, \"192.168.0.0\", False),\n        (_TRUSTED_LITERALS, \"192.168.0.1\", False),\n        (_TRUSTED_LITERALS, \"1.1.1.1\", False),\n        # Test IPv6 Addresses\n        (_TRUSTED_LITERALS, \"2001:db8::\", False),\n        (_TRUSTED_LITERALS, \"2001:db8:abcd:0012::0\", False),\n        (_TRUSTED_LITERALS, \"2001:db8:abcd:0012::1:1\", False),\n        (_TRUSTED_LITERALS, \"::\", False),\n        (_TRUSTED_LITERALS, \"::1\", False),\n        (\n            _TRUSTED_LITERALS,\n            \"2001:db8:3333:4444:5555:6666:102:304\",\n            False,\n        ),  # aka 2001:db8:3333:4444:5555:6666:1.2.3.4\n        (_TRUSTED_LITERALS, \"::b16:212c\", False),  # aka ::11.22.33.44\n        (_TRUSTED_LITERALS, \"a:b:c:d::\", False),\n        (_TRUSTED_LITERALS, \"::a:b:c:d\", False),\n        # Test Literals\n        (_TRUSTED_LITERALS, \"some-literal\", True),\n        (_TRUSTED_LITERALS, \"unix:///foo/bar\", True),\n        (_TRUSTED_LITERALS, \"*\", False),\n        (_TRUSTED_LITERALS, \"/foo/bar\", True),\n        (_TRUSTED_LITERALS, \"another-literal\", False),\n        (_TRUSTED_LITERALS, \"unix:///another/path\", False),\n        (_TRUSTED_LITERALS, \"/another/path\", False),\n        (_TRUSTED_LITERALS, \"\", False),\n    ],\n)\ndef test_forwarded_hosts(init_hosts: str | list[str], test_host: str, expected: bool) -> None:\n    trusted_hosts = _TrustedHosts(init_hosts)\n    assert (test_host in trusted_hosts) is expected"
    },
    {
      "chunk_id": 487,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\n@pytest.mark.parametrize(\n    (\"trusted_hosts\", \"expected\"),\n    [\n        # always trust\n        (\"*\", \"https://1.2.3.4:0\"),\n        # trusted proxy\n        (\"127.0.0.1\", \"https://1.2.3.4:0\"),\n        ([\"127.0.0.1\"], \"https://1.2.3.4:0\"),\n        # trusted proxy list\n        ([\"127.0.0.1\", \"10.0.0.1\"], \"https://1.2.3.4:0\"),\n        (\"127.0.0.1, 10.0.0.1\", \"https://1.2.3.4:0\"),\n        # trusted proxy network\n        # https://github.com/encode/uvicorn/issues/1068#issuecomment-1004813267\n        (\"127.0.0.0/24, 10.0.0.1\", \"https://1.2.3.4:0\"),\n        # request from untrusted proxy\n        (\"192.168.0.1\", \"http://127.0.0.1:123\"),\n        # request from untrusted proxy network\n        (\"192.168.0.0/16\", \"http://127.0.0.1:123\"),\n        # request from client running on proxy server itself\n        # https://github.com/encode/uvicorn/issues/1068#issuecomment-855371576\n        ([\"127.0.0.1\", \"1.2.3.4\"], \"https://1.2.3.4:0\"),\n    ],\n)\nasync def test_proxy_headers_trusted_hosts(trusted_hosts: str | list[str], expected: str) -> None:\n    async with make_httpx_client(trusted_hosts) as client:\n        headers = {X_FORWARDED_FOR: \"1.2.3.4\", X_FORWARDED_PROTO: \"https\"}\n        response = await client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == expected"
    },
    {
      "chunk_id": 488,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\n@pytest.mark.parametrize(\n    (\"forwarded_for\", \"forwarded_proto\", \"expected\"),\n    [\n        (\"\", \"\", \"http://127.0.0.1:123\"),\n        (\"\", None, \"http://127.0.0.1:123\"),\n        (\"\", \"asdf\", \"http://127.0.0.1:123\"),\n        (\" , \", \"https\", \"https://127.0.0.1:123\"),\n        (\", , \", \"https\", \"https://127.0.0.1:123\"),\n        (\" , 10.0.0.1\", \"https\", \"https://127.0.0.1:123\"),\n        (\"9.9.9.9 , , , 10.0.0.1\", \"https\", \"https://127.0.0.1:123\"),\n        (\", , 9.9.9.9\", \"https\", \"https://9.9.9.9:0\"),\n        (\", , 9.9.9.9, , \", \"https\", \"https://127.0.0.1:123\"),\n    ],\n)\nasync def test_proxy_headers_trusted_hosts_malformed(\n    forwarded_for: str,\n    forwarded_proto: str | None,\n    expected: str,\n) -> None:\n    async with make_httpx_client(\"127.0.0.1, 10.0.0.0/8\") as client:\n        headers = {X_FORWARDED_FOR: forwarded_for}\n        if forwarded_proto is not None:\n            headers[X_FORWARDED_PROTO] = forwarded_proto\n        response = await client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == expected"
    },
    {
      "chunk_id": 489,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\n@pytest.mark.parametrize(\n    (\"trusted_hosts\", \"expected\"),\n    [\n        # always trust\n        (\"*\", \"https://1.2.3.4:0\"),\n        # all proxies are trusted\n        ([\"127.0.0.1\", \"10.0.2.1\", \"192.168.0.2\"], \"https://1.2.3.4:0\"),\n        # order doesn't matter\n        ([\"10.0.2.1\", \"192.168.0.2\", \"127.0.0.1\"], \"https://1.2.3.4:0\"),\n        # should set first untrusted as remote address\n        ([\"192.168.0.2\", \"127.0.0.1\"], \"https://10.0.2.1:0\"),\n        # Mixed literals and networks\n        ([\"127.0.0.1\", \"10.0.0.0/8\", \"192.168.0.2\"], \"https://1.2.3.4:0\"),\n    ],\n)\nasync def test_proxy_headers_multiple_proxies(trusted_hosts: str | list[str], expected: str) -> None:\n    async with make_httpx_client(trusted_hosts) as client:\n        headers = {X_FORWARDED_FOR: \"1.2.3.4, 10.0.2.1, 192.168.0.2\", X_FORWARDED_PROTO: \"https\"}\n        response = await client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == expected"
    },
    {
      "chunk_id": 490,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\nasync def test_proxy_headers_invalid_x_forwarded_for() -> None:\n    async with make_httpx_client(\"*\") as client:\n        headers = httpx.Headers(\n            {\n                X_FORWARDED_FOR: \"1.2.3.4, \\xf0\\xfd\\xfd\\xfd, unix:, ::1\",\n                X_FORWARDED_PROTO: \"https\",\n            },\n            encoding=\"latin-1\",\n        )\n        response = await client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"https://1.2.3.4:0\""
    },
    {
      "chunk_id": 491,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\n@pytest.mark.parametrize(\n    \"forwarded_proto,expected\",\n    [\n        (\"http\", \"ws://1.2.3.4:0\"),\n        (\"https\", \"wss://1.2.3.4:0\"),\n        (\"ws\", \"ws://1.2.3.4:0\"),\n        (\"wss\", \"wss://1.2.3.4:0\"),\n    ],\n)\nasync def test_proxy_headers_websocket_x_forwarded_proto(\n    forwarded_proto: str,\n    expected: str,\n    ws_protocol_cls: type[WSProtocol | WebSocketProtocol],\n    http_protocol_cls: type[H11Protocol | HttpToolsProtocol],\n    unused_tcp_port: int,\n) -> None:\n    async def websocket_app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        assert scope[\"type\"] == \"websocket\"\n        scheme = scope[\"scheme\"]\n        assert scope[\"client\"] is not None\n        host, port = scope[\"client\"]\n        await send({\"type\": \"websocket.accept\"})\n        await send({\"type\": \"websocket.send\", \"text\": f\"{scheme}://{host}:{port}\"})\n\n    app_with_middleware = ProxyHeadersMiddleware(websocket_app, trusted_hosts=\"*\")\n    config = Config(\n        app=app_with_middleware,\n        ws=ws_protocol_cls,\n        http=http_protocol_cls,\n        lifespan=\"off\",\n        port=unused_tcp_port,\n    )\n\n    async with run_server(config):\n        url = f\"ws://127.0.0.1:{unused_tcp_port}\"\n        headers = {X_FORWARDED_FOR: \"1.2.3.4\", X_FORWARDED_PROTO: forwarded_proto}\n        async with websockets.client.connect(url, extra_headers=headers) as websocket:\n            data = await websocket.recv()\n            assert data == expected"
    },
    {
      "chunk_id": 492,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_proxy_headers.py",
      "content": "@pytest.mark.anyio\nasync def test_proxy_headers_empty_x_forwarded_for() -> None:\n    # fallback to the default behavior if x-forwarded-for is an empty list\n    # https://github.com/encode/uvicorn/issues/1068#issuecomment-855371576\n    async with make_httpx_client(\"*\") as client:\n        headers = {X_FORWARDED_FOR: \"\", X_FORWARDED_PROTO: \"https\"}\n        response = await client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"https://127.0.0.1:123\""
    },
    {
      "chunk_id": 493,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "from __future__ import annotations\n\nimport contextlib\nimport logging\nimport socket\nimport sys\nimport typing\n\nimport httpx\nimport pytest\nimport websockets\nimport websockets.client\n\nfrom tests.utils import run_server\nfrom uvicorn import Config\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\n\nif typing.TYPE_CHECKING:\n    import sys\n\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol as _WSProtocol\n\n    if sys.version_info >= (3, 10):  # pragma: no cover\n        from typing import TypeAlias\n    else:  # pragma: no cover\n        from typing_extensions import TypeAlias\n\n    WSProtocol: TypeAlias = \"type[WebSocketProtocol | _WSProtocol]\"\n\npytestmark = pytest.mark.anyio"
    },
    {
      "chunk_id": 494,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "@contextlib.contextmanager\ndef caplog_for_logger(caplog: pytest.LogCaptureFixture, logger_name: str) -> typing.Iterator[pytest.LogCaptureFixture]:\n    logger = logging.getLogger(logger_name)\n    logger.propagate, old_propagate = False, logger.propagate\n    logger.addHandler(caplog.handler)\n    try:\n        yield caplog\n    finally:\n        logger.removeHandler(caplog.handler)\n        logger.propagate = old_propagate"
    },
    {
      "chunk_id": 495,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n    assert scope[\"type\"] == \"http\"\n    await send({\"type\": \"http.response.start\", \"status\": 204, \"headers\": []})\n    await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})"
    },
    {
      "chunk_id": 496,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def test_trace_logging(caplog: pytest.LogCaptureFixture, logging_config, unused_tcp_port: int):\n    config = Config(\n        app=app,\n        log_level=\"trace\",\n        log_config=logging_config,\n        lifespan=\"auto\",\n        port=unused_tcp_port,\n    )\n    with caplog_for_logger(caplog, \"uvicorn.asgi\"):\n        async with run_server(config):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")\n        assert response.status_code == 204\n        messages = [record.message for record in caplog.records if record.name == \"uvicorn.asgi\"]\n        assert \"ASGI [1] Started scope=\" in messages.pop(0)\n        assert \"ASGI [1] Raised exception\" in messages.pop(0)\n        assert \"ASGI [2] Started scope=\" in messages.pop(0)\n        assert \"ASGI [2] Send \" in messages.pop(0)\n        assert \"ASGI [2] Send \" in messages.pop(0)\n        assert \"ASGI [2] Completed\" in messages.pop(0)"
    },
    {
      "chunk_id": 497,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def test_trace_logging_on_http_protocol(http_protocol_cls, caplog, logging_config, unused_tcp_port: int):\n    config = Config(\n        app=app,\n        log_level=\"trace\",\n        http=http_protocol_cls,\n        log_config=logging_config,\n        port=unused_tcp_port,\n    )\n    with caplog_for_logger(caplog, \"uvicorn.error\"):\n        async with run_server(config):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")\n        assert response.status_code == 204\n        messages = [record.message for record in caplog.records if record.name == \"uvicorn.error\"]\n        assert any(\" - HTTP connection made\" in message for message in messages)\n        assert any(\" - HTTP connection lost\" in message for message in messages)"
    },
    {
      "chunk_id": 498,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def test_trace_logging_on_ws_protocol(\n    ws_protocol_cls: WSProtocol,\n    caplog,\n    logging_config,\n    unused_tcp_port: int,\n):\n    async def websocket_app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"websocket\"\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"websocket.connect\":\n                await send({\"type\": \"websocket.accept\"})\n            elif message[\"type\"] == \"websocket.disconnect\":\n                break\n\n    async def open_connection(url):\n        async with websockets.client.connect(url) as websocket:\n            return websocket.open\n\n    config = Config(\n        app=websocket_app,\n        log_level=\"trace\",\n        log_config=logging_config,\n        ws=ws_protocol_cls,\n        port=unused_tcp_port,\n    )\n    with caplog_for_logger(caplog, \"uvicorn.error\"):\n        async with run_server(config):\n            is_open = await open_connection(f\"ws://127.0.0.1:{unused_tcp_port}\")\n        assert is_open\n        messages = [record.message for record in caplog.records if record.name == \"uvicorn.error\"]\n        assert any(\" - Upgrading to WebSocket\" in message for message in messages)\n        assert any(\" - WebSocket connection made\" in message for message in messages)\n        assert any(\" - WebSocket connection lost\" in message for message in messages)"
    },
    {
      "chunk_id": 499,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "@pytest.mark.parametrize(\"use_colors\", [(True), (False), (None)])\nasync def test_access_logging(use_colors: bool, caplog: pytest.LogCaptureFixture, logging_config, unused_tcp_port: int):\n    config = Config(app=app, use_colors=use_colors, log_config=logging_config, port=unused_tcp_port)\n    with caplog_for_logger(caplog, \"uvicorn.access\"):\n        async with run_server(config):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")\n\n        assert response.status_code == 204\n        messages = [record.message for record in caplog.records if record.name == \"uvicorn.access\"]\n        assert '\"GET / HTTP/1.1\" 204' in messages.pop()"
    },
    {
      "chunk_id": 500,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "@pytest.mark.parametrize(\"use_colors\", [(True), (False)])\nasync def test_default_logging(\n    use_colors: bool, caplog: pytest.LogCaptureFixture, logging_config, unused_tcp_port: int\n):\n    config = Config(app=app, use_colors=use_colors, log_config=logging_config, port=unused_tcp_port)\n    with caplog_for_logger(caplog, \"uvicorn.access\"):\n        async with run_server(config):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")\n        assert response.status_code == 204\n        messages = [record.message for record in caplog.records if \"uvicorn\" in record.name]\n        assert \"Started server process\" in messages.pop(0)\n        assert \"Waiting for application startup\" in messages.pop(0)\n        assert \"ASGI 'lifespan' protocol appears unsupported\" in messages.pop(0)\n        assert \"Application startup complete\" in messages.pop(0)\n        assert \"Uvicorn running on http://127.0.0.1\" in messages.pop(0)\n        assert '\"GET / HTTP/1.1\" 204' in messages.pop(0)\n        assert \"Shutting down\" in messages.pop(0)"
    },
    {
      "chunk_id": 501,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "@pytest.mark.skipif(sys.platform == \"win32\", reason=\"require unix-like system\")\nasync def test_running_log_using_uds(\n    caplog: pytest.LogCaptureFixture, short_socket_name: str, unused_tcp_port: int\n):  # pragma: py-win32\n    config = Config(app=app, uds=short_socket_name, port=unused_tcp_port)\n    with caplog_for_logger(caplog, \"uvicorn.access\"):\n        async with run_server(config):\n            ...\n\n    messages = [record.message for record in caplog.records if \"uvicorn\" in record.name]\n    assert f\"Uvicorn running on unix socket {short_socket_name} (Press CTRL+C to quit)\" in messages"
    },
    {
      "chunk_id": 502,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "@pytest.mark.skipif(sys.platform == \"win32\", reason=\"require unix-like system\")\nasync def test_running_log_using_fd(caplog: pytest.LogCaptureFixture, unused_tcp_port: int):  # pragma: py-win32\n    with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:\n        fd = sock.fileno()\n        config = Config(app=app, fd=fd, port=unused_tcp_port)\n        with caplog_for_logger(caplog, \"uvicorn.access\"):\n            async with run_server(config):\n                ...\n        sockname = sock.getsockname()\n    messages = [record.message for record in caplog.records if \"uvicorn\" in record.name]\n    assert f\"Uvicorn running on socket {sockname} (Press CTRL+C to quit)\" in messages"
    },
    {
      "chunk_id": 503,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def test_unknown_status_code(caplog: pytest.LogCaptureFixture, unused_tcp_port: int):\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        assert scope[\"type\"] == \"http\"\n        await send({\"type\": \"http.response.start\", \"status\": 599, \"headers\": []})\n        await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False})\n\n    config = Config(app=app, port=unused_tcp_port)\n    with caplog_for_logger(caplog, \"uvicorn.access\"):\n        async with run_server(config):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"http://127.0.0.1:{unused_tcp_port}\")\n\n        assert response.status_code == 599\n        messages = [record.message for record in caplog.records if record.name == \"uvicorn.access\"]\n        assert '\"GET / HTTP/1.1\" 599' in messages.pop()"
    },
    {
      "chunk_id": 504,
      "source": "__internal__/data_repo/uvicorn/tests/middleware/test_logging.py",
      "content": "async def test_server_start_with_port_zero(caplog: pytest.LogCaptureFixture):\n    config = Config(app=app, port=0)\n    async with run_server(config) as _server:\n        server = _server.servers[0]\n        sock = server.sockets[0]\n        host, port = sock.getsockname()\n    messages = [record.message for record in caplog.records if \"uvicorn\" in record.name]\n    assert f\"Uvicorn running on http://{host}:{port} (Press CTRL+C to quit)\" in messages"
    }
  ]
}